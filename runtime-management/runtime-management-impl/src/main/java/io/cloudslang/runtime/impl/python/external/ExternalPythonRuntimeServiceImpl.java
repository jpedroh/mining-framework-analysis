  package      io . cloudslang . runtime . impl . python . external ;   import      io . cloudslang . runtime . api . python . PythonEvaluationResult ;  import      io . cloudslang . runtime . api . python . PythonExecutionResult ;  import      io . cloudslang . runtime . api . python . PythonRuntimeService ;  import   javax . annotation . Resource ;  import   java . io . Serializable ;  import   java . util . Map ;  import   java . util . Set ;  import    org . apache . log4j . Logger ;  import    java . util . concurrent . Semaphore ;  import    java . util . concurrent . TimeUnit ;   public class ExternalPythonRuntimeServiceImpl  implements  PythonRuntimeService  {    @ Resource  (  name = "externalPythonExecutionEngine" ) private ExternalPythonExecutionEngine  externalPythonExecutionEngine ;    @ Override public PythonExecutionResult exec  (   Set  < String > dependencies ,  String script ,   Map  < String , Serializable > vars )  { 
<<<<<<<
 return  externalPythonExecutionEngine . exec  ( dependencies , script , vars ) ;
=======
 try  {  if  (  executionControlSemaphore . tryAcquire  ( 1L ,  TimeUnit . SECONDS ) )  {  try  {  return  externalPythonExecutionNotCachedEngine . exec  ( dependencies , script , vars ) ; }  finally  {   executionControlSemaphore . release  ( ) ; } } else  {   logger . warn  (   "Maximum number of python processes has been reached. Waiting for a python process to finish. " + "You can configure the number of concurrent python executions by setting " + "'python.concurrent.execution.permits' system property." ) ;   executionControlSemaphore . acquire  ( ) ;  try  {   logger . info  ( "Acquired a permit for a new python process. Continuing with execution..." ) ;  return  externalPythonExecutionNotCachedEngine . exec  ( dependencies , script , vars ) ; }  finally  {   executionControlSemaphore . release  ( ) ; } } }  catch (   InterruptedException ie )  {  throw  new ExternalPythonScriptException  ( "Execution was interrupted while waiting for a python permit." ) ; }
>>>>>>>
 }    @ Override public PythonEvaluationResult eval  (  String prepareEnvironmentScript ,  String script ,   Map  < String , Serializable > vars )  { 
<<<<<<<
 return  externalPythonExecutionEngine . eval  ( prepareEnvironmentScript , script , vars ) ;
=======
 try  {  if  (  executionControlSemaphore . tryAcquire  ( 1L ,  TimeUnit . SECONDS ) )  {  try  {  return  externalPythonExecutionNotCachedEngine . eval  ( prepareEnvironmentScript , script , vars ) ; }  finally  {   executionControlSemaphore . release  ( ) ; } } else  {   logger . warn  (   "Maximum number of python processes has been reached. Waiting for a python process to finish. " + "You can configure the number of concurrent python executions by setting " + "'python.concurrent.execution.permits' system property." ) ;   executionControlSemaphore . acquire  ( ) ;  try  {   logger . info  ( "Acquired a permit for a new python process. Continuing with execution..." ) ;  return  externalPythonExecutionNotCachedEngine . eval  ( prepareEnvironmentScript , script , vars ) ; }  finally  {   executionControlSemaphore . release  ( ) ; } } }  catch (   InterruptedException ie )  {  throw  new ExternalPythonScriptException  ( "Execution was interrupted while waiting for a python permit." ) ; }
>>>>>>>
 }   private static final Logger  logger =  Logger . getLogger  (  ExternalPythonRuntimeServiceImpl . class ) ;   private final Semaphore  executionControlSemaphore ;   public ExternalPythonRuntimeServiceImpl  (  Semaphore executionControlSemaphore )  {    this . executionControlSemaphore = executionControlSemaphore ; } }