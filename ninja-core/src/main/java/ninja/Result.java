  package ninja ;   import   java . io . IOException ;  import   java . io . OutputStream ;  import   java . io . Writer ;  import   java . util . AbstractMap ;  import   java . util . Arrays ;  import   java . util . List ;  import   java . util . Map ;  import    java . util . Map . Entry ;  import   ninja . exceptions . InternalServerErrorException ;  import   ninja . utils . DateUtil ;  import   ninja . utils . NoHttpBody ;  import   ninja . utils . ResponseStreams ;  import   ninja . utils . SwissKnife ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     com . google . common . base . Optional ;  import     com . google . common . collect . ImmutableList ;  import     com . google . common . collect . Lists ;  import     com . google . common . collect . Maps ;   public class Result  {   private final Logger  logger =  LoggerFactory . getLogger  (  Result . class ) ;   public static final  int  SC_200_OK = 200 ;   public static final  int  SC_201_CREATED = 201 ;   public static final  int  SC_204_NO_CONTENT = 204 ;   public static final  int  SC_300_MULTIPLE_CHOICES = 300 ;   public static final  int  SC_301_MOVED_PERMANENTLY = 301 ;   public static final  int  SC_302_FOUND = 302 ;   public static final  int  SC_303_SEE_OTHER = 303 ;   public static final  int  SC_304_NOT_MODIFIED = 304 ;   public static final  int  SC_307_TEMPORARY_REDIRECT = 307 ;   public static final  int  SC_400_BAD_REQUEST = 400 ;   public static final  int  SC_401_UNAUTHORIZED = 401 ;   public static final  int  SC_403_FORBIDDEN = 403 ;   public static final  int  SC_404_NOT_FOUND = 404 ;   public static final  int  SC_500_INTERNAL_SERVER_ERROR = 500 ;   public static final  int  SC_501_NOT_IMPLEMENTED = 501 ;   public static final String  TEXT_HTML = "text/html" ;   public static final String  TEXT_PLAIN = "text/plain" ;   public static final String  APPLICATION_JSON = "application/json" ;    @ Deprecated public static final String  APPLICATON_JSON = APPLICATION_JSON ;   public static final String  APPLICATION_JSONP = "application/javascript" ;    @ Deprecated public static final String  APPLICATON_JSONP = APPLICATION_JSONP ;   public static final String  APPLICATION_XML = "application/xml" ;   public static final String  APPLICATION_OCTET_STREAM = "application/octet-stream" ;   public static final NoHttpBody  NO_HTTP_BODY =  new NoHttpBody  ( ) ;   public static final String  LOCATION = "Location" ;   public static final String  CACHE_CONTROL = "Cache-Control" ;   public static final String  CACHE_CONTROL_DEFAULT_NOCACHE_VALUE = "no-cache, no-store, max-age=0, must-revalidate" ;   public static final String  DATE = "Date" ;   public static final String  EXPIRES = "Expires" ;   public static final String  WWW_AUTHENTICATE = "WWW-Authenticate" ;   private  int  statusCode ;   private  Class  <  ? >  jsonView ;   private Object  renderable ;   private String  contentType ;   private  Optional  < String >  fallbackContentType =  Optional . absent  ( ) ;   private final  List  < String >  supportedContentTypes =  Lists . newArrayList  ( ) ;   private final static  List  < String >  DEFAULT_SUPPORTED_CONTENT_TYPES =  ImmutableList . of  ( TEXT_HTML , APPLICATION_JSON , APPLICATION_XML ) ;   private String  charset ;   private  Map  < String , String >  headers ;   private  List  < Cookie >  cookies ;   private String  template ;   public Result  (   int statusCode )  {    this . statusCode = statusCode ;    this . charset = "utf-8" ;    this . headers =  Maps . newHashMap  ( ) ;    this . cookies =  Lists . newArrayList  ( ) ; }   public Object getRenderable  ( )  {  return renderable ; }   public Result render  (  Object object )  {  if  (   this . renderable == null )  {    this . renderable = object ; } else  {   assertObjectNoRenderableOrThrowException  (  this . renderable ) ;   Map  < String , Object >  map ;  if  (   this . renderable instanceof Map )  {   map =  ( Map )  this . renderable ; } else  {   map =  Maps . newHashMap  ( ) ;   map . put  (  SwissKnife . getRealClassNameLowerCamelCase  (  this . renderable ) ,  this . renderable ) ;    this . renderable = map ; }  String  key =  SwissKnife . getRealClassNameLowerCamelCase  ( object ) ;  if  (  map . containsKey  ( key ) )  {  throw  new IllegalArgumentException  (  String . format  (   "Cannot store object with default name %s." + "An object with the same name is already stored." + "Consider using render(key, value) to name objects implicitly." , key ) ) ; } else  {   map . put  (  SwissKnife . getRealClassNameLowerCamelCase  ( object ) , object ) ; } }  return this ; }   public Result render  (   Map  < String , Object > mapToRender )  {    this . renderable = mapToRender ;  return this ; }   public Result render  (   Entry  < String , Object > entry )  {  if  (   this . renderable == null )  {   Map  < String , Object >  map =  Maps . newHashMap  ( ) ;    this . renderable = map ;   map . put  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; } else  {   assertObjectNoRenderableOrThrowException  (  this . renderable ) ;   Map  < String , Object >  map ;  if  (   this . renderable instanceof Map )  {   map =  ( Map )  this . renderable ;  if  (  map . containsKey  (  entry . getKey  ( ) ) )  {  throw  new IllegalArgumentException  (  String . format  (   "Entry with key %s already stored inside this Result object. " + "This is currently not supported and does not make sense. " + "Consider using your own map." ,  entry . getKey  ( ) ) ) ; } else  {   map . put  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; } } else  {   map =  Maps . newHashMap  ( ) ;   map . put  (  SwissKnife . getRealClassNameLowerCamelCase  (  this . renderable ) ,  this . renderable ) ;    this . renderable = map ; }   map . put  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; }  return this ; }   public Result render  (  Renderable renderable )  {    this . renderable = renderable ;  return this ; }   public Result render  (  String key ,  Object value )  {   render  (  new   AbstractMap . SimpleEntry  < String , Object >  ( key , value ) ) ;  return this ; }    @ Deprecated public Result renderRaw  (   final String string )  {  Renderable  renderable =  new Renderable  ( )  {    @ Override public void render  (  Context context ,  Result result )  {  if  (   result . getContentType  ( ) == null )  {   result . contentType  (  Result . TEXT_PLAIN ) ; }  ResponseStreams  resultJsonCustom =  context . finalizeHeaders  ( result ) ;  try  (  Writer writer =  resultJsonCustom . getWriter  ( ) )  {   writer . write  ( string ) ; }  catch (   IOException ioException )  {   logger . error  ( "Error rendering raw String via renderRaw(...)" , ioException ) ; } } } ;   render  ( renderable ) ;  return this ; }   public Result renderRaw  (   final   byte  [ ] bytes )  {  Renderable  renderable =  new Renderable  ( )  {    @ Override public void render  (  Context context ,  Result result )  {  if  (   result . getContentType  ( ) == null )  {   result . contentType  (  Result . APPLICATION_OCTET_STREAM ) ; }  ResponseStreams  responseStreams =  context . finalizeHeaders  ( result ) ;  try  (  OutputStream outputStream =  responseStreams . getOutputStream  ( ) )  {   outputStream . write  ( bytes ) ; }  catch (   IOException ioException )  {  throw  new InternalServerErrorException  ( ioException ) ; } } } ;   render  ( renderable ) ;  return this ; }   public String getContentType  ( )  {  return contentType ; }   public String getCharset  ( )  {  return charset ; }   public Result charset  (  String charset )  {    this . charset = charset ;  return this ; }    @ Deprecated public Result setContentType  (  String contentType )  {    this . contentType = contentType ;  return this ; }   public Result contentType  (  String contentType )  {    this . contentType = contentType ;  return this ; }   public Result supportedContentType  (  String contentTypeSupportedByThisResult )  {   supportedContentTypes . add  ( contentTypeSupportedByThisResult ) ;  return this ; }   public Result supportedContentTypes  (  String ...  contentTypesSupportedByThisResult )  {   supportedContentTypes . addAll  (  Arrays . asList  ( contentTypesSupportedByThisResult ) ) ;  return this ; }   public  List  < String > supportedContentTypes  ( )  {  if  (  supportedContentTypes . isEmpty  ( ) )  {  return DEFAULT_SUPPORTED_CONTENT_TYPES ; } else  {  return  ImmutableList . copyOf  ( supportedContentTypes ) ; } }   public  Optional  < String > fallbackContentType  ( )  {  return fallbackContentType ; }   public Result fallbackContentType  (  String fallbackContentType )  {    this . fallbackContentType =  Optional . of  ( fallbackContentType ) ;  return this ; }   public  Map  < String , String > getHeaders  ( )  {  return headers ; }   public Result addHeader  (  String headerName ,  String headerContent )  {   headers . put  ( headerName , headerContent ) ;  return this ; }   public Cookie getCookie  (  String cookieName )  {  for ( Cookie cookie :  getCookies  ( ) )  {  if  (   cookie . getName  ( ) . equals  ( cookieName ) )  {  return cookie ; } }  return null ; }   public  List  < Cookie > getCookies  ( )  {  return cookies ; }   public Result addCookie  (  Cookie cookie )  {   cookies . add  ( cookie ) ;  return this ; }   public Result unsetCookie  (  String name )  {   cookies . add  (    Cookie . builder  ( name , "" ) . setMaxAge  ( 0 ) . build  ( ) ) ;  return this ; }   public  int getStatusCode  ( )  {  return statusCode ; }   public Result status  (   int statusCode )  {    this . statusCode = statusCode ;  return this ; }   public String getTemplate  ( )  {  return template ; }   public Result template  (  String template )  {    this . template = template ;  return this ; }   public  Class  <  ? > getJsonView  ( )  {  return jsonView ; }   public Result jsonView  (   Class  <  ? > jsonView )  {    this . jsonView = jsonView ;  return this ; }   public Result redirect  (  String url )  {   status  (  Result . SC_303_SEE_OTHER ) ;   addHeader  (  Result . LOCATION , url ) ;  return this ; }   public Result redirectTemporary  (  String url )  {   status  (  Result . SC_307_TEMPORARY_REDIRECT ) ;   addHeader  (  Result . LOCATION , url ) ;  return this ; }   public Result html  ( )  {   contentType = TEXT_HTML ;  return this ; }   public Result json  ( )  {   contentType = APPLICATION_JSON ;  return this ; }   public Result jsonp  ( )  {   contentType = APPLICATION_JSONP ;  return this ; }   public Result text  ( )  {   contentType = TEXT_PLAIN ;  return this ; }   public Result xml  ( )  {   contentType = APPLICATION_XML ;  return this ; }   public Result doNotCacheContent  ( )  {   addHeader  ( CACHE_CONTROL , CACHE_CONTROL_DEFAULT_NOCACHE_VALUE ) ;   addHeader  ( DATE ,  DateUtil . formatForHttpHeader  (  System . currentTimeMillis  ( ) ) ) ;   addHeader  ( EXPIRES ,  DateUtil . formatForHttpHeader  ( 0L ) ) ;  return this ; }   private void assertObjectNoRenderableOrThrowException  (  Object object )  {  if  (  object instanceof Renderable )  {  throw  new IllegalArgumentException  (  "You already want to render a Renderable class. " + "Adding more items to render is not supported." ) ; } }   public Result copy  ( )  {  Result  result =  new Result  ( statusCode ) ;  for ( Cookie cookie :  result . getCookies  ( ) )  {   result . addCookie  ( cookie ) ; }   Map  < String , String >  headers =  getHeaders  ( ) ;  for (   Map . Entry  < String , String > entry :  headers . entrySet  ( ) )  {   result . addHeader  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; }   result . contentType  (  getContentType  ( ) ) ;   result . charset  (  getCharset  ( ) ) ;   result . template  (  getTemplate  ( ) ) ;   result . jsonView  (  getJsonView  ( ) ) ;   result . render  (  getRenderable  ( ) ) ;   List  < String >  supportedContentTypes =  supportedContentTypes  ( ) ;  for ( String supportedContentType : supportedContentTypes )  {   result . supportedContentType  ( supportedContentType ) ; }   Optional  < String >  fallbackContentType =  fallbackContentType  ( ) ;  if  (  fallbackContentType . isPresent  ( ) )  {   result . fallbackContentType  (  fallbackContentType . get  ( ) ) ; }  return result ; } }