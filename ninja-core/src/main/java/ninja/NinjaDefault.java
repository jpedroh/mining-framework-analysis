  package ninja ;   import   java . io . InputStream ;  import   java . util . Properties ;  import   javax . management . RuntimeErrorException ;  import   ninja . diagnostics . DiagnosticError ;  import   ninja . diagnostics . DiagnosticErrorBuilder ;  import   ninja . exceptions . BadRequestException ;  import   ninja . exceptions . RenderingException ;  import   ninja . i18n . Messages ;  import   ninja . lifecycle . LifecycleService ;  import   ninja . utils . Message ;  import   ninja . utils . NinjaConstant ;  import   ninja . utils . NinjaProperties ;  import   ninja . utils . ResultHandler ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     com . google . common . base . Optional ;  import    com . google . inject . Inject ;   public class NinjaDefault  implements  Ninja  {   private static final Logger  logger =  LoggerFactory . getLogger  (  NinjaDefault . class ) ;   private final String  NINJA_LOGO =       "\n" + " _______  .___ _______        ____.  _____   \n" + " \\      \\ |   |\\      \\      |    | /  _  \\  \n" + " /   |   \\|   |/   |   \\     |    |/  /_\\  \\ \n" + "/    |    \\   /    |    \\/\\__|    /    |    \\  http://www.ninjaframework.org\n" + "\\____|__  /___\\____|__  /\\________\\____|__  /  @ninjaframework\n" + "     web\\/framework   \\/                  \\/   {}\n" ;    @ Inject protected LifecycleService  lifecycleService ;    @ Inject protected Router  router ;    @ Inject protected ResultHandler  resultHandler ;    @ Inject Messages  messages ;    @ Inject NinjaProperties  ninjaProperties ;   public boolean isDiagnosticsEnabled  ( )  {  return   ninjaProperties . isDev  ( ) &&  ninjaProperties . getBooleanWithDefault  (  NinjaConstant . DIAGNOSTICS_KEY_NAME ,  Boolean . TRUE ) ; }    @ Override public void onRouteRequest  (   Context . Impl context )  {  String  httpMethod =  context . getMethod  ( ) ;  Route  route =  router . getRouteFor  ( httpMethod ,  context . getRequestPath  ( ) ) ;   context . setRoute  ( route ) ;  if  (  route != null )  {  Result  underlyingResult = null ;  try  {   underlyingResult =   route . getFilterChain  ( ) . next  ( context ) ;   resultHandler . handleResult  ( underlyingResult , context ) ; }  catch (   Exception exception )  {  Result  result =  onException  ( context , exception , underlyingResult ) ;   renderErrorResultAndCatchAndLogExceptions  ( result , context ) ; }  finally  {   context . cleanup  ( ) ; } } else  {  Result  result =  getNotFoundResult  ( context ) ;   renderErrorResultAndCatchAndLogExceptions  ( result , context ) ; } }    @ Override public void renderErrorResultAndCatchAndLogExceptions  (  Result result ,  Context context )  {  try  {  if  (  context . isAsync  ( ) )  {   context . returnResultAsync  ( result ) ; } else  {   resultHandler . handleResult  ( result , context ) ; } }  catch (   Exception exceptionCausingRenderError )  {   logger . error  ( "Unable to handle result. That's really really fishy." , exceptionCausingRenderError ) ; } }    @ Override public void onFrameworkStart  ( )  {   showSplashScreenViaLogger  ( ) ;   lifecycleService . start  ( ) ; }    @ Override public void onFrameworkShutdown  ( )  {   lifecycleService . stop  ( ) ; }    @ Override public Result onException  (  Context context ,  Exception exception )  {  return  onException  ( context , exception , null ) ; }   public Result onException  (  Context context ,  Exception exception ,  Result underlyingResult )  {  Result  result ;   logger . debug  ( "Unable to process request" , exception ) ;  if  (  exception instanceof BadRequestException )  {   result =  getBadRequestResult  ( context , exception ) ; } else  if  (  exception instanceof RenderingException )  {  RenderingException  renderingException =  ( RenderingException ) exception ;   result =  getRenderingExceptionResult  ( context , renderingException , underlyingResult ) ; } else  {   result =  getInternalServerErrorResult  ( context , exception , underlyingResult ) ; }  return result ; }   public Result getRenderingExceptionResult  (  Context context ,  RenderingException exception ,  Result underlyingResult )  {  if  (  isDiagnosticsEnabled  ( ) )  {  DiagnosticError  diagnosticError =  DiagnosticErrorBuilder . buildDiagnosticError  (  (    exception . getTitle  ( ) == null ? "Rendering exception" :  exception . getTitle  ( ) ) ,  (    exception . getCause  ( ) == null ? exception :  exception . getCause  ( ) ) ,  exception . getSourcePath  ( ) ,  exception . getLineNumber  ( ) , underlyingResult ) ;  return   Results . internalServerError  ( ) . render  ( diagnosticError ) ; }  return  getInternalServerErrorResult  ( context , exception ) ; }    @ Override public Result getInternalServerErrorResult  (  Context context ,  Exception exception )  {  return  getInternalServerErrorResult  ( context , exception , null ) ; }   public Result getInternalServerErrorResult  (  Context context ,  Exception exception ,  Result underlyingResult )  {  if  (  isDiagnosticsEnabled  ( ) )  {  DiagnosticError  diagnosticError =  DiagnosticErrorBuilder . build500InternalServerErrorDiagnosticError  ( exception , true , underlyingResult ) ;  return   Results . internalServerError  ( ) . render  ( diagnosticError ) ; }   logger . error  ( "Emitting bad request 500. Something really wrong when calling route: {} (class: {} method: {})" ,  context . getRequestPath  ( ) ,   context . getRoute  ( ) . getControllerClass  ( ) ,   context . getRoute  ( ) . getControllerMethod  ( ) , exception ) ;  String  messageI18n =  messages . getWithDefault  (  NinjaConstant . I18N_NINJA_SYSTEM_INTERNAL_SERVER_ERROR_TEXT_KEY ,  NinjaConstant . I18N_NINJA_SYSTEM_INTERNAL_SERVER_ERROR_TEXT_DEFAULT , context ,  Optional .  < Result > absent  ( ) ) ;  Message  message =  new Message  ( messageI18n ) ;  Result  result =      Results . internalServerError  ( ) . supportedContentTypes  (  Result . TEXT_HTML ,  Result . APPLICATION_JSON ,  Result . APPLICATION_XML ) . fallbackContentType  (  Result . TEXT_HTML ) . render  ( message ) . template  (  ninjaProperties . getWithDefault  (  NinjaConstant . LOCATION_VIEW_HTML_INTERNAL_SERVER_ERROR_KEY ,  NinjaConstant . LOCATION_VIEW_FTL_HTML_INTERNAL_SERVER_ERROR ) ) ;  return result ; }    @ Override public Result getNotFoundResult  (  Context context )  {  if  (  isDiagnosticsEnabled  ( ) )  {  DiagnosticError  diagnosticError =  DiagnosticErrorBuilder . build404NotFoundDiagnosticError  ( true ) ;  return   Results . notFound  ( ) . render  ( diagnosticError ) ; }  String  messageI18n =  messages . getWithDefault  (  NinjaConstant . I18N_NINJA_SYSTEM_NOT_FOUND_TEXT_KEY ,  NinjaConstant . I18N_NINJA_SYSTEM_NOT_FOUND_TEXT_DEFAULT , context ,  Optional .  < Result > absent  ( ) ) ;  Message  message =  new Message  ( messageI18n ) ;  Result  result =      Results . notFound  ( ) . supportedContentTypes  (  Result . TEXT_HTML ,  Result . APPLICATION_JSON ,  Result . APPLICATION_XML ) . fallbackContentType  (  Result . TEXT_HTML ) . render  ( message ) . template  (  ninjaProperties . getWithDefault  (  NinjaConstant . LOCATION_VIEW_HTML_NOT_FOUND_KEY ,  NinjaConstant . LOCATION_VIEW_FTL_HTML_NOT_FOUND ) ) ;  return result ; }    @ Override public Result getBadRequestResult  (  Context context ,  Exception exception )  {  if  (  isDiagnosticsEnabled  ( ) )  {  DiagnosticError  diagnosticError =  DiagnosticErrorBuilder . build400BadRequestDiagnosticError  ( exception , true ) ;  return   Results . badRequest  ( ) . render  ( diagnosticError ) ; }  String  messageI18n =  messages . getWithDefault  (  NinjaConstant . I18N_NINJA_SYSTEM_BAD_REQUEST_TEXT_KEY ,  NinjaConstant . I18N_NINJA_SYSTEM_BAD_REQUEST_TEXT_DEFAULT , context ,  Optional .  < Result > absent  ( ) ) ;  Message  message =  new Message  ( messageI18n ) ;  Result  result =      Results . badRequest  ( ) . supportedContentTypes  (  Result . TEXT_HTML ,  Result . APPLICATION_JSON ,  Result . APPLICATION_XML ) . fallbackContentType  (  Result . TEXT_HTML ) . render  ( message ) . template  (  ninjaProperties . getWithDefault  (  NinjaConstant . LOCATION_VIEW_HTML_BAD_REQUEST_KEY ,  NinjaConstant . LOCATION_VIEW_FTL_HTML_BAD_REQUEST ) ) ;  return result ; }    @ Override public Result getUnauthorizedResult  (  Context context )  {  if  (  isDiagnosticsEnabled  ( ) )  {  DiagnosticError  diagnosticError =  DiagnosticErrorBuilder . build401UnauthorizedDiagnosticError  ( ) ;  return   Results . unauthorized  ( ) . render  ( diagnosticError ) ; }  String  messageI18n =  messages . getWithDefault  (  NinjaConstant . I18N_NINJA_SYSTEM_UNAUTHORIZED_REQUEST_TEXT_KEY ,  NinjaConstant . I18N_NINJA_SYSTEM_UNAUTHORIZED_REQUEST_TEXT_DEFAULT , context ,  Optional .  < Result > absent  ( ) ) ;  Message  message =  new Message  ( messageI18n ) ;  Result  result =       Results . unauthorized  ( ) . addHeader  (  Result . WWW_AUTHENTICATE , "None" ) . supportedContentTypes  (  Result . TEXT_HTML ,  Result . APPLICATION_JSON ,  Result . APPLICATION_XML ) . fallbackContentType  (  Result . TEXT_HTML ) . render  ( message ) . template  (  ninjaProperties . getWithDefault  (  NinjaConstant . LOCATION_VIEW_HTML_UNAUTHORIZED_KEY ,  NinjaConstant . LOCATION_VIEW_FTL_HTML_UNAUTHORIZED ) ) ;  return result ; }    @ Override public Result getForbiddenResult  (  Context context )  {  if  (  isDiagnosticsEnabled  ( ) )  {  DiagnosticError  diagnosticError =  DiagnosticErrorBuilder . build403ForbiddenDiagnosticError  ( ) ;  return   Results . forbidden  ( ) . render  ( diagnosticError ) ; }  String  messageI18n =  messages . getWithDefault  (  NinjaConstant . I18N_NINJA_SYSTEM_FORBIDDEN_REQUEST_TEXT_KEY ,  NinjaConstant . I18N_NINJA_SYSTEM_FORBIDDEN_REQUEST_TEXT_DEFAULT , context ,  Optional .  < Result > absent  ( ) ) ;  Message  message =  new Message  ( messageI18n ) ;  Result  result =      Results . forbidden  ( ) . supportedContentTypes  (  Result . TEXT_HTML ,  Result . APPLICATION_JSON ,  Result . APPLICATION_XML ) . fallbackContentType  (  Result . TEXT_HTML ) . render  ( message ) . template  (  ninjaProperties . getWithDefault  (  NinjaConstant . LOCATION_VIEW_HTML_FORBIDDEN_KEY ,  NinjaConstant . LOCATION_VIEW_FTL_HTML_FORBIDDEN ) ) ;  return result ; }   private final String readNinjaVersion  ( )  {  String  LOCATION_OF_NINJA_BUILTIN_PROPERTIES = "ninja/ninja-builtin.properties" ;  String  NINJA_VERSION_PROPERTY_KEY = "ninja.version" ;  String  ninjaVersion ;  try  (  InputStream stream =    Thread . currentThread  ( ) . getContextClassLoader  ( ) . getResourceAsStream  ( LOCATION_OF_NINJA_BUILTIN_PROPERTIES ) )  {  Properties  prop =  new Properties  ( ) ;   prop . load  ( stream ) ;   ninjaVersion =  prop . getProperty  ( NINJA_VERSION_PROPERTY_KEY ) ; }  catch (   Exception e )  {  throw  new RuntimeErrorException  (  new Error  (  "Something is wrong with your build. Cannot find resource " + LOCATION_OF_NINJA_BUILTIN_PROPERTIES ) ) ; }  return ninjaVersion ; }   private final void showSplashScreenViaLogger  ( )  {  String  ninjaVersion =  readNinjaVersion  ( ) ;   logger . info  ( NINJA_LOGO , ninjaVersion ) ; } }