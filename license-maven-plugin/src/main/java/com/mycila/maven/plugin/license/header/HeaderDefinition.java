  package      com . mycila . maven . plugin . license . header ;   import    java . util . regex . Pattern ;  import       com . mycila . maven . plugin . license . util . StringUtils ;   public final class HeaderDefinition  {   private final String  type ;   private String  firstLine = "" ;   private String  beforeEachLine = "" ;   private String  endLine = "" ;   private String  afterEachLine = "" ;   private Boolean  allowBlankLines ;   private Pattern  skipLinePattern ;   private Pattern  firstLineDetectionPattern ;   private Pattern  otherLineDetectionPattern ;   private Pattern  lastLineDetectionPattern ;   private boolean  padLines = false ;   public HeaderDefinition  (  String type ,  String firstLine ,  String beforeEachLine ,  String endLine ,  String afterEachLine ,  String skipLinePattern ,  String firstLineDetectionPattern ,  String lastLineDetectionPattern ,  boolean allowBlankLines ,  boolean multiLine ,  boolean padLines )  {  this  ( type , firstLine , beforeEachLine , endLine , afterEachLine , skipLinePattern , firstLineDetectionPattern , null , lastLineDetectionPattern , allowBlankLines , isMultiline , padLines ) ; 
<<<<<<<
=======
   this . multiLine = multiLine ;
>>>>>>>
 
<<<<<<<
=======
 if  (  allowBlankLines &&  ! multiLine )  {  throw  new IllegalArgumentException  (   "Header style " + type + " is configured to allow blank lines, so it should be set as a multi-line header style" ) ; }
>>>>>>>
 }   public HeaderDefinition  (  String type ,  String firstLine ,  String beforeEachLine ,  String endLine ,  String afterEachLine ,  String skipLinePattern ,  String firstLineDetectionPattern ,  String otherLineDetectionPattern ,  String lastLineDetectionPattern ,  boolean allowBlankLines ,  boolean isMultiline ,  boolean padLines )  {  this  ( type ) ;    this . firstLine = firstLine ;    this . beforeEachLine = beforeEachLine ;    this . endLine = endLine ;    this . afterEachLine = afterEachLine ;    this . skipLinePattern =  compile  ( skipLinePattern ) ;    this . firstLineDetectionPattern =  compile  ( firstLineDetectionPattern ) ;    this . otherLineDetectionPattern =  compile  ( otherLineDetectionPattern ) ;    this . lastLineDetectionPattern =  compile  ( lastLineDetectionPattern ) ;    this . allowBlankLines = allowBlankLines ;    this . isMultiline = isMultiline ;    this . padLines = padLines ;  if  (  !  "unknown" . equals  ( type ) )   validate  ( ) ;  if  (  allowBlankLines &&  ! isMultiline )  {  throw  new IllegalArgumentException  (   "Header style " + type + " is configured to allow blank lines, so it should be set as a multiline header style" ) ; } }   public HeaderDefinition  (  String type )  {  if  (  type == null )  {  throw  new IllegalArgumentException  ( "The type of a header definition cannot be null" ) ; }    this . type =  type . toLowerCase  ( ) ; }   private Pattern compile  (  String regexp )  {  return   regexp == null ? null :  Pattern . compile  ( regexp ) ; }   public String getFirstLine  ( )  {  return firstLine ; }   public String getBeforeEachLine  ( )  {  return beforeEachLine ; }   public String getEndLine  ( )  {  return endLine ; }   public String getAfterEachLine  ( )  {  return afterEachLine ; }   public String getType  ( )  {  return type ; }   public boolean allowBlankLines  ( )  {  return allowBlankLines ; }   public boolean isPadLines  ( )  {  return padLines ; }   public boolean isSkipLine  (  String line )  {  return    skipLinePattern != null &&  line != null &&   skipLinePattern . matcher  ( line ) . matches  ( ) ; }   public boolean isFirstHeaderLine  (  String line )  {  return    firstLineDetectionPattern != null &&  line != null &&   firstLineDetectionPattern . matcher  ( line ) . matches  ( ) ; }   public boolean isOtherHeaderLine  (  String line )  {  if  (  line == null )  {  return false ; } else  if  (  otherLineDetectionPattern != null )  {  return   otherLineDetectionPattern . matcher  ( line ) . matches  ( ) ; } else  if  (   "" . equals  (  StringUtils . rtrim  ( beforeEachLine ) ) &&  !  isMultiLine  ( ) )  {  return  line . startsWith  ( beforeEachLine ) ; } else  {  return  line . startsWith  (  StringUtils . rtrim  ( beforeEachLine ) ) ; } }   public boolean isLastHeaderLine  (  String line )  {  return    lastLineDetectionPattern != null &&  line != null &&   lastLineDetectionPattern . matcher  ( line ) . matches  ( ) ; }   protected Pattern getSkipLinePattern  ( )  {  return skipLinePattern ; }   public void setPropertyFromString  (  String property ,  String value )  {  if  (  isEmpty  ( value ) )  {  throw  new IllegalArgumentException  (    "The value cannot be empty for XML tag " + property + " for type " + type ) ; }  if  (  "firstLine" . equalsIgnoreCase  ( property ) )   firstLine = value ; else  if  (  "allowBlankLines" . equalsIgnoreCase  ( property ) )   allowBlankLines =  Boolean . valueOf  ( value ) ; else  if  (   "multiLine" . equalsIgnoreCase  ( property ) ||  "isMultiline" . equalsIgnoreCase  ( property ) )   multiLine =  Boolean . valueOf  ( value ) ; else  if  (  "beforeEachLine" . equalsIgnoreCase  ( property ) )   beforeEachLine = value ; else  if  (  "endLine" . equalsIgnoreCase  ( property ) )   endLine = value ; else  if  (  "afterEachLine" . equalsIgnoreCase  ( property ) )   afterEachLine = value ; else  if  (  "skipLine" . equalsIgnoreCase  ( property ) )   skipLinePattern =  compile  ( value ) ; else  if  (  "padLines" . equalsIgnoreCase  ( property ) )   padLines =  Boolean . parseBoolean  ( value ) ; else  if  (  "firstLineDetectionPattern" . equalsIgnoreCase  ( property ) )   firstLineDetectionPattern =  compile  ( value ) ; else  if  (  "lastLineDetectionPattern" . equalsIgnoreCase  ( property ) )   lastLineDetectionPattern =  compile  ( value ) ; }   public void validate  ( )  {   check  ( "firstLine" ,  this . firstLine ) ;   check  ( "beforeEachLine" ,  this . beforeEachLine ) ;   check  ( "endLine" ,  this . endLine ) ;   check  ( "afterEachLine" ,  this . afterEachLine ) ;   check  ( "firstLineDetectionPattern" ,  this . firstLineDetectionPattern ) ;   check  ( "lastLineDetectionPattern" ,  this . lastLineDetectionPattern ) ;   check  ( "multiLine" ,  this . multiLine ) ;   check  ( "allowBlankLines" ,  this . allowBlankLines ) ; }   private void check  (  String name ,  Boolean value )  {  if  (  value == null )  {  throw  new IllegalStateException  (  String . format  ( "The property '%s' is missing for header definition '%s'" , name , type ) ) ; } }   private void check  (  String name ,  String value )  {  if  (  value == null )  {  throw  new IllegalStateException  (  String . format  ( "The property '%s' is missing for header definition '%s'" , name , type ) ) ; } }   private void check  (  String name ,  Pattern value )  {  if  (  isEmpty  (  value . pattern  ( ) ) )  {  throw  new IllegalStateException  (  String . format  ( "The property '%s' is missing for header definition '%s'" , name , type ) ) ; } }   private boolean isEmpty  (  String s )  {  return   s == null ||  "" . equals  ( s ) ; }    @ Override public boolean equals  (  Object o )  {  if  (  this == o )  return true ;  if  (   o == null ||   getClass  ( ) !=  o . getClass  ( ) )  return false ;  HeaderDefinition  that =  ( HeaderDefinition ) o ;  return  !  (   type != null ?  !  type . equals  (  that . type ) :   that . type != null ) ; }    @ Override public  int hashCode  ( )  {  return   type != null ?  type . hashCode  ( ) : 0 ; }    @ Override public String toString  ( )  {  return type ; }   public boolean isMultiLine  ( )  {  return multiLine ; }   private Boolean  multiLine ; }