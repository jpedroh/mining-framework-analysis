  package    cc . redpen . parser . markdown ;   import   cc . redpen . RedPenException ;  import    cc . redpen . model . Document ;  import    cc . redpen . model . DocumentCollection ;  import    cc . redpen . model . Section ;  import    cc . redpen . model . Sentence ;  import    cc . redpen . parser . SentenceExtractor ;  import    org . parboiled . common . StringUtils ;  import   org . pegdown . Printer ;  import   org . pegdown . ast .  * ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import   java . util . ArrayList ;  import   java . util . HashMap ;  import   java . util . List ;  import   java . util . Map ;  import static     org . parboiled . common . Preconditions . checkArgNotNull ;   public class ToFileContentSerializer  implements  Visitor  {   private static final Logger  LOG =  LoggerFactory . getLogger  (  ToFileContentSerializer . class ) ;   private final  Map  < String , ReferenceNode >  references =  new  HashMap  < String , ReferenceNode >  ( ) ;   private final  Map  < String , String >  abbreviations =  new  HashMap  < String , String >  ( ) ;   private  DocumentCollection . Builder  builder = null ;   private SentenceExtractor  sentenceExtractor ;   private  int  itemDepth = 0 ;   private  List  < Integer >  lineList = null ;   private String  period ;   private  List  < CandidateSentence >  candidateSentences =  new  ArrayList  < CandidateSentence >  ( ) ;   private Printer  printer =  new Printer  ( ) ;   public ToFileContentSerializer  (   DocumentCollection . Builder docBuilder ,   List  < Integer > listOfLineNumber ,  SentenceExtractor extractor )  {    this . builder = docBuilder ;    this . lineList = listOfLineNumber ;    this . sentenceExtractor = extractor ; }   protected void visitChildren  (  SuperNode node )  {  for ( Node child :  node . getChildren  ( ) )  {   child . accept  ( this ) ; } }   public Document toFileContent  (  RootNode astRoot )  throws RedPenException  {  try  {   checkArgNotNull  ( astRoot , "astRoot" ) ;   astRoot . accept  ( this ) ; }  catch (   NullPointerException e )  {   LOG . error  ( "Fail to traverse RootNode." ) ;  throw  new RedPenException  ( "Fail to traverse RootNode." , e ) ; }  return  builder . getLastDocument  ( ) ; }   private void fixSentence  ( )  {   List  < Sentence >  sentences =  createSentenceList  ( ) ;  for ( Sentence sentence : sentences )  {   builder . addSentence  ( sentence ) ; } }   private void addCandidateSentence  (   int lineNum ,  String text )  {   addCandidateSentence  ( lineNum , text , null ) ; }   private void addCandidateSentence  (   int lineNum ,  String text ,  String link )  {   candidateSentences . add  (  new CandidateSentence  ( lineNum , text , link ) ) ; }   private  int lineNumberFromStartIndex  (   int startIndex )  {   int  lineNum = 0 ;  for (  int end : lineList )  {  if  (  startIndex < end )  {  break ; }   lineNum ++ ; }  return lineNum ; }   private String printChildrenToString  (  SuperNode node )  {  Printer  priorPrinter = printer ;   printer =  new Printer  ( ) ;   visitChildren  ( node ) ;  String  result =  printer . getString  ( ) ;   printer = priorPrinter ;  return result ; }   private  List  < Sentence > createSentenceList  ( )  {   List  < Sentence >  newSentences =  new  ArrayList  < >  ( ) ;  String  remainStr = "" ;  Sentence  currentSentence = null ;   List  < String >  remainLinks =  new  ArrayList  < >  ( ) ;   int  lineNum =  - 1 ;  for ( CandidateSentence candidateSentence : candidateSentences )  {   lineNum =  candidateSentence . getLineNum  ( ) ;   List  < Sentence >  currentSentences =  new  ArrayList  < >  ( ) ;   remainStr =  sentenceExtractor . extract  (  remainStr +  candidateSentence . getSentence  ( ) , currentSentences , lineNum ) ;  if  (   currentSentences . size  ( ) > 0 )  {   currentSentence =  addExtractedSentences  ( newSentences , remainLinks , currentSentences ) ;   remainLinks =  new  ArrayList  < >  ( ) ; }  if  (   candidateSentence . getLink  ( ) == null )  {  continue ; }  if  (  currentSentence != null )  {    currentSentence . links . add  (  candidateSentence . getLink  ( ) ) ; } else  {   remainLinks . add  (  candidateSentence . getLink  ( ) ) ; } }  if  (   remainStr . length  ( ) > 0 )  {   newSentences . add  (  new Sentence  ( remainStr , lineNum ) ) ; }   candidateSentences . clear  ( ) ;  return newSentences ; }   private boolean addChild  (  Section candidate ,  Section child )  {  if  (   candidate . getLevel  ( ) <  child . getLevel  ( ) )  {   candidate . appendSubSection  ( child ) ;   child . setParentSection  ( candidate ) ; } else  {  Section  parent =  candidate . getParentSection  ( ) ;  while  (  parent != null )  {  if  (   parent . getLevel  ( ) <  child . getLevel  ( ) )  {   parent . appendSubSection  ( child ) ;   child . setParentSection  ( parent ) ;  break ; }   parent =  parent . getParentSection  ( ) ; }  if  (  parent == null )  {  return false ; } }  return true ; }   private void appendSection  (  HeaderNode headerNode )  {   fixSentence  ( ) ;   visitChildren  ( headerNode ) ;   List  < Sentence >  headerContents =  createSentenceList  ( ) ;  if  (   headerContents . size  ( ) > 0 )  {     headerContents . get  ( 0 ) . isFirstSentence = true ; }  Section  currentSection =  builder . getLastSection  ( ) ;   builder . addSection  (  headerNode . getLevel  ( ) , headerContents ) ;  if  (  !  addChild  ( currentSection ,  builder . getLastSection  ( ) ) )  {   LOG . warn  (  "Failed to add parent for a Section: " +    builder . getLastSection  ( ) . getHeaderContents  ( ) . get  ( 0 ) ) ; } }    @ Override public void visit  (  AbbreviationNode abbreviationNode )  { }    @ Override public void visit  (  AutoLinkNode autoLinkNode )  {   addCandidateSentence  (  lineNumberFromStartIndex  (  autoLinkNode . getStartIndex  ( ) ) ,  autoLinkNode . getText  ( ) ,  autoLinkNode . getText  ( ) ) ; }    @ Override public void visit  (  BlockQuoteNode blockQuoteNode )  {   visitChildren  ( blockQuoteNode ) ; }    @ Override public void visit  (  CodeNode codeNode )  {   addCandidateSentence  (  lineNumberFromStartIndex  (  codeNode . getStartIndex  ( ) ) ,  codeNode . getText  ( ) ) ; }    @ Override public void visit  (  ExpImageNode expImageNode )  { }    @ Override public void visit  (  ExpLinkNode expLinkNode )  {  String  linkName =  printChildrenToString  ( expLinkNode ) ;  CandidateSentence  lastCandidateSentence =  candidateSentences . get  (   candidateSentences . size  ( ) - 1 ) ;   lastCandidateSentence . setLink  (  expLinkNode . url ) ; }    @ Override public void visit  (  HeaderNode headerNode )  {   appendSection  ( headerNode ) ; }    @ Override public void visit  (  BulletListNode bulletListNode )  {  if  (  itemDepth == 0 )  {   fixSentence  ( ) ;   builder . addListBlock  ( ) ; } else  {   List  < Sentence >  sentences =  createSentenceList  ( ) ;   builder . addListElement  ( itemDepth , sentences ) ; }   itemDepth ++ ;   visitChildren  ( bulletListNode ) ;   itemDepth -- ; }    @ Override public void visit  (  OrderedListNode orderedListNode )  {  if  (  itemDepth == 0 )  {   fixSentence  ( ) ;   builder . addListBlock  ( ) ; } else  {   List  < Sentence >  sentences =  createSentenceList  ( ) ;   builder . addListElement  ( itemDepth , sentences ) ; }   itemDepth ++ ;   visitChildren  ( orderedListNode ) ;   itemDepth -- ; }    @ Override public void visit  (  ListItemNode listItemNode )  {   visitChildren  ( listItemNode ) ;   List  < Sentence >  sentences =  createSentenceList  ( ) ;  if  (   sentences != null &&   sentences . size  ( ) > 0 )  {   builder . addListElement  ( itemDepth , sentences ) ; } }    @ Override public void visit  (  ParaNode paraNode )  {   builder . addParagraph  ( ) ;   visitChildren  ( paraNode ) ;   fixSentence  ( ) ; }    @ Override public void visit  (  RootNode rootNode )  {  for ( ReferenceNode refNode :  rootNode . getReferences  ( ) )  { }  for ( AbbreviationNode abbrNode :  rootNode . getAbbreviations  ( ) )  { }   visitChildren  ( rootNode ) ; }    @ Override public void visit  (  SimpleNode simpleNode )  {  switch  (  simpleNode . getType  ( ) )  {   case Linebreak :  break ;   case Nbsp :  break ;   case HRule :  break ;   case Apostrophe :   addCandidateSentence  (  lineNumberFromStartIndex  (  simpleNode . getStartIndex  ( ) ) , "'" ) ;  break ;   case Ellipsis :   addCandidateSentence  (  lineNumberFromStartIndex  (  simpleNode . getStartIndex  ( ) ) , "..." ) ;  break ;   case Emdash :   addCandidateSentence  (  lineNumberFromStartIndex  (  simpleNode . getStartIndex  ( ) ) , "–" ) ;  break ;   case Endash :   addCandidateSentence  (  lineNumberFromStartIndex  (  simpleNode . getStartIndex  ( ) ) , "—" ) ;  break ;   default :   LOG . warn  (   "Illegal SimpleNode:[" +  simpleNode . toString  ( ) + "]" ) ; } }    @ Override public void visit  (  SpecialTextNode specialTextNode )  {   addCandidateSentence  (  lineNumberFromStartIndex  (  specialTextNode . getStartIndex  ( ) ) ,  specialTextNode . getText  ( ) ) ; }    @ Override public void visit  (  StrikeNode strikeNode )  {   visitChildren  ( strikeNode ) ; }    @ Override public void visit  (  StrongEmphSuperNode strongEmphSuperNode )  {   visitChildren  ( strongEmphSuperNode ) ; }    @ Override public void visit  (  TextNode textNode )  {   addCandidateSentence  (  lineNumberFromStartIndex  (  textNode . getStartIndex  ( ) ) ,  textNode . getText  ( ) ) ;   printer . print  (  textNode . getText  ( ) ) ; }    @ Override public void visit  (  VerbatimNode verbatimNode )  { }    @ Override public void visit  (  QuotedNode quotedNode )  { }    @ Override public void visit  (  ReferenceNode referenceNode )  { }    @ Override public void visit  (  RefImageNode refImageNode )  { }    @ Override public void visit  (  RefLinkNode refLinkNode )  {  String  linkName =  printChildrenToString  ( refLinkNode ) ;  String  url =  getRefLinkUrl  (  refLinkNode . referenceKey , linkName ) ;  CandidateSentence  lastCandidateSentence =  candidateSentences . get  (   candidateSentences . size  ( ) - 1 ) ;  if  (  StringUtils . isNotEmpty  ( url ) )  {   lastCandidateSentence . setLink  ( url ) ; } else  {   lastCandidateSentence . setSentence  (   "[" +  lastCandidateSentence . getSentence  ( ) + "]" ) ; } }   private String getRefLinkUrl  (  SuperNode referenceKey ,  String linkName )  {  ReferenceNode  refNode =  references . get  ( linkName ) ;  StringBuilder  sb =  new StringBuilder  ( ) ;  if  (  refNode != null )  {   sb . append  (  refNode . getUrl  ( ) ) ; }  return  sb . toString  ( ) ; }    @ Override public void visit  (  HtmlBlockNode htmlBlockNode )  { }    @ Override public void visit  (  InlineHtmlNode inlineHtmlNode )  { }    @ Override public void visit  (  MailLinkNode mailLinkNode )  { }    @ Override public void visit  (  WikiLinkNode wikiLinkNode )  { }    @ Override public void visit  (  SuperNode superNode )  {   visitChildren  ( superNode ) ; }    @ Override public void visit  (  Node node )  { }    @ Override public void visit  (  DefinitionListNode definitionListNode )  { }    @ Override public void visit  (  DefinitionNode definitionNode )  { }    @ Override public void visit  (  DefinitionTermNode definitionTermNode )  { }    @ Override public void visit  (  TableBodyNode tableBodyNode )  { }    @ Override public void visit  (  TableCaptionNode tableCaptionNode )  { }    @ Override public void visit  (  TableCellNode tableCellNode )  { }    @ Override public void visit  (  TableColumnNode tableColumnNode )  { }    @ Override public void visit  (  TableHeaderNode tableHeaderNode )  { }    @ Override public void visit  (  TableNode tableNode )  { }    @ Override public void visit  (  TableRowNode tableRowNode )  { }   private Sentence addExtractedSentences  (   List  < Sentence > newSentences ,   List  < String > remainLinks ,   List  < Sentence > currentSentences )  {  Sentence  currentSentence ;   newSentences . addAll  ( currentSentences ) ;   currentSentence =  currentSentences . get  (   currentSentences . size  ( ) - 1 ) ;  for ( String remainLink : remainLinks )  {    currentSentence . links . add  ( remainLink ) ; }  return currentSentence ; } }