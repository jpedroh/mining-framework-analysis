  package   cc . redpen . validator ;   import   cc . redpen . DocumentValidatorException ;  import    cc . redpen . config . SymbolTable ;  import    cc . redpen . config . ValidatorConfiguration ;  import    java . lang . reflect . Constructor ;  import    java . lang . reflect . InvocationTargetException ;  import   java . util . ArrayList ;  import   java . util . List ;   public class ValidatorFactory  {   public static  Validator  <  ? > getInstance  (  ValidatorConfiguration config ,  SymbolTable symbolTable )  throws DocumentValidatorException  {  switch  (  config . getConfigurationName  ( ) )  {   case "SentenceLength" :  return  new SentenceLengthValidator  ( config , symbolTable ) ;   case "InvalidExpression" :  return  new InvalidExpressionValidator  ( config , symbolTable ) ;   case "InvalidWord" :  return  new InvalidWordValidator  ( config , symbolTable ) ;   case "SpaceAfterPeriod" :  return  new SpaceBeginningOfSentenceValidator  ( config , symbolTable ) ;   case "CommaNumber" :  return  new CommaNumberValidator  ( config , symbolTable ) ;   case "WordNumber" :  return  new WordNumberValidator  ( config , symbolTable ) ;   case "SuggestExpression" :  return  new SuggestExpressionValidator  ( config , symbolTable ) ;   case "InvalidSymbol" :  return  new InvalidSymbolValidator  ( config , symbolTable ) ;   case "SpaceWithSymbol" :  return  new SymbolWithSpaceValidator  ( config , symbolTable ) ;   case "KatakanaEndHyphen" :  return  new KatakanaEndHyphenValidator  ( config , symbolTable ) ;   case "KatakanaSpellCheck" :  return  new KatakanaSpellCheckValidator  ( config , symbolTable ) ;   case "Spelling" :  return  new SpellingValidator  ( config , symbolTable ) ;   case "SpaceBetweenAlphabeticalWord" :  return  new SpaceBetweenAlphabeticalWord  ( ) ;   case "SectionLength" :  return  new SectionLengthValidator  ( config , symbolTable ) ;   case "MaxParagraphNumber" :  return  new ParagraphNumberValidator  ( config , symbolTable ) ;   case "ParagraphStartWith" :  return  new ParagraphStartWithValidator  ( config , symbolTable ) ;   default :  throw  new DocumentValidatorException  (  "There is no Validator like " +  config . getConfigurationName  ( ) ) ; } }   private static final  List  < String >  VALIDATOR_PACKAGES =  new  ArrayList  < >  ( ) ;  static  {   addValidatorPackage  ( "cc.redpen.validator" ) ;   addValidatorPackage  ( "cc.redpen.validator.sentence" ) ;   addValidatorPackage  ( "cc.redpen.validator.section" ) ; }   private static void addValidatorPackage  (  String packageToAdd )  {   VALIDATOR_PACKAGES . add  ( packageToAdd ) ; } 
<<<<<<<
=======
  public static  Validator  <  ? > getInstance  (  ValidatorConfiguration config ,  CharacterTable characterTable )  throws DocumentValidatorException  {  try  {  for ( String validatorPackage : VALIDATOR_PACKAGES )  {  String  validatorClassName =    validatorPackage + "." +  config . getConfigurationName  ( ) + "Validator" ;  try  {   Class  <  ? >  clazz =  Class . forName  ( validatorClassName ) ;  boolean  implementsValidator = false ;  for (  Class  <  ? > aClass :  clazz . getInterfaces  ( ) )  {  if  (  aClass . equals  (     cc . redpen . validator . Validator . class ) )  {   implementsValidator = true ;  break ; } }  if  (  ! implementsValidator )  {  throw  new RuntimeException  (  validatorClassName + " doesn't implement cc.redpen.validator.Validator" ) ; }   Constructor  <  ? >  constructor =  clazz . getConstructor  (  ValidatorConfiguration . class ,  CharacterTable . class ) ;  return  (  Validator  <  ? > )  constructor . newInstance  ( config , characterTable ) ; }  catch (   ClassNotFoundException ignore )  { } } }  catch (   NoSuchMethodException | InvocationTargetException | IllegalAccessException | InstantiationException e )  {  throw  new RuntimeException  ( e ) ; }  throw  new DocumentValidatorException  (  "There is no such Validator: " +  config . getConfigurationName  ( ) ) ; }
>>>>>>>
 }