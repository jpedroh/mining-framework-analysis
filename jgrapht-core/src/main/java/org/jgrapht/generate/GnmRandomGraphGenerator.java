  package   org . jgrapht . generate ;   import   java . util . HashMap ;  import   java . util . Map ;  import   java . util . Objects ;  import   java . util . Random ;  import   org . jgrapht . Graph ;   public class GnmRandomGraphGenerator  <  V ,  E >  implements   GraphGenerator  < V , E , V >  {   private static final boolean  DEFAULT_ALLOW_LOOPS = false ;   private static final boolean  DEFAULT_ALLOW_MULTIPLE_EDGES = false ;   private final Random  rng ;   private final  int  n ;   private final  int  m ;   private final boolean  loops ;   private final boolean  multipleEdges ;   public GnmRandomGraphGenerator  (   int n ,   int m )  {  this  ( n , m ,  new Random  ( ) , DEFAULT_ALLOW_LOOPS , DEFAULT_ALLOW_MULTIPLE_EDGES ) ; }   public GnmRandomGraphGenerator  (   int n ,   int m ,   long seed )  {  this  ( n , m ,  new Random  ( seed ) , DEFAULT_ALLOW_LOOPS , DEFAULT_ALLOW_MULTIPLE_EDGES ) ; }   public GnmRandomGraphGenerator  (   int n ,   int m ,   long seed ,  boolean loops ,  boolean multipleEdges )  {  this  ( n , m ,  new Random  ( seed ) , loops , multipleEdges ) ; }   public GnmRandomGraphGenerator  (   int n ,   int m ,  Random rng ,  boolean loops ,  boolean multipleEdges )  {  if  (  n < 0 )  {  throw  new IllegalArgumentException  ( "number of vertices must be non-negative" ) ; }    this . n = n ;  if  (  m < 0 )  {  throw  new IllegalArgumentException  ( "number of edges must be non-negative" ) ; }    this . m = m ;    this . rng =  Objects . requireNonNull  ( rng ) ;    this . loops = loops ;    this . multipleEdges = multipleEdges ; }    @ Override public void generateGraph  (   Graph  < V , E > target ,   Map  < String , V > resultMap )  {  if  (  n == 0 )  {  return ; }  boolean  createLoops = loops ;  if  (  createLoops &&  !   target . getType  ( ) . isAllowingSelfLoops  ( ) )  {  throw  new IllegalArgumentException  ( "Provided graph does not support self-loops" ) ; }  boolean  createMultipleEdges = multipleEdges ;  if  (  createMultipleEdges &&  !   target . getType  ( ) . isAllowingMultipleEdges  ( ) )  {  throw  new IllegalArgumentException  ( "Provided graph does not support multiple edges between the same vertices" ) ; }  if  (  m >  computeMaximumAllowedEdges  ( n ,   target . getType  ( ) . isDirected  ( ) , createLoops , createMultipleEdges ) )  {  throw  new IllegalArgumentException  (        "number of edges is not valid for the graph type " + "\n-> invalid number of edges=" + m + " for:" + " graph type=" +  target . getClass  ( ) + ", number of vertices=" + n ) ; }   Map  < Integer , V >  vertices =  new  HashMap  < >  ( n ) ;   int  previousVertexSetSize =   target . vertexSet  ( ) . size  ( ) ;  for (   int  i = 0 ;  i < n ;  i ++ )  {  V  currVertex =  target . addVertex  ( ) ;   vertices . put  ( i , currVertex ) ; }  if  (    target . vertexSet  ( ) . size  ( ) !=  previousVertexSetSize + n )  {  throw  new IllegalArgumentException  (   "Vertex factory did not produce " + n + " distinct vertices." ) ; }   int  edgesCounter = 0 ;  while  (  edgesCounter < m )  {  V  s =  vertices . get  (  rng . nextInt  ( n ) ) ;  V  t =  vertices . get  (  rng . nextInt  ( n ) ) ;  boolean  addEdge = false ;  if  (  s . equals  ( t ) )  {  if  ( createLoops )  {   addEdge = true ; } } else  {  if  ( createMultipleEdges )  {   addEdge = true ; } else  {  if  (  !  target . containsEdge  ( s , t ) )  {   addEdge = true ; } } }  if  ( addEdge )  {  try  {  E  resultEdge =  target . addEdge  ( s , t ) ;  if  (  resultEdge != null )  {   edgesCounter ++ ; } }  catch (   IllegalArgumentException e )  { } } } }   static  <  V ,  E >  int computeMaximumAllowedEdges  (   int n ,  boolean isDirected ,  boolean createLoops ,  boolean createMultipleEdges )  {  if  (  n == 0 )  {  return 0 ; }   int  maxAllowedEdges ;  try  {  if  ( isDirected )  {   maxAllowedEdges =  Math . multiplyExact  ( n ,  n - 1 ) ; } else  {  if  (   n % 2 == 0 )  {   maxAllowedEdges =  Math . multiplyExact  (  n / 2 ,  n - 1 ) ; } else  {   maxAllowedEdges =  Math . multiplyExact  ( n ,   (  n - 1 ) / 2 ) ; } }  if  ( createLoops )  {  if  ( createMultipleEdges )  {  return  Integer . MAX_VALUE ; } else  {  if  ( isDirected )  {   maxAllowedEdges =  Math . addExact  ( maxAllowedEdges ,  Math . multiplyExact  ( 2 , n ) ) ; } else  {   maxAllowedEdges =  Math . addExact  ( maxAllowedEdges , n ) ; } } } else  {  if  ( createMultipleEdges )  {  if  (  n > 1 )  {  return  Integer . MAX_VALUE ; } } } }  catch (   ArithmeticException e )  {  return  Integer . MAX_VALUE ; }  return maxAllowedEdges ; } }