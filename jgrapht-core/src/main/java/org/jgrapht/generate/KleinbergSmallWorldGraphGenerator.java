  package   org . jgrapht . generate ;   import  java . util .  * ;  import  org . jgrapht .  * ;  import    org . jgrapht . alg . util .  * ;   public class KleinbergSmallWorldGraphGenerator  <  V ,  E >  implements   GraphGenerator  < V , E , V >  {   private final Random  rng ;   private final  int  n ;   private final  int  p ;   private final  int  q ;   private final  int  r ;   public KleinbergSmallWorldGraphGenerator  (   int n ,   int p ,   int q ,   int r )  {  this  ( n , p , q , r ,  new Random  ( ) ) ; }   public KleinbergSmallWorldGraphGenerator  (   int n ,   int p ,   int q ,   int r ,   long seed )  {  this  ( n , p , q , r ,  new Random  ( seed ) ) ; }   public KleinbergSmallWorldGraphGenerator  (   int n ,   int p ,   int q ,   int r ,  Random rng )  {  if  (  n < 1 )  {  throw  new IllegalArgumentException  ( "parameter n must be positive" ) ; }    this . n = n ;  if  (  p < 1 )  {  throw  new IllegalArgumentException  ( "parameter p must be positive" ) ; }  if  (  p >   2 * n - 2 )  {  throw  new IllegalArgumentException  ( "lattice distance too large" ) ; }    this . p = p ;  if  (  q < 0 )  {  throw  new IllegalArgumentException  ( "parameter q must be non-negative" ) ; }    this . q = q ;  if  (  r < 0 )  {  throw  new IllegalArgumentException  ( "parameter r must be non-negative" ) ; }    this . r = r ;    this . rng =  Objects . requireNonNull  ( rng , "Random number generator cannot be null" ) ; }    @ Override public void generateGraph  (   Graph  < V , E > target ,   Map  < String , V > resultMap )  {  if  (  n == 0 )  {  return ; } else  if  (  n == 1 )  {   target . addVertex  ( ) ;  return ; }   GraphTests . requireDirectedOrUndirected  ( target ) ;  boolean  isDirected =   target . getType  ( ) . isDirected  ( ) ;   List  < V >  nodes =  new  ArrayList  < >  (  n * n ) ;  for (   int  i = 0 ;  i <  n * n ;  i ++ )  {  V  v =  target . addVertex  ( ) ;  if  (  v == null )  {  throw  new IllegalArgumentException  ( "Invalid vertex supplier" ) ; }   nodes . add  ( v ) ; }  for (   int  i = 0 ;  i < n ;  i ++ )  {  for (   int  j = 0 ;  j < n ;  j ++ )  {   int  vi =   i * n + j ;  V  v =  nodes . get  ( vi ) ;  for (   int  di =  - p ;  di <= p ;  di ++ )  {  for (   int  dj =  - p ;  dj <= p ;  dj ++ )  {   int  t =    (  i + di ) * n +  (  j + dj ) ;  if  (    t < 0 ||  t == vi ||  t >=  n * n )  {  continue ; }  if  (     Math . abs  ( di ) +  Math . abs  ( dj ) <= p &&  (  isDirected ||  t >   i * n + j ) )  {   target . addEdge  ( v ,  nodes . get  ( t ) ) ; } } } } }    double  [ ]  p =  new  double  [  n * n ] ;  for (   int  i = 0 ;  i < n ;  i ++ )  {  for (   int  j = 0 ;  j < n ;  j ++ )  {  V  v =  nodes . get  (   i * n + j ) ;   double  sum = 0d ;  for (   int  oi = 0 ;  oi < n ;  oi ++ )  {  for (   int  oj = 0 ;  oj < n ;  oj ++ )  {  if  (   oi != i ||  oj != j )  {   double  weight =  Math . pow  (   Math . abs  (  i - oi ) +  Math . abs  (  j - oj ) ,  - r ) ;    p [   oi * n + oj ] = weight ;   sum += weight ; } } }    p [   i * n + j ] = 0d ;  for (   int  k = 0 ;  k <  n * n ;  k ++ )  {    p [ k ] /= sum ; }  AliasMethodSampler  sampler =  new AliasMethodSampler  ( p , rng ) ;  for (   int  k = 0 ;  k < q ;  k ++ )  {  V  u =  nodes . get  (  sampler . next  ( ) ) ;  if  (   !  u . equals  ( v ) &&  !  target . containsEdge  ( v , u ) )  {   target . addEdge  ( v , u ) ; } } } } } }