  package   org . jgrapht . generate ;   import  java . util .  * ;  import  org . jgrapht .  * ;   public class GnmRandomBipartiteGraphGenerator  <  V ,  E >  implements   GraphGenerator  < V , E , V >  {   private final Random  rng ;   private final  int  n1 ;   private final  int  n2 ;   private final  int  m ;   private  Map  < Integer , V >  partitionA ;   private  Map  < Integer , V >  partitionB ;   public GnmRandomBipartiteGraphGenerator  (   int n1 ,   int n2 ,   int m )  {  this  ( n1 , n2 , m ,  new Random  ( ) ) ; }   public GnmRandomBipartiteGraphGenerator  (   int n1 ,   int n2 ,   int m ,   long seed )  {  this  ( n1 , n2 , m ,  new Random  ( seed ) ) ; }   public GnmRandomBipartiteGraphGenerator  (   int n1 ,   int n2 ,   int m ,  Random rng )  {  if  (  n1 < 0 )  {  throw  new IllegalArgumentException  ( "number of vertices must be non-negative" ) ; }    this . n1 = n1 ;  if  (  n2 < 0 )  {  throw  new IllegalArgumentException  ( "number of vertices must be non-negative" ) ; }    this . n2 = n2 ;  if  (  m < 0 )  {  throw  new IllegalArgumentException  ( "number of edges must be non-negative" ) ; }    this . m = m ;    this . rng =  Objects . requireNonNull  ( rng ) ; }    @ Override public void generateGraph  (   Graph  < V , E > target ,   Map  < String , V > resultMap )  {  if  (   n1 + n2 == 0 )  {  return ; }   int  previousVertexSetSize =   target . vertexSet  ( ) . size  ( ) ;   partitionA =  new  LinkedHashMap  < >  ( n1 ) ;  for (   int  i = 0 ;  i < n1 ;  i ++ )  {   partitionA . put  ( i ,  target . addVertex  ( ) ) ; }   partitionB =  new  LinkedHashMap  < >  ( n2 ) ;  for (   int  i = 0 ;  i < n2 ;  i ++ )  {   partitionB . put  ( i ,  target . addVertex  ( ) ) ; }  if  (    target . vertexSet  ( ) . size  ( ) !=   previousVertexSetSize + n1 + n2 )  {  throw  new IllegalArgumentException  (   "Vertex factory did not produce " +  (  n1 + n2 ) + " distinct vertices." ) ; }   final boolean  isDirected =   target . getType  ( ) . isDirected  ( ) ;   int  maxAllowedEdges ;  try  {  if  ( isDirected )  {   maxAllowedEdges =  Math . multiplyExact  ( 2 ,  Math . multiplyExact  ( n1 , n2 ) ) ; } else  {   maxAllowedEdges =  Math . multiplyExact  ( n1 , n2 ) ; } }  catch (   ArithmeticException e )  {   maxAllowedEdges =  Integer . MAX_VALUE ; }  if  (  m > maxAllowedEdges )  {  throw  new IllegalArgumentException  (     "number of edges not valid for bipartite graph with " + n1 + " and " + n2 + " vertices" ) ; }   int  edgesCounter = 0 ;  while  (  edgesCounter < m )  {  V  s =  partitionA . get  (  rng . nextInt  ( n1 ) ) ;  V  t =  partitionB . get  (  rng . nextInt  ( n2 ) ) ;  if  (  isDirected &&  rng . nextBoolean  ( ) )  {  V  tmp = s ;   s = t ;   t = tmp ; }  if  (  !  target . containsEdge  ( s , t ) )  {  try  {  E  resultEdge =  target . addEdge  ( s , t ) ;  if  (  resultEdge != null )  {   edgesCounter ++ ; } }  catch (   IllegalArgumentException e )  { } } } }   public  Set  < V > getFirstPartition  ( )  {  if  (   partitionA . size  ( ) <=  partitionB . size  ( ) )  return  new  LinkedHashSet  < >  (  partitionA . values  ( ) ) ; else  return  new  LinkedHashSet  < >  (  partitionB . values  ( ) ) ; }   public  Set  < V > getSecondPartition  ( )  {  if  (   partitionB . size  ( ) >=  partitionA . size  ( ) )  return  new  LinkedHashSet  < >  (  partitionB . values  ( ) ) ; else  return  new  LinkedHashSet  < >  (  partitionA . values  ( ) ) ; } }