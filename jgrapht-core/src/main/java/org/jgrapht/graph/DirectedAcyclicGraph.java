  package   org . jgrapht . graph ;   import   java . io . Serializable ;  import  java . util .  * ;  import    java . util . function . Supplier ;  import  org . jgrapht .  * ;  import     org . jgrapht . graph . builder . GraphBuilder ;  import    org . jgrapht . traverse . DepthFirstIterator ;  import    org . jgrapht . util . SupplierUtil ;   public class DirectedAcyclicGraph  <  V ,  E >  extends  SimpleDirectedGraph  < V , E >  implements   Iterable  < V >  {   private static final  long  serialVersionUID = 4522128427004938150L ;   private static final String  EDGE_WOULD_INDUCE_A_CYCLE = "Edge would induce a cycle" ;   private final  Comparator  < V >  topoComparator ;   private final  TopoOrderMap  < V >  topoOrderMap ;   private  int  maxTopoIndex = 0 ;   private  int  minTopoIndex = 0 ;   private transient  long  topoModCount = 0 ;   private final VisitedStrategyFactory  visitedStrategyFactory ;   public DirectedAcyclicGraph  (   Class  <  ? extends E > edgeClass )  {  this  ( null ,  SupplierUtil . createSupplier  ( edgeClass ) , false ) ; }   public DirectedAcyclicGraph  (   Supplier  < V > vertexSupplier ,   Supplier  < E > edgeSupplier ,  boolean weighted )  {  this  ( vertexSupplier , edgeSupplier ,  new VisitedBitSetImpl  ( ) ,  new  TopoVertexBiMap  < >  ( ) , weighted ) ; }    @ Deprecated public DirectedAcyclicGraph  (   Class  <  ? extends E > edgeClass ,  boolean weighted )  {  this  ( null ,  SupplierUtil . createSupplier  ( edgeClass ) , weighted ) ; }    @ Deprecated public DirectedAcyclicGraph  (   EdgeFactory  < V , E > ef )  {  this  ( ef ,  new VisitedBitSetImpl  ( ) ,  new  TopoVertexBiMap  < >  ( ) , false ) ; }    @ Deprecated public DirectedAcyclicGraph  (   EdgeFactory  < V , E > ef ,  boolean weighted )  {  this  ( ef ,  new VisitedBitSetImpl  ( ) ,  new  TopoVertexBiMap  < >  ( ) , weighted ) ; }    @ Deprecated protected DirectedAcyclicGraph  (   EdgeFactory  < V , E > ef ,  VisitedStrategyFactory visitedStrategyFactory ,   TopoOrderMap  < V > topoOrderMap ,  boolean weighted )  {  super  ( ef , weighted ) ;    this . visitedStrategyFactory =  Objects . requireNonNull  ( visitedStrategyFactory , "Visited factory cannot be null" ) ;    this . topoOrderMap =  Objects . requireNonNull  ( topoOrderMap , "Topological order map cannot be null" ) ;    this . topoComparator =  new TopoComparator  ( ) ; }   protected DirectedAcyclicGraph  (   Supplier  < V > vertexSupplier ,   Supplier  < E > edgeSupplier ,  VisitedStrategyFactory visitedStrategyFactory ,   TopoOrderMap  < V > topoOrderMap ,  boolean weighted )  {  super  ( vertexSupplier , edgeSupplier , weighted ) ;    this . visitedStrategyFactory =  Objects . requireNonNull  ( visitedStrategyFactory , "Visited factory cannot be null" ) ;    this . topoOrderMap =  Objects . requireNonNull  ( topoOrderMap , "Topological order map cannot be null" ) ;    this . topoComparator =  new TopoComparator  ( ) ; }   public static  <  V ,  E >  GraphBuilder  < V , E ,  ? extends  DirectedAcyclicGraph  < V , E > > createBuilder  (   Class  <  ? extends E > edgeClass )  {  return  new  GraphBuilder  < >  (  new  DirectedAcyclicGraph  < >  ( edgeClass ) ) ; }   public static  <  V ,  E >  GraphBuilder  < V , E ,  ? extends  DirectedAcyclicGraph  < V , E > > createBuilder  (   Supplier  < E > edgeSupplier )  {  return  new  GraphBuilder  < >  (  new  DirectedAcyclicGraph  < >  ( null , edgeSupplier , false ) ) ; }    @ Deprecated public static  <  V ,  E >  GraphBuilder  < V , E ,  ? extends  DirectedAcyclicGraph  < V , E > > createBuilder  (   EdgeFactory  < V , E > ef )  {  return  new  GraphBuilder  < >  (  new  DirectedAcyclicGraph  < >  ( ef ) ) ; }    @ Override public GraphType getType  ( )  {  return        new  DefaultGraphType . Builder  ( ) . directed  ( ) . weighted  (   super . getType  ( ) . isWeighted  ( ) ) . allowMultipleEdges  ( false ) . allowSelfLoops  ( false ) . allowCycles  ( false ) . build  ( ) ; }    @ Override public V addVertex  ( )  {  V  v =  super . addVertex  ( ) ;  if  (  v != null )  {   ++ maxTopoIndex ;   topoOrderMap . putVertex  ( maxTopoIndex , v ) ;   ++ topoModCount ; }  return v ; }    @ Override public boolean addVertex  (  V v )  {  boolean  added =  super . addVertex  ( v ) ;  if  ( added )  {   ++ maxTopoIndex ;   topoOrderMap . putVertex  ( maxTopoIndex , v ) ;   ++ topoModCount ; }  return added ; }    @ Override public boolean removeVertex  (  V v )  {  boolean  removed =  super . removeVertex  ( v ) ;  if  ( removed )  {  Integer  topoIndex =  topoOrderMap . removeVertex  ( v ) ;  if  (  topoIndex == minTopoIndex )  {  while  (   (  minTopoIndex < 0 ) &&  (   topoOrderMap . getVertex  ( minTopoIndex ) == null ) )  {   ++ minTopoIndex ; } }  if  (  topoIndex == maxTopoIndex )  {  while  (   (  maxTopoIndex > 0 ) &&  (   topoOrderMap . getVertex  ( maxTopoIndex ) == null ) )  {   -- maxTopoIndex ; } }   ++ topoModCount ; }  return removed ; }    @ Override public E addEdge  (  V sourceVertex ,  V targetVertex )  {   assertVertexExist  ( sourceVertex ) ;   assertVertexExist  ( targetVertex ) ;  E  result ;  try  {   updateDag  ( sourceVertex , targetVertex ) ;   result =  super . addEdge  ( sourceVertex , targetVertex ) ; }  catch (   CycleFoundException e )  {  throw  new IllegalArgumentException  ( EDGE_WOULD_INDUCE_A_CYCLE ) ; }  return result ; }    @ Override public boolean addEdge  (  V sourceVertex ,  V targetVertex ,  E e )  {  if  (  e == null )  {  throw  new NullPointerException  ( ) ; } else  if  (  containsEdge  ( e ) )  {  return false ; }   assertVertexExist  ( sourceVertex ) ;   assertVertexExist  ( targetVertex ) ;  boolean  result ;  try  {   updateDag  ( sourceVertex , targetVertex ) ;   result =  super . addEdge  ( sourceVertex , targetVertex , e ) ; }  catch (   CycleFoundException ex )  {  throw  new IllegalArgumentException  ( EDGE_WOULD_INDUCE_A_CYCLE ) ; }  return result ; }   public  Set  < V > getAncestors  (  V vertex )  {   EdgeReversedGraph  < V , E >  reversedGraph =  new  EdgeReversedGraph  < >  ( this ) ;   Iterator  < V >  iterator =  new  DepthFirstIterator  < >  ( reversedGraph , vertex ) ;   Set  < V >  ancestors =  new  HashSet  < >  ( ) ;  if  (  iterator . hasNext  ( ) )  {   iterator . next  ( ) ; }   iterator . forEachRemaining  (  ancestors :: add ) ;  return ancestors ; }   public  Set  < V > getDescendants  (  V vertex )  {   Iterator  < V >  iterator =  new  DepthFirstIterator  < >  ( this , vertex ) ;   Set  < V >  descendants =  new  HashSet  < >  ( ) ;  if  (  iterator . hasNext  ( ) )  {   iterator . next  ( ) ; }   iterator . forEachRemaining  (  descendants :: add ) ;  return descendants ; }   public  Iterator  < V > iterator  ( )  {  return  new TopoIterator  ( ) ; }   private void updateDag  (  V sourceVertex ,  V targetVertex )  throws CycleFoundException  {  Integer  lb =  topoOrderMap . getTopologicalIndex  ( targetVertex ) ;  Integer  ub =  topoOrderMap . getTopologicalIndex  ( sourceVertex ) ;  if  (  lb < ub )  {   Set  < V >  df =  new  HashSet  < >  ( ) ;   Set  < V >  db =  new  HashSet  < >  ( ) ;  Region  affectedRegion =  new Region  ( lb , ub ) ;  VisitedStrategy  visited =  visitedStrategyFactory . getVisitedStrategy  ( affectedRegion ) ;   dfsF  ( targetVertex , df , visited , affectedRegion ) ;   dfsB  ( sourceVertex , db , visited , affectedRegion ) ;   reorder  ( df , db , visited ) ;   ++ topoModCount ; } }   private void dfsF  (  V initialVertex ,   Set  < V > df ,  VisitedStrategy visited ,  Region affectedRegion )  throws CycleFoundException  {   Deque  < V >  vertices =  new  ArrayDeque  < >  ( ) ;   vertices . push  ( initialVertex ) ;  while  (  !  vertices . isEmpty  ( ) )  {  V  vertex =  vertices . pop  ( ) ;   int  topoIndex =  topoOrderMap . getTopologicalIndex  ( vertex ) ;  if  (  visited . getVisited  ( topoIndex ) )  {  continue ; }   visited . setVisited  ( topoIndex ) ;   df . add  ( vertex ) ;  for ( E outEdge :  outgoingEdgesOf  ( vertex ) )  {  V  nextVertex =  getEdgeTarget  ( outEdge ) ;  Integer  nextVertexTopoIndex =  topoOrderMap . getTopologicalIndex  ( nextVertex ) ;  if  (  nextVertexTopoIndex ==  affectedRegion . finish )  {  try  {  for ( V visitedVertex : df )  {   visited . clearVisited  (  topoOrderMap . getTopologicalIndex  ( visitedVertex ) ) ; } }  catch (   UnsupportedOperationException e )  { }  throw  new CycleFoundException  ( ) ; }  if  (   affectedRegion . isIn  ( nextVertexTopoIndex ) &&  !  visited . getVisited  ( nextVertexTopoIndex ) )  {   vertices . push  ( nextVertex ) ; } } } }   private void dfsB  (  V initialVertex ,   Set  < V > db ,  VisitedStrategy visited ,  Region affectedRegion )  {   Deque  < V >  vertices =  new  ArrayDeque  < >  ( ) ;   vertices . push  ( initialVertex ) ;  while  (  !  vertices . isEmpty  ( ) )  {  V  vertex =  vertices . pop  ( ) ;   int  topoIndex =  topoOrderMap . getTopologicalIndex  ( vertex ) ;  if  (  visited . getVisited  ( topoIndex ) )  {  continue ; }   visited . setVisited  ( topoIndex ) ;   db . add  ( vertex ) ;  for ( E inEdge :  incomingEdgesOf  ( vertex ) )  {  V  previousVertex =  getEdgeSource  ( inEdge ) ;  Integer  previousVertexTopoIndex =  topoOrderMap . getTopologicalIndex  ( previousVertex ) ;  if  (   affectedRegion . isIn  ( previousVertexTopoIndex ) &&  !  visited . getVisited  ( previousVertexTopoIndex ) )  {   vertices . push  ( previousVertex ) ; } } } }    @ SuppressWarnings  ( "unchecked" ) private void reorder  (   Set  < V > df ,   Set  < V > db ,  VisitedStrategy visited )  {   List  < V >  topoDf =  new  ArrayList  < >  ( df ) ;   List  < V >  topoDb =  new  ArrayList  < >  ( db ) ;   topoDf . sort  ( topoComparator ) ;   topoDb . sort  ( topoComparator ) ;   SortedSet  < Integer >  availableTopoIndices =  new  TreeSet  < >  ( ) ;   V  [ ]  bigL =  (  V  [ ] )  new Object  [   df . size  ( ) +  db . size  ( ) ] ;   int  lIndex = 0 ;  boolean  clearVisited = true ;  for ( V vertex : topoDb )  {  Integer  topoIndex =  topoOrderMap . getTopologicalIndex  ( vertex ) ;   availableTopoIndices . add  ( topoIndex ) ;    bigL [  lIndex ++ ] = vertex ;  if  ( clearVisited )  {  try  {   visited . clearVisited  ( topoIndex ) ; }  catch (   UnsupportedOperationException e )  {   clearVisited = false ; } } }  for ( V vertex : topoDf )  {  Integer  topoIndex =  topoOrderMap . getTopologicalIndex  ( vertex ) ;   availableTopoIndices . add  ( topoIndex ) ;    bigL [  lIndex ++ ] = vertex ;  if  ( clearVisited )  {  try  {   visited . clearVisited  ( topoIndex ) ; }  catch (   UnsupportedOperationException e )  {   clearVisited = false ; } } }   lIndex = 0 ;  for ( Integer topoIndex : availableTopoIndices )  {  V  vertex =  bigL [  lIndex ++ ] ;   topoOrderMap . putVertex  ( topoIndex , vertex ) ; } }   protected interface TopoOrderMap  <  V >  extends  Serializable  {  void putVertex  (  Integer index ,  V vertex ) ;  V getVertex  (  Integer index ) ;  Integer getTopologicalIndex  (  V vertex ) ;  Integer removeVertex  (  V vertex ) ;  void removeAllVertices  ( ) ; }   protected interface VisitedStrategy  {  void setVisited  (   int index ) ;  boolean getVisited  (   int index ) ;  void clearVisited  (   int index )  throws UnsupportedOperationException ; }   protected interface VisitedStrategyFactory  extends  Serializable  {  VisitedStrategy getVisitedStrategy  (  Region affectedRegion ) ; }   protected static class TopoVertexBiMap  <  V >  implements   TopoOrderMap  < V >  {   private static final  long  serialVersionUID = 1L ;   private final  Map  < Integer , V >  topoToVertex =  new  HashMap  < >  ( ) ;   private final  Map  < V , Integer >  vertexToTopo =  new  HashMap  < >  ( ) ;   public TopoVertexBiMap  ( )  { }    @ Override public void putVertex  (  Integer index ,  V vertex )  {   topoToVertex . put  ( index , vertex ) ;   vertexToTopo . put  ( vertex , index ) ; }    @ Override public V getVertex  (  Integer index )  {  return  topoToVertex . get  ( index ) ; }    @ Override public Integer getTopologicalIndex  (  V vertex )  {  return  vertexToTopo . get  ( vertex ) ; }    @ Override public Integer removeVertex  (  V vertex )  {  Integer  topoIndex =  vertexToTopo . remove  ( vertex ) ;  if  (  topoIndex != null )  {   topoToVertex . remove  ( topoIndex ) ; }  return topoIndex ; }    @ Override public void removeAllVertices  ( )  {   vertexToTopo . clear  ( ) ;   topoToVertex . clear  ( ) ; } }   protected class TopoVertexMap  implements   TopoOrderMap  < V >  {   private static final  long  serialVersionUID = 1L ;   private final  List  < V >  topoToVertex =  new  ArrayList  < >  ( ) ;   private final  Map  < V , Integer >  vertexToTopo =  new  HashMap  < >  ( ) ;   public TopoVertexMap  ( )  { }    @ Override public void putVertex  (  Integer index ,  V vertex )  {   int  translatedIndex =  translateIndex  ( index ) ;  while  (   (  translatedIndex + 1 ) >  topoToVertex . size  ( ) )  {   topoToVertex . add  ( null ) ; }   topoToVertex . set  ( translatedIndex , vertex ) ;   vertexToTopo . put  ( vertex , index ) ; }    @ Override public V getVertex  (  Integer index )  {  return  topoToVertex . get  (  translateIndex  ( index ) ) ; }    @ Override public Integer getTopologicalIndex  (  V vertex )  {  return  vertexToTopo . get  ( vertex ) ; }    @ Override public Integer removeVertex  (  V vertex )  {  Integer  topoIndex =  vertexToTopo . remove  ( vertex ) ;  if  (  topoIndex != null )  {   topoToVertex . set  (  translateIndex  ( topoIndex ) , null ) ; }  return topoIndex ; }    @ Override public void removeAllVertices  ( )  {   vertexToTopo . clear  ( ) ;   topoToVertex . clear  ( ) ; }   private  int translateIndex  (   int index )  {  if  (  index >= 0 )  {  return  2 * index ; }  return   - 1 *  (   (  index * 2 ) - 1 ) ; } }   protected static class Region  implements  Serializable  {   private static final  long  serialVersionUID = 1L ;   private final  int  start ;   private final  int  finish ;   public Region  (   int start ,   int finish )  {  if  (  start > finish )  {  throw  new IllegalArgumentException  ( "(start > finish): invariant broken" ) ; }    this . start = start ;    this . finish = finish ; }   public  int getSize  ( )  {  return   (  finish - start ) + 1 ; }   public boolean isIn  (   int index )  {  return   (  index >= start ) &&  (  index <= finish ) ; }   public  int getStart  ( )  {  return start ; }   public  int getFinish  ( )  {  return finish ; } }   protected static class VisitedBitSetImpl  implements  VisitedStrategy , VisitedStrategyFactory  {   private static final  long  serialVersionUID = 1L ;   private final BitSet  visited =  new BitSet  ( ) ;   private Region  affectedRegion ;   public VisitedBitSetImpl  ( )  { }    @ Override public VisitedStrategy getVisitedStrategy  (  Region affectedRegion )  {    this . affectedRegion = affectedRegion ;  return this ; }    @ Override public void setVisited  (   int index )  {   visited . set  (  translateIndex  ( index ) , true ) ; }    @ Override public boolean getVisited  (   int index )  {  return  visited . get  (  translateIndex  ( index ) ) ; }    @ Override public void clearVisited  (   int index )  throws UnsupportedOperationException  {   visited . clear  (  translateIndex  ( index ) ) ; }   private  int translateIndex  (   int index )  {  return  index -  affectedRegion . start ; } }   protected static class VisitedArrayListImpl  implements  VisitedStrategy , VisitedStrategyFactory  {   private static final  long  serialVersionUID = 1L ;   private final  List  < Boolean >  visited =  new  ArrayList  < >  ( ) ;   private Region  affectedRegion ;   public VisitedArrayListImpl  ( )  { }    @ Override public VisitedStrategy getVisitedStrategy  (  Region affectedRegion )  {   int  minSize =   (   affectedRegion . finish -  affectedRegion . start ) + 1 ;  while  (   visited . size  ( ) < minSize )  {   visited . add  (  Boolean . FALSE ) ; }    this . affectedRegion = affectedRegion ;  return this ; }    @ Override public void setVisited  (   int index )  {   visited . set  (  translateIndex  ( index ) ,  Boolean . TRUE ) ; }    @ Override public boolean getVisited  (   int index )  {  return  visited . get  (  translateIndex  ( index ) ) ; }    @ Override public void clearVisited  (   int index )  throws UnsupportedOperationException  {   visited . set  (  translateIndex  ( index ) ,  Boolean . FALSE ) ; }   private  int translateIndex  (   int index )  {  return  index -  affectedRegion . start ; } }   protected static class VisitedHashSetImpl  implements  VisitedStrategy , VisitedStrategyFactory  {   private static final  long  serialVersionUID = 1L ;   private final  Set  < Integer >  visited =  new  HashSet  < >  ( ) ;   public VisitedHashSetImpl  ( )  { }    @ Override public VisitedStrategy getVisitedStrategy  (  Region affectedRegion )  {   visited . clear  ( ) ;  return this ; }    @ Override public void setVisited  (   int index )  {   visited . add  ( index ) ; }    @ Override public boolean getVisited  (   int index )  {  return  visited . contains  ( index ) ; }    @ Override public void clearVisited  (   int index )  throws UnsupportedOperationException  {  throw  new UnsupportedOperationException  ( ) ; } }   protected static class VisitedArrayImpl  implements  VisitedStrategy , VisitedStrategyFactory  {   private static final  long  serialVersionUID = 1L ;   private final  boolean  [ ]  visited ;   private final Region  region ;   public VisitedArrayImpl  ( )  {  this  ( null ) ; }   public VisitedArrayImpl  (  Region region )  {  if  (  region == null )  {    this . visited = null ;    this . region = null ; } else  {    this . region = region ;   visited =  new boolean  [  region . getSize  ( ) ] ; } }    @ Override public VisitedStrategy getVisitedStrategy  (  Region affectedRegion )  {  return  new VisitedArrayImpl  ( affectedRegion ) ; }    @ Override public void setVisited  (   int index )  {    visited [  index -  region . start ] = true ; }    @ Override public boolean getVisited  (   int index )  {  return  visited [  index -  region . start ] ; }    @ Override public void clearVisited  (   int index )  throws UnsupportedOperationException  {  throw  new UnsupportedOperationException  ( ) ; } }   private static class CycleFoundException  extends Exception  {   private static final  long  serialVersionUID = 5583471522212552754L ; }   private class TopoComparator  implements   Comparator  < V > , Serializable  {   private static final  long  serialVersionUID = 8144905376266340066L ;    @ Override public  int compare  (  V o1 ,  V o2 )  {  return   topoOrderMap . getTopologicalIndex  ( o1 ) . compareTo  (  topoOrderMap . getTopologicalIndex  ( o2 ) ) ; } }   private class TopoIterator  implements   Iterator  < V >  {   private  int  currentTopoIndex ;   private final  long  expectedTopoModCount = topoModCount ;   private Integer  nextIndex = null ;   public TopoIterator  ( )  {   currentTopoIndex =  minTopoIndex - 1 ; }    @ Override public boolean hasNext  ( )  {  if  (  expectedTopoModCount != topoModCount )  {  throw  new ConcurrentModificationException  ( ) ; }   nextIndex =  getNextIndex  ( ) ;  return  nextIndex != null ; }    @ Override public V next  ( )  {  if  (  expectedTopoModCount != topoModCount )  {  throw  new ConcurrentModificationException  ( ) ; }  if  (  nextIndex == null )  {   nextIndex =  getNextIndex  ( ) ; }  if  (  nextIndex == null )  {  throw  new NoSuchElementException  ( ) ; }   currentTopoIndex = nextIndex ;   nextIndex = null ;  return  topoOrderMap . getVertex  ( currentTopoIndex ) ; }    @ Override public void remove  ( )  {  if  (  expectedTopoModCount != topoModCount )  {  throw  new ConcurrentModificationException  ( ) ; }  V  vertexToRemove ;  if  (   (  vertexToRemove =  topoOrderMap . getVertex  ( currentTopoIndex ) ) != null )  {   topoOrderMap . removeVertex  ( vertexToRemove ) ; } else  {  throw  new IllegalStateException  ( ) ; } }   private Integer getNextIndex  ( )  {  for (   int  i =  currentTopoIndex + 1 ;  i <= maxTopoIndex ;  i ++ )  {  if  (   topoOrderMap . getVertex  ( i ) != null )  {  return i ; } }  return null ; } } }