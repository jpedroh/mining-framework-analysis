  package   org . jgrapht . graph ;   import  java . io .  * ;  import  java . util .  * ;  import    java . util . function . Supplier ;  import   java . util . stream .  * ;  import  org . jgrapht .  * ;  import   org . jgrapht . event .  * ;   public class AsSubgraph  <  V ,  E >  extends  AbstractGraph  < V , E >  implements  Serializable  {   private static final  long  serialVersionUID =  - 1471811754881775298L ;   private static final String  NO_SUCH_EDGE_IN_BASE = "no such edge in base graph" ;   private static final String  NO_SUCH_VERTEX_IN_BASE = "no such vertex in base graph" ;   private static final String  CANNOT_CREATE_NEW_VERTICES_FROM_SUBGRAPH = "Cannot create new vertices from subgraph" ;   protected final  Set  < E >  edgeSet =  new  LinkedHashSet  < >  ( ) ;   protected final  Set  < V >  vertexSet =  new  LinkedHashSet  < >  ( ) ;   protected final  Graph  < V , E >  base ;   protected final GraphType  baseType ;   protected final boolean  isInduced ;   private transient  Set  < E >  unmodifiableEdgeSet = null ;   private transient  Set  < V >  unmodifiableVertexSet = null ;   public AsSubgraph  (   Graph  < V , E > base ,   Set  <  ? extends V > vertexSubset ,   Set  <  ? extends E > edgeSubset )  {  super  ( ) ;    this . base =  GraphTests . requireDirectedOrUndirected  ( base ) ;    this . baseType =  base . getType  ( ) ;    this . isInduced =  edgeSubset == null ;  if  (  base instanceof  ListenableGraph  <  ? ,  ? > )  {    (  (  ListenableGraph  < V , E > ) base ) . addGraphListener  (  new BaseGraphListener  ( ) ) ; }   initialize  ( vertexSubset , edgeSubset ) ; }   public AsSubgraph  (   Graph  < V , E > base ,   Set  <  ? extends V > vertexSubset )  {  this  ( base , vertexSubset , null ) ; }   public AsSubgraph  (   Graph  < V , E > base )  {  this  ( base , null , null ) ; }    @ Override public  Set  < E > getAllEdges  (  V sourceVertex ,  V targetVertex )  {  if  (   containsVertex  ( sourceVertex ) &&  containsVertex  ( targetVertex ) )  {  return     base . getAllEdges  ( sourceVertex , targetVertex ) . stream  ( ) . filter  (  edgeSet :: contains ) . collect  (  Collectors . toCollection  (  LinkedHashSet :: new ) ) ; } else  {  return null ; } }    @ Override public E getEdge  (  V sourceVertex ,  V targetVertex )  {   Set  < E >  edges =  getAllEdges  ( sourceVertex , targetVertex ) ;  if  (  edges == null )  {  return null ; } else  {  return    edges . stream  ( ) . findAny  ( ) . orElse  ( null ) ; } }    @ Override  @ Deprecated public  EdgeFactory  < V , E > getEdgeFactory  ( )  {  return  base . getEdgeFactory  ( ) ; }    @ Override public  Supplier  < V > getVertexSupplier  ( )  {  return  base . getVertexSupplier  ( ) ; }    @ Override public  Supplier  < E > getEdgeSupplier  ( )  {  return  base . getEdgeSupplier  ( ) ; }    @ Override public E addEdge  (  V sourceVertex ,  V targetVertex )  {   assertVertexExist  ( sourceVertex ) ;   assertVertexExist  ( targetVertex ) ;  if  (  !  base . containsEdge  ( sourceVertex , targetVertex ) )  {  throw  new IllegalArgumentException  ( NO_SUCH_EDGE_IN_BASE ) ; }   Set  < E >  edges =  base . getAllEdges  ( sourceVertex , targetVertex ) ;  for ( E e : edges )  {  if  (  !  containsEdge  ( e ) )  {   edgeSet . add  ( e ) ;  return e ; } }  return null ; }    @ Override public boolean addEdge  (  V sourceVertex ,  V targetVertex ,  E e )  {  if  (  e == null )  {  throw  new NullPointerException  ( ) ; }  if  (  !  base . containsEdge  ( e ) )  {  throw  new IllegalArgumentException  ( NO_SUCH_EDGE_IN_BASE ) ; }   assertVertexExist  ( sourceVertex ) ;   assertVertexExist  ( targetVertex ) ;  assert  (   base . getEdgeSource  ( e ) == sourceVertex ) ;  assert  (   base . getEdgeTarget  ( e ) == targetVertex ) ;  return  edgeSet . add  ( e ) ; }    @ Override public V addVertex  ( )  {  throw  new UnsupportedOperationException  ( CANNOT_CREATE_NEW_VERTICES_FROM_SUBGRAPH ) ; }    @ Override public boolean addVertex  (  V v )  {  if  (  v == null )  {  throw  new NullPointerException  ( ) ; }  if  (  !  base . containsVertex  ( v ) )  {  throw  new IllegalArgumentException  ( NO_SUCH_VERTEX_IN_BASE ) ; }  return  vertexSet . add  ( v ) ; }    @ Override public boolean containsEdge  (  E e )  {  return  edgeSet . contains  ( e ) ; }    @ Override public boolean containsVertex  (  V v )  {  return  vertexSet . contains  ( v ) ; }    @ Override public  Set  < E > edgeSet  ( )  {  if  (  unmodifiableEdgeSet == null )  {   unmodifiableEdgeSet =  Collections . unmodifiableSet  ( edgeSet ) ; }  return unmodifiableEdgeSet ; }    @ Override public  Set  < E > edgesOf  (  V vertex )  {   assertVertexExist  ( vertex ) ;  return     base . edgesOf  ( vertex ) . stream  ( ) . filter  (  edgeSet :: contains ) . collect  (  Collectors . toCollection  (  LinkedHashSet :: new ) ) ; }    @ Override public  int degreeOf  (  V vertex )  {   assertVertexExist  ( vertex ) ;  if  (  baseType . isUndirected  ( ) )  {   int  degree = 0 ;   Iterator  < E >  it =     base . edgesOf  ( vertex ) . stream  ( ) . filter  (  edgeSet :: contains ) . iterator  ( ) ;  while  (  it . hasNext  ( ) )  {  E  e =  it . next  ( ) ;   degree ++ ;  if  (   getEdgeSource  ( e ) . equals  (  getEdgeTarget  ( e ) ) )  {   degree ++ ; } }  return degree ; } else  {  return   inDegreeOf  ( vertex ) +  outDegreeOf  ( vertex ) ; } }    @ Override public  Set  < E > incomingEdgesOf  (  V vertex )  {   assertVertexExist  ( vertex ) ;  return     base . incomingEdgesOf  ( vertex ) . stream  ( ) . filter  (  edgeSet :: contains ) . collect  (  Collectors . toCollection  (  LinkedHashSet :: new ) ) ; }    @ Override public  int inDegreeOf  (  V vertex )  {  if  (  baseType . isUndirected  ( ) )  {  return  degreeOf  ( vertex ) ; } else  {  return   incomingEdgesOf  ( vertex ) . size  ( ) ; } }    @ Override public  Set  < E > outgoingEdgesOf  (  V vertex )  {   assertVertexExist  ( vertex ) ;  return     base . outgoingEdgesOf  ( vertex ) . stream  ( ) . filter  (  edgeSet :: contains ) . collect  (  Collectors . toCollection  (  LinkedHashSet :: new ) ) ; }    @ Override public  int outDegreeOf  (  V vertex )  {  if  (  baseType . isUndirected  ( ) )  {  return  degreeOf  ( vertex ) ; } else  {  return   outgoingEdgesOf  ( vertex ) . size  ( ) ; } }    @ Override public boolean removeEdge  (  E e )  {  return  edgeSet . remove  ( e ) ; }    @ Override public E removeEdge  (  V sourceVertex ,  V targetVertex )  {  E  e =  getEdge  ( sourceVertex , targetVertex ) ;  return   edgeSet . remove  ( e ) ? e : null ; }    @ Override public boolean removeVertex  (  V v )  {  if  (   containsVertex  ( v ) &&  base . containsVertex  ( v ) )  {   removeAllEdges  (  edgesOf  ( v ) ) ; }  return  vertexSet . remove  ( v ) ; }    @ Override public  Set  < V > vertexSet  ( )  {  if  (  unmodifiableVertexSet == null )  {   unmodifiableVertexSet =  Collections . unmodifiableSet  ( vertexSet ) ; }  return unmodifiableVertexSet ; }    @ Override public V getEdgeSource  (  E e )  {  return  base . getEdgeSource  ( e ) ; }    @ Override public V getEdgeTarget  (  E e )  {  return  base . getEdgeTarget  ( e ) ; }    @ Override public GraphType getType  ( )  {  return  base . getType  ( ) ; }    @ Override public  double getEdgeWeight  (  E e )  {  return  base . getEdgeWeight  ( e ) ; }    @ Override public void setEdgeWeight  (  E e ,   double weight )  {   base . setEdgeWeight  ( e , weight ) ; }   private void initialize  (   Set  <  ? extends V > vertexFilter ,   Set  <  ? extends E > edgeFilter )  {  if  (   vertexFilter == null &&  edgeFilter == null )  {   vertexSet . addAll  (  base . vertexSet  ( ) ) ;   edgeSet . addAll  (  base . edgeSet  ( ) ) ;  return ; }  if  (  vertexFilter == null )  {   vertexSet . addAll  (  base . vertexSet  ( ) ) ; } else  {  if  (   vertexFilter . size  ( ) >   base . vertexSet  ( ) . size  ( ) )  {      base . vertexSet  ( ) . stream  ( ) . filter  (  vertexFilter :: contains ) . forEach  (  vertexSet :: add ) ; } else  {     vertexFilter . stream  ( ) . filter  (  v ->   v != null &&  base . containsVertex  ( v ) ) . forEach  (  vertexSet :: add ) ; } }  if  (  edgeFilter == null )  {      base . edgeSet  ( ) . stream  ( ) . filter  (  e ->   vertexSet . contains  (  base . getEdgeSource  ( e ) ) &&  vertexSet . contains  (  base . getEdgeTarget  ( e ) ) ) . forEach  (  edgeSet :: add ) ; } else  {  if  (   edgeFilter . size  ( ) >   base . edgeSet  ( ) . size  ( ) )  {      base . edgeSet  ( ) . stream  ( ) . filter  (  e ->    edgeFilter . contains  ( e ) &&  vertexSet . contains  (  base . getEdgeSource  ( e ) ) &&  vertexSet . contains  (  base . getEdgeTarget  ( e ) ) ) . forEach  (  edgeSet :: add ) ; } else  {     edgeFilter . stream  ( ) . filter  (  e ->     e != null &&  base . containsEdge  ( e ) &&  vertexSet . contains  (  base . getEdgeSource  ( e ) ) &&  vertexSet . contains  (  base . getEdgeTarget  ( e ) ) ) . forEach  (  edgeSet :: add ) ; } } }   private class BaseGraphListener  implements   GraphListener  < V , E > , Serializable  {   private static final  long  serialVersionUID = 4343535244243546391L ;    @ Override public void edgeAdded  (   GraphEdgeChangeEvent  < V , E > e )  {  if  ( isInduced )  {  E  edge =  e . getEdge  ( ) ;  V  source =  e . getEdgeSource  ( ) ;  V  target =  e . getEdgeTarget  ( ) ;  if  (   containsVertex  ( source ) &&  containsVertex  ( target ) )  {   addEdge  ( source , target , edge ) ; } } }    @ Override public void edgeRemoved  (   GraphEdgeChangeEvent  < V , E > e )  {  E  edge =  e . getEdge  ( ) ;   removeEdge  ( edge ) ; }    @ Override public void vertexAdded  (   GraphVertexChangeEvent  < V > e )  { }    @ Override public void vertexRemoved  (   GraphVertexChangeEvent  < V > e )  {  V  vertex =  e . getVertex  ( ) ;   removeVertex  ( vertex ) ; } } }