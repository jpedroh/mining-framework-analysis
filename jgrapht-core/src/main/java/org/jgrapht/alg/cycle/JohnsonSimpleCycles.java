  package    org . jgrapht . alg . cycle ;   import  java . util .  * ;  import  org . jgrapht .  * ;  import     org . jgrapht . alg . util . Pair ;  import     org . jgrapht . graph . builder . GraphTypeBuilder ;   public class JohnsonSimpleCycles  <  V ,  E >  implements   DirectedSimpleCycles  < V , E >  {   private  Graph  < V , E >  graph ;   private  List  <  List  < V > >  cycles = null ;   private  V  [ ]  iToV = null ;   private  Map  < V , Integer >  vToI = null ;   private  Set  < V >  blocked = null ;   private  Map  < V ,  Set  < V > >  bSets = null ;   private  ArrayDeque  < V >  stack = null ;   private  List  <  Set  < V > >  SCCs = null ;   private  int  index = 0 ;   private  Map  < V , Integer >  vIndex = null ;   private  Map  < V , Integer >  vLowlink = null ;   private  ArrayDeque  < V >  path = null ;   private  Set  < V >  pathSet = null ;    @ Deprecated public JohnsonSimpleCycles  ( )  { }   public JohnsonSimpleCycles  (   Graph  < V , E > graph )  {    this . graph =  GraphTests . requireDirected  ( graph , "Graph must be directed" ) ;  if  (  GraphTests . hasMultipleEdges  ( graph ) )  {  throw  new IllegalArgumentException  ( "Graph should not have multiple (parallel) edges" ) ; } }    @ Override  @ Deprecated public  Graph  < V , E > getGraph  ( )  {  return graph ; }    @ Override  @ Deprecated public void setGraph  (   Graph  < V , E > graph )  {    this . graph =  GraphTests . requireDirected  ( graph , "Graph must be directed" ) ;  if  (  GraphTests . hasMultipleEdges  ( graph ) )  {  throw  new IllegalArgumentException  ( "Graph should not have multiple (parallel) edges" ) ; } }    @ Override public  List  <  List  < V > > findSimpleCycles  ( )  {  if  (  graph == null )  {  throw  new IllegalArgumentException  ( "Null graph." ) ; }   initState  ( ) ;   int  startIndex = 0 ;   int  size =   graph . vertexSet  ( ) . size  ( ) ;  while  (  startIndex < size )  {   Pair  <  Graph  < V , E > , Integer >  minSCCGResult =  findMinSCSG  ( startIndex ) ;  if  (  minSCCGResult != null )  {   startIndex =  minSCCGResult . getSecond  ( ) ;   Graph  < V , E >  scg =  minSCCGResult . getFirst  ( ) ;  V  startV =  toV  ( startIndex ) ;  for ( E e :  scg . outgoingEdgesOf  ( startV ) )  {  V  v =  graph . getEdgeTarget  ( e ) ;   blocked . remove  ( v ) ;    getBSet  ( v ) . clear  ( ) ; }   findCyclesInSCG  ( startIndex , startIndex , scg ) ;   startIndex ++ ; } else  {  break ; } }   List  <  List  < V > >  result = cycles ;   clearState  ( ) ;  return result ; }   private  Pair  <  Graph  < V , E > , Integer > findMinSCSG  (   int startIndex )  {   initMinSCGState  ( ) ;   List  <  Set  < V > >  SCCs =  findSCCS  ( startIndex ) ;   int  minIndexFound =  Integer . MAX_VALUE ;   Set  < V >  minSCC = null ;  for (  Set  < V > scc : SCCs )  {  for ( V v : scc )  {   int  t =  toI  ( v ) ;  if  (  t < minIndexFound )  {   minIndexFound = t ;   minSCC = scc ; } } }  if  (  minSCC == null )  {  return null ; }   Graph  < V , E >  resultGraph =       GraphTypeBuilder .  < V , E > directed  ( ) . edgeSupplier  (  graph . getEdgeSupplier  ( ) ) . vertexSupplier  (  graph . getVertexSupplier  ( ) ) . allowingMultipleEdges  ( false ) . allowingSelfLoops  ( true ) . buildGraph  ( ) ;  for ( V v : minSCC )  {   resultGraph . addVertex  ( v ) ; }  for ( V v : minSCC )  {  for ( V w : minSCC )  {  E  edge =  graph . getEdge  ( v , w ) ;  if  (  edge != null )  {   resultGraph . addEdge  ( v , w , edge ) ; } } }   Pair  <  Graph  < V , E > , Integer >  result =  Pair . of  ( resultGraph , minIndexFound ) ;   clearMinSCCState  ( ) ;  return result ; }   private  List  <  Set  < V > > findSCCS  (   int startIndex )  {  for ( V v :  graph . vertexSet  ( ) )  {   int  vI =  toI  ( v ) ;  if  (  vI < startIndex )  {  continue ; }  if  (  !  vIndex . containsKey  ( v ) )  {   getSCCs  ( startIndex , vI ) ; } }   List  <  Set  < V > >  result = SCCs ;   SCCs = null ;  return result ; }   private void getSCCs  (   int startIndex ,   int vertexIndex )  {  V  vertex =  toV  ( vertexIndex ) ;   vIndex . put  ( vertex , index ) ;   vLowlink . put  ( vertex , index ) ;   index ++ ;   path . push  ( vertex ) ;   pathSet . add  ( vertex ) ;   Set  < E >  edges =  graph . outgoingEdgesOf  ( vertex ) ;  for ( E e : edges )  {  V  successor =  graph . getEdgeTarget  ( e ) ;   int  successorIndex =  toI  ( successor ) ;  if  (  successorIndex < startIndex )  {  continue ; }  if  (  !  vIndex . containsKey  ( successor ) )  {   getSCCs  ( startIndex , successorIndex ) ;   vLowlink . put  ( vertex ,  Math . min  (  vLowlink . get  ( vertex ) ,  vLowlink . get  ( successor ) ) ) ; } else  if  (  pathSet . contains  ( successor ) )  {   vLowlink . put  ( vertex ,  Math . min  (  vLowlink . get  ( vertex ) ,  vIndex . get  ( successor ) ) ) ; } }  if  (   vLowlink . get  ( vertex ) . equals  (  vIndex . get  ( vertex ) ) )  {   Set  < V >  result =  new  HashSet  < >  ( ) ;  V  temp ;  do  {   temp =  path . pop  ( ) ;   pathSet . remove  ( temp ) ;   result . add  ( temp ) ; } while  (  !  vertex . equals  ( temp ) ) ;  if  (   result . size  ( ) == 1 )  {  V  v =   result . iterator  ( ) . next  ( ) ;  if  (  graph . containsEdge  ( vertex , v ) )  {   SCCs . add  ( result ) ; } } else  {   SCCs . add  ( result ) ; } } }   private boolean findCyclesInSCG  (   int startIndex ,   int vertexIndex ,   Graph  < V , E > scg )  {  boolean  foundCycle = false ;  V  vertex =  toV  ( vertexIndex ) ;   stack . push  ( vertex ) ;   blocked . add  ( vertex ) ;  for ( E e :  scg . outgoingEdgesOf  ( vertex ) )  {  V  successor =  scg . getEdgeTarget  ( e ) ;   int  successorIndex =  toI  ( successor ) ;  if  (  successorIndex == startIndex )  {   List  < V >  cycle =  new  ArrayList  < >  (  stack . size  ( ) ) ;    stack . descendingIterator  ( ) . forEachRemaining  (  cycle :: add ) ;   cycles . add  ( cycle ) ;   foundCycle = true ; } else  if  (  !  blocked . contains  ( successor ) )  {  boolean  gotCycle =  findCyclesInSCG  ( startIndex , successorIndex , scg ) ;   foundCycle =  foundCycle || gotCycle ; } }  if  ( foundCycle )  {   unblock  ( vertex ) ; } else  {  for ( E ew :  scg . outgoingEdgesOf  ( vertex ) )  {  V  w =  scg . getEdgeTarget  ( ew ) ;   Set  < V >  bSet =  getBSet  ( w ) ;   bSet . add  ( vertex ) ; } }   stack . pop  ( ) ;  return foundCycle ; }   private void unblock  (  V vertex )  {   blocked . remove  ( vertex ) ;   Set  < V >  bSet =  getBSet  ( vertex ) ;  while  (   bSet . size  ( ) > 0 )  {  V  w =   bSet . iterator  ( ) . next  ( ) ;   bSet . remove  ( w ) ;  if  (  blocked . contains  ( w ) )  {   unblock  ( w ) ; } } }    @ SuppressWarnings  ( "unchecked" ) private void initState  ( )  {   cycles =  new  LinkedList  < >  ( ) ;   iToV =  (  V  [ ] )   graph . vertexSet  ( ) . toArray  ( ) ;   vToI =  new  HashMap  < >  ( ) ;   blocked =  new  HashSet  < >  ( ) ;   bSets =  new  HashMap  < >  ( ) ;   stack =  new  ArrayDeque  < >  ( ) ;  for (   int  i = 0 ;  i <  iToV . length ;  i ++ )  {   vToI . put  (  iToV [ i ] , i ) ; } }   private void clearState  ( )  {   cycles = null ;   iToV = null ;   vToI = null ;   blocked = null ;   bSets = null ;   stack = null ; }   private void initMinSCGState  ( )  {   index = 0 ;   SCCs =  new  ArrayList  < >  ( ) ;   vIndex =  new  HashMap  < >  ( ) ;   vLowlink =  new  HashMap  < >  ( ) ;   path =  new  ArrayDeque  < >  ( ) ;   pathSet =  new  HashSet  < >  ( ) ; }   private void clearMinSCCState  ( )  {   index = 0 ;   SCCs = null ;   vIndex = null ;   vLowlink = null ;   path = null ;   pathSet = null ; }   private Integer toI  (  V vertex )  {  return  vToI . get  ( vertex ) ; }   private V toV  (  Integer i )  {  return  iToV [ i ] ; }   private  Set  < V > getBSet  (  V v )  {  return  bSets . computeIfAbsent  ( v ,  k ->  new  HashSet  < >  ( ) ) ; } }