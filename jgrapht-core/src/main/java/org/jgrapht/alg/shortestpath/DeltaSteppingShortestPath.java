  package    org . jgrapht . alg . shortestpath ;   import   org . jgrapht . Graph ;  import   org . jgrapht . GraphPath ;  import   org . jgrapht . Graphs ;  import     org . jgrapht . alg . util . Pair ;  import     org . jgrapht . alg . util . Triple ;  import  java . util .  * ;  import    java . util . concurrent . ExecutorCompletionService ;  import    java . util . concurrent . ExecutorService ;  import    java . util . concurrent . Executors ;  import    java . util . concurrent . TimeUnit ;  import     java . util . concurrent . atomic . AtomicReference ;  import    java . util . stream . Collectors ;   public class DeltaSteppingShortestPath  <  V ,  E >  extends  BaseShortestPathAlgorithm  < V , E >  {   private static final String  NEGATIVE_EDGE_WEIGHT_NOT_ALLOWED = "Negative edge weight not allowed" ;   private static final String  DELTA_MUST_BE_POSITIVE = "Delta must be positive" ;   private  double  delta ;   private  int  numOfBuckets ;   private  Map  < V ,  Set  < E > >  light ;   private  Map  < V ,  Set  < E > >  heavy ;   private  Map  < V ,  Triple  < Integer , Double , E > >  verticesDataMap ;   private ExecutorService  executor ;   private  ExecutorCompletionService  < Void >  completionService ;   private static final  int  NUMBER_OF_REQUESTS_PER_RELAX_TAKS = 2500 ;   public DeltaSteppingShortestPath  (   Graph  < V , E > graph )  {  super  ( graph ) ;   delta = 0.0 ;   init  ( ) ; }   public DeltaSteppingShortestPath  (   Graph  < V , E > graph ,   double delta )  {  super  ( graph ) ;  if  (  delta <= 0 )  {  throw  new IllegalArgumentException  ( DELTA_MUST_BE_POSITIVE ) ; }    this . delta = delta ;   init  ( ) ; }   private void init  ( )  {   light =  new  HashMap  < >  ( ) ;   heavy =  new  HashMap  < >  ( ) ;   verticesDataMap =  new  HashMap  < >  ( ) ;   executor =  Executors . newFixedThreadPool  (   Runtime . getRuntime  ( ) . availableProcessors  ( ) ) ;   completionService =  new  ExecutorCompletionService  < >  ( executor ) ; }   private  double getMaxEdgeWeight  ( )  {   double  result = 0.0 ;   double  weight ;  for ( E defaultWeightedEdge :  graph . edgeSet  ( ) )  {   weight =  graph . getEdgeWeight  ( defaultWeightedEdge ) ;  if  (  weight < 0 )  {  throw  new IllegalArgumentException  ( NEGATIVE_EDGE_WEIGHT_NOT_ALLOWED ) ; }  if  (  weight > result )  {   result = weight ; } }  return result ; }    @ Override public  GraphPath  < V , E > getPath  (  V source ,  V sink )  {  if  (  !  graph . containsVertex  ( source ) )  {  throw  new IllegalArgumentException  ( GRAPH_MUST_CONTAIN_THE_SOURCE_VERTEX ) ; }  if  (  !  graph . containsVertex  ( sink ) )  {  throw  new IllegalArgumentException  ( GRAPH_MUST_CONTAIN_THE_SINK_VERTEX ) ; }  return   getPaths  ( source ) . getPath  ( sink ) ; }    @ Override public  SingleSourcePaths  < V , E > getPaths  (  V source )  {  if  (  !  graph . containsVertex  ( source ) )  {  throw  new IllegalArgumentException  ( GRAPH_MUST_CONTAIN_THE_SOURCE_VERTEX ) ; }   maxEdgeWeight =  getMaxEdgeWeight  ( ) ;  if  (  delta == 0.0 )  {   delta =  findDelta  ( ) ; }   fillMaps  ( ) ;   numOfBuckets =  numOfBuckets  ( ) ;   computeShortestPaths  ( source ) ;   Map  < V ,  Pair  < Double , E > >  distanceAndPredecessorMap =  new  HashMap  < >  ( ) ;  for (   Map . Entry  < V ,  Triple  < Integer , Double , E > > entry :  verticesDataMap . entrySet  ( ) )  {   distanceAndPredecessorMap . put  (  entry . getKey  ( ) ,  Pair . of  (   entry . getValue  ( ) . getSecond  ( ) ,   entry . getValue  ( ) . getThird  ( ) ) ) ; }  return  new  TreeSingleSourcePathsImpl  < >  ( graph , source , distanceAndPredecessorMap ) ; }   private  double findDelta  ( )  {  if  (  maxEdgeWeight == 0 )  {  return 1.0 ; } else  {   int  maxOutDegree =      graph . vertexSet  ( ) . parallelStream  ( ) . mapToInt  (  graph :: outDegreeOf ) . max  ( ) . orElse  ( 0 ) ;  return  maxEdgeWeight / maxOutDegree ; } else  {  return 1.0 ; } }   private void fillMaps  ( )  {    graph . vertexSet  ( ) . forEach  (  v ->  {   light . put  ( v ,  new  HashSet  < >  ( ) ) ;   heavy . put  ( v ,  new  HashSet  < >  ( ) ) ;   verticesDataMap . putIfAbsent  ( v ,  Triple . of  (  - 1 ,  Double . POSITIVE_INFINITY , null ) ) ; } ) ;     graph . vertexSet  ( ) . parallelStream  ( ) . forEach  (  v ->  {  for ( E e :  graph . outgoingEdgesOf  ( v ) )  {  if  (   graph . getEdgeWeight  ( e ) > delta )  {    heavy . get  ( v ) . add  ( e ) ; } else  {    light . get  ( v ) . add  ( e ) ; } } } ) ; }   private void computeShortestPaths  (  V source )  {   relax  ( source , null , 0.0 ) ;   int  firstNonEmptyBucket = 0 ;  while  (  firstNonEmptyBucket <= numOfBuckets )  {   List  < V >  removed =  new  ArrayList  < >  ( ) ;   List  < V >  bucketElements =  bucketElements  ( firstNonEmptyBucket ) ;  while  (  !  bucketElements . isEmpty  ( ) )  {   removed . addAll  ( bucketElements ) ;   clearBucket  ( firstNonEmptyBucket ) ;   findAndRelaxRequests  ( bucketElements , light ) ;   bucketElements =  bucketElements  ( firstNonEmptyBucket ) ; }   findAndRelaxRequests  ( removed , heavy ) ;   firstNonEmptyBucket ++ ; }   executor . shutdown  ( ) ;  try  {   executor . awaitTermination  (  Long . MAX_VALUE ,  TimeUnit . MILLISECONDS ) ; }  catch (   InterruptedException e )  {   e . printStackTrace  ( ) ; } }   private void findAndRelaxRequests  (   List  < V > vertices ,   Map  < V ,  Set  < E > > edgesKind )  { 
<<<<<<<
  List  < Runnable >  tasks =  generateRelaxTasks  ( vertices , edgesKind ) ;
=======
   vertices . parallelStream  ( ) . forEach  (  v ->  {  for ( E e :  edgesKind . get  ( v ) )  {   relax  (  Graphs . getOppositeVertex  ( graph , e , v ) , e ,    verticesDataMap . get  ( v ) . getSecond  ( ) +  graph . getEdgeWeight  ( e ) ) ; } } ) ;
>>>>>>>
  for ( Runnable task : tasks )  {   completionService . submit  ( task , null ) ; }  for (   int  i = 0 ;  i <  tasks . size  ( ) ;  i ++ )  {  try  {   completionService . take  ( ) ; }  catch (   InterruptedException e )  {   e . printStackTrace  ( ) ; } } }   private  List  < Runnable > generateRelaxTasks  (   List  < V > vertices ,   Map  < V ,  Set  < E > > edgesKind )  {   List  < Runnable >  tasks =  new  ArrayList  < >  ( ) ;   int  begin = 0 ;   int  end = 0 ;  while  (  begin <  vertices . size  ( ) )  {   int  numOfRequests = 0 ;  while  (   numOfRequests < NUMBER_OF_REQUESTS_PER_RELAX_TAKS &&  end <  vertices . size  ( ) )  {   numOfRequests +=   edgesKind . get  (  vertices . get  ( end ) ) . size  ( ) ;   end ++ ; }  if  (  numOfRequests != 0 )  {   tasks . add  (  new RelaxTask  (  vertices . subList  ( begin , end ) , edgesKind ) ) ; }   begin = end ; }  return tasks ; }  class RelaxTask  implements  Runnable  {   private  List  < V >  vertices ;   Map  < V ,  Set  < E > >  edgesKind ;  RelaxTask  (   List  < V > vertices ,   Map  < V ,  Set  < E > > edgesKind )  {    this . vertices = vertices ;    this . edgesKind = edgesKind ; }    @ Override public void run  ( )  {  for ( V v : vertices )  {  for ( E e :  edgesKind . get  ( v ) )  {   relax  (  Graphs . getOppositeVertex  ( graph , e , v ) , e ,     verticesDataMap . get  ( v ) . get  ( ) . getSecond  ( ) +  graph . getEdgeWeight  ( e ) ) ; } } } }   private void relax  (  V v ,  E e ,   double distance )  {  boolean  updated = false ;   Triple  < Integer , Double , E >  updatedData =  Triple . of  (  bucketIndex  ( distance ) , distance , e ) ;  while  (  ! updated )  {   Triple  < Integer , Double , E >  oldData =  verticesDataMap . get  ( v ) ;   updated =   !  (  distance <  oldData . getSecond  ( ) ) ||  verticesDataMap . replace  ( v , oldData , updatedData ) ; } }   private  int numOfBuckets  ( )  {  return  (  int )  (   Math . ceil  (  maxEdgeWeight / delta ) + 1 ) ; }   private  int bucketIndex  (   double distance )  {  return   (  (  int )  Math . round  (  distance / delta ) ) % numOfBuckets ; }   private  List  < V > bucketElements  (   int bucket )  {  return      verticesDataMap . entrySet  ( ) . stream  ( ) . filter  (  entry ->    entry . getValue  ( ) . getFirst  ( ) == bucket ) . map  (   Map . Entry :: getKey ) . collect  (  Collectors . toCollection  (  ArrayList :: new ) ) ; }   private void clearBucket  (   int bucket )  {   List  < V >  bucketElements =  bucketElements  ( bucket ) ;  for ( V v : bucketElements )  {   Triple  < Integer , Double , E >  data =  verticesDataMap . get  ( v ) ;   verticesDataMap . put  ( v ,  Triple . of  (  - 1 ,  data . getSecond  ( ) ,  data . getThird  ( ) ) ) ; } }   private  double  maxEdgeWeight ; }