  package   org . jgrapht . alg ;   import   org . jgrapht . Graph ;  import   org . jgrapht . GraphTests ;  import  java . util .  * ;   public class NaiveLcaFinder  <  V ,  E >  {   private  Graph  < V , E >  graph ;   public NaiveLcaFinder  (   Graph  < V , E > graph )  {    this . graph =  GraphTests . requireDirected  ( graph , "Graph must be directed" ) ; }   public V findLca  (  V a ,  V b )  {  return  findLca  (  Collections . singleton  ( a ) ,  Collections . singleton  ( b ) ,  new  LinkedHashSet  < >  ( ) ,  new  LinkedHashSet  < >  ( ) ) ; }    @ SuppressWarnings  ( "unchecked" ) public  Set  < V > findLcas  (  V a ,  V b )  {    Set  < V >  [ ]  visitedSets =  new Set  [ 2 ] ;    visitedSets [ 0 ] =  new  LinkedHashSet  < >  ( ) ;    visitedSets [ 1 ] =  new  LinkedHashSet  < >  ( ) ;   doubleBfs  ( a , b , visitedSets ) ;   Set  < V >  intersection ;  if  (    visitedSets [ 0 ] . size  ( ) <   visitedSets [ 1 ] . size  ( ) )  {    visitedSets [ 0 ] . retainAll  (  visitedSets [ 1 ] ) ;   intersection =  visitedSets [ 0 ] ; } else  {    visitedSets [ 1 ] . retainAll  (  visitedSets [ 0 ] ) ;   intersection =  visitedSets [ 1 ] ; }   Set  < V >  nonLeaves =  new  LinkedHashSet  < >  ( ) ;  for ( V node : intersection )  {  for ( E edge :  graph . incomingEdgesOf  ( node ) )  {  if  (   graph . getEdgeTarget  ( edge ) . equals  ( node ) )  {  V  source =  graph . getEdgeSource  ( edge ) ;  if  (  intersection . contains  ( source ) )   nonLeaves . add  ( source ) ; } } }   intersection . removeAll  ( nonLeaves ) ;  return intersection ; }    @ SuppressWarnings  ( "unchecked" ) private void doubleBfs  (  V a ,  V b ,    Set  < V >  [ ] visitedSets )  {    Queue  < V >  [ ]  queues =  new Queue  [ 2 ] ;    queues [ 0 ] =  new  ArrayDeque  < >  ( ) ;    queues [ 1 ] =  new  ArrayDeque  < >  ( ) ;    queues [ 0 ] . add  ( a ) ;    queues [ 1 ] . add  ( b ) ;    visitedSets [ 0 ] . add  ( a ) ;    visitedSets [ 1 ] . add  ( b ) ;  for (   int  ind = 0 ;   !   queues [ 0 ] . isEmpty  ( ) ||  !   queues [ 1 ] . isEmpty  ( ) ;  ind ^= 1 )  {  if  (  !   queues [ ind ] . isEmpty  ( ) )  {  V  node =   queues [ ind ] . poll  ( ) ;  if  (   !   visitedSets [ 0 ] . contains  ( node ) ||  !   visitedSets [ 1 ] . contains  ( node ) )  for ( E edge :  graph . incomingEdgesOf  ( node ) )  {  if  (   graph . getEdgeTarget  ( edge ) . equals  ( node ) )  {  V  source =  graph . getEdgeSource  ( edge ) ;  if  (  !   visitedSets [ ind ] . contains  ( source ) )  {    queues [ ind ] . add  ( source ) ;    visitedSets [ ind ] . add  ( source ) ; } } } } } }   private V findLca  (   Set  < V > aSet ,   Set  < V > bSet ,   LinkedHashSet  < V > aSeenSet ,   LinkedHashSet  < V > bSeenSet )  {  while  ( true )  {  if  (   (   aSet . size  ( ) == 0 ) &&  (   bSet . size  ( ) == 0 ) )  {  return null ; }  if  (  !  Collections . disjoint  ( aSet , bSeenSet ) )  {  return  overlappingMember  ( aSet , bSeenSet ) ; }  if  (  !  Collections . disjoint  ( bSet , aSeenSet ) )  {  return  overlappingMember  ( bSet , aSeenSet ) ; }  if  (  !  Collections . disjoint  ( aSet , bSet ) )  {  return  overlappingMember  ( aSet , bSet ) ; }   aSeenSet . addAll  ( aSet ) ;   bSeenSet . addAll  ( bSet ) ;   aSet =  allParents  ( aSet ) ;   aSet . removeAll  ( aSeenSet ) ;   bSet =  allParents  ( bSet ) ;   bSet . removeAll  ( bSeenSet ) ; } }   private  Set  < V > allParents  (   Set  < V > vertexSet )  {   HashSet  < V >  result =  new  HashSet  < >  ( ) ;  for ( V e : vertexSet )  {  for ( E edge :  graph . incomingEdgesOf  ( e ) )  {  if  (   graph . getEdgeTarget  ( edge ) . equals  ( e ) )  {   result . add  (  graph . getEdgeSource  ( edge ) ) ; } } }  return result ; }   private V overlappingMember  (   Set  < V > x ,   Set  < V > y )  {   y . retainAll  ( x ) ;  return   y . iterator  ( ) . next  ( ) ; } }