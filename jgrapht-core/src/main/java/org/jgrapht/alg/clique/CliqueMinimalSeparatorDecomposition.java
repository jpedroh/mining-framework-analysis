  package    org . jgrapht . alg . clique ;   import  java . util .  * ;  import   java . util . Map .  * ;  import  org . jgrapht .  * ;  import     org . jgrapht . alg . connectivity . ConnectivityInspector ;  import     org . jgrapht . graph . builder . GraphTypeBuilder ;   public class CliqueMinimalSeparatorDecomposition  <  V ,  E >  {   private  Graph  < V , E >  graph ;   private  Graph  < V , E >  chordalGraph ;   private  Set  < E >  fillEdges ;   private  LinkedList  < V >  meo ;   private  List  < V >  generators ;   private  Set  <  Set  < V > >  separators ;   private  Set  <  Set  < V > >  atoms ;   private  Map  <  Set  < V > , Integer >  fullComponentCount =  new  HashMap  < >  ( ) ;   public CliqueMinimalSeparatorDecomposition  (   Graph  < V , E > g )  {    this . graph =  GraphTests . requireUndirected  ( g ) ;    this . fillEdges =  new  HashSet  < >  ( ) ; }   private void computeMinimalTriangulation  ( )  {   chordalGraph =       GraphTypeBuilder .  < V , E > undirected  ( ) . edgeSupplier  (  graph . getEdgeSupplier  ( ) ) . vertexSupplier  (  graph . getVertexSupplier  ( ) ) . allowingMultipleEdges  ( false ) . allowingSelfLoops  ( false ) . buildGraph  ( ) ;  for ( V v :  graph . vertexSet  ( ) )  {   chordalGraph . addVertex  ( v ) ; }   final  Graph  < V , E >  gprime =  copyAsSimpleGraph  ( graph ) ;   int  s =  - 1 ;   generators =  new  ArrayList  < >  ( ) ;   meo =  new  LinkedList  < >  ( ) ;   final  Map  < V , Integer >  vertexLabels =  new  HashMap  < >  ( ) ;  for ( V v :  gprime . vertexSet  ( ) )  {   vertexLabels . put  ( v , 0 ) ; }  for (   int  i = 1 ,  n =   graph . vertexSet  ( ) . size  ( ) ;  i <= n ;  i ++ )  {  V  v =  getMaxLabelVertex  ( vertexLabels ) ;   LinkedList  < V >  Y =  new  LinkedList  < >  (  Graphs . neighborListOf  ( gprime , v ) ) ;  if  (   vertexLabels . get  ( v ) <= s )  {   generators . add  ( v ) ; }   s =  vertexLabels . get  ( v ) ;   HashSet  < V >  reached =  new  HashSet  < >  ( ) ;   reached . add  ( v ) ;   HashMap  < Integer ,  HashSet  < V > >  reach =  new  HashMap  < >  ( ) ;  for ( V y : Y )  {   reached . add  ( y ) ;   addToReach  (  vertexLabels . get  ( y ) , y , reach ) ; }  for (   int  j = 0 ;  j <   graph . vertexSet  ( ) . size  ( ) ;  j ++ )  {  if  (  !  reach . containsKey  ( j ) )  {  continue ; }  while  (    reach . get  ( j ) . size  ( ) > 0 )  {  V  y =    reach . get  ( j ) . iterator  ( ) . next  ( ) ;    reach . get  ( j ) . remove  ( y ) ;  for ( V z :  Graphs . neighborListOf  ( gprime , y ) )  {  if  (  !  reached . contains  ( z ) )  {   reached . add  ( z ) ;  if  (   vertexLabels . get  ( z ) > j )  {   Y . add  ( z ) ;  E  fillEdge =   graph . getEdgeSupplier  ( ) . get  ( ) ;   fillEdges . add  ( fillEdge ) ;   addToReach  (  vertexLabels . get  ( z ) , z , reach ) ; } else  {   addToReach  ( j , z , reach ) ; } } } } }  for ( V y : Y )  {   chordalGraph . addEdge  ( v , y ) ;   vertexLabels . put  ( y ,   vertexLabels . get  ( y ) + 1 ) ; }   meo . addLast  ( v ) ;   gprime . removeVertex  ( v ) ;   vertexLabels . remove  ( v ) ; } }   private V getMaxLabelVertex  (   Map  < V , Integer > vertexLabels )  {   Iterator  <  Entry  < V , Integer > >  iterator =   vertexLabels . entrySet  ( ) . iterator  ( ) ;   Entry  < V , Integer >  max =  iterator . next  ( ) ;  while  (  iterator . hasNext  ( ) )  {   Entry  < V , Integer >  e =  iterator . next  ( ) ;  if  (   e . getValue  ( ) >  max . getValue  ( ) )  {   max = e ; } }  return  max . getKey  ( ) ; }   private void addToReach  (  Integer k ,  V v ,   HashMap  < Integer ,  HashSet  < V > > r )  {  if  (  r . containsKey  ( k ) )  {    r . get  ( k ) . add  ( v ) ; } else  {   HashSet  < V >  set =  new  HashSet  < >  ( ) ;   set . add  ( v ) ;   r . put  ( k , set ) ; } }   private void computeAtoms  ( )  {  if  (  chordalGraph == null )  {   computeMinimalTriangulation  ( ) ; }   separators =  new  HashSet  < >  ( ) ;   Graph  < V , E >  gprime =  copyAsSimpleGraph  ( graph ) ;   Graph  < V , E >  hprime =  copyAsSimpleGraph  ( chordalGraph ) ;   atoms =  new  HashSet  < >  ( ) ;   Iterator  < V >  iterator =  meo . descendingIterator  ( ) ;  while  (  iterator . hasNext  ( ) )  {  V  v =  iterator . next  ( ) ;  if  (  generators . contains  ( v ) )  {   Set  < V >  separator =  new  HashSet  < >  (  Graphs . neighborListOf  ( hprime , v ) ) ;  if  (  isClique  ( graph , separator ) )  {  if  (   separator . size  ( ) > 0 )  {  if  (  separators . contains  ( separator ) )  {   fullComponentCount . put  ( separator ,   fullComponentCount . get  ( separator ) + 1 ) ; } else  {   fullComponentCount . put  ( separator , 2 ) ;   separators . add  ( separator ) ; } }   Graph  < V , E >  tmpGraph =  copyAsSimpleGraph  ( gprime ) ;   tmpGraph . removeAllVertices  ( separator ) ;   ConnectivityInspector  < V , E >  con =  new  ConnectivityInspector  < >  ( tmpGraph ) ;  if  (  con . isConnected  ( ) )  {  throw  new RuntimeException  ( "separator did not separate the graph" ) ; }  for (  Set  < V > component :  con . connectedSets  ( ) )  {  if  (  component . contains  ( v ) )  {   gprime . removeAllVertices  ( component ) ;   component . addAll  ( separator ) ;   atoms . add  (  new  HashSet  < >  ( component ) ) ;  assert  (   component . size  ( ) > 0 ) ;  break ; } } } }   hprime . removeVertex  ( v ) ; }  if  (    gprime . vertexSet  ( ) . size  ( ) > 0 )  {   atoms . add  (  new  HashSet  < >  (  gprime . vertexSet  ( ) ) ) ; } }   private static  <  V ,  E > boolean isClique  (   Graph  < V , E > graph ,   Set  < V > vertices )  {  for ( V v1 : vertices )  {  for ( V v2 : vertices )  {  if  (   !  v1 . equals  ( v2 ) &&  (   graph . getEdge  ( v1 , v2 ) == null ) )  {  return false ; } } }  return true ; }   private static  <  V ,  E >  Graph  < V , E > copyAsSimpleGraph  (   Graph  < V , E > graph )  {   Graph  < V , E >  copy =       GraphTypeBuilder .  < V , E > undirected  ( ) . edgeSupplier  (  graph . getEdgeSupplier  ( ) ) . vertexSupplier  (  graph . getVertexSupplier  ( ) ) . allowingMultipleEdges  ( false ) . allowingSelfLoops  ( false ) . buildGraph  ( ) ;  if  (   graph . getType  ( ) . isSimple  ( ) )  {   Graphs . addGraph  ( copy , graph ) ; } else  {   Graphs . addAllVertices  ( copy ,  graph . vertexSet  ( ) ) ;  for ( E e :  graph . edgeSet  ( ) )  {  V  v1 =  graph . getEdgeSource  ( e ) ;  V  v2 =  graph . getEdgeTarget  ( e ) ;  if  (   !  v1 . equals  ( v2 ) &&  !  copy . containsEdge  ( e ) )  {   copy . addEdge  ( v1 , v2 ) ; } } }  return copy ; }   public boolean isChordal  ( )  {  if  (  chordalGraph == null )  {   computeMinimalTriangulation  ( ) ; }  return  (    chordalGraph . edgeSet  ( ) . size  ( ) ==   graph . edgeSet  ( ) . size  ( ) ) ; }   public  Set  < E > getFillEdges  ( )  {  if  (  fillEdges == null )  {   computeMinimalTriangulation  ( ) ; }  return fillEdges ; }   public  Graph  < V , E > getMinimalTriangulation  ( )  {  if  (  chordalGraph == null )  {   computeMinimalTriangulation  ( ) ; }  return chordalGraph ; }   public  List  < V > getGenerators  ( )  {  if  (  generators == null )  {   computeMinimalTriangulation  ( ) ; }  return generators ; }   public  LinkedList  < V > getMeo  ( )  {  if  (  meo == null )  {   computeMinimalTriangulation  ( ) ; }  return meo ; }   public  Map  <  Set  < V > , Integer > getFullComponentCount  ( )  {  if  (  fullComponentCount == null )  {   computeAtoms  ( ) ; }  return fullComponentCount ; }   public  Set  <  Set  < V > > getAtoms  ( )  {  if  (  atoms == null )  {   computeAtoms  ( ) ; }  return atoms ; }   public  Set  <  Set  < V > > getSeparators  ( )  {  if  (  separators == null )  {   computeAtoms  ( ) ; }  return separators ; }   public  Graph  < V , E > getGraph  ( )  {  return graph ; } }