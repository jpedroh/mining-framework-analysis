  package   org . jgrapht . alg ;   import  java . util .  * ;  import  org . jgrapht .  * ;  import   org . jgrapht . event .  * ;  import   org . jgrapht . graph .  * ;  import   org . jgrapht . traverse .  * ;   public class ConnectivityInspector  <  V ,  E >  implements   GraphListener  < V , E >  {   List  <  Set  < V > >  connectedSets ;   Map  < V ,  Set  < V > >  vertexToConnectedSet ;   private  Graph  < V , E >  graph ;   private  Graph  < V , E >  originalgraph ;   public ConnectivityInspector  (   UndirectedGraph  < V , E > g )  {   init  ( ) ;    this . graph = g ;    this . originalgraph = g ; }   public ConnectivityInspector  (   DirectedGraph  < V , E > g )  {   init  ( ) ;    this . graph =  new  AsUndirectedGraph  < >  ( g ) ;    this . originalgraph = g ; }   public boolean isGraphConnected  ( )  {  return    lazyFindConnectedSets  ( ) . size  ( ) == 1 ; }   public  Set  < V > connectedSetOf  (  V vertex )  {   Set  < V >  connectedSet =  vertexToConnectedSet . get  ( vertex ) ;  if  (  connectedSet == null )  {   connectedSet =  new  HashSet  < >  ( ) ;   BreadthFirstIterator  < V , E >  i =  new  BreadthFirstIterator  < >  ( graph , vertex ) ;  while  (  i . hasNext  ( ) )  {   connectedSet . add  (  i . next  ( ) ) ; }   vertexToConnectedSet . put  ( vertex , connectedSet ) ; }  return connectedSet ; }   public  List  <  Set  < V > > connectedSets  ( )  {  return  lazyFindConnectedSets  ( ) ; }   public  @ Override void edgeAdded  (   GraphEdgeChangeEvent  < V , E > e )  {   init  ( ) ; }   public  @ Override void edgeRemoved  (   GraphEdgeChangeEvent  < V , E > e )  {   init  ( ) ; }   public boolean pathExists  (  V sourceVertex ,  V targetVertex )  {   Set  < V >  sourceSet =  connectedSetOf  ( sourceVertex ) ;  return  sourceSet . contains  ( targetVertex ) ; }   public  @ Override void vertexAdded  (   GraphVertexChangeEvent  < V > e )  {   init  ( ) ; }   public  @ Override void vertexRemoved  (   GraphVertexChangeEvent  < V > e )  {   init  ( ) ; }   private void init  ( )  {   connectedSets = null ;   vertexToConnectedSet =  new  HashMap  < >  ( ) ; }   private  List  <  Set  < V > > lazyFindConnectedSets  ( )  {  if  (  connectedSets == null )  {   connectedSets =  new  ArrayList  < >  ( ) ;   Set  < V >  vertexSet =  graph . vertexSet  ( ) ;  if  (   vertexSet . size  ( ) > 0 )  {   BreadthFirstIterator  < V , E >  i =  new  BreadthFirstIterator  < >  ( graph , null ) ;   i . addTraversalListener  (  new MyTraversalListener  ( ) ) ;  while  (  i . hasNext  ( ) )  {   i . next  ( ) ; } } }  return connectedSets ; }   private class MyTraversalListener  extends  TraversalListenerAdapter  < V , E >  {   private  Set  < V >  currentConnectedSet ;   public  @ Override void connectedComponentFinished  (  ConnectedComponentTraversalEvent e )  {   connectedSets . add  ( currentConnectedSet ) ; }   public  @ Override void connectedComponentStarted  (  ConnectedComponentTraversalEvent e )  {   currentConnectedSet =  new  HashSet  < >  ( ) ; }   public  @ Override void vertexTraversed  (   VertexTraversalEvent  < V > e )  {  V  v =  e . getVertex  ( ) ;   currentConnectedSet . add  ( v ) ;   vertexToConnectedSet . put  ( v , currentConnectedSet ) ; } }   public boolean isComplete  ( )  {  return   this . incompleteVertices  ( ) . isEmpty  ( ) ; }   public  Set  < V > incompleteVertices  ( )  {   int  grade =  (    originalgraph . vertexSet  ( ) . size  ( ) - 1 ) ;  if  (  isDirectedGraph  ( ) )  {  return  this . incompleteVertices_DirectedGraph  ( grade ) ; }   Set  < V >  set =  new  HashSet  < V >  ( ) ;   Set  < V >  temp ;  for ( V v :  originalgraph . vertexSet  ( ) )  {   temp =  new  HashSet  < V >  (  Graphs . neighborListOf  ( originalgraph , v ) ) ;  if  (   temp . size  ( ) < grade )  {   set . add  ( v ) ; } }  return set ; }  boolean isDirectedGraph  ( )  {  return  (  originalgraph instanceof DirectedGraph ) ; }   Set  < V > incompleteVertices_DirectedGraph  (   int grade )  {   Set  < V >  set =  new  HashSet  < V >  ( ) ;   DirectedGraph  < V , E >  dg =  (  DirectedGraph  < V , E > ) originalgraph ;   List  < V >  sucessors ;   int  loopCount ;  for ( V v :  originalgraph . vertexSet  ( ) )  {   loopCount = 0 ;   sucessors =  Graphs . successorListOf  ( dg , v ) ;  if  (  sucessors . contains  ( v ) )  {   loopCount = 1 ; }  if  (   sucessors . size  ( ) <  (  grade + loopCount ) )  {   set . add  ( v ) ; } }  return set ; } }