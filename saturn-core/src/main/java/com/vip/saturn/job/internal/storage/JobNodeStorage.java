  package      com . vip . saturn . job . internal . storage ;   import      com . vip . saturn . job . basic . SaturnConstant ;  import      com . vip . saturn . job . exception . JobException ;  import       com . vip . saturn . job . internal . config . JobConfiguration ;  import       com . vip . saturn . job . internal . server . ServerNode ;  import       com . vip . saturn . job . reg . base . CoordinatorRegistryCenter ;  import       com . vip . saturn . job . reg . exception . RegExceptionHandler ;  import       com . vip . saturn . job . reg . zookeeper . ZookeeperConfiguration ;  import       com . vip . saturn . job . reg . zookeeper . ZookeeperRegistryCenter ;  import      com . vip . saturn . job . utils . BlockUtils ;  import     org . apache . curator . framework . CuratorFramework ;  import       org . apache . curator . framework . api . transaction . CuratorTransactionFinal ;  import       org . apache . curator . framework . recipes . leader . LeaderLatch ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import   java . util . List ;  import    java . util . concurrent . TimeUnit ;  import      com . vip . saturn . job . utils . LogUtils ;   public class JobNodeStorage  {   private static Logger  log =  LoggerFactory . getLogger  (  JobNodeStorage . class ) ;   private static final  int  MAX_DELETE_RETRY_TIMES = 10 ;   private final CoordinatorRegistryCenter  coordinatorRegistryCenter ;   private final JobConfiguration  jobConfiguration ;   private String  executorName ;   private final String  jobName ;   public JobNodeStorage  (   final CoordinatorRegistryCenter coordinatorRegistryCenter ,   final JobConfiguration jobConfiguration )  {    this . coordinatorRegistryCenter = coordinatorRegistryCenter ;    this . jobConfiguration = jobConfiguration ;    this . jobName =  jobConfiguration . getJobName  ( ) ;  if  (  coordinatorRegistryCenter != null )  {   executorName =  coordinatorRegistryCenter . getExecutorName  ( ) ; } }   public boolean isJobNodeExisted  (   final String node )  {  return  coordinatorRegistryCenter . isExisted  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) ) ; }   public boolean isJobExisted  (   final String jobName )  {  return  coordinatorRegistryCenter . isExisted  (  JobNodePath . getJobNameFullPath  ( jobName ) ) ; }   public String getJobNodeData  (   final String node )  {  return  coordinatorRegistryCenter . get  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) ) ; }   public String getJobNodeDataDirectly  (   final String node )  {  return  coordinatorRegistryCenter . getDirectly  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) ) ; }   public String getJobNodeDataDirectly  (  String jobName ,   final String node )  {  return  coordinatorRegistryCenter . getDirectly  (  JobNodePath . getNodeFullPath  ( jobName , node ) ) ; }   public  List  < String > getJobNodeChildrenKeys  (   final String node )  {  return  coordinatorRegistryCenter . getChildrenKeys  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) ) ; }   public void createJobNodeIfNeeded  (   final String node )  {   coordinatorRegistryCenter . persist  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) , "" ) ; }   public JobConfiguration getJobConfiguration  ( )  {  return jobConfiguration ; }   public void createOrUpdateJobNodeWithValue  (   final String node ,   final String value )  {   coordinatorRegistryCenter . persist  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) , value ) ; }   public void removeJobNodeIfExisted  (   final String node )  {  if  (  isJobNodeExisted  ( node ) )  {   coordinatorRegistryCenter . remove  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) ) ; } }   public void removeJobNode  (   final String node )  {   coordinatorRegistryCenter . remove  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) ) ; }   public void fillJobNodeIfNullOrOverwrite  (   final String node ,   final Object value )  {  if  (  null == value )  {   LogUtils . info  ( log , jobName , "[{}] msg=job node value is null, node:{}" , jobName , node ) ;  return ; }  if  (   !  isJobNodeExisted  ( node ) ||  (  !   value . toString  ( ) . equals  (  getJobNodeDataDirectly  ( node ) ) ) )  {   coordinatorRegistryCenter . persist  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) ,  value . toString  ( ) ) ; } }   public void fillEphemeralJobNode  (   final String node ,   final Object value )  {   coordinatorRegistryCenter . persistEphemeral  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) ,  value . toString  ( ) ) ; }   public void updateJobNode  (   final String node ,   final Object value )  {   coordinatorRegistryCenter . update  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) ,  value . toString  ( ) ) ; }   public void updateJobNode  (   final String jobName ,   final String node ,   final Object value )  {   coordinatorRegistryCenter . update  (  JobNodePath . getNodeFullPath  ( jobName , node ) ,  value . toString  ( ) ) ; }   public void replaceJobNode  (   final String node ,   final Object value )  {   coordinatorRegistryCenter . persist  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , node ) ,  value . toString  ( ) ) ; }   public void replaceJobNode  (   final String jobName ,   final String node ,   final Object value )  {   coordinatorRegistryCenter . persist  (  JobNodePath . getNodeFullPath  ( jobName , node ) ,  value . toString  ( ) ) ; }   public void executeInTransaction  (   final TransactionExecutionCallback callback )  {  try  {  CuratorTransactionFinal  curatorTransactionFinal =      getClient  ( ) . inTransaction  ( ) . check  ( ) . forPath  ( "/" ) . and  ( ) ;   callback . execute  ( curatorTransactionFinal ) ;   curatorTransactionFinal . commit  ( ) ; }  catch (   final  Exception ex )  {   RegExceptionHandler . handleException  ( ex ) ; } }   public void executeInLeader  (   final String latchNode ,   final LeaderExecutionCallback callback )  {  try  (  LeaderLatch latch =  new LeaderLatch  (  getClient  ( ) ,  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , latchNode ) ) )  {   latch . start  ( ) ;   latch . await  ( ) ;   callback . execute  ( ) ; }  catch (   final  Exception e )  {   LogUtils . error  ( log , jobName ,  String . format  (  SaturnConstant . LOG_FORMAT_FOR_STRING , jobName ,  e . getMessage  ( ) ) , e ) ;  if  (  e instanceof InterruptedException )  {    Thread . currentThread  ( ) . interrupt  ( ) ; } else  {  throw  new JobException  ( e ) ; } } }   public void executeInLeader  (   final String latchNode ,   final LeaderExecutionCallback callback ,   final  long timeout ,   final TimeUnit unit ,   final LeaderExecutionCallback timeoutCallback )  {  try  (  LeaderLatch latch =  new LeaderLatch  (  getClient  ( ) ,  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , latchNode ) ) )  {   latch . start  ( ) ;  if  (  latch . await  ( timeout , unit ) )  {   callback . execute  ( ) ; } else  {  if  (  timeoutCallback != null )  {   timeoutCallback . execute  ( ) ; } } }  catch (   final  Exception e )  {   LogUtils . error  ( log , jobName ,  String . format  (  SaturnConstant . LOG_FORMAT_FOR_STRING , jobName ,  e . getMessage  ( ) ) , e ) ;  if  (  e instanceof InterruptedException )  {    Thread . currentThread  ( ) . interrupt  ( ) ; } else  {  throw  new JobException  ( e ) ; } } }   public CuratorFramework getClient  ( )  {  return  ( CuratorFramework )  coordinatorRegistryCenter . getRawClient  ( ) ; }   public  List  < String > getRunningItems  ( )  {  return  coordinatorRegistryCenter . getChildrenKeys  (  JobNodePath . getNodeFullPath  (  jobConfiguration . getJobName  ( ) , "execution" ) ) ; }   public void deleteJobNode  ( )  {  ZookeeperConfiguration  zkConfig =   (  ( ZookeeperRegistryCenter ) coordinatorRegistryCenter ) . getZkConfig  ( ) ;  ZookeeperRegistryCenter  newZk =  new ZookeeperRegistryCenter  ( zkConfig ) ;  try  {   newZk . init  ( ) ;   newZk . remove  (  ServerNode . getServerNode  ( jobName , executorName ) ) ;  for (   int  i = 0 ;  i < MAX_DELETE_RETRY_TIMES ;  i ++ )  {  String  fullPath =  JobNodePath . getJobNameFullPath  (  jobConfiguration . getJobName  ( ) ) ;  if  (  !  newZk . isExisted  ( fullPath ) )  {  return ; }   List  < String >  servers =  newZk . getChildrenKeys  (  ServerNode . getServerRoot  ( jobName ) ) ;  if  (   servers == null ||  servers . isEmpty  ( ) )  {  if  (  tryToRemoveNode  ( newZk , fullPath ) )  {  return ; } }   BlockUtils . waitingShortTime  ( ) ; } }  catch (   Throwable t )  {   log . error  (  String . format  (  SaturnConstant . LOG_FORMAT_FOR_STRING , jobName , "delete job node error" ) , t ) ; }  finally  {   newZk . close  ( ) ; } }   private boolean tryToRemoveNode  (  ZookeeperRegistryCenter newZk ,  String fullPath )  {  try  {   newZk . remove  ( fullPath ) ;  return true ; }  catch (   Exception e )  {   LogUtils . error  ( log , jobName ,  String . format  (  SaturnConstant . LOG_FORMAT_FOR_STRING , jobName ,  e . getMessage  ( ) ) , e ) ; }  return false ; }   public boolean isConnected  ( )  {  return  coordinatorRegistryCenter . isConnected  ( ) ; } }