  package     com . vip . saturn . job . basic ;   import      com . vip . saturn . job . executor . SaturnExecutorService ;  import       com . vip . saturn . job . internal . config . ConfigurationService ;  import       com . vip . saturn . job . internal . control . ReportService ;  import       com . vip . saturn . job . internal . execution . ExecutionContextService ;  import       com . vip . saturn . job . internal . execution . ExecutionNode ;  import       com . vip . saturn . job . internal . execution . ExecutionService ;  import       com . vip . saturn . job . internal . failover . FailoverService ;  import       com . vip . saturn . job . internal . server . ServerService ;  import       com . vip . saturn . job . internal . sharding . ShardingService ;  import       com . vip . saturn . job . internal . storage . JobNodePath ;  import      com . vip . saturn . job . trigger . SaturnScheduler ;  import      com . vip . saturn . job . trigger . SaturnTrigger ;  import      com . vip . saturn . job . utils . LogUtils ;  import     org . apache . curator . framework . CuratorFramework ;  import     org . apache . zookeeper . data . Stat ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import   java . util . Date ;  import   java . util . List ;  import    java . util . concurrent . ExecutorService ;   public abstract class AbstractElasticJob  implements  Stoppable  {   private static Logger  log =  LoggerFactory . getLogger  (  AbstractElasticJob . class ) ;   private volatile boolean  stopped = false ;   private volatile boolean  forceStopped = false ;   private volatile boolean  aborted = false ;   private volatile boolean  running = false ;   protected ConfigurationService  configService ;   protected ShardingService  shardingService ;   protected ExecutionContextService  executionContextService ;   protected ExecutionService  executionService ;   protected FailoverService  failoverService ;   protected ServerService  serverService ;   protected String  executorName ;   protected String  jobName ;   protected String  namespace ;   protected SaturnScheduler  scheduler ;   protected JobScheduler  jobScheduler ;   protected SaturnExecutorService  saturnExecutorService ;   protected ReportService  reportService ;   protected String  jobVersion ;   private void reset  ( )  {   stopped = false ;   forceStopped = false ;   aborted = false ;   running = true ; }    @ Override public void shutdown  ( )  {  if  (  scheduler != null )  {   scheduler . shutdown  ( ) ;   jobScheduler . shutdownExecutorService  ( ) ;  if  (  !  scheduler . isTerminated  ( ) )  {   abort  ( ) ; } } }   public ExecutorService getExecutorService  ( )  {  return  jobScheduler . getExecutorService  ( ) ; }   protected void init  ( )  {   scheduler =   getTrigger  ( ) . build  ( this ) ;   getExecutorService  ( ) ; }   public final void execute  ( )  {   LogUtils . debug  ( log , jobName , "Saturn start to execute job [{}]" , jobName ) ;   reset  ( ) ;  if  (  configService == null )  {   LogUtils . warn  ( log , jobName , "configService is null" ) ;  return ; }  JobExecutionMultipleShardingContext  shardingContext = null ;  try  {  if  (   !  configService . isEnabledReport  ( ) ||   failoverService . getLocalHostFailoverItems  ( ) . isEmpty  ( ) )  {   shardingService . shardingIfNecessary  ( ) ; }  if  (  !  configService . isJobEnabled  ( ) )  {   LogUtils . debug  ( log , jobName , "{} is disabled, cannot be continued, do nothing about business." , jobName ) ;  return ; }   shardingContext =  executionContextService . getJobExecutionShardingContext  ( ) ;  if  (    shardingContext . getShardingItems  ( ) == null ||   shardingContext . getShardingItems  ( ) . isEmpty  ( ) )  {   LogUtils . debug  ( log , jobName , "{} 's items of the executor is empty, do nothing about business." , jobName ) ;   callbackWhenShardingItemIsEmpty  ( shardingContext ) ;  return ; }  if  (  configService . isInPausePeriod  ( ) )  {   LogUtils . info  ( log , jobName , "the job {} current running time is in pausePeriod, do nothing about business." , jobName ) ;  return ; }   executeJobInternal  ( shardingContext ) ;  if  (      isFailoverSupported  ( ) &&  configService . isFailover  ( ) &&  ! stopped &&  ! forceStopped &&  ! aborted )  {   failoverService . failoverIfNecessary  ( ) ; }   LogUtils . debug  ( log , jobName , "Saturn finish to execute job [{}], sharding context:{}." , jobName , shardingContext ) ; }  catch (   Exception e )  {   LogUtils . warn  ( log , jobName ,  String . format  (  SaturnConstant . LOG_FORMAT_FOR_STRING , jobName ,  e . getMessage  ( ) ) , e ) ; }  finally  {   running = false ; } }   private void executeJobInternal  (   final JobExecutionMultipleShardingContext shardingContext )  throws Exception  {   executionService . registerJobBegin  ( shardingContext ) ;  try  {   executeJob  ( shardingContext ) ; }  finally  {   List  < Integer >  shardingItems =  shardingContext . getShardingItems  ( ) ;  if  (  !  shardingItems . isEmpty  ( ) )  {  Date  nextFireTimePausePeriodEffected =  jobScheduler . getNextFireTimePausePeriodEffected  ( ) ;  boolean  isEnabledReport =  configService . isEnabledReport  ( ) ;  for (  int item : shardingItems )  {  if  (  isEnabledReport &&  !  checkIfZkLostAfterExecution  ( item ) )  {  continue ; }  if  (  ! aborted )  {   executionService . registerJobCompletedByItem  ( shardingContext , item , nextFireTimePausePeriodEffected ) ; }  if  (   isFailoverSupported  ( ) &&  configService . isFailover  ( ) )  {   failoverService . updateFailoverComplete  ( item ) ; } } }   afterMainThreadDone  ( shardingContext ) ; } }   private boolean checkIfZkLostAfterExecution  (   final Integer item )  {  CuratorFramework  curatorFramework =  ( CuratorFramework )   executionService . getCoordinatorRegistryCenter  ( ) . getRawClient  ( ) ;  try  {  String  runningPath =  JobNodePath . getNodeFullPath  ( jobName ,  ExecutionNode . getRunningNode  ( item ) ) ;  Stat  itemStat =   curatorFramework . checkExists  ( ) . forPath  ( runningPath ) ;   long  sessionId =    curatorFramework . getZookeeperClient  ( ) . getZooKeeper  ( ) . getSessionId  ( ) ;  if  (  itemStat != null )  {   long  ephemeralOwner =  itemStat . getEphemeralOwner  ( ) ;  if  (  ephemeralOwner != sessionId )  {   LogUtils . info  ( log , jobName ,  "item={} 's running node doesn't belong to current zk, node sessionid is {}, current zk " + "sessionid is {}" , item , ephemeralOwner , sessionId ) ;  return false ; } else  {  return true ; } }   LogUtils . info  ( log , jobName , "item={} 's running node is not exists, zk sessionid={} " , item , sessionId ) ;  return false ; }  catch (   Throwable e )  {   LogUtils . error  ( log , jobName ,  String . format  (  SaturnConstant . LOG_FORMAT_FOR_STRING , jobName ,  e . getMessage  ( ) ) , e ) ;  return false ; } }   protected abstract void executeJob  (   final JobExecutionMultipleShardingContext shardingContext ) ;   public void afterMainThreadDone  (   final JobExecutionMultipleShardingContext shardingContext )  { }   public void callbackWhenShardingItemIsEmpty  (   final JobExecutionMultipleShardingContext shardingContext )  { }   public abstract boolean isFailoverSupported  ( ) ;    @ Override public void stop  ( )  {   stopped = true ; }    @ Override public void forceStop  ( )  {   forceStopped = true ; }    @ Override public void abort  ( )  {   aborted = true ; }    @ Override public void resume  ( )  {   stopped = false ; }   public abstract SaturnTrigger getTrigger  ( ) ;   public abstract void enableJob  ( ) ;   public abstract void disableJob  ( ) ;   public abstract void onResharding  ( ) ;   public abstract void onForceStop  (   int item ) ;   public abstract void onTimeout  (   int item ) ;   public abstract void onNeedRaiseAlarm  (   int item ,  String alarmMessage ) ;   public void notifyJobEnabled  ( )  { }   public void notifyJobDisabled  ( )  { }   protected void setShardingService  (  ShardingService shardingService )  {    this . shardingService = shardingService ; }   protected void setExecutionContextService  (  ExecutionContextService executionContextService )  {    this . executionContextService = executionContextService ; }   protected void setExecutionService  (  ExecutionService executionService )  {    this . executionService = executionService ; }   protected void setFailoverService  (  FailoverService failoverService )  {    this . failoverService = failoverService ; }   protected void setServerService  (  ServerService serverService )  {    this . serverService = serverService ; }   protected void setReportService  (  ReportService reportService )  {    this . reportService = reportService ; }   public String getExecutorName  ( )  {  return executorName ; }   protected void setExecutorName  (  String executorName )  {    this . executorName = executorName ; }   public String getJobName  ( )  {  return jobName ; }   protected void setJobName  (  String jobName )  {    this . jobName = jobName ; }   public String getNamespace  ( )  {  return namespace ; }   protected void setNamespace  (  String namespace )  {    this . namespace = namespace ; }   protected SaturnScheduler getScheduler  ( )  {  return scheduler ; }   protected void setScheduler  (  SaturnScheduler scheduler )  {    this . scheduler = scheduler ; }   protected JobScheduler getJobScheduler  ( )  {  return jobScheduler ; }   public void setJobScheduler  (  JobScheduler jobScheduler )  {    this . jobScheduler = jobScheduler ; }   public SaturnExecutorService getSaturnExecutorService  ( )  {  return saturnExecutorService ; }   protected void setSaturnExecutorService  (  SaturnExecutorService saturnExecutorService )  {    this . saturnExecutorService = saturnExecutorService ; }   public boolean isRunning  ( )  {  return running ; }   public ConfigurationService getConfigService  ( )  {  return configService ; }   public final void setConfigService  (   final ConfigurationService configService )  {    this . configService = configService ; }   public String getJobVersion  ( )  {  return jobVersion ; }   public void setJobVersion  (  String jobVersion )  {    this . jobVersion = jobVersion ; } }