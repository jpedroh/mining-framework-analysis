  package      com . vip . saturn . job . internal . server ;   import      com . vip . saturn . job . basic . JobScheduler ;  import       com . vip . saturn . job . internal . config . ConfigurationNode ;  import       com . vip . saturn . job . internal . listener . AbstractJobListener ;  import       com . vip . saturn . job . internal . listener . AbstractListenerManager ;  import       com . vip . saturn . job . internal . storage . JobNodePath ;  import      com . vip . saturn . job . threads . SaturnThreadFactory ;  import      com . vip . saturn . job . utils . LogUtils ;  import     org . apache . curator . framework . CuratorFramework ;  import       org . apache . curator . framework . recipes . cache . TreeCacheEvent ;  import        org . apache . curator . framework . recipes . cache . TreeCacheEvent . Type ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import    java . util . concurrent . ExecutorService ;  import    java . util . concurrent . Executors ;   public class JobOperationListenerManager  extends AbstractListenerManager  {   static Logger  log =  LoggerFactory . getLogger  (  JobOperationListenerManager . class ) ;   private boolean  isShutdown = false ;   private ExecutorService  jobDeleteExecutorService ;   public JobOperationListenerManager  (   final JobScheduler jobScheduler )  {  super  ( jobScheduler ) ; }    @ Override public void start  ( )  {   jobDeleteExecutorService =  Executors . newSingleThreadExecutor  (  new SaturnThreadFactory  (    executorName + "-" + jobName + "-jobDelete" , false ) ) ;   zkCacheManager . addTreeCacheListener  (  new TriggerJobRunAtOnceListener  ( ) ,  JobNodePath . getNodeFullPath  ( jobName ,  String . format  (  ServerNode . RUNONETIME , executorName ) ) , 0 ) ;   zkCacheManager . addTreeCacheListener  (  new JobForcedToStopListener  ( ) ,  JobNodePath . getNodeFullPath  ( jobName ,  String . format  (  ServerNode . STOPONETIME , executorName ) ) , 0 ) ;   zkCacheManager . addTreeCacheListener  (  new JobDeleteListener  ( ) ,  JobNodePath . getNodeFullPath  ( jobName ,  ConfigurationNode . TO_DELETE ) , 0 ) ; }    @ Override public void shutdown  ( )  {   super . shutdown  ( ) ;   isShutdown = true ;  if  (  jobDeleteExecutorService != null )  {   jobDeleteExecutorService . shutdown  ( ) ; }   zkCacheManager . closeTreeCache  (  JobNodePath . getNodeFullPath  ( jobName ,  String . format  (  ServerNode . RUNONETIME , executorName ) ) , 0 ) ;   zkCacheManager . closeTreeCache  (  JobNodePath . getNodeFullPath  ( jobName ,  String . format  (  ServerNode . STOPONETIME , executorName ) ) , 0 ) ;   zkCacheManager . closeTreeCache  (  JobNodePath . getNodeFullPath  ( jobName ,  ConfigurationNode . TO_DELETE ) , 0 ) ; }  class TriggerJobRunAtOnceListener  extends AbstractJobListener  {    @ Override protected void dataChanged  (   final CuratorFramework client ,   final TreeCacheEvent event ,   final String path )  {  if  ( isShutdown )  {  return ; }  if  (   (    Type . NODE_ADDED ==  event . getType  ( ) ||   Type . NODE_UPDATED ==  event . getType  ( ) ) &&  ServerNode . isRunOneTimePath  ( jobName , path , executorName ) )  {  if  (  !   jobScheduler . getJob  ( ) . isRunning  ( ) )  {   LogUtils . info  ( log , jobName , "[{}] msg=job run-at-once triggered." , jobName ) ;   jobScheduler . triggerJob  ( ) ; } else  {   LogUtils . info  ( log , jobName , "[{}] msg=job is running, run-at-once ignored." , jobName ) ; }   coordinatorRegistryCenter . remove  ( path ) ; } } }  class JobDeleteListener  extends AbstractJobListener  {    @ Override protected void dataChanged  (  CuratorFramework client ,  TreeCacheEvent event ,  String path )  {  if  ( isShutdown )  {  return ; }  if  (   ConfigurationNode . isToDeletePath  ( jobName , path ) &&  (    Type . NODE_ADDED ==  event . getType  ( ) ||   Type . NODE_UPDATED ==  event . getType  ( ) ) )  {   LogUtils . info  ( log , jobName , "[{}] msg={} is going to be deleted." , jobName , jobName ) ;   jobDeleteExecutorService . execute  (  new Runnable  ( )  {    @ Override public void run  ( )  {  try  {   jobScheduler . shutdown  ( true ) ; }  catch (   Throwable t )  {   LogUtils . error  ( log , jobName , "delete job error" , t ) ; } } } ) ; } } }  class JobForcedToStopListener  extends AbstractJobListener  {    @ Override protected void dataChanged  (  CuratorFramework client ,  TreeCacheEvent event ,  String path )  {  if  ( isShutdown )  {  return ; }  if  (    Type . NODE_ADDED ==  event . getType  ( ) ||   Type . NODE_UPDATED ==  event . getType  ( ) )  {  try  {   LogUtils . info  ( log , jobName , "[{}] msg={} is going to be stopped at once." , jobName , jobName ) ;    jobScheduler . getJob  ( ) . forceStop  ( ) ; }  finally  {   coordinatorRegistryCenter . remove  ( path ) ; } } } } }