  package     be . ugent . mmlab . rml . processor ;   import      be . ugent . mmlab . rml . core . ConditionalJoinRMLPerformer ;  import      be . ugent . mmlab . rml . core . JoinRMLPerformer ;  import      be . ugent . mmlab . rml . core . RMLEngine ;  import      be . ugent . mmlab . rml . core . RMLPerformer ;  import      be . ugent . mmlab . rml . core . SimpleReferencePerformer ;  import      be . ugent . mmlab . rml . model . GraphMap ;  import      be . ugent . mmlab . rml . model . JoinCondition ;  import      be . ugent . mmlab . rml . model . LogicalSource ;  import      be . ugent . mmlab . rml . model . ObjectMap ;  import      be . ugent . mmlab . rml . model . PredicateMap ;  import      be . ugent . mmlab . rml . model . PredicateObjectMap ;  import      be . ugent . mmlab . rml . model . ReferencingObjectMap ;  import      be . ugent . mmlab . rml . model . SubjectMap ;  import      be . ugent . mmlab . rml . model . TermMap ;  import static       be . ugent . mmlab . rml . model . TermType . BLANK_NODE ;  import static       be . ugent . mmlab . rml . model . TermType . IRI ;  import      be . ugent . mmlab . rml . model . TriplesMap ;  import       be . ugent . mmlab . rml . model . reference . ReferenceIdentifierImpl ;  import       be . ugent . mmlab . rml . processor . concrete . ConcreteRMLProcessorFactory ;  import       be . ugent . mmlab . rml . vocabulary . Vocab . QLTerm ;  import   java . io . IOException ;  import   java . io . InputStream ;  import   java . io . UnsupportedEncodingException ;  import   java . net . MalformedURLException ;  import   java . net . URLEncoder ;  import   java . util . ArrayList ;  import   java . util . HashMap ;  import   java . util . List ;  import   java . util . Set ;  import    java . util . logging . Level ;  import    java . util . logging . Logger ;  import        net . antidot . semantic . rdf . model . impl . sesame . SesameDataSet ;  import        net . antidot . semantic . rdf . rdb2rdf . r2rml . core . R2RMLEngine ;  import        net . antidot . semantic . rdf . rdb2rdf . r2rml . tools . R2RMLToolkit ;  import     org . apache . commons . logging . Log ;  import     org . apache . commons . logging . LogFactory ;  import    org . openrdf . model . Resource ;  import    org . openrdf . model . URI ;  import    org . openrdf . model . Value ;  import     org . openrdf . model . impl . BNodeImpl ;  import     org . openrdf . model . impl . LiteralImpl ;  import     org . openrdf . model . impl . URIImpl ;  import     org . openrdf . model . vocabulary . RDF ;  import    java . util . regex . Pattern ;  import        net . antidot . semantic . rdf . rdb2rdf . r2rml . model . TermType ;   public abstract class AbstractRMLProcessor  implements  RMLProcessor  {   private static Log  log =  LogFactory . getLog  (  R2RMLEngine . class ) ;   protected String getReference  (  LogicalSource ls )  {  return  ls . getReference  ( ) ; }    @ Override public Resource processSubjectMap  (  SesameDataSet dataset ,  SubjectMap subjectMap ,  Object node )  {   List  < String >  values =  processTermMap  ( subjectMap , node ) ;  if  (  values . isEmpty  ( ) )  if  (   subjectMap . getTermType  ( ) != BLANK_NODE )  return null ;  String  value = null ;  if  (   subjectMap . getTermType  ( ) != BLANK_NODE )  {   value =  values . get  ( 0 ) ;  if  (   (  value == null ) ||  (  value . equals  ( "" ) ) )  return null ; }  Resource  subject = null ;  switch  (  subjectMap . getTermType  ( ) )  {   case IRI :  if  (   value != null &&  !  value . equals  ( "" ) )  {  if  (  value . startsWith  ( "www." ) )   value =  "http://" + value ;   subject =  new URIImpl  ( value ) ; }  break ;   case BLANK_NODE :   subject =  new BNodeImpl  (      org . apache . commons . lang . RandomStringUtils . randomAlphanumeric  ( 10 ) ) ;  break ;   default :   subject =  new URIImpl  ( value ) ; }  return subject ; }    @ Override public void processSubjectTypeMap  (  SesameDataSet dataset ,  Resource subject ,  SubjectMap subjectMap ,  Object node )  {    Set <    org . openrdf . model . URI >  classIRIs =  subjectMap . getClassIRIs  ( ) ;  if  (  subject != null )  for (    org . openrdf . model . URI classIRI : classIRIs )  if  (   subjectMap . getGraphMaps  ( ) . isEmpty  ( ) )   dataset . add  ( subject ,  RDF . TYPE , classIRI ) ; else  for ( GraphMap map :  subjectMap . getGraphMaps  ( ) )  if  (   map . getConstantValue  ( ) != null )   dataset . add  ( subject ,  RDF . TYPE , classIRI ,  new URIImpl  (   map . getConstantValue  ( ) . toString  ( ) ) ) ; }    @ Override public  List  < String > processTermMap  (  TermMap map ,  Object node )  {   List  < String >  value =  new  ArrayList  < >  ( ) ;  switch  (  map . getTermMapType  ( ) )  {   case REFERENCE_VALUED :  ReferenceIdentifierImpl  identifier =  ( ReferenceIdentifierImpl )  map . getReferenceValue  ( ) ;  return  extractValueFromNode  ( node ,   identifier . toString  ( ) . trim  ( ) ) ;   case CONSTANT_VALUED :   value . add  (    map . getConstantValue  ( ) . stringValue  ( ) . trim  ( ) ) ;  return value ;   case TEMPLATE_VALUED :  String  template =  map . getStringTemplate  ( ) ;   Set  < String >  tokens =  R2RMLToolkit . extractColumnNamesFromStringTemplate  ( template ) ;  for ( String expression : tokens )  {   List  < String >  replacements =  extractValueFromNode  ( node , expression ) ;  for (   int  i = 0 ;  i <  replacements . size  ( ) ;  i ++ )  {  if  (   value . size  ( ) <  (  i + 1 ) )  {   value . add  ( template ) ; }  String  replacement = null ;  if  (   replacements . get  ( i ) != null )   replacement =   replacements . get  ( i ) . trim  ( ) ;  if  (   replacement == null ||  replacement . equals  ( "" ) )  {  continue ; }  String  temp =   value . get  ( i ) . trim  ( ) ;  if  (  expression . contains  ( "[" ) )  {   expression =   expression . replaceAll  ( "\\[" , "" ) . replaceAll  ( "\\]" , "" ) ;   temp =   temp . replaceAll  ( "\\[" , "" ) . replaceAll  ( "\\]" , "" ) ; }  if  (   (     map . getOwnTriplesMap  ( ) . getLogicalSource  ( ) . getReferenceFormulation  ( ) ==  QLTerm . JSONPATH_CLASS ) &&  expression . contains  ( "$" ) )  {   expression =  expression . replaceAll  ( "\\$" , "" ) ;   temp =  temp . replaceAll  ( "\\$" , "" ) ; }  try  {  if  (    map . getTermType  ( ) . toString  ( ) . equals  (   TermType . IRI . toString  ( ) ) )  {   temp =  temp . replaceAll  (   "\\{" +  Pattern . quote  ( expression ) + "\\}" ,        URLEncoder . encode  ( replacement , "UTF-8" ) . replaceAll  ( "\\+" , "%20" ) . replaceAll  ( "\\%21" , "!" ) . replaceAll  ( "\\%27" , "'" ) . replaceAll  ( "\\%28" , "(" ) . replaceAll  ( "\\%29" , ")" ) . replaceAll  ( "\\%7E" , "~" ) ) ; } else  {   temp =  temp . replaceAll  (   "\\{" + expression + "\\}" , replacement ) ; } }  catch (   UnsupportedEncodingException ex )  {    Logger . getLogger  (   AbstractRMLProcessor . class . getName  ( ) ) . log  (  Level . SEVERE , null , ex ) ; }   value . set  ( i ,  temp . toString  ( ) ) ; } }   List  < String >  validValues =  new  ArrayList  < >  ( ) ;  for ( String uri : value )  {  if  (   R2RMLToolkit . extractColumnNamesFromStringTemplate  ( uri ) . isEmpty  ( ) )  {   validValues . add  ( uri ) ; } }  return validValues ;   default :  return value ; } }    @ Override public void processPredicateObjectMap  (  SesameDataSet dataset ,  Resource subject ,  PredicateObjectMap pom ,  Object node ,  TriplesMap map )  {   Set  < PredicateMap >  predicateMaps =  pom . getPredicateMaps  ( ) ;  for ( PredicateMap predicateMap : predicateMaps )  {   List  < URI >  predicates =  processPredicateMap  ( predicateMap , node ) ;  for ( URI predicate : predicates )  {   Set  < ReferencingObjectMap >  referencingObjectMaps =  pom . getReferencingObjectMaps  ( ) ;  for ( ReferencingObjectMap referencingObjectMap : referencingObjectMaps )  {   Set  < JoinCondition >  joinConditions =  referencingObjectMap . getJoinConditions  ( ) ;  TriplesMap  parentTriplesMap =  referencingObjectMap . getParentTriplesMap  ( ) ;  RMLProcessorFactory  factory =  new ConcreteRMLProcessorFactory  ( ) ;  QLTerm  queryLanguage =   parentTriplesMap . getLogicalSource  ( ) . getReferenceFormulation  ( ) ;  String  source =   parentTriplesMap . getLogicalSource  ( ) . getIdentifier  ( ) ;  InputStream  input = null ;  try  {   input =  RMLEngine . getInputStream  ( source , parentTriplesMap ) ; }  catch (   MalformedURLException ex )  {    Logger . getLogger  (   AbstractRMLProcessor . class . getName  ( ) ) . log  (  Level . SEVERE , null , ex ) ; }  catch (   IOException ex )  {    Logger . getLogger  (   AbstractRMLProcessor . class . getName  ( ) ) . log  (  Level . SEVERE , null , ex ) ; }  RMLProcessor  processor =  factory . create  ( queryLanguage ) ;  RMLPerformer  performer ;  if  (   joinConditions . isEmpty  ( ) &  !    parentTriplesMap . getLogicalSource  ( ) . getIdentifier  ( ) . equals  (   map . getLogicalSource  ( ) . getIdentifier  ( ) ) )  {   performer =  new JoinRMLPerformer  ( processor , subject , predicate ) ;   processor . execute  ( dataset , parentTriplesMap , performer , input ) ; } else  if  (   joinConditions . isEmpty  ( ) &    parentTriplesMap . getLogicalSource  ( ) . getIdentifier  ( ) . equals  (   map . getLogicalSource  ( ) . getIdentifier  ( ) ) )  {   performer =  new SimpleReferencePerformer  ( processor , subject , predicate ) ;  if  (   (     parentTriplesMap . getLogicalSource  ( ) . getReferenceFormulation  ( ) . toString  ( ) . equals  ( "CSV" ) ) ||  (    parentTriplesMap . getLogicalSource  ( ) . getReference  ( ) . equals  (   map . getLogicalSource  ( ) . getReference  ( ) ) ) )  {   performer . perform  ( node , dataset , parentTriplesMap ) ; } else  {   int  end =    map . getLogicalSource  ( ) . getReference  ( ) . length  ( ) ;   log . info  (  "RML:AbstractRMLProcessor " +    parentTriplesMap . getLogicalSource  ( ) . getReference  ( ) . toString  ( ) ) ;  String  expression = "" ;  switch  (    parentTriplesMap . getLogicalSource  ( ) . getReferenceFormulation  ( ) . toString  ( ) )  {   case "XPath" :   expression =     parentTriplesMap . getLogicalSource  ( ) . getReference  ( ) . toString  ( ) . substring  ( end ) ;  break ;   case "JSONPath" :   expression =     parentTriplesMap . getLogicalSource  ( ) . getReference  ( ) . toString  ( ) . substring  (  end + 1 ) ;  break ; }   processor . execute_node  ( dataset , expression , parentTriplesMap , performer , node , null ) ; } } else  {   HashMap  < String , String >  joinMap =  new  HashMap  < >  ( ) ;  for ( JoinCondition joinCondition : joinConditions )  {   List  < String >  childValues =  extractValueFromNode  ( node ,  joinCondition . getChild  ( ) ) ;  for ( String childValue : childValues )  {   joinMap . put  (  joinCondition . getParent  ( ) , childValue ) ;  if  (   joinMap . size  ( ) ==  joinConditions . size  ( ) )  {   performer =  new ConditionalJoinRMLPerformer  ( processor , joinMap , subject , predicate ) ;   processor . execute  ( dataset , parentTriplesMap , performer , input ) ; } } } } }   Set  < ObjectMap >  objectMaps =  pom . getObjectMaps  ( ) ;  for ( ObjectMap objectMap : objectMaps )  {   List  < Value >  objects =  processObjectMap  ( objectMap , node ) ;  for ( Value object : objects )  {  if  (   object . stringValue  ( ) != null )  {   Set  < GraphMap >  graphs =  pom . getGraphMaps  ( ) ;  if  (   graphs . isEmpty  ( ) &&  subject != null )   dataset . add  ( subject , predicate , object ) ; else  for ( GraphMap graph : graphs )  {  Resource  graphResource =  new URIImpl  (   graph . getConstantValue  ( ) . toString  ( ) ) ;   dataset . add  ( subject , predicate , object , graphResource ) ; } } } } } } }   private  List  < URI > processPredicateMap  (  PredicateMap predicateMap ,  Object node )  {   List  < String >  values =  processTermMap  ( predicateMap , node ) ;   List  < URI >  uris =  new  ArrayList  < >  ( ) ;  for ( String value : values )  {  if  (  value . startsWith  ( "www." ) )   value =  "http://" + value ;   uris . add  (  new URIImpl  ( value ) ) ; }  return uris ; }   public  List  < Value > processObjectMap  (  ObjectMap objectMap ,  Object node )  {   List  < String >  values =  processTermMap  ( objectMap , node ) ;   List  < Value >  valueList =  new  ArrayList  < >  ( ) ;  for ( String value : values )  {  switch  (  objectMap . getTermType  ( ) )  {   case IRI :  if  (   value != null &&  !  value . equals  ( "" ) )  {  if  (  value . startsWith  ( "www." ) )   value =  "http://" + value ;   valueList . add  (  new URIImpl  ( value ) ) ; }  break ;   case BLANK_NODE :   valueList . add  (  new BNodeImpl  ( value ) ) ;  break ;   case LITERAL :  if  (    objectMap . getLanguageTag  ( ) != null &&  !  value . equals  ( "" ) )  {   valueList . add  (  new LiteralImpl  ( value ,  objectMap . getLanguageTag  ( ) ) ) ; } else  if  (    value != null &&  !  value . equals  ( "" ) &&   objectMap . getDataType  ( ) != null )  {   valueList . add  (  new LiteralImpl  ( value ,  objectMap . getDataType  ( ) ) ) ; } else  if  (   value != null &&  !  value . equals  ( "" ) )  {   valueList . add  (  new LiteralImpl  (  value . trim  ( ) ) ) ; } } }  return valueList ; } }