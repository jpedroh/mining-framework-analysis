  package  hudson . security ;   import      edu . umd . cs . findbugs . annotations . SuppressFBWarnings ;  import   groovy . lang . Binding ;  import  hudson . DescriptorExtensionList ;  import  hudson . Extension ;  import static   hudson . Util . fixEmpty ;  import static   hudson . Util . fixEmptyAndTrim ;  import static   hudson . Util . fixNull ;  import  hudson . Util ;  import   hudson . model . AbstractDescribableImpl ;  import   hudson . model . Descriptor ;  import   hudson . model . User ;  import   hudson . tasks . MailAddressResolver ;  import   hudson . tasks . Mailer ;  import    hudson . tasks . Mailer . UserProperty ;  import   hudson . util . FormValidation ;  import   hudson . util . ListBoxModel ;  import   hudson . util . Scrambler ;  import   hudson . util . Secret ;  import    hudson . util . spring . BeanBuilder ;  import   java . io . File ;  import   java . io . FileInputStream ;  import   java . io . FileNotFoundException ;  import   java . io . IOException ;  import   java . io . Serializable ;  import   java . net . InetAddress ;  import   java . net . Socket ;  import   java . net . URISyntaxException ;  import   java . net . UnknownHostException ;  import   java . net . URI ;  import  java . util .  * ;  import    java . util . concurrent . TimeUnit ;  import    java . util . logging . Level ;  import    java . util . logging . Logger ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import   javax . annotation . CheckForNull ;  import   javax . annotation . Nonnull ;  import   javax . naming . Context ;  import   javax . naming . NamingException ;  import    javax . naming . directory . Attribute ;  import    javax . naming . directory . Attributes ;  import    javax . naming . directory . BasicAttributes ;  import    javax . naming . directory . DirContext ;  import    javax . naming . directory . InitialDirContext ;  import    javax . naming . ldap . Control ;  import   jenkins . model . IdStrategy ;  import   jenkins . model . Jenkins ;  import     jenkins . security . plugins . ldap . FromGroupSearchLDAPGroupMembershipStrategy ;  import     jenkins . security . plugins . ldap . LDAPConfiguration ;  import     jenkins . security . plugins . ldap . LDAPGroupMembershipStrategy ;  import    net . sf . json . JSONArray ;  import    net . sf . json . JSONObject ;  import  org . acegisecurity .  * ;  import    org . acegisecurity . ldap . InitialDirContextFactory ;  import    org . acegisecurity . ldap . LdapDataAccessException ;  import    org . acegisecurity . ldap . LdapTemplate ;  import    org . acegisecurity . ldap . LdapUserSearch ;  import     org . acegisecurity . ldap . search . FilterBasedLdapUserSearch ;  import    org . acegisecurity . providers . UsernamePasswordAuthenticationToken ;  import     org . acegisecurity . providers . ldap . LdapAuthoritiesPopulator ;  import      org . acegisecurity . providers . ldap . populator . DefaultLdapAuthoritiesPopulator ;  import    org . acegisecurity . userdetails . UserDetails ;  import    org . acegisecurity . userdetails . UserDetailsService ;  import    org . acegisecurity . userdetails . UsernameNotFoundException ;  import     org . acegisecurity . userdetails . ldap . LdapUserDetails ;  import     org . acegisecurity . userdetails . ldap . LdapUserDetailsImpl ;  import      org . apache . commons . collections . map . LRUMap ;  import      org . apache . commons . io . input . AutoCloseInputStream ;  import     org . apache . commons . lang . StringUtils ;  import    org . kohsuke . accmod . Restricted ;  import     org . kohsuke . accmod . restrictions . DoNotUse ;  import     org . kohsuke . accmod . restrictions . NoExternalUse ;  import    org . kohsuke . stapler . DataBoundConstructor ;  import    org . kohsuke . stapler . QueryParameter ;  import    org . kohsuke . stapler . StaplerRequest ;  import    org . springframework . dao . DataAccessException ;  import     org . springframework . web . context . WebApplicationContext ;  import   java . util . ArrayList ;  import   java . util . Collection ;  import   java . util . TreeSet ;  import   org . acegisecurity . BadCredentialsException ;  import     org . acegisecurity . providers . ldap . LdapAuthenticationProvider ;  import     org . acegisecurity . providers . ldap . LdapAuthenticator ;  import     org . apache . commons . io . IOUtils ;  import    org . kohsuke . stapler . DataBoundSetter ;  import     org . kohsuke . stapler . interceptor . RequirePOST ;   public class LDAPSecurityRealm  extends AbstractPasswordBasedSecurityRealm  {   private static final boolean  FORCE_USERNAME_LOWERCASE =  Boolean . getBoolean  (    LDAPSecurityRealm . class . getName  ( ) + ".forceUsernameLowercase" ) ;   private static final boolean  FORCE_GROUPNAME_LOWERCASE =  Boolean . getBoolean  (    LDAPSecurityRealm . class . getName  ( ) + ".forceGroupnameLowercase" ) ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  server ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  rootDN ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient boolean  inhibitInferRootDN ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  userSearchBase ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  userSearch ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  groupSearchBase ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  groupSearchFilter ;    @ Deprecated  @ Restricted  (  NoExternalUse . class )  @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" ) public transient String  groupMembershipFilter ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient LDAPGroupMembershipStrategy  groupMembershipStrategy ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  managerDN ;    @ Deprecated  @ Restricted  (  NoExternalUse . class )  @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" ) private transient String  managerPassword ;    @ Deprecated  @ Restricted  (  NoExternalUse . class ) private transient Secret  managerPasswordSecret ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" ) public final boolean  disableMailAddressResolver ;   private  List  < LDAPConfiguration >  configurations ;   private final CacheConfiguration  cache ;   private transient  Map  < String ,  CacheEntry  < LdapUserDetails > >  userDetailsCache = null ;   private transient  Map  < String ,  CacheEntry  <  Set  < String > > >  groupDetailsCache = null ;    @ Deprecated  @ Restricted  (  NoExternalUse . class ) private transient  Map  < String , String >  extraEnvVars ;    @ Deprecated  @ Restricted  (  NoExternalUse . class ) private transient String  displayNameAttributeName ;    @ Deprecated  @ Restricted  (  NoExternalUse . class ) private transient String  mailAddressAttributeName ;   private final IdStrategy  userIdStrategy ;   private final IdStrategy  groupIdStrategy ;    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , managerDN , managerPassword , inhibitInferRootDN , false ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , managerDN , managerPassword , inhibitInferRootDN , disableMailAddressResolver , null ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , null , null , managerDN , managerPassword , inhibitInferRootDN , disableMailAddressResolver , cache ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  String groupMembershipFilter ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter , groupMembershipFilter , managerDN , managerPassword , inhibitInferRootDN , disableMailAddressResolver , cache , null ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  String groupMembershipFilter ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,   EnvironmentProperty  [ ] environmentProperties )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter , groupMembershipFilter , managerDN , managerPassword , inhibitInferRootDN , disableMailAddressResolver , cache , environmentProperties , null , null ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  String groupMembershipFilter ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,   EnvironmentProperty  [ ] environmentProperties ,  String displayNameAttributeName ,  String mailAddressAttributeName )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter , groupMembershipFilter , managerDN ,  Secret . fromString  ( managerPassword ) , inhibitInferRootDN , disableMailAddressResolver , cache , environmentProperties , null , null ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  String groupMembershipFilter ,  String managerDN ,  Secret managerPasswordSecret ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,   EnvironmentProperty  [ ] environmentProperties ,  String displayNameAttributeName ,  String mailAddressAttributeName )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter ,  new FromGroupSearchLDAPGroupMembershipStrategy  ( groupMembershipFilter ) , managerDN , managerPasswordSecret , inhibitInferRootDN , disableMailAddressResolver , cache , environmentProperties , displayNameAttributeName , mailAddressAttributeName ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  LDAPGroupMembershipStrategy groupMembershipStrategy ,  String managerDN ,  Secret managerPasswordSecret ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,   EnvironmentProperty  [ ] environmentProperties ,  String displayNameAttributeName ,  String mailAddressAttributeName )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter , groupMembershipStrategy , managerDN , managerPasswordSecret , inhibitInferRootDN , disableMailAddressResolver , cache , environmentProperties , displayNameAttributeName , mailAddressAttributeName ,  IdStrategy . CASE_INSENSITIVE ,  IdStrategy . CASE_INSENSITIVE ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  LDAPGroupMembershipStrategy groupMembershipStrategy ,  String managerDN ,  Secret managerPasswordSecret ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,   EnvironmentProperty  [ ] environmentProperties ,  String displayNameAttributeName ,  String mailAddressAttributeName ,  IdStrategy userIdStrategy ,  IdStrategy groupIdStrategy )  {  this  (  createLdapConfiguration  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter , groupMembershipStrategy , managerDN , managerPasswordSecret , inhibitInferRootDN , environmentProperties , displayNameAttributeName , mailAddressAttributeName ) , disableMailAddressResolver , cache , userIdStrategy , groupIdStrategy ) ; }    @ DataBoundConstructor public LDAPSecurityRealm  (   List  < LDAPConfiguration > configurations ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,  IdStrategy userIdStrategy ,  IdStrategy groupIdStrategy )  {  if  (   configurations == null ||  configurations . isEmpty  ( ) )  {  throw  new IllegalArgumentException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AtLeastOne  ( ) ) ; }    this . configurations = configurations ;    this . disableMailAddressResolver = disableMailAddressResolver ;    this . cache = cache ;    this . userIdStrategy = userIdStrategy ;    this . groupIdStrategy = groupIdStrategy ; }   private static  List  < LDAPConfiguration > createLdapConfiguration  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  LDAPGroupMembershipStrategy groupMembershipStrategy ,  String managerDN ,  Secret managerPasswordSecret ,  boolean inhibitInferRootDN ,   EnvironmentProperty  [ ] environmentProperties ,  String displayNameAttributeName ,  String mailAddressAttributeName )  {  LDAPConfiguration  conf =  new LDAPConfiguration  ( server , rootDN , inhibitInferRootDN , managerDN , managerPasswordSecret ) ;   conf . setUserSearchBase  ( userSearchBase ) ;   conf . setUserSearch  ( userSearch ) ;   conf . setGroupSearchBase  ( groupSearchBase ) ;   conf . setGroupSearchFilter  ( groupSearchFilter ) ;   conf . setGroupMembershipStrategy  ( groupMembershipStrategy ) ;   conf . setEnvironmentProperties  ( environmentProperties ) ;   conf . setDisplayNameAttributeName  ( displayNameAttributeName ) ;   conf . setMailAddressAttributeName  ( mailAddressAttributeName ) ;  return  Collections . singletonList  ( conf ) ; }   public  List  < LDAPConfiguration > getConfigurations  ( )  {  return configurations ; }   private boolean hasConfiguration  ( )  {  return   configurations != null &&  !  configurations . isEmpty  ( ) ; }   private Object readResolve  ( )  {  if  (  managerPassword != null )  {   managerPasswordSecret =  Secret . fromString  (  Scrambler . descramble  ( managerPassword ) ) ;   managerPassword = null ; }  if  (  server != null )  {  LDAPConfiguration  conf =  new LDAPConfiguration  ( server , rootDN , inhibitInferRootDN , managerDN , managerPasswordSecret ) ;   server = null ;   rootDN = null ;   managerDN = null ;   managerPasswordSecret = null ;   conf . setMailAddressAttributeName  ( mailAddressAttributeName ) ;   mailAddressAttributeName = null ;   conf . setDisplayNameAttributeName  ( displayNameAttributeName ) ;   displayNameAttributeName = null ;   conf . setExtraEnvVars  ( extraEnvVars ) ;   extraEnvVars = null ;  if  (  groupMembershipStrategy == null )  {   conf . setGroupMembershipStrategy  (  new FromGroupSearchLDAPGroupMembershipStrategy  ( groupMembershipFilter ) ) ;   groupMembershipFilter = null ; } else  {   conf . setGroupMembershipStrategy  ( groupMembershipStrategy ) ;   groupMembershipStrategy = null ; }   conf . setGroupSearchBase  ( groupSearchBase ) ;   groupSearchBase = null ;   conf . setGroupSearchFilter  ( groupSearchFilter ) ;   groupSearchFilter = null ;   conf . setUserSearch  ( userSearch ) ;   userSearch = null ;   conf . setUserSearchBase  ( userSearchBase ) ;   userSearchBase = null ;    this . configurations =  new  ArrayList  < >  ( ) ;   configurations . add  ( conf ) ; }  return this ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getServerUrl  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getServerUrl  ( ) : null ; }    @ Override public IdStrategy getUserIdStrategy  ( )  {  return   userIdStrategy == null ?  IdStrategy . CASE_INSENSITIVE : userIdStrategy ; }    @ Override public IdStrategy getGroupIdStrategy  ( )  {  return   groupIdStrategy == null ?  IdStrategy . CASE_INSENSITIVE : groupIdStrategy ; }   public CacheConfiguration getCache  ( )  {  return cache ; }   public Integer getCacheSize  ( )  {  return   cache == null ? null :  cache . getSize  ( ) ; }   public Integer getCacheTTL  ( )  {  return   cache == null ? null :  cache . getTtl  ( ) ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getGroupMembershipFilter  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getGroupSearchFilter  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public LDAPGroupMembershipStrategy getGroupMembershipStrategy  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getGroupMembershipStrategy  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getGroupSearchFilter  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getGroupSearchFilter  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public  Map  < String , String > getExtraEnvVars  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getExtraEnvVars  ( ) :  Collections .  < String , String > emptyMap  ( ) :  Collections . unmodifiableMap  ( extraEnvVars ) ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public  EnvironmentProperty  [ ] getEnvironmentProperties  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getEnvironmentProperties  ( ) :  new EnvironmentProperty  [ 0 ] ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getManagerPassword  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getManagerPassword  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public Secret getManagerPasswordSecret  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getManagerPasswordSecret  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getLDAPURL  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getLDAPURL  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getDisplayNameAttributeName  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getDisplayNameAttributeName  ( ) :  DescriptorImpl . DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getMailAddressAttributeName  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getMailAddressAttributeName  ( ) :  DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ; }    @ CheckForNull  @ Restricted  (  NoExternalUse . class ) public LDAPConfiguration getConfigurationFor  (  LdapUserDetails d )  {  if  (  d instanceof DelegatedLdapUserDetails )  {  return  getConfigurationFor  (   (  ( DelegatedLdapUserDetails ) d ) . getServer  ( ) ) ; } else  if  (   hasConfiguration  ( ) &&   configurations . size  ( ) == 1 )  {  return  configurations . get  ( 0 ) ; } else  {  return null ; } }    @ CheckForNull  @ Restricted  (  NoExternalUse . class ) public LDAPConfiguration getConfigurationFor  (  String server )  {  for ( LDAPConfiguration configuration : configurations )  {  if  (   configuration . getServer  ( ) . equals  ( server ) )  {  return configuration ; } }  return null ; }    @ Restricted  (  NoExternalUse . class ) public static String toProviderUrl  (  String serverUrl ,  String rootDN )  {  StringBuilder  buf =  new StringBuilder  ( ) ;  boolean  first = true ;  for ( String s :  serverUrl . split  ( "\\s+" ) )  {  if  (    s . trim  ( ) . length  ( ) == 0 )  continue ;   s =  getProviderUrl  ( s , rootDN ) ;  if  (  s != null )  {  if  ( first )   first = false ; else   buf . append  ( ' ' ) ;   buf . append  ( s ) ; } }  return  buf . toString  ( ) ; }   private static String getProviderUrl  (  String server ,  String rootDN )  {   server =  addPrefix  ( server ) ;  if  (  !  server . endsWith  ( "/" ) )  {   server =  server + '/' ; }  if  (  rootDN != null )  {   rootDN =  rootDN . trim  ( ) ;  if  (  !  rootDN . isEmpty  ( ) )  {  try  {   server =  server +   new URI  ( null , null , rootDN , null ) . toASCIIString  ( ) ; }  catch (   URISyntaxException e )  {   LOGGER . log  (  Level . WARNING ,  "Unable to build URL with rootDN: " + server , e ) ;  return null ; } } }  return server ; }    @ Override  @ Nonnull public SecurityComponents createSecurityComponents  ( )  {  LDAPAuthenticationManager  manager =  new LDAPAuthenticationManager  ( ) ;  DelegateLDAPUserDetailsService  details =  new DelegateLDAPUserDetailsService  ( ) ;  for ( LDAPConfiguration conf : configurations )  {  WebApplicationContext  appContext =  conf . createApplicationContext  ( ) ;   manager . addDelegate  (  findBean  (  AuthenticationManager . class , appContext ) ,  conf . getServer  ( ) ) ;   details . addDelegate  (  new LDAPUserDetailsService  ( appContext ,  conf . getGroupMembershipStrategy  ( ) ,  conf . getServer  ( ) ) ) ; }  return  new SecurityComponents  ( manager , details ) ; }    @ Override protected UserDetails authenticate  (  String username ,  String password )  throws AuthenticationException  {  return  updateUserDetails  (  ( UserDetails )     getSecurityComponents  ( ) . manager . authenticate  (  new UsernamePasswordAuthenticationToken  (  fixUsername  ( username ) , password ) ) . getPrincipal  ( ) ) ; }    @ Override public UserDetails loadUserByUsername  (  String username )  throws UsernameNotFoundException , DataAccessException  {  return  updateUserDetails  (    getSecurityComponents  ( ) . userDetails . loadUserByUsername  (  fixUsername  ( username ) ) ) ; }   public Authentication updateUserDetails  (  Authentication authentication )  {   updateUserDetails  (  ( UserDetails )  authentication . getPrincipal  ( ) ) ;  return authentication ; }   public UserDetails updateUserDetails  (  UserDetails userDetails )  {  if  (  userDetails instanceof LdapUserDetails )  {   updateUserDetails  (  ( LdapUserDetails ) userDetails ) ; }  return userDetails ; }   public LdapUserDetails updateUserDetails  (  LdapUserDetails d )  {    hudson . model . User  u =    hudson . model . User . get  (  fixUsername  (  d . getUsername  ( ) ) ) ;  LDAPConfiguration  configuration =  getConfigurationFor  ( d ) ;  String  displayNameAttributeName ;  String  mailAddressAttributeName ;  if  (  configuration != null )  {   displayNameAttributeName =  configuration . getDisplayNameAttributeName  ( ) ;   mailAddressAttributeName =  configuration . getMailAddressAttributeName  ( ) ;  if  (  StringUtils . isEmpty  ( displayNameAttributeName ) )  {   displayNameAttributeName =  DescriptorImpl . DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME ; }  if  (  StringUtils . isEmpty  ( mailAddressAttributeName ) )  {   mailAddressAttributeName =  DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ; } } else  {   displayNameAttributeName =  DescriptorImpl . DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME ;   mailAddressAttributeName =  DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ; }  try  {  Attribute  attribute =   d . getAttributes  ( ) . get  ( displayNameAttributeName ) ;  String  displayName =   attribute == null ? null :  ( String )  attribute . get  ( ) ;  if  (    StringUtils . isNotBlank  ( displayName ) &&   u . getId  ( ) . equals  (  u . getFullName  ( ) ) &&  !   u . getFullName  ( ) . equals  ( displayName ) )  {   u . setFullName  ( displayName ) ; } }  catch (   NamingException e )  {   LOGGER . log  (  Level . FINEST , "Could not retrieve display name attribute" , e ) ; }  if  (  ! disableMailAddressResolver )  {  try  {  Attribute  attribute =   d . getAttributes  ( ) . get  ( mailAddressAttributeName ) ;  String  mailAddress =   attribute == null ? null :  ( String )  attribute . get  ( ) ;  if  (  StringUtils . isNotBlank  ( mailAddress ) )  {  UserProperty  existing =  u . getProperty  (  UserProperty . class ) ;  if  (   existing == null ||  !  existing . hasExplicitlyConfiguredAddress  ( ) )   u . addProperty  (  new  Mailer . UserProperty  ( mailAddress ) ) ; } }  catch (   NamingException e )  {   LOGGER . log  (  Level . FINEST , "Could not retrieve email address attribute" , e ) ; }  catch (   IOException e )  {   LOGGER . log  (  Level . WARNING , "Failed to associate the e-mail address" , e ) ; } }  return d ; }    @ Override public GroupDetails loadGroupByGroupname  (  String groupname )  throws UsernameNotFoundException , DataAccessException  {   groupname =  fixGroupname  ( groupname ) ;   Set  < String >  cachedGroups ;  if  (  cache != null )  {   final  CacheEntry  <  Set  < String > >  cached ;  synchronized  ( this )  {   cached =   groupDetailsCache != null ?  groupDetailsCache . get  ( groupname ) : null ; }  if  (   cached != null &&  cached . isValid  ( ) )  {   cachedGroups =  cached . getValue  ( ) ; } else  {   cachedGroups = null ; } } else  {   cachedGroups = null ; }   final  Set  < String >  groups =   cachedGroups != null ? cachedGroups :  searchForGroupName  ( groupname ) ;  if  (    cache != null &&  cachedGroups == null &&  !  groups . isEmpty  ( ) )  {  synchronized  ( this )  {  if  (  groupDetailsCache == null )  {   groupDetailsCache =  new  CacheMap  < String ,  Set  < String > >  (  cache . getSize  ( ) ) ; }   groupDetailsCache . put  ( groupname ,  new  CacheEntry  <  Set  < String > >  (  cache . getTtl  ( ) , groups ) ) ; } }  if  (  groups . isEmpty  ( ) )  throw  new UsernameNotFoundException  ( groupname ) ;  return  new GroupDetailsImpl  (  fixGroupname  (   groups . iterator  ( ) . next  ( ) ) ) ; }   private  Set  < String > searchForGroupName  (  String groupname )  {   Set  < String >  groups =  new  TreeSet  < >  ( ) ;  for ( LDAPConfiguration conf : configurations )  {  String  searchBase =    conf . getGroupSearchBase  ( ) != null ?  conf . getGroupSearchBase  ( ) : "" ;  String  searchFilter =    conf . getGroupSearchFilter  ( ) != null ?  conf . getGroupSearchFilter  ( ) : GROUP_SEARCH ;   groups . addAll  (   conf . getLdapTemplate  ( ) . searchForSingleAttributeValues  ( searchBase , searchFilter ,  new String  [ ]  { groupname } , "cn" ) ) ; }  return groups ; }   private static String fixGroupname  (  String groupname )  {  return  FORCE_GROUPNAME_LOWERCASE ?  groupname . toLowerCase  ( ) : groupname ; }   private static String fixUsername  (  String username )  {  return  FORCE_USERNAME_LOWERCASE ?  username . toLowerCase  ( ) : username ; }   private static class GroupDetailsImpl  extends GroupDetails  {   private String  name ;   public GroupDetailsImpl  (  String name )  {    this . name = name ; }   public String getName  ( )  {  return name ; } }   private class LDAPAuthenticationManager  implements  AuthenticationManager  {   private final  List  < ManagerEntry >  delegates ;   private LDAPAuthenticationManager  ( )  {    this . delegates =  new  ArrayList  < >  ( ) ; }   private void addDelegate  (   final AuthenticationManager delegate ,   final String server )  {    this . delegates . add  (  new ManagerEntry  ( delegate , server ) ) ; }   public Authentication authenticate  (  Authentication authentication )  throws AuthenticationException  {  BadCredentialsException  lastException = null ;  for ( ManagerEntry delegate : delegates )  {  try  {  Authentication  a =   delegate . delegate . authenticate  ( authentication ) ;  return  updateUserDetails  (  new DelegatedLdapAuthentication  ( a ,  delegate . server ) ) ; }  catch (   BadCredentialsException e )  {   lastException = e ; } }  if  (  lastException != null )  {  throw lastException ; } else  {  throw  new UserMayOrMayNotExistException  ( "This is not intentional." , authentication ) ; } }   private class ManagerEntry  {   final AuthenticationManager  delegate ;   final String  server ;   public ManagerEntry  (  AuthenticationManager delegate ,  String server )  {    this . delegate = delegate ;    this . server = server ; } } }   protected static class DelegatedLdapAuthentication  implements  Authentication  {   private final Authentication  delegate ;   private final String  server ;   public DelegatedLdapAuthentication  (  Authentication delegate ,  String server )  {    this . delegate = delegate ;    this . server = server ; }    @ Override public  GrantedAuthority  [ ] getAuthorities  ( )  {  return  delegate . getAuthorities  ( ) ; }    @ Override public Object getCredentials  ( )  {  return  delegate . getCredentials  ( ) ; }    @ Override public Object getDetails  ( )  {  return  delegate . getDetails  ( ) ; }    @ Override public Object getPrincipal  ( )  {  Object  principal =  delegate . getPrincipal  ( ) ;  if  (   principal instanceof LdapUserDetails &&  !  (  principal instanceof DelegatedLdapUserDetails ) )  {  return  new DelegatedLdapUserDetails  (  ( LdapUserDetails ) principal ,  this . server ) ; } else  {  return principal ; } }    @ Override public boolean isAuthenticated  ( )  {  return  delegate . isAuthenticated  ( ) ; }    @ Override public void setAuthenticated  (  boolean isAuthenticated )  throws IllegalArgumentException  {   delegate . setAuthenticated  ( isAuthenticated ) ; }    @ Override public String getName  ( )  {  return  delegate . getName  ( ) ; }   public Authentication getDelegate  ( )  {  return delegate ; }   public String getServer  ( )  {  return server ; } }   protected static class DelegatedLdapUserDetails  implements  LdapUserDetails , Serializable  {   private static final  long  serialVersionUID = 1L ;   private final LdapUserDetails  userDetails ;   private final String  server ;   public DelegatedLdapUserDetails  (    @ Nonnull LdapUserDetails userDetails ,    @ Nonnull String server )  {    this . userDetails = userDetails ;    this . server = server ; }    @ Override public Attributes getAttributes  ( )  {  return  userDetails . getAttributes  ( ) ; }    @ Override public  Control  [ ] getControls  ( )  {  return  userDetails . getControls  ( ) ; }    @ Override public String getDn  ( )  {  return  userDetails . getDn  ( ) ; }    @ Override public  GrantedAuthority  [ ] getAuthorities  ( )  {  return  userDetails . getAuthorities  ( ) ; }    @ Override public String getPassword  ( )  {  return  userDetails . getPassword  ( ) ; }    @ Override public String getUsername  ( )  {  return  userDetails . getUsername  ( ) ; }    @ Override public boolean isAccountNonExpired  ( )  {  return  userDetails . isAccountNonExpired  ( ) ; }    @ Override public boolean isAccountNonLocked  ( )  {  return  userDetails . isAccountNonLocked  ( ) ; }    @ Override public boolean isCredentialsNonExpired  ( )  {  return  userDetails . isCredentialsNonExpired  ( ) ; }    @ Override public boolean isEnabled  ( )  {  return  userDetails . isEnabled  ( ) ; }   public LdapUserDetails getUserDetails  ( )  {  return userDetails ; }   public String getServer  ( )  {  return server ; } }   private static class DelegateLDAPUserDetailsService  implements  UserDetailsService  {   private final  List  < LDAPUserDetailsService >  delegates ;   public DelegateLDAPUserDetailsService  ( )  {   delegates =  new  ArrayList  < >  ( ) ; }   public void addDelegate  (  LDAPUserDetailsService delegate )  {   delegates . add  ( delegate ) ; }   public boolean contains  (  LDAPUserDetailsService delegate )  {  return  delegates . contains  ( delegate ) ; }    @ Override public UserDetails loadUserByUsername  (  String username )  throws UsernameNotFoundException , DataAccessException  {  UsernameNotFoundException  lastUNFE = null ;  for ( LDAPUserDetailsService delegate : delegates )  {  try  {  LdapUserDetails  userDetails =  delegate . loadUserByUsername  ( username ) ;  if  (  userDetails instanceof DelegatedLdapUserDetails )  {  return userDetails ; } else  {  return  new DelegatedLdapUserDetails  ( userDetails ,  delegate . server ) ; } }  catch (   UsernameNotFoundException e )  {   lastUNFE = e ; }  catch (   DataAccessException e )  {   LOGGER . log  (  Level . WARNING ,   "LDAP connection " +  delegate . server + " seems to be broken, will _not_ try the next configuration." , e ) ;  throw e ; } }  if  (  lastUNFE != null )  {  throw lastUNFE ; } else  {  throw  new UserMayOrMayNotExistException  ( "This is not intentional." , username ) ; } } }   public static class LDAPUserDetailsService  implements  UserDetailsService  {   public final LdapUserSearch  ldapSearch ;   public final LdapAuthoritiesPopulator  authoritiesPopulator ;   public final LDAPGroupMembershipStrategy  groupMembershipStrategy ;   public final String  server ;   private final LRUMap  attributesCache =  new LRUMap  ( 32 ) ;    @ Deprecated LDAPUserDetailsService  (  WebApplicationContext appContext )  {  this  ( appContext , null , null ) ; }    @ Deprecated LDAPUserDetailsService  (  LdapUserSearch ldapSearch ,  LdapAuthoritiesPopulator authoritiesPopulator )  {  this  ( ldapSearch , authoritiesPopulator , null , null ) ; }  LDAPUserDetailsService  (  LdapUserSearch ldapSearch ,  LdapAuthoritiesPopulator authoritiesPopulator ,  LDAPGroupMembershipStrategy groupMembershipStrategy ,  String server )  {    this . ldapSearch = ldapSearch ;    this . authoritiesPopulator = authoritiesPopulator ;    this . groupMembershipStrategy = groupMembershipStrategy ;    this . server = server ; }    @ Deprecated public LDAPUserDetailsService  (  WebApplicationContext appContext ,  LDAPGroupMembershipStrategy groupMembershipStrategy )  {  this  (  findBean  (  LdapUserSearch . class , appContext ) ,  findBean  (  LdapAuthoritiesPopulator . class , appContext ) , groupMembershipStrategy , null ) ; }   public LDAPUserDetailsService  (  WebApplicationContext appContext ,  LDAPGroupMembershipStrategy groupMembershipStrategy ,  String server )  {  this  (  findBean  (  LdapUserSearch . class , appContext ) ,  findBean  (  LdapAuthoritiesPopulator . class , appContext ) , groupMembershipStrategy , server ) ; }   public LdapUserDetails loadUserByUsername  (  String username )  throws UsernameNotFoundException , DataAccessException  {   username =  fixUsername  ( username ) ;  try  {   final Jenkins  jenkins =  Jenkins . getInstance  ( ) ;   final SecurityRealm  securityRealm =   jenkins == null ? null :  jenkins . getSecurityRealm  ( ) ;  if  (   securityRealm instanceof LDAPSecurityRealm &&  (     securityRealm . getSecurityComponents  ( ) . userDetails == this ||  (     securityRealm . getSecurityComponents  ( ) . userDetails instanceof DelegateLDAPUserDetailsService &&   (  ( DelegateLDAPUserDetailsService )   securityRealm . getSecurityComponents  ( ) . userDetails ) . contains  ( this ) ) ) )  {  LDAPSecurityRealm  ldapSecurityRealm =  ( LDAPSecurityRealm ) securityRealm ;  if  (   ldapSecurityRealm . cache != null )  {   final  CacheEntry  < LdapUserDetails >  cached ;  synchronized  ( ldapSecurityRealm )  {   cached =   (   ldapSecurityRealm . userDetailsCache != null ) ?   ldapSecurityRealm . userDetailsCache . get  ( username ) : null ; }  if  (   cached != null &&  cached . isValid  ( ) )  {  return  cached . getValue  ( ) ; } } }  LdapUserDetails  ldapUser =  ldapSearch . searchForUser  ( username ) ;  if  (  ldapUser != null )  {   LdapUserDetailsImpl . Essence  user =  new  LdapUserDetailsImpl . Essence  ( ldapUser ) ;  Attributes  v =  ldapUser . getAttributes  ( ) ;  if  (  v instanceof BasicAttributes )  {  synchronized  ( attributesCache )  {  Attributes  vv =  ( Attributes )  attributesCache . get  ( v ) ;  if  (  vv == null )   attributesCache . put  ( v ,  vv = v ) ;   user . setAttributes  ( vv ) ; } }   GrantedAuthority  [ ]  extraAuthorities =   groupMembershipStrategy == null ?  authoritiesPopulator . getGrantedAuthorities  ( ldapUser ) :  groupMembershipStrategy . getGrantedAuthorities  ( ldapUser ) ;  for ( GrantedAuthority extraAuthority : extraAuthorities )  {  if  ( FORCE_GROUPNAME_LOWERCASE )  {   user . addAuthority  (  new GrantedAuthorityImpl  (   extraAuthority . getAuthority  ( ) . toLowerCase  ( ) ) ) ; } else  {   user . addAuthority  ( extraAuthority ) ; } }   ldapUser =  new DelegatedLdapUserDetails  (  user . createUserDetails  ( ) , server ) ; }  if  (   securityRealm instanceof LDAPSecurityRealm &&  (     securityRealm . getSecurityComponents  ( ) . userDetails == this ||  (     securityRealm . getSecurityComponents  ( ) . userDetails instanceof DelegateLDAPUserDetailsService &&   (  ( DelegateLDAPUserDetailsService )   securityRealm . getSecurityComponents  ( ) . userDetails ) . contains  ( this ) ) ) )  {  LDAPSecurityRealm  ldapSecurityRealm =  ( LDAPSecurityRealm ) securityRealm ;  if  (   ldapSecurityRealm . cache != null )  {  synchronized  ( ldapSecurityRealm )  {  if  (   ldapSecurityRealm . userDetailsCache == null )  {    ldapSecurityRealm . userDetailsCache =  new  CacheMap  < String , LdapUserDetails >  (   ldapSecurityRealm . cache . getSize  ( ) ) ; }    ldapSecurityRealm . userDetailsCache . put  ( username ,  new  CacheEntry  < LdapUserDetails >  (   ldapSecurityRealm . cache . getTtl  ( ) ,  ldapSecurityRealm . updateUserDetails  ( ldapUser ) ) ) ; } } }  return ldapUser ; }  catch (   LdapDataAccessException e )  {   LOGGER . log  (  Level . WARNING ,  "Failed to search LDAP for username=" + username , e ) ;  throw  new UserMayOrMayNotExistException  (  e . getMessage  ( ) , e ) ; }  catch (   UsernameNotFoundException x )  {  throw x ; }  catch (   DataAccessException x )  {  throw x ; }  catch (   RuntimeException x )  {  throw  new LdapDataAccessException  (    "Failed to search LDAP for " + username + ": " + x , x ) ; } } }    @ Extension public static final class MailAdressResolverImpl  extends MailAddressResolver  {   public String findMailAddressFor  (  User u )  {   final Jenkins  jenkins =  Jenkins . getInstance  ( ) ;  if  (  jenkins == null )  {  return null ; }  SecurityRealm  realm =  jenkins . getSecurityRealm  ( ) ;  if  (  !  (  realm instanceof LDAPSecurityRealm ) )  {  return null ; }  if  (   (  ( LDAPSecurityRealm ) realm ) . disableMailAddressResolver )  {   LOGGER . info  ( "LDAPSecurityRealm MailAddressResolver is disabled" ) ;  return null ; }  try  {  LdapUserDetails  details =  ( LdapUserDetails )    realm . getSecurityComponents  ( ) . userDetails . loadUserByUsername  (  u . getId  ( ) ) ;   final LDAPConfiguration  configuration =   (  ( LDAPSecurityRealm ) realm ) . getConfigurationFor  ( details ) ;  String  attr ;  if  (  configuration != null )  {   attr =  configuration . getMailAddressAttributeName  ( ) ;  if  (  StringUtils . isEmpty  ( attr ) )  {   attr =  DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ; } } else  {   attr =  DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ; }  Attribute  mail =   details . getAttributes  ( ) . get  ( attr ) ;  if  (  mail == null )  return null ;  return  ( String )  mail . get  ( ) ; }  catch (   DataAccessException | NamingException | AcegiSecurityException e )  {   LOGGER . log  (  Level . FINE , "Failed to look up LDAP for e-mail address" , e ) ;  return null ; } } }   public static final class AuthoritiesPopulatorImpl  extends DefaultLdapAuthoritiesPopulator  {  String  rolePrefix = "ROLE_" ;  boolean  convertToUpperCase = true ;   public AuthoritiesPopulatorImpl  (  InitialDirContextFactory initialDirContextFactory ,  String groupSearchBase )  {  super  ( initialDirContextFactory ,  fixNull  ( groupSearchBase ) ) ;   super . setRolePrefix  ( "" ) ;   super . setConvertToUpperCase  ( false ) ; }    @ Override public Set getAdditionalRoles  (  LdapUserDetails ldapUser )  {  return  Collections . singleton  ( AUTHENTICATED_AUTHORITY ) ; }    @ Override public void setRolePrefix  (  String rolePrefix )  {    this . rolePrefix = rolePrefix ; }    @ Override public void setConvertToUpperCase  (  boolean convertToUpperCase )  {    this . convertToUpperCase = convertToUpperCase ; }    @ Override public Set getGroupMembershipRoles  (  String userDn ,  String username )  {   Set  < GrantedAuthority >  names =  super . getGroupMembershipRoles  ( userDn , username ) ;   Set  < GrantedAuthority >  r =  new  HashSet  < GrantedAuthority >  (   names . size  ( ) * 2 ) ;   r . addAll  ( names ) ;  if  (  isGeneratingPrefixRoles  ( ) )  {  for ( GrantedAuthority ga : names )  {  String  role =  ga . getAuthority  ( ) ;  if  ( convertToUpperCase )   role =  role . toUpperCase  ( ) ;   r . add  (  new GrantedAuthorityImpl  (  rolePrefix + role ) ) ; } }  return r ; }   private GrantedAuthority  defaultRole = null ;   public boolean isGeneratingPrefixRoles  ( )  {  return   StringUtils . isNotBlank  ( rolePrefix ) || convertToUpperCase ; }   public boolean isConvertToUpperCase  ( )  {  return convertToUpperCase ; }   public String getRolePrefix  ( )  {  return rolePrefix ; }   public GrantedAuthority getDefaultRole  ( )  {  return defaultRole ; }   public void setDefaultRole  (  String defaultRole )  {   super . setDefaultRole  ( defaultRole ) ;    this . defaultRole =  new GrantedAuthorityImpl  ( defaultRole ) ; } }    @ Extension public static final class DescriptorImpl  extends  Descriptor  < SecurityRealm >  {   public static final String  DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME = "displayname" ;   public static final String  DEFAULT_MAILADDRESS_ATTRIBUTE_NAME = "mail" ;   public static final String  DEFAULT_USER_SEARCH = "uid={0}" ;   public String getDisplayName  ( )  {  return  Messages . LDAPSecurityRealm_DisplayName  ( ) ; }   public IdStrategy getDefaultIdStrategy  ( )  {  return  IdStrategy . CASE_INSENSITIVE ; }    @ Override public SecurityRealm newInstance  (  StaplerRequest req ,  JSONObject formData )  throws FormException  {  if  (  !  formData . has  ( "configurations" ) )  {  throw  new  Descriptor . FormException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AtLeastOne  ( ) , "configurations" ) ; } else  {   final Object  configurations =  formData . get  ( "configurations" ) ;  if  (   configurations instanceof JSONArray &&   (  ( JSONArray ) configurations ) . isEmpty  ( ) )  {  throw  new  Descriptor . FormException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AtLeastOne  ( ) , "configurations" ) ; } else  if  (  !  (  configurations instanceof JSONObject ) )  {  throw  new  Descriptor . FormException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AtLeastOne  ( ) , "configurations" ) ; } else  if  (   (  ( JSONObject ) configurations ) . isNullObject  ( ) )  {  throw  new  Descriptor . FormException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AtLeastOne  ( ) , "configurations" ) ; } }  return  super . newInstance  ( req , formData ) ; }    @ RequirePOST public FormValidation doValidate  (  StaplerRequest req )  throws Exception  {  if  (  !   Jenkins . getActiveInstance  ( ) . hasPermission  (  Jenkins . ADMINISTER ) )  {  return  FormValidation . ok  ( ) ; }  JSONObject  json =  JSONObject . fromObject  (  IOUtils . toString  (  req . getInputStream  ( ) ) ) ;  String  user =  json . getString  ( "testUser" ) ;  String  password =  json . getString  ( "testPassword" ) ;  JSONObject  realmCfg =   json . getJSONObject  ( "useSecurity" ) . getJSONObject  ( "realm" ) ;  LDAPSecurityRealm  realm =  req . bindJSON  (  LDAPSecurityRealm . class , realmCfg ) ;  return  validate  ( realm , user , password ) ; }   private void rsp  (  StringBuilder response ,  String kind ,  String testId ,  String message ,  Object ...  extras )  {     response . append  ( "<div class='" ) . append  ( kind ) . append  ( "' data-test='" ) ;   response . append  (  Util . escape  ( testId ) ) ;   response . append  ( "'>" ) ;   response . append  ( message ) ;  boolean  needBr = true ;  for ( Object extra : extras )  {  if  (  extra instanceof String )  {  if  ( needBr )  {   response . append  ( "<br/>" ) ; }   response . append  ( extra ) ;   needBr = true ; } else  if  (  extra instanceof Collection )  {   response . append  ( "<ul>" ) ;  for ( String item :  (  Collection  < String > ) extra )  {   response . append  ( "<li>" ) ;   response . append  ( item ) ;   response . append  ( "</li>" ) ; }   response . append  ( "</ul>" ) ;   needBr = false ; } }   response . append  ( "</div>" ) ; }   private void ok  (  StringBuilder response ,  String testId ,  String message ,  Object ...  extras )  {   rsp  ( response , "validation-ok" , testId , message , extras ) ; }   private void warning  (  StringBuilder response ,  String testId ,  String message ,  Object ...  extras )  {   rsp  ( response , "warning" , testId , message , extras ) ; }   private void error  (  StringBuilder response ,  String testId ,  String message ,  Object ...  extras )  {   rsp  ( response , "error" , testId , message , extras ) ; }   public FormValidation validate  (  LDAPSecurityRealm realm ,  String user ,  String password )  {  FormValidation  connnectionCheck =  doCheckServer  (  realm . getServerUrl  ( ) ,  realm . managerDN ,  realm . managerPasswordSecret ) ;  if  (   connnectionCheck . kind !=   FormValidation . Kind . OK )  {  return connnectionCheck ; }  StringBuilder  response =  new StringBuilder  ( 1024 ) ;     response . append  ( "<div>" ) . append  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_LoginHeader  ( ) ) . append  ( "</div>" ) ;  boolean  potentialLockout = false ;  LdapUserDetails  loginDetails = null ;  try  {   loginDetails =  ( LdapUserDetails )     realm . getSecurityComponents  ( ) . manager . authenticate  (  new UsernamePasswordAuthenticationToken  (  fixUsername  ( user ) , password ) ) . getPrincipal  ( ) ;   ok  ( response , "authentication" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AuthenticationSuccessful  ( ) ) ; }  catch (   AuthenticationException e )  {  if  (  StringUtils . isBlank  ( password ) )  {   warning  ( response , "authentication" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AuthenticationFailedEmptyPass  ( user ) ) ; } else  {   error  ( response , "authentication" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AuthenticationFailed  ( user ) ) ;   potentialLockout = true ; } }   Set  < String >  loginAuthorities =  new  HashSet  < >  ( ) ;  if  (  loginDetails != null )  {   ok  ( response , "authentication-username" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserId  (  Util . escape  (  loginDetails . getUsername  ( ) ) ) ) ;   ok  ( response , "authentication-dn" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserDn  (  Util . escape  (  loginDetails . getDn  ( ) ) ) ) ;   validateDisplayName  ( realm , response , loginDetails , "authentication-displayname" ) ;  if  (  !  realm . disableMailAddressResolver )  {   validateEmailAddress  ( realm , response , loginDetails , "authentication-email" ) ; }  for ( GrantedAuthority a :  loginDetails . getAuthorities  ( ) )  {   loginAuthorities . add  (  a . getAuthority  ( ) ) ; }  if  (    loginDetails . getAuthorities  ( ) . length < 1 )  {   error  ( response , "authentication-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_NoGroupMembership  ( ) ) ; } else  if  (    loginDetails . getAuthorities  ( ) . length == 1 )  {   warning  ( response , "authentication-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_BasicGroupMembership  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_BasicGroupMembershipDetail  ( ) ) ; } else  {   List  < String >  authorities =  new  ArrayList  < >  ( ) ;  for ( GrantedAuthority a :  loginDetails . getAuthorities  ( ) )  {  if  (  AUTHENTICATED_AUTHORITY . equals  ( a ) )  {  continue ; }   authorities . add  (   "<code>" +  Util . escape  (  a . getAuthority  ( ) ) + "</code>" ) ; }   ok  ( response , "authentication-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupMembership  ( ) , authorities ) ; } }     response . append  ( "<div>" ) . append  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_LookupHeader  ( ) ) . append  ( "</div>" ) ;  LdapUserDetails  lookUpDetails = null ;  try  {   lookUpDetails =  ( LdapUserDetails )    realm . getSecurityComponents  ( ) . userDetails . loadUserByUsername  (  fixUsername  ( user ) ) ;   ok  ( response , "lookup" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupSuccessful  ( ) ) ; }  catch (   UserMayOrMayNotExistException e1 )  {   rsp  ( response ,   loginDetails == null ? "warning" : "error" , "lookup" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupInconclusive  ( user ) ,   StringUtils . isBlank  (  realm . managerDN ) ?      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnRequired  ( ) :      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnPermissions  ( ) ) ; }  catch (   UsernameNotFoundException e1 )  {   rsp  ( response ,   loginDetails == null ? "warning" : "error" , "lookup" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupDoesNotExist  ( user ) ,   StringUtils . isBlank  (  realm . managerDN ) ?      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnRequired  ( ) :      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnPermissions  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupSettingsCorrect  ( ) ) ; }  catch (   LdapDataAccessException e )  {  Throwable  cause =  e . getCause  ( ) ;  while  (   cause != null &&  !  (  cause instanceof BadCredentialsException ) )  {   cause =  cause . getCause  ( ) ; }  if  (  cause != null )  {   error  ( response , "lookup" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupBadCredentials  ( ) ,   StringUtils . isBlank  (  realm . managerDN ) ?      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnCorrect  ( ) :      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnPermissions  ( ) ) ;   potentialLockout = true ; } else  {   error  ( response , "lookup" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupFailed  ( user ) ,  Util . escape  (  e . getLocalizedMessage  ( ) ) ) ;   potentialLockout = true ; } }  if  (   loginDetails == null &&  lookUpDetails != null )  {   ok  ( response , "lookup-username" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserId  (  Util . escape  (  lookUpDetails . getUsername  ( ) ) ) ) ;   ok  ( response , "lookup-dn" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserDn  (  Util . escape  (  lookUpDetails . getDn  ( ) ) ) ) ;   validateDisplayName  ( realm , response , lookUpDetails , "lookup-displayname" ) ;  if  (  !  realm . disableMailAddressResolver )  {   validateEmailAddress  ( realm , response , lookUpDetails , "lookup-email" ) ; } }   Set  < String >  lookupAuthorities =  new  HashSet  < >  ( ) ;  if  (  lookUpDetails != null )  {  for ( GrantedAuthority a :  lookUpDetails . getAuthorities  ( ) )  {   lookupAuthorities . add  (  a . getAuthority  ( ) ) ; }  if  (   loginDetails == null ||  !  loginAuthorities . equals  ( lookupAuthorities ) )  {  if  (    lookUpDetails . getAuthorities  ( ) . length < 1 )  {   error  ( response , "lookup-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_NoGroupMembership  ( ) ) ; } else  if  (    lookUpDetails . getAuthorities  ( ) . length == 1 )  {   warning  ( response , "lookup-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_BasicGroupMembership  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_BasicGroupMembershipDetail  ( ) ) ; } else  {   List  < String >  authorities =  new  ArrayList  < >  ( ) ;  for ( GrantedAuthority a :  lookUpDetails . getAuthorities  ( ) )  {  if  (  AUTHENTICATED_AUTHORITY . equals  ( a ) )  {  continue ; }   authorities . add  (   "<code>" +  Util . escape  (  a . getAuthority  ( ) ) + "</code>" ) ; }   ok  ( response , "lookup-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupMembership  ( ) , authorities ) ; } } }  if  (   loginDetails != null &&  lookUpDetails != null )  {  if  (  !  StringUtils . equals  (  loginDetails . getUsername  ( ) ,  lookUpDetails . getUsername  ( ) ) )  {   error  ( response , "consistency-username" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UsernameMismatch  (  loginDetails . getUsername  ( ) ,  lookUpDetails . getUsername  ( ) ) ) ;   potentialLockout = true ; }  if  (  !  StringUtils . equals  (  loginDetails . getDn  ( ) ,  lookUpDetails . getDn  ( ) ) )  {   error  ( response , "consistency-dn" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_DnMismatch  (  loginDetails . getDn  ( ) ,  lookUpDetails . getDn  ( ) ) ) ;   potentialLockout = true ; }  if  (  StringUtils . isNotBlank  (  realm . getDisplayNameAttributeName  ( ) ) )  {  Attribute  loginAttr =   loginDetails . getAttributes  ( ) . get  (  realm . getDisplayNameAttributeName  ( ) ) ;  Object  loginValue ;  try  {   loginValue =   loginAttr == null ? null :  loginAttr . get  ( ) ; }  catch (   NamingException e )  {   loginValue =  e . getClass  ( ) ; }  Attribute  lookUpAttr =   lookUpDetails . getAttributes  ( ) . get  (  realm . getDisplayNameAttributeName  ( ) ) ;  Object  lookUpValue ;  try  {   lookUpValue =   lookUpAttr == null ? null :  lookUpAttr . get  ( ) ; }  catch (   NamingException e )  {   lookUpValue =  e . getClass  ( ) ; }  if  (   loginValue == null ?  lookUpValue != null :  !  loginValue . equals  ( lookUpValue ) )  {   error  ( response , "consistency-displayname" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_DisplayNameMismatch  ( loginValue , lookUpValue ) ) ;   potentialLockout = true ; } }  if  (   !  realm . disableMailAddressResolver &&  StringUtils . isNotBlank  (  realm . getMailAddressAttributeName  ( ) ) )  {  Attribute  loginAttr =   loginDetails . getAttributes  ( ) . get  (  realm . getMailAddressAttributeName  ( ) ) ;  Object  loginValue ;  try  {   loginValue =   loginAttr == null ? null :  loginAttr . get  ( ) ; }  catch (   NamingException e )  {   loginValue =  e . getClass  ( ) ; }  Attribute  lookUpAttr =   lookUpDetails . getAttributes  ( ) . get  (  realm . getMailAddressAttributeName  ( ) ) ;  Object  lookUpValue ;  try  {   lookUpValue =   lookUpAttr == null ? null :  lookUpAttr . get  ( ) ; }  catch (   NamingException e )  {   lookUpValue =  e . getClass  ( ) ; }  if  (   loginValue == null ?  lookUpValue != null :  !  loginValue . equals  ( lookUpValue ) )  {   error  ( response , "consistency-email" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_EmailAddressMismatch  ( loginValue , lookUpValue ) ) ;   potentialLockout = true ; } }  if  (  loginAuthorities . equals  ( lookupAuthorities ) )  {   ok  ( response , "consistency" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupMembershipMatch  ( ) ) ; } else  {   error  ( response , "consistency" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupMembershipMismatch  ( ) ) ;   potentialLockout = true ; } }   Set  < String >  groups =  new  HashSet  < >  ( loginAuthorities ) ;   Set  < String >  badGroups =  new  TreeSet  < >  ( ) ;   groups . addAll  ( lookupAuthorities ) ;   groups . remove  (  AUTHENTICATED_AUTHORITY . getAuthority  ( ) ) ;  for ( String group : groups )  {  try  {   realm . loadGroupByGroupname  ( group ) ; }  catch (   UsernameNotFoundException e )  {   badGroups . add  ( group ) ; } }  if  (  groups . isEmpty  ( ) )  {   warning  ( response , "resolve-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupNotPossible  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupNotPossibleDetail  ( ) ) ; } else  if  (  badGroups . isEmpty  ( ) )  {   ok  ( response , "resolve-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupSuccessful  (  groups . size  ( ) ) ) ; } else  {   List  < String >  escaped =  new  ArrayList  < >  (  badGroups . size  ( ) ) ;  for ( String group : badGroups )  {   escaped . add  (   "<code>" +  Util . escape  ( group ) + "</code>" ) ; }   warning  ( response , "resolve-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupFailed  (  badGroups . size  ( ) ) , escaped ,   StringUtils . isBlank  (  realm . managerDN ) ?      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupManagerDnRequired  ( ) :      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupManagerDnPermissions  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupSettingsCorrect  ( ) ) ; }  if  ( potentialLockout )  {     response . append  ( "<div>" ) . append  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_LockoutHeader  ( ) ) . append  ( "</div>" ) ;   error  ( response , "lockout" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_PotentialLockout  ( user ) ) ; }  return  FormValidation . okWithMarkup  (  response . toString  ( ) ) ; }   private void validateEmailAddress  (  LDAPSecurityRealm realm ,  StringBuilder response ,  LdapUserDetails details ,  String testId )  {  Attribute  attribute =   details . getAttributes  ( ) . get  (  realm . getMailAddressAttributeName  ( ) ) ;  if  (  attribute == null )  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   warning  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_NoEmailAddress  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  realm . getMailAddressAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } else  {  try  {  String  mailAddress =  ( String )  attribute . get  ( ) ;  if  (  StringUtils . isNotBlank  ( mailAddress ) )  {   ok  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserEmail  (  Util . escape  ( mailAddress ) ) ) ; } else  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   warning  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_EmptyEmailAddress  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  realm . getMailAddressAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } }  catch (   NamingException e )  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   error  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_CouldNotRetrieveEmailAddress  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  realm . getMailAddressAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } } }   private void validateDisplayName  (  LDAPSecurityRealm realm ,  StringBuilder response ,  LdapUserDetails details ,  String testId )  {  Attribute  attribute =   details . getAttributes  ( ) . get  (  realm . getDisplayNameAttributeName  ( ) ) ;  if  (  attribute == null )  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   warning  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_NoDisplayName  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  realm . getDisplayNameAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } else  {  try  {  String  displayName =  ( String )  attribute . get  ( ) ;  if  (  displayName != null )  {   ok  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserDisplayName  (  Util . escape  ( displayName ) ) ) ; } else  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   warning  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_EmptyDisplayName  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  realm . getDisplayNameAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } }  catch (   NamingException e )  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   error  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_CouldNotRetrieveDisplayName  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  realm . getDisplayNameAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } } } }   private static String addPrefix  (  String server )  {  if  (  server . contains  ( "://" ) )  return server ; else  return  "ldap://" + server ; }    @ Restricted  (  NoExternalUse . class ) public static final Logger  LOGGER =  Logger . getLogger  (   LDAPSecurityRealm . class . getName  ( ) ) ;   public static final String  GROUP_SEARCH =  System . getProperty  (    LDAPSecurityRealm . class . getName  ( ) + ".groupSearch" , "(& (cn={0}) (| (objectclass=groupOfNames) (objectclass=groupOfUniqueNames) (objectclass=posixGroup)))" ) ;   public static class CacheConfiguration  extends  AbstractDescribableImpl  < CacheConfiguration >  {   private final  int  size ;   private final  int  ttl ;    @ DataBoundConstructor public CacheConfiguration  (   int size ,   int ttl )  {    this . size =  Math . max  ( 10 ,  Math . min  ( size , 1000 ) ) ;    this . ttl =  Math . max  ( 30 ,  Math . min  ( ttl , 3600 ) ) ; }   public  int getSize  ( )  {  return size ; }   public  int getTtl  ( )  {  return ttl ; }    @ Extension public static class DescriptorImpl  extends  Descriptor  < CacheConfiguration >  {    @ Override public String getDisplayName  ( )  {  return "" ; }   public ListBoxModel doFillSizeItems  ( )  {  ListBoxModel  m =  new ListBoxModel  ( ) ;   m . add  ( "10" ) ;   m . add  ( "20" ) ;   m . add  ( "50" ) ;   m . add  ( "100" ) ;   m . add  ( "200" ) ;   m . add  ( "500" ) ;   m . add  ( "1000" ) ;  return m ; }   public ListBoxModel doFillTtlItems  ( )  {  ListBoxModel  m =  new ListBoxModel  ( ) ;  for (  int ttl :  new  int  [ ]  { 30 , 60 , 120 , 300 , 600 , 900 , 1800 , 3600 } )  {   m . add  (  Util . getTimeSpanString  (  ttl * 1000L ) ,  Integer . toString  ( ttl ) ) ; }  return m ; } } }   private static class CacheEntry  <  T >  {   private final  long  expires ;   private final T  value ;   public CacheEntry  (   int ttlSeconds ,  T value )  {    this . expires =   System . currentTimeMillis  ( ) +   TimeUnit . SECONDS . toMillis  ( ttlSeconds ) ;    this . value = value ; }   public T getValue  ( )  {  return value ; }   public boolean isValid  ( )  {  return   System . currentTimeMillis  ( ) < expires ; } }   private static class CacheMap  <  K ,  V >  extends  LinkedHashMap  < K ,  CacheEntry  < V > >  {   private final  int  cacheSize ;   public CacheMap  (   int cacheSize )  {  super  (  cacheSize + 1 ) ;    this . cacheSize = cacheSize ; }    @ Override protected boolean removeEldestEntry  (    Map . Entry  < K ,  CacheEntry  < V > > eldest )  {  return     size  ( ) > cacheSize ||   eldest . getValue  ( ) == null ||  !   eldest . getValue  ( ) . isValid  ( ) ; } }   public static class EnvironmentProperty  extends  AbstractDescribableImpl  < EnvironmentProperty >  implements  Serializable  {   private final String  name ;   private final String  value ;    @ DataBoundConstructor public EnvironmentProperty  (  String name ,  String value )  {    this . name = name ;    this . value = value ; }   public String getName  ( )  {  return name ; }   public String getValue  ( )  {  return value ; }   public static  Map  < String , String > toMap  (   List  < EnvironmentProperty > properties )  {  if  (  properties != null )  {   final  Map  < String , String >  result =  new  LinkedHashMap  < String , String >  ( ) ;  for ( EnvironmentProperty property : properties )  {   result . put  (  property . getName  ( ) ,  property . getValue  ( ) ) ; }  return result ; }  return null ; }    @ Extension public static class DescriptorImpl  extends  Descriptor  < EnvironmentProperty >  {    @ Override public String getDisplayName  ( )  {  return "" ; } } }   private boolean  disableRolePrefixing ;   public boolean isDisableRolePrefixing  ( )  {  return disableRolePrefixing ; }    @ DataBoundSetter public void setDisableRolePrefixing  (  boolean disableRolePrefixing )  {    this . disableRolePrefixing = disableRolePrefixing ; }    @ Override public DescriptorImpl getDescriptor  ( )  {  return  ( DescriptorImpl )  super . getDescriptor  ( ) ; }   public static final class LdapAuthenticationProviderImpl  extends LdapAuthenticationProvider  {   public LdapAuthenticationProviderImpl  (  LdapAuthenticator authenticator ,  LdapAuthoritiesPopulator authoritiesPopulator ,  LDAPGroupMembershipStrategy groupMembershipStrategy )  {  super  ( authenticator ,   groupMembershipStrategy != null ?  new WrappedAuthoritiesPopulator  ( groupMembershipStrategy , authoritiesPopulator ) : authoritiesPopulator ) ; } }   private static final class WrappedAuthoritiesPopulator  implements  LdapAuthoritiesPopulator  {   private final LDAPGroupMembershipStrategy  strategy ;   private final LdapAuthoritiesPopulator  populator ;   private WrappedAuthoritiesPopulator  (  LDAPGroupMembershipStrategy strategy ,  LdapAuthoritiesPopulator populator )  {    this . strategy = strategy ;    this . populator = populator ;   strategy . setAuthoritiesPopulator  ( populator ) ; }    @ Override public  GrantedAuthority  [ ] getGrantedAuthorities  (  LdapUserDetails userDetails )  throws LdapDataAccessException  {  if  (   strategy . getAuthoritiesPopulator  ( ) != populator )  {   strategy . setAuthoritiesPopulator  ( populator ) ; }  return  strategy . getGrantedAuthorities  ( userDetails ) ; } } }