  package  hudson . security ;   import      edu . umd . cs . findbugs . annotations . SuppressFBWarnings ;  import  hudson . Extension ;  import  hudson . Main ;  import  hudson . Util ;  import   hudson . model . AbstractDescribableImpl ;  import   hudson . model . Descriptor ;  import   hudson . model . User ;  import   hudson . tasks . MailAddressResolver ;  import   hudson . tasks . Mailer ;  import    hudson . tasks . Mailer . UserProperty ;  import   hudson . util . FormValidation ;  import   hudson . util . ListBoxModel ;  import   hudson . util . Scrambler ;  import   hudson . util . Secret ;  import   jenkins . model . IdStrategy ;  import   jenkins . model . Jenkins ;  import     jenkins . security . plugins . ldap . FromGroupSearchLDAPGroupMembershipStrategy ;  import     jenkins . security . plugins . ldap . LDAPConfiguration ;  import     jenkins . security . plugins . ldap . LDAPGroupMembershipStrategy ;  import    net . sf . json . JSONArray ;  import    net . sf . json . JSONObject ;  import   org . acegisecurity . AcegiSecurityException ;  import   org . acegisecurity . Authentication ;  import   org . acegisecurity . AuthenticationException ;  import   org . acegisecurity . AuthenticationManager ;  import   org . acegisecurity . AuthenticationServiceException ;  import   org . acegisecurity . BadCredentialsException ;  import   org . acegisecurity . GrantedAuthority ;  import   org . acegisecurity . GrantedAuthorityImpl ;  import    org . acegisecurity . ldap . InitialDirContextFactory ;  import    org . acegisecurity . ldap . LdapDataAccessException ;  import    org . acegisecurity . ldap . LdapUserSearch ;  import     org . acegisecurity . ldap . search . FilterBasedLdapUserSearch ;  import    org . acegisecurity . providers . UsernamePasswordAuthenticationToken ;  import     org . acegisecurity . providers . ldap . LdapAuthenticationProvider ;  import     org . acegisecurity . providers . ldap . LdapAuthenticator ;  import     org . acegisecurity . providers . ldap . LdapAuthoritiesPopulator ;  import      org . acegisecurity . providers . ldap . populator . DefaultLdapAuthoritiesPopulator ;  import    org . acegisecurity . userdetails . UserDetails ;  import    org . acegisecurity . userdetails . UserDetailsService ;  import    org . acegisecurity . userdetails . UsernameNotFoundException ;  import     org . acegisecurity . userdetails . ldap . LdapUserDetails ;  import     org . acegisecurity . userdetails . ldap . LdapUserDetailsImpl ;  import      org . apache . commons . collections . map . LRUMap ;  import     org . apache . commons . io . IOUtils ;  import     org . apache . commons . lang . StringUtils ;  import    org . kohsuke . accmod . Restricted ;  import     org . kohsuke . accmod . restrictions . DoNotUse ;  import     org . kohsuke . accmod . restrictions . NoExternalUse ;  import    org . kohsuke . stapler . DataBoundConstructor ;  import    org . kohsuke . stapler . DataBoundSetter ;  import    org . kohsuke . stapler . StaplerRequest ;  import     org . kohsuke . stapler . interceptor . RequirePOST ;  import    org . springframework . dao . DataAccessException ;  import     org . springframework . web . context . WebApplicationContext ;  import   javax . annotation . CheckForNull ;  import   javax . annotation . Nonnull ;  import   javax . naming . NamingException ;  import    javax . naming . directory . Attribute ;  import    javax . naming . directory . Attributes ;  import    javax . naming . directory . BasicAttributes ;  import    javax . naming . ldap . Control ;  import   java . io . IOException ;  import   java . io . Serializable ;  import   java . net . URI ;  import   java . net . URISyntaxException ;  import   java . util . ArrayList ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . HashSet ;  import   java . util . LinkedHashMap ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Set ;  import   java . util . TreeSet ;  import    java . util . concurrent . TimeUnit ;  import    java . util . logging . Level ;  import    java . util . logging . Logger ;  import static   hudson . Util . fixNull ;  import     jenkins . security . plugins . ldap . LDAPExtendedTemplate ;  import    org . acegisecurity . ldap . LdapEntryMapper ;  import    javax . naming . ldap . LdapName ;   public class LDAPSecurityRealm  extends AbstractPasswordBasedSecurityRealm  {   private static final boolean  FORCE_USERNAME_LOWERCASE =  Boolean . getBoolean  (    LDAPSecurityRealm . class . getName  ( ) + ".forceUsernameLowercase" ) ;   private static final boolean  FORCE_GROUPNAME_LOWERCASE =  Boolean . getBoolean  (    LDAPSecurityRealm . class . getName  ( ) + ".forceGroupnameLowercase" ) ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  server ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  rootDN ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient boolean  inhibitInferRootDN ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  userSearchBase ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  userSearch ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  groupSearchBase ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  groupSearchFilter ;    @ Deprecated  @ Restricted  (  NoExternalUse . class )  @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" ) public transient String  groupMembershipFilter ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient LDAPGroupMembershipStrategy  groupMembershipStrategy ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" )  @ Deprecated  @ Restricted  (  NoExternalUse . class ) public transient String  managerDN ;    @ Deprecated  @ Restricted  (  NoExternalUse . class )  @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" ) private transient String  managerPassword ;    @ Deprecated  @ Restricted  (  NoExternalUse . class ) private transient Secret  managerPasswordSecret ;    @ SuppressFBWarnings  (  value = "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD" ,  justification = "This public field is exposed to the plugin's API" ) public final boolean  disableMailAddressResolver ;   private  List  < LDAPConfiguration >  configurations ;   private final CacheConfiguration  cache ;   private transient  Map  < String ,  CacheEntry  < LdapUserDetails > >  userDetailsCache = null ;   private transient  Map  < String ,  CacheEntry  < GroupDetailsImpl > >  groupDetailsCache = null ;    @ Deprecated  @ Restricted  (  NoExternalUse . class ) private transient  Map  < String , String >  extraEnvVars ;    @ Deprecated  @ Restricted  (  NoExternalUse . class ) private transient String  displayNameAttributeName ;    @ Deprecated  @ Restricted  (  NoExternalUse . class ) private transient String  mailAddressAttributeName ;   private final IdStrategy  userIdStrategy ;   private final IdStrategy  groupIdStrategy ;   private boolean  disableRolePrefixing ;    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , managerDN , managerPassword , inhibitInferRootDN , false ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , managerDN , managerPassword , inhibitInferRootDN , disableMailAddressResolver , null ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , null , null , managerDN , managerPassword , inhibitInferRootDN , disableMailAddressResolver , cache ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  String groupMembershipFilter ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter , groupMembershipFilter , managerDN , managerPassword , inhibitInferRootDN , disableMailAddressResolver , cache , null ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  String groupMembershipFilter ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,   EnvironmentProperty  [ ] environmentProperties )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter , groupMembershipFilter , managerDN , managerPassword , inhibitInferRootDN , disableMailAddressResolver , cache , environmentProperties , null , null ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  String groupMembershipFilter ,  String managerDN ,  String managerPassword ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,   EnvironmentProperty  [ ] environmentProperties ,  String displayNameAttributeName ,  String mailAddressAttributeName )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter , groupMembershipFilter , managerDN ,  Secret . fromString  ( managerPassword ) , inhibitInferRootDN , disableMailAddressResolver , cache , environmentProperties , null , null ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  String groupMembershipFilter ,  String managerDN ,  Secret managerPasswordSecret ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,   EnvironmentProperty  [ ] environmentProperties ,  String displayNameAttributeName ,  String mailAddressAttributeName )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter ,  new FromGroupSearchLDAPGroupMembershipStrategy  ( groupMembershipFilter ) , managerDN , managerPasswordSecret , inhibitInferRootDN , disableMailAddressResolver , cache , environmentProperties , displayNameAttributeName , mailAddressAttributeName ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  LDAPGroupMembershipStrategy groupMembershipStrategy ,  String managerDN ,  Secret managerPasswordSecret ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,   EnvironmentProperty  [ ] environmentProperties ,  String displayNameAttributeName ,  String mailAddressAttributeName )  {  this  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter , groupMembershipStrategy , managerDN , managerPasswordSecret , inhibitInferRootDN , disableMailAddressResolver , cache , environmentProperties , displayNameAttributeName , mailAddressAttributeName ,  IdStrategy . CASE_INSENSITIVE ,  IdStrategy . CASE_INSENSITIVE ) ; }    @ Deprecated public LDAPSecurityRealm  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  LDAPGroupMembershipStrategy groupMembershipStrategy ,  String managerDN ,  Secret managerPasswordSecret ,  boolean inhibitInferRootDN ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,   EnvironmentProperty  [ ] environmentProperties ,  String displayNameAttributeName ,  String mailAddressAttributeName ,  IdStrategy userIdStrategy ,  IdStrategy groupIdStrategy )  {  this  (  createLdapConfiguration  ( server , rootDN , userSearchBase , userSearch , groupSearchBase , groupSearchFilter , groupMembershipStrategy , managerDN , managerPasswordSecret , inhibitInferRootDN , environmentProperties , displayNameAttributeName , mailAddressAttributeName ) , disableMailAddressResolver , cache , userIdStrategy , groupIdStrategy ) ; }    @ DataBoundConstructor public LDAPSecurityRealm  (   List  < LDAPConfiguration > configurations ,  boolean disableMailAddressResolver ,  CacheConfiguration cache ,  IdStrategy userIdStrategy ,  IdStrategy groupIdStrategy )  {  if  (   configurations == null ||  configurations . isEmpty  ( ) )  {  throw  new IllegalArgumentException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AtLeastOne  ( ) ) ; }  if  (   configurations . size  ( ) > 1 )  {  if  (   !  Main . isUnitTest ||  !  Boolean . getBoolean  (    LDAPSecurityRealm . class . getName  ( ) + "do a bad thing during testing" ) )  {  for (   int  i = 0 ;  i <  configurations . size  ( ) ;  i ++ )  {  LDAPConfiguration  ci =  configurations . get  ( i ) ;  for (   int  k =  i + 1 ;  k <  configurations . size  ( ) ;  k ++ )  {  LDAPConfiguration  ck =  configurations . get  ( k ) ;  if  (  ci . isConfiguration  (  ck . getId  ( ) ) )  {  throw  new IllegalArgumentException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_NotSameServer  ( ) ) ; } } } } }    this . configurations = configurations ;    this . disableMailAddressResolver = disableMailAddressResolver ;    this . cache = cache ;    this . userIdStrategy = userIdStrategy ;    this . groupIdStrategy = groupIdStrategy ; }   private static  List  < LDAPConfiguration > createLdapConfiguration  (  String server ,  String rootDN ,  String userSearchBase ,  String userSearch ,  String groupSearchBase ,  String groupSearchFilter ,  LDAPGroupMembershipStrategy groupMembershipStrategy ,  String managerDN ,  Secret managerPasswordSecret ,  boolean inhibitInferRootDN ,   EnvironmentProperty  [ ] environmentProperties ,  String displayNameAttributeName ,  String mailAddressAttributeName )  {  LDAPConfiguration  conf =  new LDAPConfiguration  ( server , rootDN , inhibitInferRootDN , managerDN , managerPasswordSecret ) ;   conf . setUserSearchBase  ( userSearchBase ) ;   conf . setUserSearch  ( userSearch ) ;   conf . setGroupSearchBase  ( groupSearchBase ) ;   conf . setGroupSearchFilter  ( groupSearchFilter ) ;   conf . setGroupMembershipStrategy  ( groupMembershipStrategy ) ;   conf . setEnvironmentProperties  ( environmentProperties ) ;   conf . setDisplayNameAttributeName  ( displayNameAttributeName ) ;   conf . setMailAddressAttributeName  ( mailAddressAttributeName ) ;  return  Collections . singletonList  ( conf ) ; }   public  List  < LDAPConfiguration > getConfigurations  ( )  {  return configurations ; }   private boolean hasConfiguration  ( )  {  return   configurations != null &&  !  configurations . isEmpty  ( ) ; }   public boolean isDisableRolePrefixing  ( )  {  return disableRolePrefixing ; }    @ DataBoundSetter public void setDisableRolePrefixing  (  boolean disableRolePrefixing )  {    this . disableRolePrefixing = disableRolePrefixing ; }   private Object readResolve  ( )  {  if  (  managerPassword != null )  {   managerPasswordSecret =  Secret . fromString  (  Scrambler . descramble  ( managerPassword ) ) ;   managerPassword = null ; }  if  (  server != null )  {  LDAPConfiguration  conf =  new LDAPConfiguration  ( server , rootDN , inhibitInferRootDN , managerDN , managerPasswordSecret ) ;   server = null ;   rootDN = null ;   managerDN = null ;   managerPasswordSecret = null ;   conf . setMailAddressAttributeName  ( mailAddressAttributeName ) ;   mailAddressAttributeName = null ;   conf . setDisplayNameAttributeName  ( displayNameAttributeName ) ;   displayNameAttributeName = null ;   conf . setExtraEnvVars  ( extraEnvVars ) ;   extraEnvVars = null ;  if  (  groupMembershipStrategy == null )  {   conf . setGroupMembershipStrategy  (  new FromGroupSearchLDAPGroupMembershipStrategy  ( groupMembershipFilter ) ) ;   groupMembershipFilter = null ; } else  {   conf . setGroupMembershipStrategy  ( groupMembershipStrategy ) ;   groupMembershipStrategy = null ; }   conf . setGroupSearchBase  ( groupSearchBase ) ;   groupSearchBase = null ;   conf . setGroupSearchFilter  ( groupSearchFilter ) ;   groupSearchFilter = null ;   conf . setUserSearch  ( userSearch ) ;   userSearch = null ;   conf . setUserSearchBase  ( userSearchBase ) ;   userSearchBase = null ;    this . configurations =  new  ArrayList  < >  ( ) ;   configurations . add  ( conf ) ; }  return this ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getServerUrl  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getServerUrl  ( ) : null ; }    @ Override public IdStrategy getUserIdStrategy  ( )  {  return   userIdStrategy == null ?  IdStrategy . CASE_INSENSITIVE : userIdStrategy ; }    @ Override public IdStrategy getGroupIdStrategy  ( )  {  return   groupIdStrategy == null ?  IdStrategy . CASE_INSENSITIVE : groupIdStrategy ; }   public CacheConfiguration getCache  ( )  {  return cache ; }   public Integer getCacheSize  ( )  {  return   cache == null ? null :  cache . getSize  ( ) ; }   public Integer getCacheTTL  ( )  {  return   cache == null ? null :  cache . getTtl  ( ) ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getGroupMembershipFilter  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getGroupSearchFilter  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public LDAPGroupMembershipStrategy getGroupMembershipStrategy  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getGroupMembershipStrategy  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getGroupSearchFilter  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getGroupSearchFilter  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public  Map  < String , String > getExtraEnvVars  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getExtraEnvVars  ( ) :  Collections .  < String , String > emptyMap  ( ) ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public  EnvironmentProperty  [ ] getEnvironmentProperties  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getEnvironmentProperties  ( ) :  new EnvironmentProperty  [ 0 ] ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getManagerPassword  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getManagerPassword  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public Secret getManagerPasswordSecret  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getManagerPasswordSecret  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getLDAPURL  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getLDAPURL  ( ) : null ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getDisplayNameAttributeName  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getDisplayNameAttributeName  ( ) :  DescriptorImpl . DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME ; }    @ Deprecated  @ Restricted  (  DoNotUse . class ) public String getMailAddressAttributeName  ( )  {  return   hasConfiguration  ( ) ?   configurations . get  ( 0 ) . getMailAddressAttributeName  ( ) :  DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ; }    @ CheckForNull  @ Restricted  (  NoExternalUse . class ) public LDAPConfiguration getConfigurationFor  (  LdapUserDetails d )  {  if  (  d instanceof DelegatedLdapUserDetails )  {  return  getConfigurationFor  (   (  ( DelegatedLdapUserDetails ) d ) . getConfigurationId  ( ) ) ; } else  if  (   hasConfiguration  ( ) &&   configurations . size  ( ) == 1 )  {  return  configurations . get  ( 0 ) ; } else  {  return null ; } }    @ Restricted  (  NoExternalUse . class ) public boolean hasMultiConfiguration  ( )  {  return   hasConfiguration  ( ) &&   configurations . size  ( ) > 1 ; }    @ CheckForNull  @ Restricted  (  NoExternalUse . class ) public LDAPConfiguration getConfigurationFor  (  String configurationId )  {  if  (  configurations != null )  {  for ( LDAPConfiguration configuration : configurations )  {  if  (  configuration . isConfiguration  ( configurationId ) )  {  return configuration ; } }  if  (   configurations . size  ( ) == 1 )  {  return  configurations . get  ( 0 ) ; } }   LOGGER . log  (  Level . FINE , "Unable to find configuration for {0}" , configurationId ) ;  return null ; }    @ CheckForNull private static LDAPConfiguration _getConfigurationFor  (  String configurationId )  {   final SecurityRealm  securityRealm =   Jenkins . getActiveInstance  ( ) . getSecurityRealm  ( ) ;  if  (  securityRealm instanceof LDAPSecurityRealm )  {  return   (  ( LDAPSecurityRealm ) securityRealm ) . getConfigurationFor  ( configurationId ) ; }  return null ; }    @ Restricted  (  NoExternalUse . class ) public static String toProviderUrl  (  String serverUrl ,  String rootDN )  {  StringBuilder  buf =  new StringBuilder  ( ) ;  boolean  first = true ;  for ( String s :  serverUrl . split  ( "\\s+" ) )  {  if  (    s . trim  ( ) . length  ( ) == 0 )  continue ;   s =  getProviderUrl  ( s , rootDN ) ;  if  (  s != null )  {  if  ( first )  {   first = false ; } else  {   buf . append  ( ' ' ) ; }   buf . append  ( s ) ; } }  return  buf . toString  ( ) ; }   private static String getProviderUrl  (  String server ,  String rootDN )  {   server =  addPrefix  ( server ) ;  if  (  !  server . endsWith  ( "/" ) )  {   server =  server + '/' ; }  if  (  rootDN != null )  {   rootDN =  rootDN . trim  ( ) ;  if  (  !  rootDN . isEmpty  ( ) )  {  try  {   server =  server +   new URI  ( null , null , rootDN , null ) . toASCIIString  ( ) ; }  catch (   URISyntaxException e )  {   LOGGER . log  (  Level . WARNING ,  "Unable to build URL with rootDN: " + server , e ) ;  return null ; } } }  return server ; }    @ Override  @ Nonnull public SecurityComponents createSecurityComponents  ( )  {  if  (   configurations . size  ( ) > 1 )  {  DelegateLDAPUserDetailsService  details =  new DelegateLDAPUserDetailsService  ( ) ;  LDAPAuthenticationManager  manager =  new LDAPAuthenticationManager  ( details ) ;  for ( LDAPConfiguration conf : configurations )  {  WebApplicationContext  appContext =  conf . createApplicationContext  ( this , false ) ;   manager . addDelegate  (  findBean  (  AuthenticationManager . class , appContext ) ,  conf . getId  ( ) ) ;   details . addDelegate  (  new LDAPUserDetailsService  ( appContext ,  conf . getGroupMembershipStrategy  ( ) ,  conf . getId  ( ) ) ) ; }  return  new SecurityComponents  ( manager , details ) ; } else  {   final LDAPConfiguration  conf =  configurations . get  ( 0 ) ;  WebApplicationContext  appContext =  conf . createApplicationContext  ( this , true ) ;   final LDAPAuthenticationManager  manager =  new LDAPAuthenticationManager  ( ) ;   manager . addDelegate  (  findBean  (  AuthenticationManager . class , appContext ) , "" ) ;  return  new SecurityComponents  ( manager ,  new LDAPUserDetailsService  ( appContext ,  conf . getGroupMembershipStrategy  ( ) , null ) ) ; } }    @ Override protected UserDetails authenticate  (  String username ,  String password )  throws AuthenticationException  {  return  updateUserDetails  (  ( UserDetails )     getSecurityComponents  ( ) . manager . authenticate  (  new UsernamePasswordAuthenticationToken  (  fixUsername  ( username ) , password ) ) . getPrincipal  ( ) ) ; }    @ Override public UserDetails loadUserByUsername  (  String username )  throws UsernameNotFoundException , DataAccessException  {  return  updateUserDetails  (    getSecurityComponents  ( ) . userDetails . loadUserByUsername  (  fixUsername  ( username ) ) ) ; }   public Authentication updateUserDetails  (  Authentication authentication )  {   updateUserDetails  (  ( UserDetails )  authentication . getPrincipal  ( ) ) ;  return authentication ; }   public UserDetails updateUserDetails  (  UserDetails userDetails )  {  if  (  userDetails instanceof LdapUserDetails )  {   updateUserDetails  (  ( LdapUserDetails ) userDetails ) ; }  return userDetails ; }   public LdapUserDetails updateUserDetails  (  LdapUserDetails d )  {    hudson . model . User  u =    hudson . model . User . get  (  fixUsername  (  d . getUsername  ( ) ) ) ;  LDAPConfiguration  configuration =  getConfigurationFor  ( d ) ;  String  displayNameAttributeName ;  String  mailAddressAttributeName ;  if  (  configuration != null )  {   displayNameAttributeName =  configuration . getDisplayNameAttributeName  ( ) ;   mailAddressAttributeName =  configuration . getMailAddressAttributeName  ( ) ;  if  (  StringUtils . isEmpty  ( displayNameAttributeName ) )  {   displayNameAttributeName =  DescriptorImpl . DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME ; }  if  (  StringUtils . isEmpty  ( mailAddressAttributeName ) )  {   mailAddressAttributeName =  DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ; } } else  {   displayNameAttributeName =  DescriptorImpl . DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME ;   mailAddressAttributeName =  DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ; }  try  {  Attribute  attribute =   d . getAttributes  ( ) . get  ( displayNameAttributeName ) ;  String  displayName =   attribute == null ? null :  ( String )  attribute . get  ( ) ;  if  (    StringUtils . isNotBlank  ( displayName ) &&   u . getId  ( ) . equals  (  u . getFullName  ( ) ) &&  !   u . getFullName  ( ) . equals  ( displayName ) )  {   u . setFullName  ( displayName ) ; } }  catch (   NamingException e )  {   LOGGER . log  (  Level . FINEST , "Could not retrieve display name attribute" , e ) ; }  if  (  ! disableMailAddressResolver )  {  try  {  Attribute  attribute =   d . getAttributes  ( ) . get  ( mailAddressAttributeName ) ;  String  mailAddress =   attribute == null ? null :  ( String )  attribute . get  ( ) ;  if  (  StringUtils . isNotBlank  ( mailAddress ) )  {  UserProperty  existing =  u . getProperty  (  UserProperty . class ) ;  if  (   existing == null ||  !  existing . hasExplicitlyConfiguredAddress  ( ) )   u . addProperty  (  new  Mailer . UserProperty  ( mailAddress ) ) ; } }  catch (   NamingException e )  {   LOGGER . log  (  Level . FINEST , "Could not retrieve email address attribute" , e ) ; }  catch (   IOException e )  {   LOGGER . log  (  Level . WARNING , "Failed to associate the e-mail address" , e ) ; } }  return d ; }    @ Override public GroupDetails loadGroupByGroupname  (  String groupname )  throws UsernameNotFoundException , DataAccessException  {  return  loadGroupByGroupname  ( groupname , false ) ; } 
<<<<<<<
  private  Set  < String > searchForGroupName  (  String groupname )  {   Set  < String >  groups =  new  TreeSet  < >  ( ) ;  for ( LDAPConfiguration conf : configurations )  {  try  {  String  searchBase =    conf . getGroupSearchBase  ( ) != null ?  conf . getGroupSearchBase  ( ) : "" ;  String  searchFilter =    conf . getGroupSearchFilter  ( ) != null ?  conf . getGroupSearchFilter  ( ) : GROUP_SEARCH ;   groups . addAll  (   conf . getLdapTemplate  ( ) . searchForSingleAttributeValues  ( searchBase , searchFilter ,  new String  [ ]  { groupname } , "cn" ) ) ; }  catch (   DataAccessException e )  {   throwUnlessConfigIsIgnorable  ( e , conf ) ; }  catch (   RuntimeException e )  {   throwUnlessConfigIsIgnorable  (  new LdapDataAccessException  (  "Failed to search LDAP for group: " + groupname , e ) , conf ) ; } }  return groups ; }
=======
>>>>>>>
   private static String fixGroupname  (  String groupname )  {  return  FORCE_GROUPNAME_LOWERCASE ?  groupname . toLowerCase  ( ) : groupname ; }   private static String fixUsername  (  String username )  {  return  FORCE_USERNAME_LOWERCASE ?  username . toLowerCase  ( ) : username ; }    @ Override public DescriptorImpl getDescriptor  ( )  {  return  ( DescriptorImpl )  super . getDescriptor  ( ) ; }   private static  <  T  extends Exception > void throwUnlessConfigIsIgnorable  (  T e ,    @ CheckForNull LDAPConfiguration config )  throws T  {  boolean  shouldThrow =   config == null ||  !  config . isIgnoreIfUnavailable  ( ) ;   LOGGER . log  (  Level . WARNING ,  String . format  ( "Failed communication with ldap server %s (%s), will %s the next configuration" ,   config == null ? "null" :  config . getId  ( ) ,   config == null ? "null" :  config . getServer  ( ) ,  shouldThrow ? "_not_ try" : "try" ) , e ) ;  if  ( shouldThrow )  {  throw e ; } }   private static class GroupDetailsImpl  extends GroupDetails  {   private final String  name ;   public  @ Override String getName  ( )  {  return name ; }   private final String  dn ;   private final  Set  < String >  members ;   public GroupDetailsImpl  (  String dn ,  String name )  {  this  ( dn , name , null ) ; }   public GroupDetailsImpl  (  String dn ,  String name ,   Set  < String > members )  {    this . dn = dn ;    this . name = name ;    this . members = members ; }   public String getDn  ( )  {  return dn ; }    @ Override public  Set  < String > getMembers  ( )  {  return members ; } }   private class LDAPAuthenticationManager  implements  AuthenticationManager  {   private final  List  < ManagerEntry >  delegates =  new  ArrayList  < >  ( ) ; ;   private final DelegateLDAPUserDetailsService  detailsService ;   private LDAPAuthenticationManager  ( )  {   detailsService = null ; }   private LDAPAuthenticationManager  (  DelegateLDAPUserDetailsService detailsService )  {    this . detailsService = detailsService ; }   private void addDelegate  (   final AuthenticationManager delegate ,   final String configurationId )  {    this . delegates . add  (  new ManagerEntry  ( delegate , configurationId ) ) ; }   public Authentication authenticate  (  Authentication authentication )  throws AuthenticationException  {  if  (   delegates . size  ( ) == 1 )  {  try  {  return  updateUserDetails  (    delegates . get  ( 0 ) . delegate . authenticate  ( authentication ) ) ; }  catch (   AuthenticationServiceException e )  {   LOGGER . log  (  Level . WARNING , "Failed communication with ldap server." , e ) ;  throw e ; } }  AuthenticationException  lastException = null ;  for ( ManagerEntry delegate : delegates )  {  try  {  Authentication  a =   delegate . delegate . authenticate  ( authentication ) ;  return  updateUserDetails  (  new DelegatedLdapAuthentication  ( a ,  delegate . configurationId ) ) ; }  catch (   BadCredentialsException e )  {  if  (   detailsService != null &&   delegates . size  ( ) > 1 )  {  try  {  UserDetails  details =  detailsService . loadUserByUsername  (  delegate . configurationId ,  String . valueOf  (  authentication . getPrincipal  ( ) ) ) ;  if  (  details != null )  {  throw e ; } }  catch (   UsernameNotFoundException e1 )  {   lastException = e ; }  catch (   DataAccessException e1 )  {   final LDAPConfiguration  configuration =  getConfigurationFor  (  delegate . configurationId ) ;   throwUnlessConfigIsIgnorable  ( e1 , configuration ) ;   lastException = e ; } } else  {   lastException = e ; } }  catch (   AuthenticationServiceException e )  {   final LDAPConfiguration  configuration =  getConfigurationFor  (  delegate . configurationId ) ;   throwUnlessConfigIsIgnorable  ( e , configuration ) ;   lastException = e ; } }  if  (  lastException != null )  {  throw lastException ; } else  {  throw  new UserMayOrMayNotExistException  ( "No ldap server configuration" , authentication ) ; } }   private class ManagerEntry  {   final AuthenticationManager  delegate ;   final String  configurationId ;   public ManagerEntry  (  AuthenticationManager delegate ,  String configurationId )  {    this . delegate = delegate ;    this . configurationId = configurationId ; } } }   static class DelegatedLdapAuthentication  implements  Authentication  {   private final Authentication  delegate ;   private final String  configurationId ;   public DelegatedLdapAuthentication  (  Authentication delegate ,  String configurationId )  {    this . delegate = delegate ;    this . configurationId = configurationId ; }    @ Override public  GrantedAuthority  [ ] getAuthorities  ( )  {  return  delegate . getAuthorities  ( ) ; }    @ Override public Object getCredentials  ( )  {  return  delegate . getCredentials  ( ) ; }    @ Override public Object getDetails  ( )  {  return  delegate . getDetails  ( ) ; }    @ Override public Object getPrincipal  ( )  {  Object  principal =  delegate . getPrincipal  ( ) ;  if  (   principal instanceof LdapUserDetails &&  !  (  principal instanceof DelegatedLdapUserDetails ) )  {  return  new DelegatedLdapUserDetails  (  ( LdapUserDetails ) principal ,  this . configurationId ) ; } else  {  return principal ; } }    @ Override public boolean isAuthenticated  ( )  {  return  delegate . isAuthenticated  ( ) ; }    @ Override public void setAuthenticated  (  boolean isAuthenticated )  throws IllegalArgumentException  {   delegate . setAuthenticated  ( isAuthenticated ) ; }    @ Override public String getName  ( )  {  return  delegate . getName  ( ) ; }   public Authentication getDelegate  ( )  {  return delegate ; }   public String getConfigurationId  ( )  {  return configurationId ; } }   static class DelegatedLdapUserDetails  implements  LdapUserDetails , Serializable  {   private static final  long  serialVersionUID = 1L ;   private final LdapUserDetails  userDetails ;   private final String  configurationId ;   public DelegatedLdapUserDetails  (    @ Nonnull LdapUserDetails userDetails ,    @ Nonnull String configurationId )  {    this . userDetails = userDetails ;    this . configurationId = configurationId ; }    @ Override public Attributes getAttributes  ( )  {  return  userDetails . getAttributes  ( ) ; }    @ Override public  Control  [ ] getControls  ( )  {  return  userDetails . getControls  ( ) ; }    @ Override public String getDn  ( )  {  return  userDetails . getDn  ( ) ; }    @ Override public  GrantedAuthority  [ ] getAuthorities  ( )  {  return  userDetails . getAuthorities  ( ) ; }    @ Override public String getPassword  ( )  {  return  userDetails . getPassword  ( ) ; }    @ Override public String getUsername  ( )  {  return  userDetails . getUsername  ( ) ; }    @ Override public boolean isAccountNonExpired  ( )  {  return  userDetails . isAccountNonExpired  ( ) ; }    @ Override public boolean isAccountNonLocked  ( )  {  return  userDetails . isAccountNonLocked  ( ) ; }    @ Override public boolean isCredentialsNonExpired  ( )  {  return  userDetails . isCredentialsNonExpired  ( ) ; }    @ Override public boolean isEnabled  ( )  {  return  userDetails . isEnabled  ( ) ; }   public LdapUserDetails getUserDetails  ( )  {  return userDetails ; }   public String getConfigurationId  ( )  {  return configurationId ; } }   private static class DelegateLDAPUserDetailsService  implements  UserDetailsService  {   private final  List  < LDAPUserDetailsService >  delegates ;   public DelegateLDAPUserDetailsService  ( )  {   delegates =  new  ArrayList  < >  ( ) ; }   public void addDelegate  (  LDAPUserDetailsService delegate )  {   delegates . add  ( delegate ) ; }   public boolean contains  (  LDAPUserDetailsService delegate )  {  return  delegates . contains  ( delegate ) ; }   public DelegatedLdapUserDetails loadUserByUsername  (  String configurationId ,  String username )  throws UsernameNotFoundException , DataAccessException  {  for ( LDAPUserDetailsService delegate : delegates )  {  if  (   delegate . configurationId . equals  ( configurationId ) )  {  try  {  LdapUserDetails  userDetails =  delegate . loadUserByUsername  ( username ) ;  if  (  userDetails instanceof DelegatedLdapUserDetails )  {  return  ( DelegatedLdapUserDetails ) userDetails ; } else  {  return  new DelegatedLdapUserDetails  ( userDetails ,  delegate . configurationId ) ; } }  catch (   DataAccessException e )  {   final LDAPConfiguration  configuration =  _getConfigurationFor  (  delegate . configurationId ) ;   LOGGER . log  (  Level . WARNING ,  String . format  ( "Failed communication with ldap server %s (%s)" ,  delegate . configurationId ,   configuration != null ?  configuration . getServer  ( ) : "null" ) , e ) ;  throw e ; } } }  return null ; }    @ Override public UserDetails loadUserByUsername  (  String username )  throws UsernameNotFoundException , DataAccessException  {  UsernameNotFoundException  lastUNFE = null ;  for ( LDAPUserDetailsService delegate : delegates )  {  try  {  LdapUserDetails  userDetails =  delegate . loadUserByUsername  ( username ) ;  if  (  userDetails instanceof DelegatedLdapUserDetails )  {  return userDetails ; } else  {  return  new DelegatedLdapUserDetails  ( userDetails ,  delegate . configurationId ) ; } }  catch (   UsernameNotFoundException e )  {   lastUNFE = e ; }  catch (   DataAccessException e )  {  LDAPConfiguration  configuration =  _getConfigurationFor  (  delegate . configurationId ) ;   throwUnlessConfigIsIgnorable  ( e , configuration ) ; } }  if  (  lastUNFE != null )  {  throw lastUNFE ; } else  {  throw  new UsernameNotFoundException  ( username ) ; } } }   public static class LDAPUserDetailsService  implements  UserDetailsService  {   public final LdapUserSearch  ldapSearch ;   public final LdapAuthoritiesPopulator  authoritiesPopulator ;   public final LDAPGroupMembershipStrategy  groupMembershipStrategy ;   public final String  configurationId ;   private final LRUMap  attributesCache =  new LRUMap  ( 32 ) ;    @ Deprecated LDAPUserDetailsService  (  WebApplicationContext appContext )  {  this  ( appContext , null , null ) ; }    @ Deprecated LDAPUserDetailsService  (  LdapUserSearch ldapSearch ,  LdapAuthoritiesPopulator authoritiesPopulator )  {  this  ( ldapSearch , authoritiesPopulator , null , null ) ; }  LDAPUserDetailsService  (  LdapUserSearch ldapSearch ,  LdapAuthoritiesPopulator authoritiesPopulator ,  LDAPGroupMembershipStrategy groupMembershipStrategy ,  String configurationId )  {    this . ldapSearch = ldapSearch ;    this . authoritiesPopulator = authoritiesPopulator ;    this . groupMembershipStrategy = groupMembershipStrategy ;    this . configurationId = configurationId ; }    @ Deprecated public LDAPUserDetailsService  (  WebApplicationContext appContext ,  LDAPGroupMembershipStrategy groupMembershipStrategy )  {  this  (  findBean  (  LdapUserSearch . class , appContext ) ,  findBean  (  LdapAuthoritiesPopulator . class , appContext ) , groupMembershipStrategy , null ) ; }   public LDAPUserDetailsService  (  WebApplicationContext appContext ,  LDAPGroupMembershipStrategy groupMembershipStrategy ,  String configurationId )  {  this  (  findBean  (  LdapUserSearch . class , appContext ) ,  findBean  (  LdapAuthoritiesPopulator . class , appContext ) , groupMembershipStrategy , configurationId ) ; }    @ SuppressFBWarnings  (  value = "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE" ,  justification = "Only on newer core versions" ) public LdapUserDetails loadUserByUsername  (  String username )  throws UsernameNotFoundException , DataAccessException  {   username =  fixUsername  ( username ) ;  try  {   final Jenkins  jenkins =  Jenkins . getInstance  ( ) ;   final SecurityRealm  securityRealm =   jenkins == null ? null :  jenkins . getSecurityRealm  ( ) ;  if  (   securityRealm instanceof LDAPSecurityRealm &&  (     securityRealm . getSecurityComponents  ( ) . userDetails == this ||  (     securityRealm . getSecurityComponents  ( ) . userDetails instanceof DelegateLDAPUserDetailsService &&   (  ( DelegateLDAPUserDetailsService )   securityRealm . getSecurityComponents  ( ) . userDetails ) . contains  ( this ) ) ) )  {  LDAPSecurityRealm  ldapSecurityRealm =  ( LDAPSecurityRealm ) securityRealm ;  if  (   ldapSecurityRealm . cache != null )  {   final  CacheEntry  < LdapUserDetails >  cached ;  synchronized  ( ldapSecurityRealm )  {   cached =   (   ldapSecurityRealm . userDetailsCache != null ) ?   ldapSecurityRealm . userDetailsCache . get  ( username ) : null ; }  if  (   cached != null &&  cached . isValid  ( ) )  {  return  cached . getValue  ( ) ; } } }  LdapUserDetails  ldapUser =  ldapSearch . searchForUser  ( username ) ;  if  (  ldapUser != null )  {   LdapUserDetailsImpl . Essence  user =  new  LdapUserDetailsImpl . Essence  ( ldapUser ) ;  Attributes  v =  ldapUser . getAttributes  ( ) ;  if  (  v instanceof BasicAttributes )  {  synchronized  ( attributesCache )  {  Attributes  vv =  ( Attributes )  attributesCache . get  ( v ) ;  if  (  vv == null )   attributesCache . put  ( v ,  vv = v ) ;   user . setAttributes  ( vv ) ; } }   GrantedAuthority  [ ]  extraAuthorities =   groupMembershipStrategy == null ?  authoritiesPopulator . getGrantedAuthorities  ( ldapUser ) :  groupMembershipStrategy . getGrantedAuthorities  ( ldapUser ) ;  for ( GrantedAuthority extraAuthority : extraAuthorities )  {  if  ( FORCE_GROUPNAME_LOWERCASE )  {   user . addAuthority  (  new GrantedAuthorityImpl  (   extraAuthority . getAuthority  ( ) . toLowerCase  ( ) ) ) ; } else  {   user . addAuthority  ( extraAuthority ) ; } }  if  (  StringUtils . isNotEmpty  ( configurationId ) )  {   ldapUser =  new DelegatedLdapUserDetails  (  user . createUserDetails  ( ) , configurationId ) ; } else  {   ldapUser =  user . createUserDetails  ( ) ; } }  if  (   securityRealm instanceof LDAPSecurityRealm &&  (     securityRealm . getSecurityComponents  ( ) . userDetails == this ||  (     securityRealm . getSecurityComponents  ( ) . userDetails instanceof DelegateLDAPUserDetailsService &&   (  ( DelegateLDAPUserDetailsService )   securityRealm . getSecurityComponents  ( ) . userDetails ) . contains  ( this ) ) ) )  {  LDAPSecurityRealm  ldapSecurityRealm =  ( LDAPSecurityRealm ) securityRealm ;  if  (   ldapSecurityRealm . cache != null )  {  synchronized  ( ldapSecurityRealm )  {  if  (   ldapSecurityRealm . userDetailsCache == null )  {    ldapSecurityRealm . userDetailsCache =  new  CacheMap  < String , LdapUserDetails >  (   ldapSecurityRealm . cache . getSize  ( ) ) ; }    ldapSecurityRealm . userDetailsCache . put  ( username ,  new  CacheEntry  < LdapUserDetails >  (   ldapSecurityRealm . cache . getTtl  ( ) ,  ldapSecurityRealm . updateUserDetails  ( ldapUser ) ) ) ; } } }  return ldapUser ; }  catch (   DataAccessException | UsernameNotFoundException x )  {  throw x ; }  catch (   RuntimeException x )  {  throw  new LdapDataAccessException  (  "Failed to search LDAP for " + username , x ) ; } } }    @ Extension public static final class MailAdressResolverImpl  extends MailAddressResolver  {    @ SuppressFBWarnings  (  value = "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE" ,  justification = "Only on newer core versions" ) public String findMailAddressFor  (  User u )  {   final Jenkins  jenkins =  Jenkins . getInstance  ( ) ;  if  (  jenkins == null )  {  return null ; }  SecurityRealm  realm =  jenkins . getSecurityRealm  ( ) ;  if  (  !  (  realm instanceof LDAPSecurityRealm ) )  {  return null ; }  if  (   (  ( LDAPSecurityRealm ) realm ) . disableMailAddressResolver )  {   LOGGER . info  ( "LDAPSecurityRealm MailAddressResolver is disabled" ) ;  return null ; }  try  {  LdapUserDetails  details =  ( LdapUserDetails )    realm . getSecurityComponents  ( ) . userDetails . loadUserByUsername  (  u . getId  ( ) ) ;   final LDAPConfiguration  configuration =   (  ( LDAPSecurityRealm ) realm ) . getConfigurationFor  ( details ) ;  String  attr ;  if  (  configuration != null )  {   attr =  configuration . getMailAddressAttributeName  ( ) ;  if  (  StringUtils . isEmpty  ( attr ) )  {   attr =  DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ; } } else  {   attr =  DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ; }  Attribute  mail =   details . getAttributes  ( ) . get  ( attr ) ;  if  (  mail == null )  return null ;  return  ( String )  mail . get  ( ) ; }  catch (   DataAccessException | NamingException | AcegiSecurityException e )  {   LOGGER . log  (  Level . FINE , "Failed to look up LDAP for e-mail address" , e ) ;  return null ; } } }   public static final class LdapAuthenticationProviderImpl  extends LdapAuthenticationProvider  {   public LdapAuthenticationProviderImpl  (  LdapAuthenticator authenticator ,  LdapAuthoritiesPopulator authoritiesPopulator ,  LDAPGroupMembershipStrategy groupMembershipStrategy )  {  super  ( authenticator ,   groupMembershipStrategy != null ?  new WrappedAuthoritiesPopulator  ( groupMembershipStrategy , authoritiesPopulator ) : authoritiesPopulator ) ; } }   private static final class WrappedAuthoritiesPopulator  implements  LdapAuthoritiesPopulator  {   private final LDAPGroupMembershipStrategy  strategy ;   private final LdapAuthoritiesPopulator  populator ;   private WrappedAuthoritiesPopulator  (  LDAPGroupMembershipStrategy strategy ,  LdapAuthoritiesPopulator populator )  {    this . strategy = strategy ;    this . populator = populator ;   strategy . setAuthoritiesPopulator  ( populator ) ; }    @ Override public  GrantedAuthority  [ ] getGrantedAuthorities  (  LdapUserDetails userDetails )  throws LdapDataAccessException  {  if  (   strategy . getAuthoritiesPopulator  ( ) != populator )  {   strategy . setAuthoritiesPopulator  ( populator ) ; }  return  strategy . getGrantedAuthorities  ( userDetails ) ; } }   public static final class AuthoritiesPopulatorImpl  extends DefaultLdapAuthoritiesPopulator  {  String  rolePrefix = "ROLE_" ;  boolean  convertToUpperCase = true ;   private GrantedAuthority  defaultRole = null ;   public AuthoritiesPopulatorImpl  (  InitialDirContextFactory initialDirContextFactory ,  String groupSearchBase )  {  super  ( initialDirContextFactory ,  fixNull  ( groupSearchBase ) ) ;   super . setRolePrefix  ( "" ) ;   super . setConvertToUpperCase  ( false ) ; }    @ Override public Set getAdditionalRoles  (  LdapUserDetails ldapUser )  {  return  Collections . singleton  ( AUTHENTICATED_AUTHORITY ) ; }    @ Override public void setRolePrefix  (  String rolePrefix )  {    this . rolePrefix = rolePrefix ; }    @ Override public void setConvertToUpperCase  (  boolean convertToUpperCase )  {    this . convertToUpperCase = convertToUpperCase ; }    @ Override public Set getGroupMembershipRoles  (  String userDn ,  String username )  {   Set  < GrantedAuthority >  names =  super . getGroupMembershipRoles  ( userDn , username ) ;   Set  < GrantedAuthority >  r =  new  HashSet  < GrantedAuthority >  (   names . size  ( ) * 2 ) ;   r . addAll  ( names ) ;  if  (  isGeneratingPrefixRoles  ( ) )  {  for ( GrantedAuthority ga : names )  {  String  role =  ga . getAuthority  ( ) ;  if  ( convertToUpperCase )   role =  role . toUpperCase  ( ) ;   r . add  (  new GrantedAuthorityImpl  (  rolePrefix + role ) ) ; } }  return r ; }   public boolean isGeneratingPrefixRoles  ( )  {  return   StringUtils . isNotBlank  ( rolePrefix ) || convertToUpperCase ; }   public boolean isConvertToUpperCase  ( )  {  return convertToUpperCase ; }   public String getRolePrefix  ( )  {  return rolePrefix ; }   public GrantedAuthority getDefaultRole  ( )  {  return defaultRole ; }   public void setDefaultRole  (  String defaultRole )  {   super . setDefaultRole  ( defaultRole ) ;    this . defaultRole =  new GrantedAuthorityImpl  ( defaultRole ) ; } }    @ Extension public static final class DescriptorImpl  extends  Descriptor  < SecurityRealm >  {   public static final String  DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME = "displayname" ;   public static final String  DEFAULT_MAILADDRESS_ATTRIBUTE_NAME = "mail" ;   public static final String  DEFAULT_USER_SEARCH = "uid={0}" ;   public String getDisplayName  ( )  {  return  Messages . LDAPSecurityRealm_DisplayName  ( ) ; }   public IdStrategy getDefaultIdStrategy  ( )  {  return  IdStrategy . CASE_INSENSITIVE ; }    @ Override public SecurityRealm newInstance  (  StaplerRequest req ,  JSONObject formData )  throws FormException  {  if  (  !  formData . has  ( "configurations" ) )  {  throw  new  Descriptor . FormException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AtLeastOne  ( ) , "configurations" ) ; } else  {   final Object  configurations =  formData . get  ( "configurations" ) ;  if  (  configurations instanceof JSONArray )  {  if  (   (  ( JSONArray ) configurations ) . isEmpty  ( ) )  {  throw  new  Descriptor . FormException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AtLeastOne  ( ) , "configurations" ) ; } else  if  (    (  ( JSONArray ) configurations ) . size  ( ) > 1 )  {   List  < LDAPConfiguration >  confs =  req . bindJSONToList  (  LDAPConfiguration . class , configurations ) ;  for (   int  i = 0 ;  i <  confs . size  ( ) ;  i ++ )  {  LDAPConfiguration  ci =  confs . get  ( i ) ;  for (   int  k =  i + 1 ;  k <  confs . size  ( ) ;  k ++ )  {  LDAPConfiguration  ck =  confs . get  ( k ) ;  if  (  ci . isConfiguration  (  ck . getId  ( ) ) )  {  throw  new  Descriptor . FormException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_NotSameServer  ( ) , "configurations" ) ; } } } } } else  if  (  !  (  configurations instanceof JSONObject ) )  {  throw  new  Descriptor . FormException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AtLeastOne  ( ) , "configurations" ) ; } else  if  (   (  ( JSONObject ) configurations ) . isNullObject  ( ) )  {  throw  new  Descriptor . FormException  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AtLeastOne  ( ) , "configurations" ) ; } }  return  super . newInstance  ( req , formData ) ; }   public boolean hasCustomBindScript  ( )  {  return   LDAPConfiguration . getLdapBindOverrideFile  (  Jenkins . getActiveInstance  ( ) ) . exists  ( ) ; }    @ RequirePOST public FormValidation doValidate  (  StaplerRequest req )  throws Exception  {  if  (  !   Jenkins . getActiveInstance  ( ) . hasPermission  (  Jenkins . ADMINISTER ) )  {  return  FormValidation . ok  ( ) ; }  JSONObject  json =  JSONObject . fromObject  (  IOUtils . toString  (  req . getInputStream  ( ) ) ) ;  String  user =  json . getString  ( "testUser" ) ;  String  password =  json . getString  ( "testPassword" ) ;  JSONObject  realmCfg =   json . getJSONObject  ( "useSecurity" ) . getJSONObject  ( "realm" ) ;  LDAPSecurityRealm  realm =  req . bindJSON  (  LDAPSecurityRealm . class , realmCfg ) ;  return  validate  ( realm , user , password ) ; }   private void rsp  (  StringBuilder response ,  String kind ,  String testId ,  String message ,  Object ...  extras )  {     response . append  ( "<div class='" ) . append  ( kind ) . append  ( "' data-test='" ) ;   response . append  (  Util . escape  ( testId ) ) ;   response . append  ( "'>" ) ;   response . append  ( message ) ;  boolean  needBr = true ;  for ( Object extra : extras )  {  if  (  extra instanceof String )  {  if  ( needBr )  {   response . append  ( "<br/>" ) ; }   response . append  ( extra ) ;   needBr = true ; } else  if  (  extra instanceof Collection )  {   response . append  ( "<ul>" ) ;  for ( String item :  (  Collection  < String > ) extra )  {   response . append  ( "<li>" ) ;   response . append  ( item ) ;   response . append  ( "</li>" ) ; }   response . append  ( "</ul>" ) ;   needBr = false ; } }   response . append  ( "</div>" ) ; }   private void ok  (  StringBuilder response ,  String testId ,  String message ,  Object ...  extras )  {   rsp  ( response , "validation-ok" , testId , message , extras ) ; }   private void warning  (  StringBuilder response ,  String testId ,  String message ,  Object ...  extras )  {   rsp  ( response , "warning" , testId , message , extras ) ; }   private void error  (  StringBuilder response ,  String testId ,  String message ,  Object ...  extras )  {   rsp  ( response , "error" , testId , message , extras ) ; }   public FormValidation validate  (  LDAPSecurityRealm realm ,  String user ,  String password )  {   LDAPConfiguration . LDAPConfigurationDescriptor  confDescriptor =   Jenkins . getActiveInstance  ( ) . getDescriptorByType  (   LDAPConfiguration . LDAPConfigurationDescriptor . class ) ;  for ( LDAPConfiguration configuration :  realm . getConfigurations  ( ) )  {  FormValidation  connnectionCheck =  confDescriptor . doCheckServer  (  configuration . getServerUrl  ( ) ,  configuration . getManagerDN  ( ) ,  configuration . getManagerPasswordSecret  ( ) ) ;  if  (   connnectionCheck . kind !=   FormValidation . Kind . OK )  {  return connnectionCheck ; } }  StringBuilder  response =  new StringBuilder  ( 1024 ) ;     response . append  ( "<div>" ) . append  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_LoginHeader  ( ) ) . append  ( "</div>" ) ;  boolean  potentialLockout = false ;  boolean  likelyLockout = false ;  LdapUserDetails  loginDetails = null ;  try  {   loginDetails =  ( LdapUserDetails )     realm . getSecurityComponents  ( ) . manager . authenticate  (  new UsernamePasswordAuthenticationToken  (  fixUsername  ( user ) , password ) ) . getPrincipal  ( ) ;   ok  ( response , "authentication" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AuthenticationSuccessful  ( ) ) ; }  catch (   AuthenticationException e )  {  if  (  StringUtils . isBlank  ( password ) )  {   warning  ( response , "authentication" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AuthenticationFailedEmptyPass  ( user ) ) ; } else  {   error  ( response , "authentication" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AuthenticationFailed  ( user ) ) ;   potentialLockout = true ;   likelyLockout = true ; } }   Set  < String >  loginAuthorities =  new  HashSet  < >  ( ) ;  if  (  loginDetails != null )  {   ok  ( response , "authentication-username" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserId  (  Util . escape  (  loginDetails . getUsername  ( ) ) ) ) ;   ok  ( response , "authentication-dn" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserDn  (  Util . escape  (  loginDetails . getDn  ( ) ) ) ) ;  LDAPConfiguration  loginConfiguration =  realm . getConfigurationFor  ( loginDetails ) ;  assert  loginConfiguration != null ;  if  (  realm . hasMultiConfiguration  ( ) )  {   ok  ( response , "authentication-configuration" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserConfiguration  (  Util . escape  (  loginConfiguration . getServer  ( ) ) ) ) ; }   validateDisplayName  ( loginConfiguration , response , loginDetails , "authentication-displayname" ) ;  if  (  !  realm . disableMailAddressResolver )  {   validateEmailAddress  ( loginConfiguration , response , loginDetails , "authentication-email" ) ; }  for ( GrantedAuthority a :  loginDetails . getAuthorities  ( ) )  {   loginAuthorities . add  (  a . getAuthority  ( ) ) ; }  if  (    loginDetails . getAuthorities  ( ) . length < 1 )  {   error  ( response , "authentication-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_NoGroupMembership  ( ) ) ; } else  if  (    loginDetails . getAuthorities  ( ) . length == 1 )  {   warning  ( response , "authentication-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_BasicGroupMembership  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_BasicGroupMembershipDetail  ( ) ) ; } else  {   List  < String >  authorities =  new  ArrayList  < >  ( ) ;  for ( GrantedAuthority a :  loginDetails . getAuthorities  ( ) )  {  if  (  AUTHENTICATED_AUTHORITY . equals  ( a ) )  {  continue ; }   authorities . add  (   "<code>" +  Util . escape  (  a . getAuthority  ( ) ) + "</code>" ) ; }   ok  ( response , "authentication-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupMembership  ( ) , authorities ) ; } }     response . append  ( "<div>" ) . append  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_LookupHeader  ( ) ) . append  ( "</div>" ) ;  LdapUserDetails  lookUpDetails = null ;  try  {   lookUpDetails =  ( LdapUserDetails )    realm . getSecurityComponents  ( ) . userDetails . loadUserByUsername  (  fixUsername  ( user ) ) ;   ok  ( response , "lookup" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupSuccessful  ( ) ) ; }  catch (   UserMayOrMayNotExistException e1 )  {   rsp  ( response ,   loginDetails == null ? "warning" : "error" , "lookup" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupInconclusive  ( user ) ,   isAnyManagerBlank  ( realm ) ?      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnRequired  ( ) :      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnPermissions  ( ) ) ; }  catch (   UsernameNotFoundException e1 )  {   rsp  ( response ,   loginDetails == null ? "warning" : "error" , "lookup" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupDoesNotExist  ( user ) ,   isAnyManagerBlank  ( realm ) ?      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnRequired  ( ) :      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnPermissions  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupSettingsCorrect  ( ) ) ; }  catch (   LdapDataAccessException e )  {  Throwable  cause =  e . getCause  ( ) ;  while  (   cause != null &&  !  (  cause instanceof BadCredentialsException ) )  {   cause =  cause . getCause  ( ) ; }  if  (  cause != null )  {   error  ( response , "lookup" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupBadCredentials  ( ) ,   isAnyManagerBlank  ( realm ) ?      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnCorrect  ( ) :      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupManagerDnPermissions  ( ) ) ;   potentialLockout = true ; } else  {   error  ( response , "lookup" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserLookupFailed  ( user ) ,  Util . escape  (  e . getLocalizedMessage  ( ) ) ) ;   potentialLockout = true ; } }  if  (   loginDetails == null &&  lookUpDetails != null )  {   ok  ( response , "lookup-username" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserId  (  Util . escape  (  lookUpDetails . getUsername  ( ) ) ) ) ;   ok  ( response , "lookup-dn" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserDn  (  Util . escape  (  lookUpDetails . getDn  ( ) ) ) ) ;  LDAPConfiguration  lookupConfiguration =  realm . getConfigurationFor  ( lookUpDetails ) ;  assert  lookupConfiguration != null ;  if  (  realm . hasMultiConfiguration  ( ) )  {   ok  ( response , "lookup-configuration" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserConfiguration  (  Util . escape  (  lookupConfiguration . getServer  ( ) ) ) ) ; }   validateDisplayName  ( lookupConfiguration , response , lookUpDetails , "lookup-displayname" ) ;  if  (  !  realm . disableMailAddressResolver )  {   validateEmailAddress  ( lookupConfiguration , response , lookUpDetails , "lookup-email" ) ; } }   Set  < String >  lookupAuthorities =  new  HashSet  < >  ( ) ;  if  (  lookUpDetails != null )  {  for ( GrantedAuthority a :  lookUpDetails . getAuthorities  ( ) )  {   lookupAuthorities . add  (  a . getAuthority  ( ) ) ; }  if  (   loginDetails == null ||  !  loginAuthorities . equals  ( lookupAuthorities ) )  {  if  (    lookUpDetails . getAuthorities  ( ) . length < 1 )  {   error  ( response , "lookup-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_NoGroupMembership  ( ) ) ; } else  if  (    lookUpDetails . getAuthorities  ( ) . length == 1 )  {   warning  ( response , "lookup-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_BasicGroupMembership  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_BasicGroupMembershipDetail  ( ) ) ; } else  {   List  < String >  authorities =  new  ArrayList  < >  ( ) ;  for ( GrantedAuthority a :  lookUpDetails . getAuthorities  ( ) )  {  if  (  AUTHENTICATED_AUTHORITY . equals  ( a ) )  {  continue ; }   authorities . add  (   "<code>" +  Util . escape  (  a . getAuthority  ( ) ) + "</code>" ) ; }   ok  ( response , "lookup-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupMembership  ( ) , authorities ) ; } } }  if  (   loginDetails != null &&  lookUpDetails != null )  {  LDAPConfiguration  loginConfiguration =  realm . getConfigurationFor  ( loginDetails ) ;  LDAPConfiguration  lookupConfiguration =  realm . getConfigurationFor  ( lookUpDetails ) ;  assert  loginConfiguration == lookupConfiguration : "The lookup user details and login user details are not from the same server configuration" ;  if  (  !  StringUtils . equals  (  loginDetails . getUsername  ( ) ,  lookUpDetails . getUsername  ( ) ) )  {   error  ( response , "consistency-username" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UsernameMismatch  (  loginDetails . getUsername  ( ) ,  lookUpDetails . getUsername  ( ) ) ) ;   potentialLockout = true ; }  if  (  !  StringUtils . equals  (  loginDetails . getDn  ( ) ,  lookUpDetails . getDn  ( ) ) )  {   error  ( response , "consistency-dn" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_DnMismatch  (  loginDetails . getDn  ( ) ,  lookUpDetails . getDn  ( ) ) ) ;   potentialLockout = true ; }  if  (  StringUtils . isNotBlank  (  loginConfiguration . getDisplayNameAttributeName  ( ) ) )  {  Attribute  loginAttr =   loginDetails . getAttributes  ( ) . get  (  loginConfiguration . getDisplayNameAttributeName  ( ) ) ;  Object  loginValue ;  try  {   loginValue =   loginAttr == null ? null :  loginAttr . get  ( ) ; }  catch (   NamingException e )  {   loginValue =  e . getClass  ( ) ; }  Attribute  lookUpAttr =   lookUpDetails . getAttributes  ( ) . get  (  lookupConfiguration . getDisplayNameAttributeName  ( ) ) ;  Object  lookUpValue ;  try  {   lookUpValue =   lookUpAttr == null ? null :  lookUpAttr . get  ( ) ; }  catch (   NamingException e )  {   lookUpValue =  e . getClass  ( ) ; }  if  (   loginValue == null ?  lookUpValue != null :  !  loginValue . equals  ( lookUpValue ) )  {   error  ( response , "consistency-displayname" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_DisplayNameMismatch  ( loginValue , lookUpValue ) ) ;   potentialLockout = true ; } }  if  (   !  realm . disableMailAddressResolver &&  StringUtils . isNotBlank  (  loginConfiguration . getMailAddressAttributeName  ( ) ) )  {  Attribute  loginAttr =   loginDetails . getAttributes  ( ) . get  (  loginConfiguration . getMailAddressAttributeName  ( ) ) ;  Object  loginValue ;  try  {   loginValue =   loginAttr == null ? null :  loginAttr . get  ( ) ; }  catch (   NamingException e )  {   loginValue =  e . getClass  ( ) ; }  Attribute  lookUpAttr =   lookUpDetails . getAttributes  ( ) . get  (  lookupConfiguration . getMailAddressAttributeName  ( ) ) ;  Object  lookUpValue ;  try  {   lookUpValue =   lookUpAttr == null ? null :  lookUpAttr . get  ( ) ; }  catch (   NamingException e )  {   lookUpValue =  e . getClass  ( ) ; }  if  (   loginValue == null ?  lookUpValue != null :  !  loginValue . equals  ( lookUpValue ) )  {   error  ( response , "consistency-email" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_EmailAddressMismatch  ( loginValue , lookUpValue ) ) ;   potentialLockout = true ; } }  if  (  loginAuthorities . equals  ( lookupAuthorities ) )  {   ok  ( response , "consistency" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupMembershipMatch  ( ) ) ; } else  {   error  ( response , "consistency" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupMembershipMismatch  ( ) ) ;   potentialLockout = true ; } }   Set  < String >  groups =  new  HashSet  < >  ( loginAuthorities ) ;   Set  < String >  badGroups =  new  TreeSet  < >  ( ) ;   groups . addAll  ( lookupAuthorities ) ;   groups . remove  (  AUTHENTICATED_AUTHORITY . getAuthority  ( ) ) ;  for ( String group : groups )  {  try  {   realm . loadGroupByGroupname  ( group ) ; }  catch (   UsernameNotFoundException e )  {   badGroups . add  ( group ) ; } }  if  (  groups . isEmpty  ( ) )  {   warning  ( response , "resolve-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupNotPossible  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupNotPossibleDetail  ( ) ) ; } else  if  (  badGroups . isEmpty  ( ) )  {   ok  ( response , "resolve-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupSuccessful  (  groups . size  ( ) ) ) ; } else  {   List  < String >  escaped =  new  ArrayList  < >  (  badGroups . size  ( ) ) ;  for ( String group : badGroups )  {   escaped . add  (   "<code>" +  Util . escape  ( group ) + "</code>" ) ; }   warning  ( response , "resolve-groups" ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupFailed  (  badGroups . size  ( ) ) , escaped ,   isAnyManagerBlank  ( realm ) ?      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupManagerDnRequired  ( ) :      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupManagerDnPermissions  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_GroupLookupSettingsCorrect  ( ) ) ; }  if  ( potentialLockout )  {     response . append  ( "<div>" ) . append  (      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_LockoutHeader  ( ) ) . append  ( "</div>" ) ;   error  ( response , "lockout" ,  likelyLockout ?      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_PotentialLockout  ( user ) :      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_PotentialLockout2  ( user ) ) ; }  return  FormValidation . okWithMarkup  (  response . toString  ( ) ) ; }   private boolean isAnyManagerBlank  (  LDAPSecurityRealm realm )  {  for ( LDAPConfiguration configuration :  realm . getConfigurations  ( ) )  {  if  (  StringUtils . isBlank  (  configuration . getManagerDN  ( ) ) )  {  return true ; } }  return false ; }   private void validateEmailAddress  (  LDAPConfiguration configuration ,  StringBuilder response ,  LdapUserDetails details ,  String testId )  {  Attribute  attribute =   details . getAttributes  ( ) . get  (  configuration . getMailAddressAttributeName  ( ) ) ;  if  (  attribute == null )  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   warning  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_NoEmailAddress  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  configuration . getMailAddressAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } else  {  try  {  String  mailAddress =  ( String )  attribute . get  ( ) ;  if  (  StringUtils . isNotBlank  ( mailAddress ) )  {   ok  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserEmail  (  Util . escape  ( mailAddress ) ) ) ; } else  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   warning  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_EmptyEmailAddress  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  configuration . getMailAddressAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } }  catch (   NamingException e )  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   error  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_CouldNotRetrieveEmailAddress  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  configuration . getMailAddressAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } } }   private void validateDisplayName  (  LDAPConfiguration configuration ,  StringBuilder response ,  LdapUserDetails details ,  String testId )  {  Attribute  attribute =   details . getAttributes  ( ) . get  (  configuration . getDisplayNameAttributeName  ( ) ) ;  if  (  attribute == null )  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   warning  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_NoDisplayName  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  configuration . getDisplayNameAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } else  {  try  {  String  displayName =  ( String )  attribute . get  ( ) ;  if  (  displayName != null )  {   ok  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_UserDisplayName  (  Util . escape  ( displayName ) ) ) ; } else  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   warning  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_EmptyDisplayName  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  configuration . getDisplayNameAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } }  catch (   NamingException e )  {   List  < String >  alternatives =  new  ArrayList  < >  ( ) ;  for ( Attribute attr :  Collections . list  (   details . getAttributes  ( ) . getAll  ( ) ) )  {   alternatives . add  (   "<code>" +  Util . escape  (  attr . getID  ( ) ) + "</code>" ) ; }   error  ( response , testId ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_CouldNotRetrieveDisplayName  ( ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_IsAttributeNameCorrect  (  Util . escape  (  configuration . getDisplayNameAttributeName  ( ) ) ) ,      jenkins . security . plugins . ldap . Messages . LDAPSecurityRealm_AvailableAttributes  ( ) , alternatives ) ; } } } }   private static String addPrefix  (  String server )  {  if  (  server . contains  ( "://" ) )  return server ; else  return  "ldap://" + server ; }    @ Restricted  (  NoExternalUse . class ) public static final Logger  LOGGER =  Logger . getLogger  (   LDAPSecurityRealm . class . getName  ( ) ) ;   public static final String  GROUP_SEARCH =  System . getProperty  (    LDAPSecurityRealm . class . getName  ( ) + ".groupSearch" , "(& (cn={0}) (| (objectclass=groupOfNames) (objectclass=groupOfUniqueNames) (objectclass=posixGroup)))" ) ;   public static class CacheConfiguration  extends  AbstractDescribableImpl  < CacheConfiguration >  {   private final  int  size ;   private final  int  ttl ;    @ DataBoundConstructor public CacheConfiguration  (   int size ,   int ttl )  {    this . size =  Math . max  ( 10 ,  Math . min  ( size , 1000 ) ) ;    this . ttl =  Math . max  ( 30 ,  Math . min  ( ttl , 3600 ) ) ; }   public  int getSize  ( )  {  return size ; }   public  int getTtl  ( )  {  return ttl ; }    @ Extension public static class DescriptorImpl  extends  Descriptor  < CacheConfiguration >  {    @ Override public String getDisplayName  ( )  {  return "" ; }   public ListBoxModel doFillSizeItems  ( )  {  ListBoxModel  m =  new ListBoxModel  ( ) ;   m . add  ( "10" ) ;   m . add  ( "20" ) ;   m . add  ( "50" ) ;   m . add  ( "100" ) ;   m . add  ( "200" ) ;   m . add  ( "500" ) ;   m . add  ( "1000" ) ;  return m ; }   public ListBoxModel doFillTtlItems  ( )  {  ListBoxModel  m =  new ListBoxModel  ( ) ;  for (  int ttl :  new  int  [ ]  { 30 , 60 , 120 , 300 , 600 , 900 , 1800 , 3600 } )  {   m . add  (  Util . getTimeSpanString  (  ttl * 1000L ) ,  Integer . toString  ( ttl ) ) ; }  return m ; } } }   private static class CacheEntry  <  T >  {   private final  long  expires ;   private final T  value ;   public CacheEntry  (   int ttlSeconds ,  T value )  {    this . expires =   System . currentTimeMillis  ( ) +   TimeUnit . SECONDS . toMillis  ( ttlSeconds ) ;    this . value = value ; }   public T getValue  ( )  {  return value ; }   public boolean isValid  ( )  {  return   System . currentTimeMillis  ( ) < expires ; } }   private static class CacheMap  <  K ,  V >  extends  LinkedHashMap  < K ,  CacheEntry  < V > >  {   private final  int  cacheSize ;   public CacheMap  (   int cacheSize )  {  super  (  cacheSize + 1 ) ;    this . cacheSize = cacheSize ; }    @ Override protected boolean removeEldestEntry  (    Map . Entry  < K ,  CacheEntry  < V > > eldest )  {  return     size  ( ) > cacheSize ||   eldest . getValue  ( ) == null ||  !   eldest . getValue  ( ) . isValid  ( ) ; } }   public static class EnvironmentProperty  extends  AbstractDescribableImpl  < EnvironmentProperty >  implements  Serializable  {   private final String  name ;   private final String  value ;    @ DataBoundConstructor public EnvironmentProperty  (  String name ,  String value )  {    this . name = name ;    this . value = value ; }   public String getName  ( )  {  return name ; }   public String getValue  ( )  {  return value ; }   public static  Map  < String , String > toMap  (   List  < EnvironmentProperty > properties )  {  if  (  properties != null )  {   final  Map  < String , String >  result =  new  LinkedHashMap  < String , String >  ( ) ;  for ( EnvironmentProperty property : properties )  {   result . put  (  property . getName  ( ) ,  property . getValue  ( ) ) ; }  return result ; }  return null ; }    @ Extension public static class DescriptorImpl  extends  Descriptor  < EnvironmentProperty >  {    @ Override public String getDisplayName  ( )  {  return "" ; } } }    @ Override public GroupDetails loadGroupByGroupname  (  String groupname ,  boolean fetchMembers )  throws UsernameNotFoundException , DataAccessException  {   groupname =  fixGroupname  ( groupname ) ;  GroupDetailsImpl  cachedGroup ;  if  (  cache != null )  {   final  CacheEntry  < GroupDetailsImpl >  cached ;  synchronized  ( this )  {   cached =   groupDetailsCache != null ?  groupDetailsCache . get  ( groupname ) : null ; }  if  (   cached != null &&  cached . isValid  ( ) )  {  GroupDetailsImpl  cachedValue =  cached . getValue  ( ) ;  if  (   ! fetchMembers ||   cachedValue . getMembers  ( ) != null )  {   cachedGroup = cachedValue ; } else  {   cachedGroup = null ; } } else  {   cachedGroup = null ; } } else  {   cachedGroup = null ; }   final GroupDetailsImpl  group =   cachedGroup != null ? cachedGroup :  searchForGroupName  ( groupname , fetchMembers ) ;  if  (   cache != null &&  cachedGroup == null )  {  synchronized  ( this )  {  if  (  groupDetailsCache == null )  {   groupDetailsCache =  new  CacheMap  < >  (  cache . getSize  ( ) ) ; }   groupDetailsCache . put  ( groupname ,  new  CacheEntry  < >  (  cache . getTtl  ( ) , group ) ) ; } }  return group ; }   private  @ Nonnull GroupDetailsImpl searchForGroupName  (  String groupname ,  boolean fetchMembers )  throws UsernameNotFoundException , DataAccessException  {  for ( LDAPConfiguration conf : configurations )  {  try  {  String  searchBase =    conf . getGroupSearchBase  ( ) != null ?  conf . getGroupSearchBase  ( ) : "" ;  String  searchFilter =    conf . getGroupSearchFilter  ( ) != null ?  conf . getGroupSearchFilter  ( ) : GROUP_SEARCH ;  LDAPExtendedTemplate  template =  conf . getLdapTemplate  ( ) ;  GroupDetailsImpl  groupDetails =  ( GroupDetailsImpl )  template . searchForFirstEntry  ( searchBase , searchFilter ,  new Object  [ ]  { groupname } ,  new String  [ ]  { } ,  new GroupDetailsMapper  ( ) ) ;  if  (  groupDetails != null )  {  if  ( fetchMembers )  {   Set  < String >  members =   conf . getGroupMembershipStrategy  ( ) . getGroupMembers  (  groupDetails . getDn  ( ) , conf ) ;   groupDetails =  new GroupDetailsImpl  (  groupDetails . getDn  ( ) ,  groupDetails . getName  ( ) , members ) ; }  return groupDetails ; } }  catch (   DataAccessException e )  {   LOGGER . log  (  Level . WARNING ,  String . format  ( "Failed communication with ldap server %s (%s)" ,  conf . getId  ( ) ,  conf . getServer  ( ) ) , e ) ;  throw e ; } }  throw  new UsernameNotFoundException  ( groupname ) ; }   private static class GroupDetailsMapper  implements  LdapEntryMapper  {    @ Override public GroupDetailsImpl mapAttributes  (  String dn ,  Attributes attributes )  throws NamingException  {  LdapName  name =  new LdapName  ( dn ) ;  String  groupName =  fixGroupname  (  String . valueOf  (   name . getRdn  (   name . size  ( ) - 1 ) . getValue  ( ) ) ) ;  return  new GroupDetailsImpl  ( dn , groupName ) ; } } }