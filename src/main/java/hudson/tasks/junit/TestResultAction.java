  package   hudson . tasks . junit ;   import    com . thoughtworks . xstream . XStream ;  import      edu . umd . cs . findbugs . annotations . SuppressFBWarnings ;  import  hudson . Util ;  import  hudson . XmlFile ;  import   hudson . model . AbstractBuild ;  import   hudson . model . Action ;  import   hudson . model . BuildListener ;  import   hudson . model . Job ;  import   hudson . model . Run ;  import   hudson . model . TaskListener ;  import    hudson . tasks . test . AbstractTestResultAction ;  import    hudson . tasks . test . TestObject ;  import    hudson . tasks . test . TestResultProjectAction ;  import   hudson . util . HeapSpaceStringConverter ;  import   hudson . util . XStream2 ;  import    org . kohsuke . stapler . StaplerProxy ;  import   java . io . File ;  import   java . io . IOException ;  import    java . lang . ref . WeakReference ;  import   java . util . ArrayList ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . List ;  import    java . util . logging . Level ;  import    java . util . logging . Logger ;  import   jenkins . tasks . SimpleBuildStep ;    @ SuppressFBWarnings  (  value = "UG_SYNC_SET_UNSYNC_GET" ,  justification = "False positive" ) public class TestResultAction  extends  AbstractTestResultAction  < TestResultAction >  implements  StaplerProxy ,  SimpleBuildStep . LastBuildAction  {   private transient  WeakReference  < TestResult >  result ;   private  int  failCount ;   private  int  skipCount ;   private Integer  totalCount ;   private Double  healthScaleFactor ;   private  List  < Data >  testData =  new  ArrayList  < Data >  ( ) ;    @ Deprecated public TestResultAction  (  AbstractBuild owner ,  TestResult result ,  BuildListener listener )  {  this  (  ( Run ) owner , result , listener ) ; }   public TestResultAction  (  Run owner ,  TestResult result ,  TaskListener listener )  {  super  ( owner ) ;   setResult  ( result , listener ) ; }    @ Deprecated public TestResultAction  (  TestResult result ,  BuildListener listener )  {  this  (  ( Run ) null , result , listener ) ; }    @ SuppressWarnings  ( "deprecation" )  @ Override public  Collection  <  ? extends Action > getProjectActions  ( )  {   Job  <  ? ,  ? >  job =  run . getParent  ( ) ;  if  (  !   Util . filter  (  job . getActions  ( ) ,  TestResultProjectAction . class ) . isEmpty  ( ) )  {  return  Collections . emptySet  ( ) ; }  return  Collections . singleton  (  new TestResultProjectAction  ( job ) ) ; }   public synchronized void setResult  (  TestResult result ,  TaskListener listener )  {   result . freeze  ( this ) ;   totalCount =  result . getTotalCount  ( ) ;   failCount =  result . getFailCount  ( ) ;   skipCount =  result . getSkipCount  ( ) ;  if  (  run != null )  {  try  {    getDataFile  ( ) . write  ( result ) ; }  catch (   IOException e )  {   e . printStackTrace  (  listener . fatalError  ( "Failed to save the JUnit test result" ) ) ; } }    this . result =  new  WeakReference  < TestResult >  ( result ) ; }    @ Deprecated public void setResult  (  TestResult result ,  BuildListener listener )  {   setResult  ( result ,  ( TaskListener ) listener ) ; }   private XmlFile getDataFile  ( )  {  return  new XmlFile  ( XSTREAM ,  new File  (  run . getRootDir  ( ) , "junitResult.xml" ) ) ; }   public synchronized TestResult getResult  ( )  {  TestResult  r ;  if  (  result == null )  {   r =  load  ( ) ;   result =  new  WeakReference  < TestResult >  ( r ) ; } else  {   r =  result . get  ( ) ; }  if  (  r == null )  {   r =  load  ( ) ;   result =  new  WeakReference  < TestResult >  ( r ) ; }  if  (  totalCount == null )  {   totalCount =  r . getTotalCount  ( ) ;   failCount =  r . getFailCount  ( ) ;   skipCount =  r . getSkipCount  ( ) ; }  return r ; }    @ Override public synchronized  int getFailCount  ( )  {  if  (  totalCount == null )   getResult  ( ) ;  return failCount ; }    @ Override public synchronized  int getSkipCount  ( )  {  if  (  totalCount == null )   getResult  ( ) ;  return skipCount ; }    @ Override public synchronized  int getTotalCount  ( )  {  if  (  totalCount == null )   getResult  ( ) ;  return totalCount ; }    @ Override public  double getHealthScaleFactor  ( )  {  return   healthScaleFactor == null ? 1.0 : healthScaleFactor ; }   public void setHealthScaleFactor  (   double healthScaleFactor )  {    this . healthScaleFactor =  Math . max  ( 0.0 , healthScaleFactor ) ; }    @ Override public  List  < CaseResult > getFailedTests  ( )  {  return   getResult  ( ) . getFailedTests  ( ) ; }    @ Override public  List  < CaseResult > getPassedTests  ( )  {  return   getResult  ( ) . getPassedTests  ( ) ; }    @ Override public  List  < CaseResult > getSkippedTests  ( )  {  return   getResult  ( ) . getSkippedTests  ( ) ; }   private TestResult load  ( )  {  TestResult  r ;  try  {   r =  ( TestResult )   getDataFile  ( ) . read  ( ) ; }  catch (   IOException e )  {   logger . log  (  Level . WARNING ,  "Failed to load " +  getDataFile  ( ) , e ) ;   r =  new TestResult  ( ) ; }   r . freeze  ( this ) ;  return r ; }   public Object getTarget  ( )  {  return  getResult  ( ) ; }   public  List  < TestAction > getActions  (  TestObject object )  {   List  < TestAction >  result =  new  ArrayList  < TestAction >  ( ) ;  if  (  testData != null )  {  synchronized  ( testData )  {  for ( Data data : testData )  for ( TestAction ta :  data . getTestAction  ( object ) )  if  (  ta != null )   result . add  ( ta ) ; } }  return  Collections . unmodifiableList  ( result ) ; }   List  < Data > getData  ( )  {  return testData ; }   public void setData  (   List  < Data > testData )  {    this . testData = testData ; }   public void mergeResult  (  TestResult additionalResult ,  TaskListener listener )  {  TestResult  original =  getResult  ( ) ;   original . merge  ( additionalResult ) ;   setResult  ( original , listener ) ; }   public static abstract class Data  {   public abstract  List  <  ? extends TestAction > getTestAction  (     hudson . tasks . junit . TestObject testObject ) ; }   public Object readResolve  ( )  {   super . readResolve  ( ) ;  if  (  testData == null )  {   testData =  new  ArrayList  < Data >  ( 0 ) ; }  return this ; }   private static final Logger  logger =  Logger . getLogger  (   TestResultAction . class . getName  ( ) ) ;   private static final XStream  XSTREAM =  new XStream2  ( ) ;  static  {   XSTREAM . alias  ( "result" ,  TestResult . class ) ;   XSTREAM . alias  ( "suite" ,  SuiteResult . class ) ;   XSTREAM . alias  ( "case" ,  CaseResult . class ) ;   XSTREAM . registerConverter  (  new HeapSpaceStringConverter  ( ) , 100 ) ; }   public void addData  (  Data data )  {  synchronized  ( testData )  {    this . testData . add  ( data ) ; } } }