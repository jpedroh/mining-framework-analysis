  package   hudson . tasks . junit ;   import  hudson . AbortException ;  import  hudson . Extension ;  import  hudson . FilePath ;  import  hudson . Launcher ;  import   hudson . model . AbstractBuild ;  import   hudson . model . AbstractProject ;  import   hudson . model . BuildListener ;  import   hudson . model . Descriptor ;  import   hudson . model . Result ;  import   hudson . model . Run ;  import   hudson . model . Saveable ;  import   hudson . model . TaskListener ;  import   hudson . tasks . BuildStepDescriptor ;  import   hudson . tasks . BuildStepMonitor ;  import   hudson . tasks . Publisher ;  import   hudson . tasks . Recorder ;  import     hudson . tasks . junit . TestResultAction . Data ;  import   hudson . util . DescribableList ;  import   hudson . util . FormValidation ;  import     org . apache . tools . ant . DirectoryScanner ;  import      org . apache . tools . ant . types . FileSet ;  import    org . kohsuke . stapler . AncestorInPath ;  import    org . kohsuke . stapler . DataBoundConstructor ;  import    org . kohsuke . stapler . QueryParameter ;  import   java . io . IOException ;  import   java . util . Collections ;  import   java . util . List ;  import   javax . annotation . CheckForNull ;  import   javax . annotation . Nonnull ;  import   jenkins . tasks . SimpleBuildStep ;  import    org . kohsuke . stapler . DataBoundSetter ;   public class JUnitResultArchiver  extends Recorder  implements  SimpleBuildStep , JUnitTask  {   private final String  testResults ;   private boolean  keepLongStdio ;   private  DescribableList  < TestDataPublisher ,  Descriptor  < TestDataPublisher > >  testDataPublishers ;   private Double  healthScaleFactor ;   private boolean  allowEmptyResults ;    @ DataBoundConstructor public JUnitResultArchiver  (  String testResults )  {    this . testResults = testResults ; }    @ Deprecated public JUnitResultArchiver  (  String testResults ,   DescribableList  < TestDataPublisher ,  Descriptor  < TestDataPublisher > > testDataPublishers )  {  this  ( testResults , false , testDataPublishers ) ; }    @ Deprecated public JUnitResultArchiver  (  String testResults ,  boolean keepLongStdio ,   DescribableList  < TestDataPublisher ,  Descriptor  < TestDataPublisher > > testDataPublishers )  {  this  ( testResults , keepLongStdio , testDataPublishers , 1.0 ) ; }    @ Deprecated public JUnitResultArchiver  (  String testResults ,  boolean keepLongStdio ,   DescribableList  < TestDataPublisher ,  Descriptor  < TestDataPublisher > > testDataPublishers ,   double healthScaleFactor )  {    this . testResults = testResults ;   setKeepLongStdio  ( keepLongStdio ) ;   setTestDataPublishers  (   testDataPublishers == null ?  Collections .  < TestDataPublisher > emptyList  ( ) : testDataPublishers ) ;   setHealthScaleFactor  ( healthScaleFactor ) ;   setAllowEmptyResults  ( false ) ; }   private TestResult parse  (  String expandedTestResults ,   Run  <  ? ,  ? > run ,    @ Nonnull FilePath workspace ,  Launcher launcher ,  TaskListener listener )  throws IOException , InterruptedException  {  return  parse  ( this , null , null , expandedTestResults , run , workspace , launcher , listener ) ; }   private static TestResult parse  (    @ Nonnull JUnitTask task ,    @ CheckForNull String nodeId ,   List  < String > enclosingBlocks ,  String expandedTestResults ,   Run  <  ? ,  ? > run ,    @ Nonnull FilePath workspace ,  Launcher launcher ,  TaskListener listener )  throws IOException , InterruptedException  {  return   new JUnitParser  (  task . isKeepLongStdio  ( ) ,  task . isAllowEmptyResults  ( ) ) . parseResult  ( expandedTestResults , run , nodeId , enclosingBlocks , workspace , launcher , listener ) ; }    @ Deprecated protected TestResult parse  (  String expandedTestResults ,  AbstractBuild build ,  Launcher launcher ,  BuildListener listener )  throws IOException , InterruptedException  {   final FilePath  workspace =  build . getWorkspace  ( ) ;  if  (  workspace == null )  {  throw  new IllegalArgumentException  ( "The provided build has no workspace" ) ; }  return  parse  ( expandedTestResults , build , workspace , launcher , listener ) ; }    @ Override public void perform  (  Run build ,  FilePath workspace ,  Launcher launcher ,  TaskListener listener )  throws InterruptedException , IOException  {  TestResultAction  action =  parseAndAttach  ( this , null , null , build , workspace , launcher , listener ) ; 
<<<<<<<
 if  (   action != null &&    action . getResult  ( ) . getFailCount  ( ) > 0 )   build . setResult  (  Result . UNSTABLE ) ;
=======
 synchronized  ( build )  {  TestResultAction  action =  build . getAction  (  TestResultAction . class ) ;  boolean  appending ;  if  (  action == null )  {   appending = false ;   action =  new TestResultAction  ( build , result , listener ) ; } else  {   appending = true ;   result . freeze  ( action ) ;   action . mergeResult  ( result , listener ) ; }   action . setHealthScaleFactor  (  getHealthScaleFactor  ( ) ) ;  if  (  result . isEmpty  ( ) )  {  if  (   build . getResult  ( ) ==  Result . FAILURE )  {  return ; }  if  (  this . allowEmptyResults )  {    listener . getLogger  ( ) . println  (  Messages . JUnitResultArchiver_ResultIsEmpty  ( ) ) ;  return ; }  throw  new AbortException  (  Messages . JUnitResultArchiver_ResultIsEmpty  ( ) ) ; }  if  (  testDataPublishers != null )  {  for ( TestDataPublisher tdp : testDataPublishers )  {  Data  d =  tdp . contributeTestData  ( build , workspace , launcher , listener , result ) ;  if  (  d != null )  {   action . addData  ( d ) ; } } }  if  ( appending )  {   build . save  ( ) ; } else  {   build . addAction  ( action ) ; }  if  (    action . getResult  ( ) . getFailCount  ( ) > 0 )   build . setResult  (  Result . UNSTABLE ) ; }
>>>>>>>
 }   public static TestResultAction parseAndAttach  (    @ Nonnull JUnitTask task ,    @ CheckForNull String nodeId ,   List  < String > enclosingBlocks ,  Run build ,  FilePath workspace ,  Launcher launcher ,  TaskListener listener )  throws InterruptedException , IOException  {    listener . getLogger  ( ) . println  (  Messages . JUnitResultArchiver_Recording  ( ) ) ;   final String  testResults =   build . getEnvironment  ( listener ) . expand  (  task . getTestResults  ( ) ) ;  TestResult  result =  parse  ( task , nodeId , enclosingBlocks , testResults , build , workspace , launcher , listener ) ;  synchronized  ( build )  {  TestResultAction  action =  build . getAction  (  TestResultAction . class ) ;  boolean  appending ;  if  (  action == null )  {   appending = false ;   action =  new TestResultAction  ( build , result , listener ) ; } else  {   appending = true ;   result . freeze  ( action ) ;   action . mergeResult  ( result , listener ) ; }   action . setHealthScaleFactor  (  task . getHealthScaleFactor  ( ) ) ;  if  (  result . isEmpty  ( ) )  {  if  (   build . getResult  ( ) ==  Result . FAILURE )  {  return null ; }  if  (  task . isAllowEmptyResults  ( ) )  {    listener . getLogger  ( ) . println  (  Messages . JUnitResultArchiver_ResultIsEmpty  ( ) ) ;  return null ; }  throw  new AbortException  (  Messages . JUnitResultArchiver_ResultIsEmpty  ( ) ) ; }   List  < Data >  data =  action . getData  ( ) ;  if  (   task . getTestDataPublishers  ( ) != null )  {  for ( TestDataPublisher tdp :  task . getTestDataPublishers  ( ) )  {  Data  d =  tdp . contributeTestData  ( build , workspace , launcher , listener , result ) ;  if  (  d != null )  {   data . add  ( d ) ; } } }  if  ( appending )  {   build . save  ( ) ; } else  {   build . addAction  ( action ) ; }  return action ; } }   protected TestResult parseResult  (  DirectoryScanner ds ,   long buildTime )  throws IOException  {  return  new TestResult  ( buildTime , ds ) ; }   public BuildStepMonitor getRequiredMonitorService  ( )  {  return  BuildStepMonitor . NONE ; }   public String getTestResults  ( )  {  return testResults ; }   public  double getHealthScaleFactor  ( )  {  return   healthScaleFactor == null ? 1.0 : healthScaleFactor ; }    @ DataBoundSetter public final void setHealthScaleFactor  (   double healthScaleFactor )  {    this . healthScaleFactor =  Math . max  ( 0.0 , healthScaleFactor ) ; }   public  @ Nonnull  List  < TestDataPublisher > getTestDataPublishers  ( )  {  return   testDataPublishers == null ?  Collections .  < TestDataPublisher > emptyList  ( ) : testDataPublishers ; }    @ DataBoundSetter public final void setTestDataPublishers  (    @ Nonnull  List  < TestDataPublisher > testDataPublishers )  {    this . testDataPublishers =  new  DescribableList  < TestDataPublisher ,  Descriptor  < TestDataPublisher > >  (  Saveable . NOOP ) ;    this . testDataPublishers . addAll  ( testDataPublishers ) ; }   public boolean isKeepLongStdio  ( )  {  return keepLongStdio ; }    @ DataBoundSetter public final void setKeepLongStdio  (  boolean keepLongStdio )  {    this . keepLongStdio = keepLongStdio ; }   public boolean isAllowEmptyResults  ( )  {  return allowEmptyResults ; }    @ DataBoundSetter public final void setAllowEmptyResults  (  boolean allowEmptyResults )  {    this . allowEmptyResults = allowEmptyResults ; }   private static final  long  serialVersionUID = 1L ;    @ Extension public static class DescriptorImpl  extends  BuildStepDescriptor  < Publisher >  {   public String getDisplayName  ( )  {  return  Messages . JUnitResultArchiver_DisplayName  ( ) ; }   public FormValidation doCheckTestResults  (    @ AncestorInPath AbstractProject project ,    @ QueryParameter String value )  throws IOException  {  if  (  project == null )  {  return  FormValidation . ok  ( ) ; }  return  FilePath . validateFileMask  (  project . getSomeWorkspace  ( ) , value ) ; }   public boolean isApplicable  (   Class  <  ? extends AbstractProject > jobType )  {  return true ; }   public FormValidation doCheckHealthScaleFactor  (    @ QueryParameter  double value )  {  if  (  value < 1e-7 )  return  FormValidation . warning  ( "Test health reporting disabled" ) ;  return  FormValidation . ok  (  Messages . JUnitResultArchiver_HealthScaleFactorAnalysis  ( 1 ,  (  int )  (  100.0 -  Math . max  ( 0.0 ,  Math . min  ( 100.0 ,  1 * value ) ) ) , 5 ,  (  int )  (  100.0 -  Math . max  ( 0.0 ,  Math . min  ( 100.0 ,  5 * value ) ) ) ) ) ; } } }