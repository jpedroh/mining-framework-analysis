  package   hudson . tasks . junit ;   import  hudson . AbortException ;  import  hudson . Util ;  import   hudson . model . Run ;  import    hudson . tasks . test . AbstractTestResultAction ;  import    hudson . tasks . test . MetaTabulatedResult ;  import    hudson . tasks . test . TestObject ;  import   java . io . File ;  import   java . io . IOException ;  import   java . io . PrintWriter ;  import   java . io . Serializable ;  import   java . io . StringWriter ;  import   java . util . ArrayList ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . HashMap ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Set ;  import   java . util . TreeMap ;  import   java . util . TreeSet ;  import     org . apache . tools . ant . DirectoryScanner ;  import   org . dom4j . DocumentException ;  import      org . jenkinsci . plugins . workflow . graph . FlowNode ;  import    org . kohsuke . stapler . StaplerRequest ;  import    org . kohsuke . stapler . StaplerResponse ;  import     org . kohsuke . stapler . export . Exported ;  import   javax . annotation . CheckForNull ;  import   javax . annotation . Nonnull ;   public final class TestResult  extends MetaTabulatedResult  {   private final  List  < SuiteResult >  suites =  new  ArrayList  < SuiteResult >  ( ) ;   private transient  Map  < String , SuiteResult >  suitesByName ;   private transient  Map  < String ,  Map  < String ,  List  < SuiteResult > > >  suitesByRunAndNode ;   private transient  Map  < String ,  Map  < String , BlocksWithChildren > >  testsByRunAndBlock ;   private transient  Map  < String , PackageResult >  byPackages ;   private transient AbstractTestResultAction  parentAction ;   private transient TestObject  parent ;   private transient  int  totalTests ;   private transient  List  < CaseResult >  passedTests ;   private transient  List  < CaseResult >  skippedTests ;   private transient  int  skippedTestsCounter ;   private  float  duration ;   private transient  List  < CaseResult >  failedTests ;   private final boolean  keepLongStdio ;   public TestResult  ( )  {  this  ( false ) ; }   public TestResult  (  boolean keepLongStdio )  {    this . keepLongStdio = keepLongStdio ; }    @ Deprecated public TestResult  (   long buildTime ,  DirectoryScanner results )  throws IOException  {  this  ( buildTime , results , false ) ; }    @ Deprecated public TestResult  (   long buildTime ,  DirectoryScanner results ,  boolean keepLongStdio )  throws IOException  {  this  ( buildTime , results , keepLongStdio , null , null , null ) ; }   public TestResult  (   long buildTime ,  DirectoryScanner results ,  boolean keepLongStdio ,  String runId ,  String nodeId ,   List  < String > enclosingBlocks )  throws IOException  {    this . keepLongStdio = keepLongStdio ;   parse  ( buildTime , results , runId , nodeId , enclosingBlocks ) ; }   public TestObject getParent  ( )  {  return parent ; }    @ Override public void setParent  (  TestObject parent )  {    this . parent = parent ; }    @ Override public TestResult getTestResult  ( )  {  return this ; }    @ Deprecated public void parse  (   long buildTime ,  DirectoryScanner results )  throws IOException  {   parse  ( buildTime , results , null , null , null ) ; }   public void parse  (   long buildTime ,  DirectoryScanner results ,  String runId ,  String nodeId ,   List  < String > enclosingBlocks )  throws IOException  {   String  [ ]  includedFiles =  results . getIncludedFiles  ( ) ;  File  baseDir =  results . getBasedir  ( ) ;   parse  ( buildTime , baseDir , runId , nodeId , enclosingBlocks , includedFiles ) ; }    @ Deprecated public void parse  (   long buildTime ,  File baseDir ,   String  [ ] reportFiles )  throws IOException  {   parse  ( buildTime , baseDir , null , null , null , reportFiles ) ; }   public void parse  (   long buildTime ,  File baseDir ,  String runId ,  String nodeId ,   List  < String > enclosingBlocks ,   String  [ ] reportFiles )  throws IOException  {  boolean  parsed = false ;  for ( String value : reportFiles )  {  File  reportFile =  new File  ( baseDir , value ) ;  if  (   buildTime - 3000 <=  reportFile . lastModified  ( ) )  {   parsePossiblyEmpty  ( reportFile , runId , nodeId , enclosingBlocks ) ;   parsed = true ; } }  if  (  ! parsed )  {   long  localTime =  System . currentTimeMillis  ( ) ;  if  (  localTime <  buildTime - 1000 )  throw  new AbortException  (   "Clock on this slave is out of sync with the master, and therefore \n" + "I can't figure out what test results are new and what are old.\n" + "Please keep the slave clock in sync with the master." ) ;  File  f =  new File  ( baseDir ,  reportFiles [ 0 ] ) ;  throw  new AbortException  (  String . format  (  "Test reports were found but none of them are new. Did leafNodes run? %n" + "For example, %s is %s old%n" , f ,  Util . getTimeSpanString  (  buildTime -  f . lastModified  ( ) ) ) ) ; } }    @ Deprecated public void parse  (   long buildTime ,   Iterable  < File > reportFiles )  throws IOException  {   parse  ( buildTime , reportFiles , null , null , null ) ; }   public void parse  (   long buildTime ,   Iterable  < File > reportFiles ,  String runId ,  String nodeId ,   List  < String > enclosingBlocks )  throws IOException  {  boolean  parsed = false ;  for ( File reportFile : reportFiles )  {  if  (   buildTime - 3000 <=  reportFile . lastModified  ( ) )  {   parsePossiblyEmpty  ( reportFile , runId , nodeId , enclosingBlocks ) ;   parsed = true ; } }  if  (  ! parsed )  {   long  localTime =  System . currentTimeMillis  ( ) ;  if  (  localTime <  buildTime - 1000 )  throw  new AbortException  (   "Clock on this slave is out of sync with the master, and therefore \n" + "I can't figure out what test results are new and what are old.\n" + "Please keep the slave clock in sync with the master." ) ;  File  f =   reportFiles . iterator  ( ) . next  ( ) ;  throw  new AbortException  (  String . format  (  "Test reports were found but none of them are new. Did leafNodes run? %n" + "For example, %s is %s old%n" , f ,  Util . getTimeSpanString  (  buildTime -  f . lastModified  ( ) ) ) ) ; } }   private void parsePossiblyEmpty  (  File reportFile ,  String runId ,  String nodeId ,   List  < String > enclosingBlocks )  throws IOException  {  if  (   reportFile . length  ( ) == 0 )  {  SuiteResult  sr =  new SuiteResult  (  reportFile . getName  ( ) , "" , "" , runId , nodeId , enclosingBlocks ) ;   sr . addCase  (  new CaseResult  ( sr , "[empty]" ,   "Test report file " +  reportFile . getAbsolutePath  ( ) + " was length 0" ) ) ;   add  ( sr ) ; } else  {   parse  ( reportFile , runId , nodeId , enclosingBlocks ) ; } }   private void add  (  SuiteResult sr )  {  for ( SuiteResult s : suites )  {  if  (       s . getName  ( ) . equals  (  sr . getName  ( ) ) &&  nullSafeEq  (  s . getId  ( ) ,  sr . getId  ( ) ) &&  nullSafeEq  (  s . getRunId  ( ) ,  sr . getRunId  ( ) ) &&  nullSafeEq  (  s . getNodeId  ( ) ,  sr . getNodeId  ( ) ) &&  nullSafeEq  (  s . getEnclosingBlocks  ( ) ,  sr . getEnclosingBlocks  ( ) ) )  {  if  (  strictEq  (  s . getTimestamp  ( ) ,  sr . getTimestamp  ( ) ) )  {  return ; }   duration +=  sr . getDuration  ( ) ;   s . merge  ( sr ) ;  return ; } }   suites . add  ( sr ) ;   duration +=  sr . getDuration  ( ) ; }  void merge  (  TestResult other )  {  for ( SuiteResult suite :  other . suites )  {   suite . setParent  ( null ) ;   add  ( suite ) ; }   tally  ( ) ; }   private boolean strictEq  (  Object lhs ,  Object rhs )  {  return    lhs != null &&  rhs != null &&  lhs . equals  ( rhs ) ; }   private boolean nullSafeEq  (  Object lhs ,  Object rhs )  {  if  (  lhs == null )  {  return  rhs == null ; }  return  lhs . equals  ( rhs ) ; }    @ Deprecated public void parse  (  File reportFile )  throws IOException  {   parse  ( reportFile , null , null , null ) ; }   public void parse  (  File reportFile ,  String runId ,  String nodeId ,   List  < String > enclosingBlocks )  throws IOException  {  try  {  for ( SuiteResult suiteResult :  SuiteResult . parse  ( reportFile , keepLongStdio , runId , nodeId , enclosingBlocks ) )   add  ( suiteResult ) ; }  catch (   InterruptedException e )  {  throw  new IOException  (  "Failed to read " + reportFile , e ) ; }  catch (   RuntimeException e )  {  throw  new IOException  (  "Failed to read " + reportFile , e ) ; }  catch (   DocumentException e )  {  if  (  !   reportFile . getPath  ( ) . endsWith  ( ".xml" ) )  {  throw  new IOException  (    "Failed to read " + reportFile + "\n" + "Is this really a JUnit report file? Your configuration must be matching too many files" , e ) ; } else  {  SuiteResult  sr =  new SuiteResult  (  reportFile . getName  ( ) , "" , "" , null , null , null ) ;  StringWriter  writer =  new StringWriter  ( ) ;   e . printStackTrace  (  new PrintWriter  ( writer ) ) ;  String  error =    "Failed to read test report file " +  reportFile . getAbsolutePath  ( ) + "\n" +  writer . toString  ( ) ;   sr . addCase  (  new CaseResult  ( sr , "[failed-to-read]" , error ) ) ;   add  ( sr ) ; } } }   public String getDisplayName  ( )  {  return  Messages . TestResult_getDisplayName  ( ) ; }    @ Override public  Run  <  ? ,  ? > getRun  ( )  {  return   parentAction == null ? null :  parentAction . run ; }    @ Override public    hudson . tasks . test . TestResult findCorrespondingResult  (  String id )  {  if  (    getId  ( ) . equals  ( id ) ||  (  id == null ) )  {  return this ; }  String  firstElement = null ;  String  subId = null ;   int  sepIndex =  id . indexOf  ( '/' ) ;  if  (  sepIndex < 0 )  {   firstElement = id ;   subId = null ; } else  {   firstElement =  id . substring  ( 0 , sepIndex ) ;   subId =  id . substring  (  sepIndex + 1 ) ;  if  (   subId . length  ( ) == 0 )  {   subId = null ; } }  String  packageName = null ;  if  (  firstElement . equals  (  getId  ( ) ) )  {   sepIndex =  subId . indexOf  ( '/' ) ;  if  (  sepIndex < 0 )  {   packageName = subId ;   subId = null ; } else  {   packageName =  subId . substring  ( 0 , sepIndex ) ;   subId =  subId . substring  (  sepIndex + 1 ) ; } } else  {   packageName = firstElement ;   subId = null ; }  PackageResult  child =  byPackage  ( packageName ) ;  if  (  child != null )  {  if  (  subId != null )  {  return  child . findCorrespondingResult  ( subId ) ; } else  {  return child ; } } else  {  return null ; } }    @ Override public String getTitle  ( )  {  return  Messages . TestResult_getTitle  ( ) ; }    @ Override public String getChildTitle  ( )  {  return  Messages . TestResult_getChildTitle  ( ) ; }    @ Exported  (  visibility = 999 )  @ Override public  float getDuration  ( )  {  return duration ; }    @ Exported  (  visibility = 999 )  @ Override public  int getPassCount  ( )  {  return   totalTests -  getFailCount  ( ) -  getSkipCount  ( ) ; }    @ Exported  (  visibility = 999 )  @ Override public  int getFailCount  ( )  {  if  (  failedTests == null )  return 0 ; else  return  failedTests . size  ( ) ; }    @ Exported  (  visibility = 999 )  @ Override public  int getSkipCount  ( )  {  return skippedTestsCounter ; }    @ Exported  (  visibility = 999 ) public boolean isEmpty  ( )  {  return   getTotalCount  ( ) == 0 ; }    @ Override public  List  < CaseResult > getFailedTests  ( )  {  return failedTests ; }    @ Override public synchronized  List  < CaseResult > getPassedTests  ( )  {  if  (  passedTests == null )  {   passedTests =  new  ArrayList  < CaseResult >  ( ) ;  for ( SuiteResult s : suites )  {  for ( CaseResult cr :  s . getCases  ( ) )  {  if  (  cr . isPassed  ( ) )  {   passedTests . add  ( cr ) ; } } } }  return passedTests ; }    @ Override public synchronized  List  < CaseResult > getSkippedTests  ( )  {  if  (  skippedTests == null )  {   skippedTests =  new  ArrayList  < CaseResult >  ( ) ;  for ( SuiteResult s : suites )  {  for ( CaseResult cr :  s . getCases  ( ) )  {  if  (  cr . isSkipped  ( ) )  {   skippedTests . add  ( cr ) ; } } } }  return skippedTests ; }    @ Override public  int getFailedSince  ( )  {  throw  new UnsupportedOperationException  ( ) ; }    @ Override public  Run  <  ? ,  ? > getFailedSinceRun  ( )  {  throw  new UnsupportedOperationException  ( ) ; }    @ Override public String getStdout  ( )  {  StringBuilder  sb =  new StringBuilder  ( ) ;  for ( SuiteResult suite : suites )  {   sb . append  (  "Standard Out (stdout) for Suite: " +  suite . getName  ( ) ) ;   sb . append  (  suite . getStdout  ( ) ) ; }  return  sb . toString  ( ) ; }    @ Override public String getStderr  ( )  {  StringBuilder  sb =  new StringBuilder  ( ) ;  for ( SuiteResult suite : suites )  {   sb . append  (  "Standard Error (stderr) for Suite: " +  suite . getName  ( ) ) ;   sb . append  (  suite . getStderr  ( ) ) ; }  return  sb . toString  ( ) ; }    @ Override public String getErrorStackTrace  ( )  {  return "No error stack traces available at this level. Drill down to individual leafNodes to find stack traces." ; }    @ Override public String getErrorDetails  ( )  {  return "No error details available at this level. Drill down to individual leafNodes to find details." ; }    @ Override public boolean isPassed  ( )  {  return   getFailCount  ( ) == 0 ; }    @ Override public  Collection  < PackageResult > getChildren  ( )  {  return  byPackages . values  ( ) ; }    @ Override public boolean hasChildren  ( )  {  return  !  suites . isEmpty  ( ) ; }    @ Exported  (  inline = true ,  visibility = 9 ) public  Collection  < SuiteResult > getSuites  ( )  {  return suites ; }    @ Override public String getName  ( )  {  return "junit" ; }    @ Override public Object getDynamic  (  String token ,  StaplerRequest req ,  StaplerResponse rsp )  {  if  (  token . equals  (  getId  ( ) ) )  {  return this ; }  PackageResult  result =  byPackage  ( token ) ;  if  (  result != null )  {  return result ; } else  {  return  super . getDynamic  ( token , req , rsp ) ; } }   public PackageResult byPackage  (  String packageName )  {  return  byPackages . get  ( packageName ) ; }   public SuiteResult getSuite  (  String name )  {  return  suitesByName . get  ( name ) ; }   public boolean hasMultipleBlocksForRun  (    @ Nonnull String runId )  {   Map  < String , BlocksWithChildren >  blocksForRun =  testsByRunAndBlock . get  ( runId ) ;  if  (   blocksForRun != null &&   blocksForRun . size  ( ) > 1 )  {   int  nonNested = 0 ;  for ( BlocksWithChildren b :  blocksForRun . values  ( ) )  {  if  (  !   b . leafNodes . isEmpty  ( ) )  {   nonNested ++ ; } }  return  nonNested > 1 ; }  return false ; }    @ Nonnull public TestResult getResultByRunAndNode  (    @ Nonnull String runId ,    @ Nonnull String nodeId )  {  return  getResultByRunAndNodes  ( runId ,  Collections . singletonList  ( nodeId ) ) ; }    @ Nonnull public TestResult getResultByRunAndNodes  (    @ Nonnull String runId ,    @ Nonnull  List  < String > nodeIds )  {  TestResult  result =  new TestResult  ( ) ;  if  (  suitesByRunAndNode . containsKey  ( runId ) )  {  for ( String n : nodeIds )  {   List  < SuiteResult >  suites =   suitesByRunAndNode . get  ( runId ) . get  ( n ) ;  if  (  suites != null )  {  for ( SuiteResult s : suites )  {   result . add  ( s ) ; } } } }   result . setParentAction  ( parentAction ) ;  return result ; }    @ Override public void setParentAction  (  AbstractTestResultAction action )  {    this . parentAction = action ;   tally  ( ) ; }    @ Override public AbstractTestResultAction getParentAction  ( )  {  return  this . parentAction ; }    @ Override public void tally  ( )  {   suitesByName =  new  HashMap  < String , SuiteResult >  ( ) ;   suitesByRunAndNode =  new  HashMap  < >  ( ) ;   testsByRunAndBlock =  new  HashMap  < >  ( ) ;   failedTests =  new  ArrayList  < CaseResult >  ( ) ;   skippedTests = null ;   passedTests = null ;   byPackages =  new  TreeMap  < String , PackageResult >  ( ) ;   totalTests = 0 ;   skippedTestsCounter = 0 ;  for ( SuiteResult s : suites )  {   s . setParent  ( this ) ;   suitesByName . put  (  s . getName  ( ) , s ) ;  if  (    s . getRunId  ( ) != null &&   s . getNodeId  ( ) != null )  {   addSuiteByRunAndNode  ( s ) ; }   List  < CaseResult >  cases =  s . getCases  ( ) ;  for ( CaseResult cr : cases )  {   cr . setParentAction  (  this . parentAction ) ;   cr . setParentSuiteResult  ( s ) ;   cr . tally  ( ) ;  String  pkg =  cr . getPackageName  ( ) ,  spkg =  safe  ( pkg ) ;  PackageResult  pr =  byPackage  ( spkg ) ;  if  (  pr == null )   byPackages . put  ( spkg ,  pr =  new PackageResult  ( this , pkg ) ) ;   pr . add  ( cr ) ; } }  for ( PackageResult pr :  byPackages . values  ( ) )  {   pr . tally  ( ) ;   skippedTestsCounter +=  pr . getSkipCount  ( ) ;   failedTests . addAll  (  pr . getFailedTests  ( ) ) ;   totalTests +=  pr . getTotalCount  ( ) ; } }   public void freeze  (  TestResultAction parent )  {    this . parentAction = parent ;  if  (  suitesByName == null )  {   suitesByName =  new  HashMap  < String , SuiteResult >  ( ) ;   suitesByRunAndNode =  new  HashMap  < >  ( ) ;   testsByRunAndBlock =  new  HashMap  < >  ( ) ;   totalTests = 0 ;   failedTests =  new  ArrayList  < CaseResult >  ( ) ;   skippedTests = null ;   passedTests = null ;   byPackages =  new  TreeMap  < String , PackageResult >  ( ) ; }  for ( SuiteResult s : suites )  {  if  (  !  s . freeze  ( this ) )  continue ;   suitesByName . put  (  s . getName  ( ) , s ) ;  if  (    s . getRunId  ( ) != null &&   s . getNodeId  ( ) != null )  {   addSuiteByRunAndNode  ( s ) ; }   totalTests +=   s . getCases  ( ) . size  ( ) ;  for ( CaseResult cr :  s . getCases  ( ) )  {  if  (  cr . isSkipped  ( ) )  {   skippedTestsCounter ++ ;  if  (  skippedTests != null )  {   skippedTests . add  ( cr ) ; } } else  if  (  !  cr . isPassed  ( ) )  {   failedTests . add  ( cr ) ; } else  {  if  (  passedTests != null )  {   passedTests . add  ( cr ) ; } }  String  pkg =  cr . getPackageName  ( ) ,  spkg =  safe  ( pkg ) ;  PackageResult  pr =  byPackage  ( spkg ) ;  if  (  pr == null )   byPackages . put  ( spkg ,  pr =  new PackageResult  ( this , pkg ) ) ;   pr . add  ( cr ) ; } }   Collections . sort  ( failedTests ,  CaseResult . BY_AGE ) ;  if  (  passedTests != null )  {   Collections . sort  ( passedTests ,  CaseResult . BY_AGE ) ; }  if  (  skippedTests != null )  {   Collections . sort  ( skippedTests ,  CaseResult . BY_AGE ) ; }  for ( PackageResult pr :  byPackages . values  ( ) )   pr . freeze  ( ) ; }   private void addSuiteByRunAndNode  (  SuiteResult s )  {  String  runId =  s . getRunId  ( ) ;  String  nodeId =  s . getNodeId  ( ) ;  if  (   runId != null &&  nodeId != null )  {  if  (   suitesByRunAndNode . get  ( runId ) == null )  {   suitesByRunAndNode . put  ( runId ,  new  HashMap  < String ,  List  < SuiteResult > >  ( ) ) ; }  if  (    suitesByRunAndNode . get  ( runId ) . get  ( nodeId ) == null )  {    suitesByRunAndNode . get  ( runId ) . put  ( nodeId ,  new  ArrayList  < SuiteResult >  ( ) ) ; }     suitesByRunAndNode . get  ( runId ) . get  ( nodeId ) . add  ( s ) ;   List  < String >  enclosingBlocks =  new  ArrayList  < >  (  s . getEnclosingBlocks  ( ) ) ;  if  (  !  enclosingBlocks . isEmpty  ( ) )  {  if  (   testsByRunAndBlock . get  ( runId ) == null )  {   testsByRunAndBlock . put  ( runId ,  new  HashMap  < String , BlocksWithChildren >  ( ) ) ; }   populateBlocks  ( runId , enclosingBlocks , nodeId , null ) ; } } }   private void addOrMergeBlock  (    @ Nonnull String runId ,    @ Nonnull BlocksWithChildren b )  {  if  (   testsByRunAndBlock . get  ( runId ) . containsKey  (  b . getBlockId  ( ) ) )  {     testsByRunAndBlock . get  ( runId ) . get  (  b . getBlockId  ( ) ) . merge  ( b ) ; } else  {    testsByRunAndBlock . get  ( runId ) . put  (  b . getBlockId  ( ) , b ) ; } }    @ CheckForNull public BlocksWithChildren getBlockWithChildren  (    @ Nonnull String runId ,    @ Nonnull String blockId )  {  if  (  testsByRunAndBlock . containsKey  ( runId ) )  {   Map  < String , BlocksWithChildren >  runBlocks =  testsByRunAndBlock . get  ( runId ) ;  if  (  runBlocks . containsKey  ( blockId ) )  {  return  runBlocks . get  ( blockId ) ; } }  return null ; }   private void populateBlocks  (    @ Nonnull String runId ,    @ Nonnull  List  < String > innermostFirst ,    @ Nonnull String nodeId ,    @ CheckForNull BlocksWithChildren nested )  {  if  (  innermostFirst . isEmpty  ( ) )  {  if  (  nested != null )  {   addOrMergeBlock  ( runId , nested ) ; } } else  {  String  innermost =  innermostFirst . remove  ( 0 ) ;  if  (  nested == null )  {   nested =  new BlocksWithChildren  ( innermost ) ;   nested . addLeafNode  ( nodeId ) ;   addOrMergeBlock  ( runId , nested ) ;   populateBlocks  ( runId , innermostFirst , nodeId , nested ) ; } else  {  BlocksWithChildren  nextLevel =  new BlocksWithChildren  ( innermost ) ;   nextLevel . addChildBlock  ( nested ) ;   addOrMergeBlock  ( runId , nextLevel ) ;   populateBlocks  ( runId , innermostFirst , nodeId , nextLevel ) ; } } }   private static final  long  serialVersionUID = 1L ;   public static class BlocksWithChildren  implements  Serializable  {   private final String  blockId ;   private final  Map  < String , BlocksWithChildren >  childBlocks =  new  TreeMap  < >  ( ) ;   private final  Set  < String >  leafNodes =  new  TreeSet  < >  ( ) ;   public BlocksWithChildren  (    @ Nonnull String blockId )  {    this . blockId = blockId ; }    @ Nonnull public String getBlockId  ( )  {  return blockId ; }    @ Nonnull public  Map  < String , BlocksWithChildren > getChildBlocks  ( )  {  return childBlocks ; }    @ Nonnull public  Set  < String > getLeafNodes  ( )  {  return leafNodes ; }   public void addChildBlock  (    @ Nonnull BlocksWithChildren child )  {   childBlocks . put  (  child . getBlockId  ( ) , child ) ; }   public void addLeafNode  (    @ Nonnull String leafNode )  {   leafNodes . add  ( leafNode ) ; }   public void merge  (    @ Nonnull BlocksWithChildren toMerge )  {  if  (   toMerge . getBlockId  ( ) . equals  ( blockId ) )  {  if  (  !  this . equals  ( toMerge ) )  {  for ( String childId :   toMerge . getChildBlocks  ( ) . keySet  ( ) )  {  if  (  !  childBlocks . containsKey  ( childId ) )  {   childBlocks . put  ( childId ,   toMerge . getChildBlocks  ( ) . get  ( childId ) ) ; } else  {    childBlocks . get  ( childId ) . merge  (   toMerge . getChildBlocks  ( ) . get  ( childId ) ) ; } }   leafNodes . addAll  (  toMerge . getLeafNodes  ( ) ) ; } } }    @ Override public boolean equals  (  Object o )  {  if  (  this == o )  {  return true ; }  if  (   o == null ||   getClass  ( ) !=  o . getClass  ( ) )  {  return false ; }  if  (  !  super . equals  ( o ) )  {  return false ; }  BlocksWithChildren  that =  ( BlocksWithChildren ) o ;  return     that . getBlockId  ( ) . equals  (  getBlockId  ( ) ) &&   that . getChildBlocks  ( ) . equals  (  getChildBlocks  ( ) ) &&   that . getLeafNodes  ( ) . equals  (  getLeafNodes  ( ) ) ; }    @ Nonnull public  Set  < String > nodesWithTests  ( )  {   Set  < String >  nodes =  new  TreeSet  < >  ( ) ;   nodes . addAll  ( leafNodes ) ;  for ( BlocksWithChildren child :  childBlocks . values  ( ) )  {   nodes . addAll  (  child . nodesWithTests  ( ) ) ; }  return nodes ; }    @ Nonnull public TestResult toTestResult  (    @ Nonnull String runId ,    @ Nonnull TestResult fullResult )  {  TestResult  result =  new TestResult  ( ) ;  for ( BlocksWithChildren child :  childBlocks . values  ( ) )  {  TestResult  childResult =  child . toTestResult  ( runId , fullResult ) ;  for ( SuiteResult s :  childResult . getSuites  ( ) )  {   result . add  ( s ) ; } }  TestResult  leafResult =  fullResult . getResultByRunAndNodes  ( runId ,  new  ArrayList  < >  ( leafNodes ) ) ;  for ( SuiteResult s :  leafResult . getSuites  ( ) )  {   result . add  ( s ) ; }   result . setParentAction  (  fullResult . parentAction ) ;  return result ; }   private static final  long  serialVersionUID = 1L ; } }