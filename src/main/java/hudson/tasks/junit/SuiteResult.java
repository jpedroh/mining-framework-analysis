  package   hudson . tasks . junit ;   import   hudson . model . Run ;  import    hudson . tasks . test . TestObject ;  import    hudson . util . io . ParserConfigurator ;  import   org . dom4j . Document ;  import   org . dom4j . DocumentException ;  import   org . dom4j . Element ;  import    org . dom4j . io . SAXReader ;  import      org . jenkinsci . plugins . workflow . actions . LabelAction ;  import      org . jenkinsci . plugins . workflow . actions . ThreadNameAction ;  import      org . jenkinsci . plugins . workflow . flow . FlowExecution ;  import      org . jenkinsci . plugins . workflow . graph . FlowNode ;  import      org . jenkinsci . plugins . workflow . job . WorkflowRun ;  import     org . kohsuke . stapler . export . Exported ;  import     org . kohsuke . stapler . export . ExportedBean ;  import   javax . annotation . CheckForNull ;  import   javax . annotation . Nonnull ;  import   java . io . File ;  import   java . io . IOException ;  import   java . io . Serializable ;  import   java . util . ArrayList ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Set ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import   java . io . FileInputStream ;  import    java . util . logging . Logger ;    @ ExportedBean public final class SuiteResult  implements  Serializable  {   private final String  file ;   private final String  name ;   private final String  stdout ;   private final String  stderr ;   private  float  duration ;   private String  timestamp ;   private String  id ;   private String  time ;   private String  runId ;   private String  nodeId ;   private final  List  < String >  enclosingBlocks =  new  ArrayList  < >  ( ) ;   private final  List  < String >  enclosingBlockNames =  new  ArrayList  < >  ( ) ;   private final  List  < CaseResult >  cases =  new  ArrayList  < CaseResult >  ( ) ;   private transient  Map  < String , CaseResult >  casesByName ;   private transient    hudson . tasks . junit . TestResult  parent ;    @ Deprecated SuiteResult  (  String name ,  String stdout ,  String stderr )  {  this  ( name , stdout , stderr , null , null , null ) ; }  SuiteResult  (  String name ,  String stdout ,  String stderr ,    @ CheckForNull String runId ,    @ CheckForNull String nodeId ,    @ CheckForNull  List  < String > enclosingBlocks )  {    this . name = name ;    this . stderr = stderr ;    this . stdout = stdout ;  if  (   runId != null &&  nodeId != null )  {    this . runId = runId ;    this . nodeId = nodeId ;  if  (  enclosingBlocks != null )  {    this . enclosingBlocks . addAll  ( enclosingBlocks ) ; } } else  {    this . runId = null ;    this . nodeId = null ; }    this . file = null ; }   private synchronized  Map  < String , CaseResult > casesByName  ( )  {  if  (  casesByName == null )  {   casesByName =  new  HashMap  < String , CaseResult >  ( ) ;  for ( CaseResult c : cases )  {   casesByName . put  (  c . getName  ( ) , c ) ; } }  return casesByName ; }   public static  @ Deprecated class SuiteResultParserConfigurationContext  {   public final File  xmlReport ;  SuiteResultParserConfigurationContext  (  File xmlReport )  {    this . xmlReport = xmlReport ; } }   static  List  < SuiteResult > parse  (  File xmlReport ,  boolean keepLongStdio ,  String runId ,  String nodeId ,   List  < String > enclosingBlocks )  throws DocumentException , IOException , InterruptedException  {   List  < SuiteResult >  r =  new  ArrayList  < SuiteResult >  ( ) ;  SAXReader  saxReader =  new SAXReader  ( ) ;   saxReader . setEntityResolver  (  new XMLEntityResolver  ( ) ) ;  Document  result =  saxReader . read  ( xmlReport ) ;  Element  root =  result . getRootElement  ( ) ;   parseSuite  ( xmlReport , keepLongStdio , r , root , runId , nodeId , enclosingBlocks ) ;  return r ; }   private static void parseSuite  (  File xmlReport ,  boolean keepLongStdio ,   List  < SuiteResult > r ,  Element root ,  String runId ,  String nodeId ,   List  < String > enclosingBlocks )  throws DocumentException , IOException  {    @ SuppressWarnings  ( "unchecked" )  List  < Element >  testSuites =  (  List  < Element > )  root . elements  ( "testsuite" ) ;  for ( Element suite : testSuites )   parseSuite  ( xmlReport , keepLongStdio , r , suite , runId , nodeId , enclosingBlocks ) ;  if  (    root . element  ( "testcase" ) != null ||   root . element  ( "error" ) != null )   r . add  (  new SuiteResult  ( xmlReport , root , keepLongStdio , runId , nodeId , enclosingBlocks ) ) ; }   private SuiteResult  (  File xmlReport ,  Element suite ,  boolean keepLongStdio ,    @ CheckForNull String runId ,    @ CheckForNull String nodeId ,    @ CheckForNull  List  < String > enclosingBlocks )  throws DocumentException , IOException  {    this . file =  xmlReport . getAbsolutePath  ( ) ;  String  name =  suite . attributeValue  ( "name" ) ;  if  (  name == null )   name =   '(' +  xmlReport . getName  ( ) + ')' ; else  {  String  pkg =  suite . attributeValue  ( "package" ) ;  if  (   pkg != null &&   pkg . length  ( ) > 0 )   name =   pkg + '.' + name ; }    this . name =  TestObject . safe  ( name ) ;    this . timestamp =  suite . attributeValue  ( "timestamp" ) ;    this . id =  suite . attributeValue  ( "id" ) ;  if  (   runId != null &&  nodeId != null )  {    this . runId = runId ;    this . nodeId = nodeId ;  if  (  enclosingBlocks != null )  {   Run  <  ? ,  ? >  r =  Run . fromExternalizableId  ( runId ) ;  if  (  r instanceof WorkflowRun )  {  for ( String enc : enclosingBlocks )  {    this . enclosingBlockNames . add  (  getEnclosingNodeDisplayName  (  ( WorkflowRun ) r , enc ) ) ; } }    this . enclosingBlocks . addAll  ( enclosingBlocks ) ; } }  if  (   (   this . time =  suite . attributeValue  ( "time" ) ) != null )  {   duration =   new TimeToFloat  (  this . time ) . parse  ( ) ; }  Element  ex =  suite . element  ( "error" ) ;  if  (  ex != null )  {   addCase  (  new CaseResult  ( this , suite , "<init>" , keepLongStdio ) ) ; }    @ SuppressWarnings  ( "unchecked" )  List  < Element >  testCases =  (  List  < Element > )  suite . elements  ( "testcase" ) ;  for ( Element e : testCases )  {  String  classname =  e . attributeValue  ( "classname" ) ;  if  (  classname == null )  {   classname =  suite . attributeValue  ( "name" ) ; }   addCase  (  new CaseResult  ( this , e , classname , keepLongStdio ) ) ; }  String  stdout =  CaseResult . possiblyTrimStdio  ( cases , keepLongStdio ,  suite . elementText  ( "system-out" ) ) ;  String  stderr =  CaseResult . possiblyTrimStdio  ( cases , keepLongStdio ,  suite . elementText  ( "system-err" ) ) ;  if  (   stdout == null &&  stderr == null )  {  Matcher  m =  SUREFIRE_FILENAME . matcher  (  xmlReport . getName  ( ) ) ;  if  (  m . matches  ( ) )  {  File  mavenOutputFile =  new File  (  xmlReport . getParentFile  ( ) ,   m . group  ( 1 ) + "-output.txt" ) ;  if  (  mavenOutputFile . exists  ( ) )  {  try  {   stdout =  CaseResult . possiblyTrimStdio  ( cases , keepLongStdio , mavenOutputFile ) ; }  catch (   IOException e )  {  throw  new IOException  (  "Failed to read " + mavenOutputFile , e ) ; } } } }    this . stdout = stdout ;    this . stderr = stderr ; }  void addCase  (  CaseResult cr )  {   cases . add  ( cr ) ;    casesByName  ( ) . put  (  cr . getName  ( ) , cr ) ;  if  (  !  hasTimeAttr  ( ) )  {   duration +=  cr . getDuration  ( ) ; } }    @ Nonnull private String getEnclosingNodeDisplayName  (    @ Nonnull WorkflowRun run ,    @ Nonnull String nodeId )  {  FlowExecution  execution =  run . getExecution  ( ) ;  try  {  FlowNode  node =  execution . getNode  ( nodeId ) ;  if  (   node . getAction  (  LabelAction . class ) != null )  {  ThreadNameAction  threadNameAction =  node . getAction  (  ThreadNameAction . class ) ;  if  (  threadNameAction != null )  {  return  threadNameAction . getThreadName  ( ) ; } }  return  node . getDisplayName  ( ) ; }  catch (   Exception e )  { }  return "" ; }    @ Exported  (  visibility = 9 ) public String getName  ( )  {  return name ; }    @ Exported  (  visibility = 9 ) public  float getDuration  ( )  {  return duration ; }    @ CheckForNull  @ Exported  (  visibility = 9 ) public String getRunId  ( )  {  return runId ; }    @ Exported  (  visibility = 9 )  @ CheckForNull public String getNodeId  ( )  {  return nodeId ; }    @ Exported  (  visibility = 9 )  @ Nonnull public  List  < String > getEnclosingBlocks  ( )  {  return enclosingBlocks ; }    @ Exported  (  visibility = 9 )  @ Nonnull public  List  < String > getEnclosingBlockNames  ( )  {  return enclosingBlockNames ; }    @ Exported public String getStdout  ( )  {  return stdout ; }    @ Exported public String getStderr  ( )  {  return stderr ; }   public String getFile  ( )  {  return file ; }   public    hudson . tasks . junit . TestResult getParent  ( )  {  return parent ; }    @ Exported  (  visibility = 9 ) public String getTimestamp  ( )  {  return timestamp ; }    @ Exported  (  visibility = 9 ) public String getId  ( )  {  return id ; }    @ Exported  (  inline = true ,  visibility = 9 ) public  List  < CaseResult > getCases  ( )  {  return cases ; }   public SuiteResult getPreviousResult  ( )  {     hudson . tasks . test . TestResult  pr =  parent . getPreviousResult  ( ) ;  if  (  pr == null )  return null ;  if  (  pr instanceof    hudson . tasks . junit . TestResult )  return   (  (    hudson . tasks . junit . TestResult ) pr ) . getSuite  ( name ) ;  return null ; }   public CaseResult getCase  (  String name )  {  return   casesByName  ( ) . get  ( name ) ; }   public  Set  < String > getClassNames  ( )  {   Set  < String >  result =  new  HashSet  < String >  ( ) ;  for ( CaseResult c : cases )  {   result . add  (  c . getClassName  ( ) ) ; }  return result ; }  void setParent  (     hudson . tasks . junit . TestResult parent )  {    this . parent = parent ; }  boolean freeze  (     hudson . tasks . junit . TestResult owner )  {  if  (   this . parent != null )  return false ;    this . parent = owner ;  for ( CaseResult c : cases )   c . freeze  ( this ) ;  return true ; }   private static final  long  serialVersionUID = 1L ;   private static final Pattern  SUREFIRE_FILENAME =  Pattern . compile  ( "TEST-(.+)\\.xml" ) ;   private static final Logger  LOGGER =  Logger . getLogger  (   SuiteResult . class . getName  ( ) ) ; 
<<<<<<<
=======
  static  List  < SuiteResult > parse  (  File xmlReport ,  boolean keepLongStdio )  throws DocumentException , IOException , InterruptedException  {   List  < SuiteResult >  r =  new  ArrayList  < SuiteResult >  ( ) ;  SAXReader  saxReader =  new SAXReader  ( ) ;   saxReader . setEntityResolver  (  new XMLEntityResolver  ( ) ) ;  FileInputStream  xmlReportStream =  new FileInputStream  ( xmlReport ) ;  try  {  Document  result =  saxReader . read  ( xmlReportStream ) ;  Element  root =  result . getRootElement  ( ) ;   parseSuite  ( xmlReport , keepLongStdio , r , root ) ; }  finally  {   xmlReportStream . close  ( ) ; }  return r ; }
>>>>>>>
   private boolean hasTimeAttr  ( )  {  return  time != null ; }   public void merge  (  SuiteResult sr )  {  if  (   sr . hasTimeAttr  ( ) ^  hasTimeAttr  ( ) )  {   LOGGER . warning  (     "Merging of suiteresults with incompatible time attribute may lead to incorrect durations in reports.( " +  getFile  ( ) + ", " +  sr . getFile  ( ) + ")" ) ; }  if  (  hasTimeAttr  ( ) )  {   duration +=  sr . getDuration  ( ) ; }  for ( CaseResult cr :  sr . getCases  ( ) )  {   addCase  ( cr ) ;   cr . replaceParent  ( this ) ; } } }