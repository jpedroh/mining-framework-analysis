  package     de . letsdev . maven . plugins . ios ;   import    com . google . gson . Gson ;  import     org . apache . maven . project . MavenProject ;  import  java . io .  * ;  import    java . nio . charset . Charset ;  import    java . nio . file . Files ;  import    java . nio . file . Paths ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . UUID ;  import       de . letsdev . maven . plugins . ios . mojo . IOSException ;  import        de . letsdev . maven . plugins . ios . mojo . container . FileReplacement ;  import        de . letsdev . maven . plugins . ios . mojo . container . StringReplacement ;  import        de . letsdev . maven . plugins . ios . mojo . container . StringReplacementConfig ;  import        de . letsdev . maven . plugins . ios . mojo . container . XcodeArchiveProductType ;  import        de . letsdev . maven . plugins . ios . mojo . container . XcodeExportOptions ;  import   java . util . HashMap ;  import    sun . nio . ch . Util ;   public class ProjectBuilder  {   public static void build  (   final  Map  < String , String > properties ,  MavenProject mavenProject ,   final  List  < FileReplacement > fileReplacements ,   final  List  < String > xcodeBuildParameters ,   final XcodeExportOptions xcodeExportOptions ,   final StringReplacementConfig stringReplacements ,   List  < String > targetDependencies )  throws IOSException , IOException  {  String  projectName =  Utils . buildProjectName  ( properties , mavenProject ) ;  String  schemeName =  properties . get  (    Utils . PLUGIN_PROPERTIES . SCHEME . toString  ( ) ) ;  File  projectDirectory =  Utils . getWorkDirectory  ( properties , mavenProject , projectName ) ;  try  {  if  (   fileReplacements != null &&   fileReplacements . size  ( ) > 0 )  {   replaceFiles  ( fileReplacements , projectDirectory ) ; }  if  (    stringReplacements != null &&   stringReplacements . stringReplacementList != null &&    stringReplacements . stringReplacementList . size  ( ) > 0 )  {   replaceStrings  ( stringReplacements , projectDirectory ) ; }  File  targetDirectory =  Utils . getTargetDirectory  ( mavenProject ) ;  String  projectVersion =  updateXcodeProjectInfoPlist  ( properties , mavenProject , projectName , projectDirectory ) ;   prepareEntitlementsFile  ( properties , projectDirectory ) ;   cleanXcodeProject  ( properties , projectDirectory , xcodeBuildParameters ) ;   unlockKeychain  ( properties , mavenProject , projectDirectory ) ;  if  (  Utils . cocoaPodsEnabled  ( properties ) )  {   installCocoaPodsDependencies  ( projectDirectory ) ; }  if  (  Utils . carthageEnebled  ( properties ) )  {   installCarthageDependencies  ( projectDirectory ) ; }   buildXcodeProject  ( mavenProject , properties , projectDirectory , targetDirectory , projectName , false , xcodeBuildParameters ) ;  if  (   xcodeExportOptions . method . equals  ( "app-store" ) )  {   removeSimulatorArchitectures  ( targetDirectory ) ;   removeSimulatorArchitectures  ( projectDirectory ) ; }  if  (   Utils . isiOSFramework  ( mavenProject , properties ) ||  Utils . isMacOSFramework  ( properties ) )  {  String  simulatorArchitectures =  Utils . getArchitecturesForSdk  ( properties ,  Utils . SDK_IPHONE_SIMULATOR ) ;  boolean  shouldBuildSimulatorArchitectures =   simulatorArchitectures != null &&  !  simulatorArchitectures . isEmpty  ( ) ;  if  (   !  Utils . isMacOSFramework  ( properties ) && shouldBuildSimulatorArchitectures )  {   buildXcodeProject  ( mavenProject , properties , projectDirectory , targetDirectory , projectName , true , xcodeBuildParameters ) ; }  String  appName =  properties . get  (    Utils . PLUGIN_PROPERTIES . APP_NAME . toString  ( ) ) ;  String  frameworkName =   appName + "." +    Utils . PLUGIN_SUFFIX . FRAMEWORK . toString  ( ) ;  File  targetWorkDirectory ;  if  (  Utils . isMacOSFramework  ( properties ) )  {   targetWorkDirectory =  new File  (     targetDirectory . toString  ( ) +  File . separator +  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) +  File . separator ) ; } else  {  File  targetWorkDirectoryIphone =  new File  (       targetDirectory . toString  ( ) +  File . separator +  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) + "-" +  Utils . SDK_IPHONE_OS +  File . separator ) ;  File  targetWorkDirectoryIphoneSimulator =  new File  (       targetDirectory . toString  ( ) +  File . separator +  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) + "-" +  Utils . SDK_IPHONE_SIMULATOR +  File . separator ) ;  if  (  Utils . shouldBuildXCArchive  ( mavenProject , properties ) )  {  File  archiveFile =  new File  (  Utils . getArchiveName  ( projectName , mavenProject ) ) ;   exportProductArchive  ( archiveFile , targetWorkDirectoryIphone , frameworkName ) ;   exportTargetDependencies  ( targetDependencies , archiveFile , targetWorkDirectoryIphone ) ; }  if  ( shouldBuildSimulatorArchitectures )  {   mergeFrameworkProducts  ( targetWorkDirectoryIphone , targetWorkDirectoryIphoneSimulator , appName , frameworkName ) ; }   targetWorkDirectory = targetWorkDirectoryIphone ; }  String  targetZipPath =    "../" +  properties . get  (    Utils . PLUGIN_PROPERTIES . APP_NAME . toString  ( ) ) + "." +    Utils . PLUGIN_SUFFIX . FRAMEWORK_ZIP . toString  ( ) ;   List  < String >  zipCommandParams =  new  ArrayList  < String >  ( ) ;   zipCommandParams . add  ( "zip" ) ;   zipCommandParams . add  ( "-r" ) ;   zipCommandParams . add  ( targetZipPath ) ;   zipCommandParams . add  ( frameworkName ) ;   zipCommandParams . addAll  ( targetDependencies ) ;  ProcessBuilder  processBuilder =  new ProcessBuilder  ( zipCommandParams ) ;   processBuilder . directory  ( targetWorkDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; } else  {   unlockKeychain  ( properties , mavenProject , projectDirectory ) ;  if  (   properties . get  (    Utils . PLUGIN_PROPERTIES . BUILD_ID . toString  ( ) ) != null )  {   projectVersion +=  "-b" +  properties . get  (    Utils . PLUGIN_PROPERTIES . BUILD_ID . toString  ( ) ) ; }  File  appTargetPath =  new File  (         targetDirectory +  File . separator +  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) + "-" +  Utils . SDK_IPHONE_OS + "/" +  properties . get  (    Utils . PLUGIN_PROPERTIES . TARGET . toString  ( ) ) + "." +   Utils . PLUGIN_SUFFIX . APP ) ;  File  newAppTargetPath =  new File  (         targetDirectory +  File . separator +  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) + "-" +  Utils . SDK_IPHONE_OS + "/" +  properties . get  (    Utils . PLUGIN_PROPERTIES . APP_NAME . toString  ( ) ) + "." +   Utils . PLUGIN_SUFFIX . APP ) ;  File  ipaBasePath =  new File  (     targetDirectory +  File . separator +  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) + "-" +  Utils . SDK_IPHONE_OS ) ;  File  ipaTargetPath =  new File  (        ipaBasePath . getAbsolutePath  ( ) + "/" +  properties . get  (    Utils . PLUGIN_PROPERTIES . APP_NAME . toString  ( ) ) + "-" + projectVersion + "." +   Utils . PLUGIN_SUFFIX . IPA ) ;  File  dsymTargetPath =  new File  (         targetDirectory +  File . separator +  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) + "-" +  Utils . SDK_IPHONE_OS + "/" +  properties . get  (    Utils . PLUGIN_PROPERTIES . TARGET . toString  ( ) ) + "." +   Utils . PLUGIN_SUFFIX . APP_DSYM ) ;  File  newDsymTargetPath =  new File  (         targetDirectory +  File . separator +  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) + "-" +  Utils . SDK_IPHONE_OS + "/" +  properties . get  (    Utils . PLUGIN_PROPERTIES . APP_NAME . toString  ( ) ) + "." +   Utils . PLUGIN_SUFFIX . APP_DSYM ) ;  if  (   appTargetPath . exists  ( ) &&  !  (   appTargetPath . toString  ( ) . equalsIgnoreCase  (  newAppTargetPath . toString  ( ) ) ) )  {  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "mv" ,  appTargetPath . toString  ( ) ,  newAppTargetPath . toString  ( ) ) ;   processBuilder . directory  ( projectDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; }  if  (   dsymTargetPath . exists  ( ) &&  !  (   dsymTargetPath . toString  ( ) . equalsIgnoreCase  (  newDsymTargetPath . toString  ( ) ) ) )  {  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "mv" ,  dsymTargetPath . toString  ( ) ,  newDsymTargetPath . toString  ( ) ) ;   processBuilder . directory  ( projectDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; }  File  ipaTmpDir =  new File  ( targetDirectory ,  "ipa-temp-dir-" +   UUID . randomUUID  ( ) . toString  ( ) ) ;  if  (  !  ipaTmpDir . mkdir  ( ) )  {    System . err . println  (  "Could not create ipa temp dir at path = " +  ipaTmpDir . getAbsolutePath  ( ) ) ; }  if  (  Utils . shouldBuildXCArchiveWithExportOptionsPlist  ( xcodeExportOptions ) )  {   codeSignAfterXcode8_3  ( properties , mavenProject , projectDirectory ,  Utils . getIpaName  ( schemeName ) , ipaBasePath , ipaTargetPath , ipaTmpDir , xcodeExportOptions ) ; } else  if  (  Utils . shouldBuildXCArchive  ( mavenProject , properties ) )  {   codeSignAfterXcode6  ( properties , mavenProject , projectDirectory , ipaTargetPath , ipaTmpDir ) ; } else  {   codeSignBeforeXcode6  ( properties , projectDirectory , newAppTargetPath , ipaTargetPath , ipaTmpDir ) ; } }   lockKeychain  ( properties ) ;  if  (   fileReplacements != null &&   fileReplacements . size  ( ) > 0 )  {   revertReplacedFiles  ( fileReplacements , projectDirectory ) ; }  if  (    stringReplacements != null &&   stringReplacements . stringReplacementList != null &&    stringReplacements . stringReplacementList . size  ( ) > 0 )  {   revertReplacedStrings  ( stringReplacements , projectDirectory ) ; }   generateDeployPlistFile  ( mavenProject , properties , targetDirectory , projectVersion ) ; }  catch (   Exception e )  {    System . err . println  (  "exception occurred while building project, e=" +  e . getMessage  ( ) ) ;  throw  new IOSException  (  e . getMessage  ( ) ) ; }  finally  {  if  (    properties . get  (    Utils . PLUGIN_PROPERTIES . XCODE_VERSION . toString  ( ) ) != null &&  !   properties . get  (    Utils . PLUGIN_PROPERTIES . XCODE_VERSION . toString  ( ) ) . isEmpty  ( ) )  {   selectXcodeVersion  ( currentXcodeVersion , projectDirectory ) ; } } }   private static void removeSimulatorArchitectures  (  File rootDirectory )  {  try  {   final String  scriptName = "remove-simulator-archs.sh" ;  File  tempFile =  File . createTempFile  ( scriptName , "sh" ) ;  InputStream  inputStream =   ProjectBuilder . class . getResourceAsStream  (  "/META-INF/" + scriptName ) ;  OutputStream  outputStream =  new FileOutputStream  ( tempFile ) ;    byte  [ ]  buffer =  new  byte  [ 1024 ] ;   int  bytesRead ;  while  (   (  bytesRead =  inputStream . read  ( buffer ) ) !=  - 1 )  {   outputStream . write  ( buffer , 0 , bytesRead ) ; }   outputStream . close  ( ) ;  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "sh" ,   tempFile . getAbsoluteFile  ( ) . toString  ( ) ,  rootDirectory . getAbsolutePath  ( ) ) ;   processBuilder . directory  ( rootDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; }  catch (   IOException e )  {   e . printStackTrace  ( ) ; }  catch (   IOSException e )  {   e . printStackTrace  ( ) ; } }   private static String updateXcodeProjectInfoPlist  (   Map  < String , String > properties ,  MavenProject mavenProject ,  String projectName ,  File workDirectory )  throws IOSException  {  String  projectVersion =  Utils . getAdjustedVersion  ( mavenProject , properties ) ;  ProcessBuilder  processBuilderNewMarketingVersion =  new ProcessBuilder  ( "agvtool" , "new-marketing-version" , projectVersion ) ;   processBuilderNewMarketingVersion . directory  ( workDirectory ) ;   CommandHelper . performCommand  ( processBuilderNewMarketingVersion ) ;  String  buildNumber =  getBuildNumber  ( mavenProject , properties ) ;  ProcessBuilder  processBuilderNewVersion =  new ProcessBuilder  ( "agvtool" , "new-version" , "-all" , buildNumber ) ;   processBuilderNewVersion . directory  ( workDirectory ) ;   CommandHelper . performCommand  ( processBuilderNewVersion ) ;  if  (   properties . get  (    Utils . PLUGIN_PROPERTIES . BUILD_ID . toString  ( ) ) != null )  {   executePlistScript  ( "write-buildnumber.sh" ,  properties . get  (    Utils . PLUGIN_PROPERTIES . BUILD_ID . toString  ( ) ) , workDirectory , projectName , properties ) ; }  if  (   properties . get  (    Utils . PLUGIN_PROPERTIES . APP_ICON_NAME . toString  ( ) ) != null )  {   executePlistScript  ( "write-app-icon-name.sh" ,  properties . get  (    Utils . PLUGIN_PROPERTIES . APP_ICON_NAME . toString  ( ) ) , workDirectory , projectName , properties ) ; }  if  (   properties . get  (    Utils . PLUGIN_PROPERTIES . BUNDLE_IDENTIFIER . toString  ( ) ) != null )  {   executePlistScript  ( "write-bundleidentifier.sh" ,  properties . get  (    Utils . PLUGIN_PROPERTIES . BUNDLE_IDENTIFIER . toString  ( ) ) , workDirectory , projectName , properties ) ; }  if  (   properties . get  (    Utils . PLUGIN_PROPERTIES . DISPLAY_NAME . toString  ( ) ) != null )  {   executePlistScript  ( "write-displayname.sh" ,  properties . get  (    Utils . PLUGIN_PROPERTIES . DISPLAY_NAME . toString  ( ) ) , workDirectory , projectName , properties ) ; }  return projectVersion ; }   private static void cleanXcodeProject  (   Map  < String , String > properties ,  File workDirectory ,   List  < String > xcodeBuildParameters )  throws IOSException  {  StringBuilder  xcodebuildCommand =  new StringBuilder  (    "xcodebuild -alltargets -configuration " +  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) + " clean -scheme " +  properties . get  (    Utils . PLUGIN_PROPERTIES . SCHEME . toString  ( ) ) ) ;  for ( String param : xcodeBuildParameters )  {    xcodebuildCommand . append  ( " " ) . append  ( param ) ; }  String  jsonOutputFile =  Utils . createJsonOutputFilePath  ( "clean" , properties ) ;  for ( String xcprettyArg :   Utils . getXcprettyCommand  ( "xcodebuild-clean.log" , jsonOutputFile ) . split  ( " " ) )  {    xcodebuildCommand . append  ( " " ) . append  ( xcprettyArg ) ; }   Utils . executeShellScript  ( "execute-xcodebuild.sh" ,  xcodebuildCommand . toString  ( ) , null , null , workDirectory ) ; }   private static File createPrecompileHeadersDirectory  (  File targetDirectory )  {  File  precompiledHeadersDir =  new File  ( targetDirectory ,  "precomp-dir-" +   UUID . randomUUID  ( ) . toString  ( ) ) ;  if  (  !  precompiledHeadersDir . mkdir  ( ) )  {    System . err . println  (  "Could not create precompiled headers dir at path = " +  precompiledHeadersDir . getAbsolutePath  ( ) ) ; }  return precompiledHeadersDir ; }   private static void generateDeployPlistFile  (  MavenProject mavenProject ,   Map  < String , String > properties ,  File targetDirectory ,  String projectVersion )  throws IOSException  {  if  (   (   properties . get  (    Utils . PLUGIN_PROPERTIES . DEPLOY_IPA_PATH . toString  ( ) ) != null ) &&  (   properties . get  (    Utils . PLUGIN_PROPERTIES . DEPLOY_ICON_PATH . toString  ( ) ) != null ) )  {   final String  deployPlistName =      properties . get  (    Utils . PLUGIN_PROPERTIES . APP_NAME . toString  ( ) ) + "-" + projectVersion + "." +   Utils . PLUGIN_SUFFIX . PLIST ;   writeDeployPlistFile  ( mavenProject , targetDirectory , deployPlistName , properties ) ; } }   private static void revertReplacedFiles  (   final  List  < FileReplacement > fileReplacements ,  File projectDirectory )  throws IOSException  {  for ( FileReplacement fileReplacement : fileReplacements )  {   replaceFile  ( projectDirectory ,  fileReplacement . targetFile ,  fileReplacement . sourceFile , true ) ; } }   private static void replaceFiles  (   final  List  < FileReplacement > fileReplacements ,  File projectDirectory )  throws IOSException  {  for ( FileReplacement fileReplacement : fileReplacements )  {   replaceFile  ( projectDirectory ,  fileReplacement . sourceFile ,  fileReplacement . targetFile , false ) ; } }   private static void replaceFile  (  File projectDirectory ,  String replaceSource ,  String replaceTarget ,  boolean revertTempFile )  throws IOSException  {  File  sourceFile =  new File  (    projectDirectory . toString  ( ) +  File . separator + replaceSource ) ;  File  tempFile =  new File  (     projectDirectory . toString  ( ) +  File . separator +  (   ( revertTempFile ) ? replaceSource : replaceTarget ) + ".tmp" ) ;  File  targetFile =  new File  (    projectDirectory . toString  ( ) +  File . separator + replaceTarget ) ;  if  (  sourceFile . exists  ( ) )  {  if  (  targetFile . exists  ( ) )  {  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "mv" ,  targetFile . toString  ( ) ,  tempFile . toString  ( ) ) ;   processBuilder . directory  ( projectDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; }  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "mv" ,  sourceFile . toString  ( ) ,  targetFile . toString  ( ) ) ;   processBuilder . directory  ( projectDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; } else  {    System . err . println  (  "source file doesn't exist at path= " +  sourceFile . toString  ( ) ) ; }  if  ( revertTempFile )  {  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "mv" ,  tempFile . toString  ( ) ,  sourceFile . toString  ( ) ) ;   processBuilder . directory  ( projectDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; } }   private static void revertReplacedStrings  (   final StringReplacementConfig stringReplacements ,  File projectDirectory )  throws IOSException , IOException  {  for ( StringReplacement stringReplacement :  stringReplacements . stringReplacementList )  {   replaceString  ( projectDirectory ,  stringReplacement . sourceFile ,  stringReplacement . targetString ,  stringReplacement . sourceString ,  stringReplacements . failWhenNotFound ) ; } }   private static void replaceStrings  (   final StringReplacementConfig stringReplacements ,  File projectDirectory )  throws IOSException , IOException  {  for ( StringReplacement stringReplacement :  stringReplacements . stringReplacementList )  {   replaceString  ( projectDirectory ,  stringReplacement . sourceFile ,  stringReplacement . sourceString ,  stringReplacement . targetString ,  stringReplacements . failWhenNotFound ) ; } }   private static void replaceString  (  File projectDirectory ,  String sourceFilePath ,  String replaceSource ,  String replaceTarget ,  boolean failWhenNotFound )  throws IOSException , IOException  {  File  sourceFile =  new File  (    projectDirectory . toString  ( ) +  File . separator + sourceFilePath ) ;  if  (  sourceFile . exists  ( ) )  {    byte  [ ]  encoded =  Files . readAllBytes  (  Paths . get  (  sourceFile . getAbsolutePath  ( ) ) ) ;  String  sourceFileContents =  new String  ( encoded ,  Charset . defaultCharset  ( ) ) ;  if  (  sourceFileContents . contains  ( replaceSource ) )  {   sourceFileContents =  sourceFileContents . replace  ( replaceSource , replaceTarget ) ; } else  if  ( failWhenNotFound )  {  throw  new IOSException  (    "string '" + replaceSource + "' not found in: " +  sourceFile . toString  ( ) ) ; }  FileOutputStream  sourceFileStream =  new FileOutputStream  ( sourceFile , false ) ;    byte  [ ]  contentBytes =  sourceFileContents . getBytes  ( ) ;   sourceFileStream . write  ( contentBytes ) ;   sourceFileStream . close  ( ) ; } else  {  String  error =  "source file doesn't exist at path= " +  sourceFile . toString  ( ) ;    System . err . println  ( error ) ;  if  ( failWhenNotFound )  {  throw  new IOSException  ( error ) ; } } }   private static void lockKeychain  (   Map  < String , String > properties )  throws IOSException  {  if  (   properties . containsKey  (    Utils . PLUGIN_PROPERTIES . KEYCHAIN_PATH . toString  ( ) ) &&  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . KEYCHAIN_PASSWORD . toString  ( ) ) )  {  String  command =  "security lock-keychain " +  properties . get  (    Utils . PLUGIN_PROPERTIES . KEYCHAIN_PATH . toString  ( ) ) ;  ProcessBuilder  processBuilderLockKeyChain =  new ProcessBuilder  (  CommandHelper . getCommand  ( command ) ) ;   CommandHelper . performCommand  ( processBuilderLockKeyChain ) ; } }   private static void codeSignBeforeXcode6  (   Map  < String , String > properties ,  File workDirectory ,  File newAppTargetPath ,  File ipaTargetPath ,  File ipaTmpDir )  throws IOSException  {  ProcessBuilder  processBuilderCodeSign =  new ProcessBuilder  ( "xcrun" , "--no-cache" , "-sdk" ,  properties . get  (    Utils . PLUGIN_PROPERTIES . SDK . toString  ( ) ) , "PackageApplication" , "-v" ,  newAppTargetPath . toString  ( ) , "-o" ,  ipaTargetPath . toString  ( ) , "--sign" ,  properties . get  (    Utils . PLUGIN_PROPERTIES . CODE_SIGN_IDENTITY . toString  ( ) ) ) ;   processBuilderCodeSign . directory  ( workDirectory ) ;    processBuilderCodeSign . environment  ( ) . put  ( "TMPDIR" ,  ipaTmpDir . getAbsolutePath  ( ) ) ;   CommandHelper . performCommand  ( processBuilderCodeSign ) ; }   private static void codeSignAfterXcode6  (   Map  < String , String > properties ,  MavenProject mavenProject ,  File workDirectory ,  File ipaTargetPath ,  File ipaTmpDir )  throws IOSException  {  if  (   !   ipaTargetPath . getParentFile  ( ) . exists  ( ) &&  !   ipaTargetPath . getParentFile  ( ) . mkdirs  ( ) )  {  throw  new RuntimeException  (  "Could not create directories for ipa target path=" +  ipaTargetPath . getAbsolutePath  ( ) ) ; }  StringBuilder  buildCommand =  new StringBuilder  ( ) ;   buildCommand . append  ( "xcodebuild" ) ;   buildCommand . append  ( " -exportArchive" ) ;   buildCommand . append  ( " -exportFormat " ) ;   buildCommand . append  (    Utils . PLUGIN_SUFFIX . IPA . toString  ( ) ) ;   buildCommand . append  ( " -archivePath " ) ;   buildCommand . append  (  Utils . getArchiveName  (  Utils . buildProjectName  ( properties , mavenProject ) , mavenProject ) ) ;   buildCommand . append  ( " -exportPath " ) ;   buildCommand . append  (  ipaTargetPath . toString  ( ) ) ;   buildCommand . append  ( " -exportWithOriginalSigningIdentity" ) ;  String  jsonOutputFile =  Utils . createJsonOutputFilePath  ( "codesign" , properties ) ;  for ( String xcprettyArg :   Utils . getXcprettyCommand  ( "xcodebuild-codesign.log" , jsonOutputFile ) . split  ( " " ) )  {    buildCommand . append  ( " " ) . append  ( xcprettyArg ) ; }   Utils . executeShellScript  ( "execute-xcodebuild.sh" ,  buildCommand . toString  ( ) , null , null , workDirectory ) ; }   private static void codeSignAfterXcode8_3  (   Map  < String , String > properties ,  MavenProject mavenProject ,  File workDirectory ,  String ipaName ,  File ipaBasePath ,  File ipaTargetPath ,  File ipaTmpDir ,  XcodeExportOptions xcodeExportOptions )  throws IOSException  {  if  (   !   ipaTargetPath . getParentFile  ( ) . exists  ( ) &&  !   ipaTargetPath . getParentFile  ( ) . mkdirs  ( ) )  {  throw  new RuntimeException  (  "Could not create directories for ipa target path=" +  ipaTargetPath . getAbsolutePath  ( ) ) ; }  File  plistFilePath =  generateExportOptionsPlist  ( xcodeExportOptions , workDirectory ) ;  StringBuilder  buildCommand =  new StringBuilder  ( ) ;   buildCommand . append  ( "xcodebuild" ) ;   buildCommand . append  ( " -exportArchive" ) ;   buildCommand . append  ( " -archivePath " ) ;   buildCommand . append  (  Utils . getArchiveName  (  Utils . buildProjectName  ( properties , mavenProject ) , mavenProject ) ) ;   buildCommand . append  ( " -exportPath " ) ;   buildCommand . append  (  ipaBasePath . toString  ( ) ) ;   buildCommand . append  ( " -exportOptionsPlist " ) ;   buildCommand . append  (  plistFilePath . getAbsolutePath  ( ) ) ;  String  jsonOutputFile =  Utils . createJsonOutputFilePath  ( "codesign" , properties ) ;  for ( String xcprettyArg :   Utils . getXcprettyCommand  ( "xcodebuild-codesign.log" , jsonOutputFile ) . split  ( " " ) )  {    buildCommand . append  ( " " ) . append  ( xcprettyArg ) ; }   Utils . executeShellScript  ( "execute-xcodebuild.sh" ,  buildCommand . toString  ( ) ,  ipaTmpDir . getAbsolutePath  ( ) , null , workDirectory ) ;  File  ipaPath =  new File  (    ipaBasePath . getAbsolutePath  ( ) + "/" + ipaName ) ;  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "mv" ,  ipaPath . toString  ( ) ,  ipaTargetPath . toString  ( ) ) ;   processBuilder . directory  ( workDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ;   processBuilder =  new ProcessBuilder  ( "rm" ,  plistFilePath . getAbsolutePath  ( ) ) ;   processBuilder . directory  ( workDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; }   private static void unlockKeychain  (   Map  < String , String > properties ,  MavenProject mavenProject ,  File workDirectory )  throws IOSException  {  if  (    Utils . shouldCodeSign  ( mavenProject , properties ) &&  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . KEYCHAIN_PATH . toString  ( ) ) &&  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . KEYCHAIN_PASSWORD . toString  ( ) ) )  {   Utils . executeShellScript  ( "unlock-keychain.sh" ,  properties . get  (    Utils . PLUGIN_PROPERTIES . KEYCHAIN_PASSWORD . toString  ( ) ) ,  properties . get  (    Utils . PLUGIN_PROPERTIES . KEYCHAIN_PATH . toString  ( ) ) , null , workDirectory ) ; } }   private static void buildXcodeProject  (  MavenProject mavenProject ,   Map  < String , String > properties ,  File workDirectory ,  File targetDirectory ,  String projectName ,  boolean shouldUseIphoneSimulatorSDK ,   List  < String > xcodeBuildParameters )  throws IOSException  {   List  < String >  buildParameters =  new  ArrayList  < String >  ( ) ;   buildParameters . add  ( "xcodebuild" ) ;  if  (  Utils . shouldUseWorkspaceFile  ( properties ) )  {   buildParameters . add  ( "-workspace" ) ;   buildParameters . add  (  projectName + ".xcworkspace" ) ; }  String  sdk =  properties . get  (    Utils . PLUGIN_PROPERTIES . SDK . toString  ( ) ) ;  if  ( shouldUseIphoneSimulatorSDK )  {   sdk =  Utils . SDK_IPHONE_SIMULATOR ; }   buildParameters . add  ( "-sdk" ) ;   buildParameters . add  ( sdk ) ;  String  archs =  Utils . getArchitecturesForSdk  ( properties , sdk ) ;  if  (   archs != null &&  !  archs . isEmpty  ( ) )  {   buildParameters . add  (   "ARCHS=\"" + archs + "\"" ) ;   buildParameters . add  (   "VALID_ARCHS=\"" + archs + "\"" ) ; }   buildParameters . add  ( "-configuration" ) ;   buildParameters . add  (  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) ) ;  if  (   Utils . shouldBuildXCArchive  ( mavenProject , properties ) &&  ! shouldUseIphoneSimulatorSDK )  {   buildParameters . add  ( "archive" ) ;   buildParameters . add  ( "-archivePath" ) ;   buildParameters . add  (  Utils . getArchiveName  ( projectName , mavenProject ) ) ; } else  {   buildParameters . add  (  "SYMROOT=" +  targetDirectory . getAbsolutePath  ( ) ) ; }  if  (  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . SCHEME . toString  ( ) ) )  {   buildParameters . add  ( "-scheme" ) ;   buildParameters . add  (  properties . get  (    Utils . PLUGIN_PROPERTIES . SCHEME . toString  ( ) ) ) ; }  if  (  Utils . shouldCodeSign  ( mavenProject , properties ) )  {  if  (  Utils . shouldCodeSignWithResourceRules  ( mavenProject , properties ) )  {   buildParameters . add  ( "CODE_SIGN_RESOURCE_RULES_PATH=$(SDKROOT)/ResourceRules.plist" ) ; }  if  (  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . CODE_SIGN_IDENTITY . toString  ( ) ) )  {   buildParameters . add  (   "CODE_SIGN_IDENTITY=\"" +  properties . get  (    Utils . PLUGIN_PROPERTIES . CODE_SIGN_IDENTITY . toString  ( ) ) + "\"" ) ; } } else  {   buildParameters . add  ( "CODE_SIGN_IDENTITY=" ) ;   buildParameters . add  ( "CODE_SIGNING_REQUIRED=NO" ) ; }  if  (    Utils . shouldCodeSign  ( mavenProject , properties ) &&  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . PROVISIONING_PROFILE_UUID . toString  ( ) ) &&  !   properties . get  (    Utils . PLUGIN_PROPERTIES . PROVISIONING_PROFILE_UUID . toString  ( ) ) . equals  ( "" ) )  {   buildParameters . add  (   "PROVISIONING_PROFILE=\"" +  properties . get  (    Utils . PLUGIN_PROPERTIES . PROVISIONING_PROFILE_UUID . toString  ( ) ) + "\"" ) ; }  if  (    Utils . shouldCodeSign  ( mavenProject , properties ) &&  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . PROVISIONING_PROFILE_SPECIFIER . toString  ( ) ) &&  !   properties . get  (    Utils . PLUGIN_PROPERTIES . PROVISIONING_PROFILE_SPECIFIER . toString  ( ) ) . equals  ( "" ) )  {   buildParameters . add  (   "PROVISIONING_PROFILE_SPECIFIER=\"" +  properties . get  (    Utils . PLUGIN_PROPERTIES . PROVISIONING_PROFILE_SPECIFIER . toString  ( ) ) + "\"" ) ; } else  {   buildParameters . add  ( "PROVISIONING_PROFILE_SPECIFIER=" ) ; }  if  (   Utils . shouldCodeSign  ( mavenProject , properties ) &&  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . DEVELOPMENT_TEAM . toString  ( ) ) )  {   buildParameters . add  (   "DEVELOPMENT_TEAM=\"" +  properties . get  (    Utils . PLUGIN_PROPERTIES . DEVELOPMENT_TEAM . toString  ( ) ) + "\"" ) ; } else  {   buildParameters . add  ( "DEVELOPMENT_TEAM=" ) ; }  if  (   properties . get  (    Utils . PLUGIN_PROPERTIES . BUNDLE_IDENTIFIER . toString  ( ) ) != null )  {   buildParameters . add  (   "PRODUCT_BUNDLE_IDENTIFIER=\"" +  properties . get  (    Utils . PLUGIN_PROPERTIES . BUNDLE_IDENTIFIER . toString  ( ) ) + "\"" ) ; }  if  (   (   Utils . isMacOSFramework  ( properties ) ||  Utils . isiOSFramework  ( mavenProject , properties ) ) &&  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . APP_NAME . toString  ( ) ) )  {   buildParameters . add  (   "PRODUCT_NAME=\"" +  properties . get  (    Utils . PLUGIN_PROPERTIES . APP_NAME . toString  ( ) ) + "\"" ) ; }  String  target = null ;  if  (  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . TARGET . toString  ( ) ) )  {   target =  properties . get  (    Utils . PLUGIN_PROPERTIES . TARGET . toString  ( ) ) ; }  if  (   !  Utils . shouldBuildXCArchive  ( mavenProject , properties ) &&  target != null )  {   buildParameters . add  ( "-target" ) ;   buildParameters . add  ( target ) ; }  if  (   Utils . shouldCodeSign  ( mavenProject , properties ) &&  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . KEYCHAIN_PATH . toString  ( ) ) )  {   buildParameters . add  (   "OTHER_CODE_SIGN_FLAGS=\"--keychain " +  properties . get  (    Utils . PLUGIN_PROPERTIES . KEYCHAIN_PATH . toString  ( ) ) + "\"" ) ; }  if  (  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . GCC_PREPROCESSOR_DEFINITIONS . toString  ( ) ) )  {   buildParameters . add  (   "GCC_PREPROCESSOR_DEFINITIONS='" +  properties . get  (    Utils . PLUGIN_PROPERTIES . GCC_PREPROCESSOR_DEFINITIONS . toString  ( ) ) + "'" ) ; }  if  (  shouldUseIphoneSimulatorSDK &&  Utils . isIphoneSimulatorBitcodeEnabled  ( properties ) )  {   buildParameters . add  ( "ENABLE_BITCODE=YES" ) ;   buildParameters . add  ( "OTHER_CFLAGS='-fembed-bitcode'" ) ; }  if  (  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . DERIVED_DATA_PATH . toString  ( ) ) ) else  {   buildParameters . add  (  
<<<<<<<
     "CONFIGURATION_BUILD_DIR=\"" +  targetDirectory . getAbsolutePath  ( ) + "/" +  properties . get  (    Utils . PLUGIN_PROPERTIES . CONFIGURATION . toString  ( ) ) + "-" +  Utils . SDK_IPHONE_OS
=======
"-derivedDataPath "
>>>>>>>
 + 
<<<<<<<
"\""
=======
 properties . get  (    Utils . PLUGIN_PROPERTIES . DERIVED_DATA_PATH . toString  ( ) )
>>>>>>>
 ) ; }   buildParameters . addAll  ( xcodeBuildParameters ) ;  String  jsonOutputFile =  Utils . createJsonOutputFilePath  ( "build" , properties ) ;   Collections . addAll  ( buildParameters ,   Utils . getXcprettyCommand  ( "xcodebuild.log" , jsonOutputFile ) . split  ( " " ) ) ;  StringBuilder  buildCommand =  new StringBuilder  ( ) ;  for ( String buildParam : buildParameters )  {   buildCommand . append  ( buildParam ) ;   buildCommand . append  ( " " ) ; }   Utils . executeShellScript  ( "execute-xcodebuild.sh" ,  buildCommand . toString  ( ) , null , null , workDirectory ) ; }   private static void mergeFrameworkProducts  (  File targetWorkDirectoryIphone ,  File targetWorkDirectoryIphoneSimulator ,  String appName ,  String frameworkName )  throws IOSException  {   final String  scriptName = "merge-framework-products" ;   final String  iphoneosFrameworkProductPath =    targetWorkDirectoryIphone . toString  ( ) + "/" + frameworkName ;   final String  iphoneSimulatorFrameworkProductPath =    targetWorkDirectoryIphoneSimulator . toString  ( ) + "/" + frameworkName ;   final String  mergedFrameworkPath =    targetWorkDirectoryIphone . toString  ( ) + "/" + frameworkName ;  File  tempFile ;  try  {   tempFile =  File . createTempFile  ( scriptName , "sh" ) ; }  catch (   IOException e )  {   e . printStackTrace  ( ) ;  throw  new IOSException  (  "Cannot create tempfile for script: " + scriptName ) ; }  InputStream  inputStream =   ProjectBuilder . class . getResourceAsStream  (   "/META-INF/" + scriptName + ".sh" ) ;  OutputStream  outputStream = null ;  try  {   outputStream =  new FileOutputStream  ( tempFile ) ;    byte  [ ]  buffer =  new  byte  [ 1024 ] ;   int  bytesRead ;  while  (   (  bytesRead =  inputStream . read  ( buffer ) ) !=  - 1 )  {   outputStream . write  ( buffer , 0 , bytesRead ) ; } }  catch (   IOException e )  {   e . printStackTrace  ( ) ;  throw  new IOSException  (  "Cannot find tempfile at path: " +  tempFile . getAbsolutePath  ( ) ) ; }  finally  {  try  {  if  (  outputStream != null )  {   outputStream . close  ( ) ; } }  catch (   IOException e )  {   e . printStackTrace  ( ) ; } }  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "sh" ,   tempFile . getAbsoluteFile  ( ) . toString  ( ) , iphoneosFrameworkProductPath , iphoneSimulatorFrameworkProductPath , mergedFrameworkPath , appName ) ;   processBuilder . directory  ( targetWorkDirectoryIphone ) ;   CommandHelper . performCommand  ( processBuilder ) ; }   private static void exportTargetDependencies  (   List  < String > targetDependencies ,  File archiveFile ,  File targetDirectory )  throws IOSException  {  if  (   targetDependencies != null &&   targetDependencies . size  ( ) > 0 )  {  for ( String targetDependency : targetDependencies )  {   exportProductArchive  ( archiveFile , targetDirectory , targetDependency ) ; } } }   private static void exportProductArchive  (  File archiveFile ,  File targetPath ,  String productName )  throws IOSException  {  try  {   final String  scriptName = "export-product-archive" ;   targetPath . mkdir  ( ) ;   final String  productTargetPath =    targetPath . toString  ( ) + "/" + productName ;  XcodeArchiveProductType  productType =  Utils . getExportProductType  ( productName ) ;  String  productPath =  Utils . getExportProductPath  ( productType ) ;  File  tempFile =  File . createTempFile  ( scriptName , "sh" ) ;  InputStream  inputStream =   ProjectBuilder . class . getResourceAsStream  (   "/META-INF/" + scriptName + ".sh" ) ;  OutputStream  outputStream =  new FileOutputStream  ( tempFile ) ;    byte  [ ]  buffer =  new  byte  [ 1024 ] ;   int  bytesRead ;  while  (   (  bytesRead =  inputStream . read  ( buffer ) ) !=  - 1 )  {   outputStream . write  ( buffer , 0 , bytesRead ) ; }   outputStream . close  ( ) ;  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "sh" ,   tempFile . getAbsoluteFile  ( ) . toString  ( ) ,  archiveFile . toString  ( ) , productPath , productName ,  targetPath . toString  ( ) , productTargetPath ) ;   processBuilder . directory  ( targetPath ) ;   CommandHelper . performCommand  ( processBuilder ) ; }  catch (   Exception e )  {   e . printStackTrace  ( ) ;  throw  new IOSException  ( e ) ; } }   private static String getSchemeOrTarget  (   final  Map  < String , String > properties )  {  String  targetName = null ;  if  (  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . SCHEME . toString  ( ) ) )  {   targetName =  properties . get  (    Utils . PLUGIN_PROPERTIES . SCHEME . toString  ( ) ) ; } else  if  (  properties . containsKey  (    Utils . PLUGIN_PROPERTIES . TARGET . toString  ( ) ) )  {   targetName =  properties . get  (    Utils . PLUGIN_PROPERTIES . TARGET . toString  ( ) ) ; }  return targetName ; }   private static void prepareEntitlementsFile  (   final  Map  < String , String > properties ,  File workDirectory )  throws IOSException , FileNotFoundException , IOException  {  String  targetName =  getSchemeOrTarget  ( properties ) ;  String  entitlementsFilePath =    workDirectory +  File . separator + targetName + ".entitlements" ;  File  entitlementsFile =  new File  ( entitlementsFilePath ) ;  if  (   entitlementsFile . exists  ( ) &&  !  entitlementsFile . isDirectory  ( ) )  {    byte  [ ]  encoded =  Files . readAllBytes  (  Paths . get  ( entitlementsFilePath ) ) ;  String  entitlementsFileContents =  new String  ( encoded ,  Charset . defaultCharset  ( ) ) ;  boolean  isTestflightBuild =  Utils . isTestflightBuild  ( properties ) ;  if  ( isTestflightBuild )  {  if  (  !  entitlementsFileContents . contains  ( "<key>beta-reports-active</key>" ) )  {   entitlementsFileContents =  entitlementsFileContents . replace  ( "</dict>" , "<key>beta-reports-active</key><true/></dict>" ) ; } }  FileOutputStream  entitlementsFileStream =  new FileOutputStream  ( entitlementsFile , false ) ;    byte  [ ]  contentBytes =  entitlementsFileContents . getBytes  ( ) ;   entitlementsFileStream . write  ( contentBytes ) ;   entitlementsFileStream . close  ( ) ; } else  {    System . err . println  (  "entitlements file does not exists at path=" + entitlementsFilePath ) ; } }   private static void executePlistScript  (  String scriptName ,  String value ,  File workDirectory ,  String projectName ,   final  Map  < String , String > properties )  throws IOSException  {  String  infoPlistFile =      workDirectory +  File . separator + projectName +  File . separator + projectName + "-Info.plist" ;  if  (   properties . get  (    Utils . PLUGIN_PROPERTIES . INFO_PLIST . toString  ( ) ) != null )  {   infoPlistFile =   workDirectory +  File . separator +  properties . get  (    Utils . PLUGIN_PROPERTIES . INFO_PLIST . toString  ( ) ) ; }  try  {  File  tempFile =  File . createTempFile  ( scriptName , "sh" ) ;  InputStream  inputStream =   ProjectBuilder . class . getResourceAsStream  (  "/META-INF/" + scriptName ) ;  OutputStream  outputStream =  new FileOutputStream  ( tempFile ) ;    byte  [ ]  buffer =  new  byte  [ 1024 ] ;   int  bytesRead ;  while  (   (  bytesRead =  inputStream . read  ( buffer ) ) !=  - 1 )  {   outputStream . write  ( buffer , 0 , bytesRead ) ; }   outputStream . close  ( ) ;  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "sh" ,   tempFile . getAbsoluteFile  ( ) . toString  ( ) , infoPlistFile , value ) ;   processBuilder . directory  ( workDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; }  catch (   IOException e )  {   e . printStackTrace  ( ) ;  throw  new IOSException  ( e ) ; } }   private static void writeDeployPlistFile  (  MavenProject mavenProject ,  File targetDirectory ,  String deployPlistName ,   final  Map  < String , String > properties )  throws IOSException  {  try  {   final String  scriptName = "write-deploy-plist" ;   final String  ipaLocation =  properties . get  (    Utils . PLUGIN_PROPERTIES . DEPLOY_IPA_PATH . toString  ( ) ) ;   final String  iconLocation =  properties . get  (    Utils . PLUGIN_PROPERTIES . DEPLOY_ICON_PATH . toString  ( ) ) ;   final String  displayName =  properties . get  (    Utils . PLUGIN_PROPERTIES . DISPLAY_NAME . toString  ( ) ) ;   final String  bundleIdentifier =  properties . get  (    Utils . PLUGIN_PROPERTIES . BUNDLE_IDENTIFIER . toString  ( ) ) ;  String  bundleVersion =  Utils . getAdjustedVersion  ( mavenProject , properties ) ;   final String  buildNumber =  getBuildNumber  ( mavenProject , properties ) ;  File  tempFile =  File . createTempFile  ( scriptName , "sh" ) ;  InputStream  inputStream =   ProjectBuilder . class . getResourceAsStream  (  "/META-INF/" + scriptName ) ;  OutputStream  outputStream =  new FileOutputStream  ( tempFile ) ;    byte  [ ]  buffer =  new  byte  [ 1024 ] ;   int  bytesRead ;  while  (   (  bytesRead =  inputStream . read  ( buffer ) ) !=  - 1 )  {   outputStream . write  ( buffer , 0 , bytesRead ) ; }   outputStream . close  ( ) ;  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "sh" ,   tempFile . getAbsoluteFile  ( ) . toString  ( ) , deployPlistName , ipaLocation , iconLocation , displayName , bundleIdentifier , bundleVersion , buildNumber ) ;   processBuilder . directory  ( targetDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; }  catch (   IOException e )  {   e . printStackTrace  ( ) ;  throw  new IOSException  ( e ) ; } }   private static String getBuildNumber  (  MavenProject mavenProject ,   final  Map  < String , String > properties )  {  String  bundleVersion =  Utils . getAdjustedVersion  ( mavenProject , properties ) ;  String  tmpBuildNumber =  properties . get  (    Utils . PLUGIN_PROPERTIES . BUILD_ID . toString  ( ) ) ;  if  (    tmpBuildNumber == null ||  tmpBuildNumber . equals  ( "" ) ||  tmpBuildNumber . equals  ( "n/a" ) )  {   tmpBuildNumber = bundleVersion ; }  return tmpBuildNumber ; }   private static void installCocoaPodsDependencies  (  File projectDirectory )  throws IOSException  {  try  {  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "pod" , "install" , "--repo-update" ) ;   processBuilder . directory  ( projectDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; }  catch (   Exception e )  {   e . printStackTrace  ( ) ;  throw  new IOSException  ( e ) ; } }   private static File generateExportOptionsPlist  (  XcodeExportOptions xcodeExportOptions ,  File workDirectory )  throws IOSException  {  String  plistFilePath =   "/tmp/exportOptions-" +  UUID . randomUUID  ( ) + ".plist" ;  File  plistFile =  new File  ( plistFilePath ) ;  Gson  gson =  new Gson  ( ) ;  String  jsonString =  gson . toJson  ( xcodeExportOptions ) ;  try  {   final String  scriptName = "create-export-options-plist.sh" ;  File  tempFile =  File . createTempFile  ( scriptName , "sh" ) ;  InputStream  inputStream =   ProjectBuilder . class . getResourceAsStream  (  "/META-INF/" + scriptName ) ;  OutputStream  outputStream =  new FileOutputStream  ( tempFile ) ;    byte  [ ]  buffer =  new  byte  [ 1024 ] ;   int  bytesRead ;  while  (   (  bytesRead =  inputStream . read  ( buffer ) ) !=  - 1 )  {   outputStream . write  ( buffer , 0 , bytesRead ) ; }   outputStream . close  ( ) ;  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "sh" ,   tempFile . getAbsoluteFile  ( ) . toString  ( ) , jsonString , plistFilePath ) ;   processBuilder . directory  ( workDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; }  catch (   IOException e )  {   e . printStackTrace  ( ) ;  throw  new IOSException  ( e ) ; }  return plistFile ; }   private static void installCarthageDependencies  (  File projectDirectory )  throws IOSException  {  try  {  ProcessBuilder  processBuilder =  new ProcessBuilder  ( "carthage" , "update" ) ;   processBuilder . directory  ( projectDirectory ) ;   CommandHelper . performCommand  ( processBuilder ) ; }  catch (   Exception e )  {   e . printStackTrace  ( ) ;  throw  new IOSException  ( e ) ; } } }