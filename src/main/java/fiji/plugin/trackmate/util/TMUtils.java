  package    fiji . plugin . trackmate . util ;   import static      fiji . plugin . trackmate . detection . DetectorKeys . KEY_TARGET_CHANNEL ;  import   java . io . File ;  import   java . text . SimpleDateFormat ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . Comparator ;  import   java . util . Date ;  import   java . util . LinkedHashMap ;  import   java . util . LinkedList ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Set ;  import   org . scijava . Context ;  import    fiji . plugin . trackmate . Dimension ;  import    fiji . plugin . trackmate . Logger ;  import    fiji . plugin . trackmate . Settings ;  import    fiji . plugin . trackmate . Spot ;  import      fiji . plugin . trackmate . features . edges . EdgeAnalyzer ;  import      fiji . plugin . trackmate . features . spot . SpotAnalyzerFactory ;  import      fiji . plugin . trackmate . features . track . TrackAnalyzer ;  import     fiji . plugin . trackmate . providers . EdgeAnalyzerProvider ;  import     fiji . plugin . trackmate . providers . SpotAnalyzerProvider ;  import     fiji . plugin . trackmate . providers . TrackAnalyzerProvider ;  import  ij . IJ ;  import  ij . ImagePlus ;  import   net . imagej . ImgPlus ;  import   net . imagej . ImgPlusMetadata ;  import    net . imagej . axis . Axes ;  import    net . imagej . axis . AxisType ;  import   net . imglib2 . FinalInterval ;  import   net . imglib2 . Interval ;  import    net . imglib2 . img . ImagePlusAdapter ;  import      net . imglib2 . type . numeric . real . DoubleType ;  import    net . imglib2 . util . Util ;   public class TMUtils  {   private static final SimpleDateFormat  DATE_FORMAT =  new SimpleDateFormat  ( "EEE, d MMM yyyy HH:mm:ss" ) ;   public static  <  K ,  V  extends  Comparable  <  ? super V > >  Map  < K , V > sortByValue  (   final  Map  < K , V > map ,   final  Comparator  < V > comparator )  {   final  List  <   Map . Entry  < K , V > >  list =  new  LinkedList  < >  (  map . entrySet  ( ) ) ;   Collections . sort  ( list ,  Comparator . comparing  (   Map . Entry :: getValue ) ) ;   final  LinkedHashMap  < K , V >  result =  new  LinkedHashMap  < >  ( ) ;  for (  final   Map . Entry  < K , V > entry : list )   result . put  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ;  return result ; }   public static final String echoMap  (   final  Map  < String , Object > map ,   final  int indent )  {   final StringBuilder  builder =  new StringBuilder  ( ) ;  for (  final String key :  map . keySet  ( ) )  {  for (   int  i = 0 ;  i < indent ;  i ++ )   builder . append  ( " " ) ;   builder . append  ( "- " ) ;   builder . append  (   key . toLowerCase  ( ) . replace  ( "_" , " " ) ) ;   builder . append  ( ": " ) ;   final Object  obj =  map . get  ( key ) ;  if  (  obj instanceof Map )  {   builder . append  ( '\n' ) ;    @ SuppressWarnings  ( "unchecked" ) final  Map  < String , Object >  submap =  (  Map  < String , Object > ) obj ;   builder . append  (  echoMap  ( submap ,  indent + 2 ) ) ; } else  {   builder . append  (  obj . toString  ( ) ) ;   builder . append  ( '\n' ) ; } }  return  builder . toString  ( ) ; }    @ SuppressWarnings  ( "rawtypes" ) public static final ImgPlus rawWraps  (   final ImagePlus imp )  {   final  ImgPlus  < DoubleType >  img =  ImagePlusAdapter . wrapImgPlus  ( imp ) ;   final ImgPlus  raw = img ;  return raw ; }   public static final  <  T > boolean checkMapKeys  (   final  Map  < T ,  ? > map ,   Collection  < T > mandatoryKeys ,   Collection  < T > optionalKeys ,   final StringBuilder errorHolder )  {  if  (  null == optionalKeys )   optionalKeys =  new  ArrayList  < >  ( ) ;  if  (  null == mandatoryKeys )   mandatoryKeys =  new  ArrayList  < >  ( ) ;  boolean  ok = true ;   final  Set  < T >  keySet =  map . keySet  ( ) ;  for (  final T key : keySet )  {  if  (  !  (   mandatoryKeys . contains  ( key ) ||  optionalKeys . contains  ( key ) ) )  {   ok = false ;   errorHolder . append  (   "Map contains unexpected key: " + key + ".\n" ) ; } }  for (  final T key : mandatoryKeys )  {  if  (  !  keySet . contains  ( key ) )  {   ok = false ;   errorHolder . append  (   "Mandatory key " + key + " was not found in the map.\n" ) ; } }  return ok ; }   public static final boolean checkParameter  (   final  Map  < String , Object > map ,   final String key ,   final  Class  <  ? > expectedClass ,   final StringBuilder errorHolder )  {   final Object  obj =  map . get  ( key ) ;  if  (  null == obj )  {   errorHolder . append  (   "Parameter " + key + " could not be found in settings map, or is null.\n" ) ;  return false ; }  if  (  !  expectedClass . isInstance  ( obj ) )  {   errorHolder . append  (       "Value for parameter " + key + " is not of the right class. Expected " +  expectedClass . getName  ( ) + ", got " +   obj . getClass  ( ) . getName  ( ) + ".\n" ) ;  return false ; }  return true ; }   public static final  <  J ,  K >  List  < K > getArrayFromMaping  (   final  List  < J > keys ,   final  Map  < J , K > mapping )  {   final  List  < K >  names =  new  ArrayList  < >  (  keys . size  ( ) ) ;  for (   int  i = 0 ;  i <  keys . size  ( ) ;  i ++ )   names . add  (  mapping . get  (  keys . get  ( i ) ) ) ;  return names ; }   private static final  int findAxisIndex  (   final ImgPlusMetadata img ,   final AxisType axis )  {  return  img . dimensionIndex  ( axis ) ; }   public static final  int findXAxisIndex  (   final ImgPlusMetadata img )  {  return  findAxisIndex  ( img ,  Axes . X ) ; }   public static final  int findYAxisIndex  (   final ImgPlusMetadata img )  {  return  findAxisIndex  ( img ,  Axes . Y ) ; }   public static final  int findZAxisIndex  (   final ImgPlusMetadata img )  {  return  findAxisIndex  ( img ,  Axes . Z ) ; }   public static final  int findTAxisIndex  (   final ImgPlusMetadata img )  {  return  findAxisIndex  ( img ,  Axes . TIME ) ; }   public static final  int findCAxisIndex  (   final ImgPlusMetadata img )  {  return  findAxisIndex  ( img ,  Axes . CHANNEL ) ; }   public static final   double  [ ] getSpatialCalibration  (   final ImgPlusMetadata img )  {   final   double  [ ]  calibration =  Util . getArrayFromValue  ( 1d , 3 ) ;  for (   int  d = 0 ;  d <  img . numDimensions  ( ) ;  d ++ )  {  if  (    img . axis  ( d ) . type  ( ) ==  Axes . X )    calibration [ 0 ] =  img . averageScale  ( d ) ; else  if  (    img . axis  ( d ) . type  ( ) ==  Axes . Y )    calibration [ 1 ] =  img . averageScale  ( d ) ; else  if  (    img . axis  ( d ) . type  ( ) ==  Axes . Z )    calibration [ 2 ] =  img . averageScale  ( d ) ; }  return calibration ; }   public static   double  [ ] getSpatialCalibration  (   final ImagePlus imp )  {   final   double  [ ]  calibration =  Util . getArrayFromValue  ( 1d , 3 ) ;    calibration [ 0 ] =   imp . getCalibration  ( ) . pixelWidth ;    calibration [ 1 ] =   imp . getCalibration  ( ) . pixelHeight ;  if  (   imp . getNSlices  ( ) > 1 )    calibration [ 2 ] =   imp . getCalibration  ( ) . pixelDepth ;  return calibration ; }   public static final  double getPercentile  (   final   double  [ ] values ,   final  double p )  {   final  int  size =  values . length ;  if  (   (  p > 1 ) ||  (  p <= 0 ) )  throw  new IllegalArgumentException  (  "invalid quantile value: " + p ) ;  if  (  size == 0 )  return  Double . NaN ;  if  (  size == 1 )  return  values [ 0 ] ;   final  double  n = size ;   final  double  pos =  p *  (  n + 1 ) ;   final  double  fpos =  Math . floor  ( pos ) ;   final  int  intPos =  (  int ) fpos ;   final  double  dif =  pos - fpos ;   final   double  [ ]  sorted =  new  double  [ size ] ;   System . arraycopy  ( values , 0 , sorted , 0 , size ) ;   Arrays . sort  ( sorted ) ;  if  (  pos < 1 )  return  sorted [ 0 ] ;  if  (  pos >= n )  return  sorted [  size - 1 ] ;   final  double  lower =  sorted [  intPos - 1 ] ;   final  double  upper =  sorted [ intPos ] ;  return  lower +  dif *  (  upper - lower ) ; }   private static final   double  [ ] getRange  (   final   double  [ ] data )  {   final  double  min =    Arrays . stream  ( data ) . min  ( ) . getAsDouble  ( ) ;   final  double  max =    Arrays . stream  ( data ) . max  ( ) . getAsDouble  ( ) ;  return  new  double  [ ]  {  (  max - min ) , min , max } ; }   public static final void localize  (   final Spot spot ,   final   double  [ ] coords )  {    coords [ 0 ] =   spot . getFeature  (  Spot . POSITION_X ) . doubleValue  ( ) ;    coords [ 1 ] =   spot . getFeature  (  Spot . POSITION_Y ) . doubleValue  ( ) ;    coords [ 2 ] =   spot . getFeature  (  Spot . POSITION_Z ) . doubleValue  ( ) ; }   public static final  int getNBins  (   final   double  [ ] values ,   final  int minBinNumber ,   final  int maxBinNumber )  {   final  int  size =  values . length ;   final  double  q1 =  getPercentile  ( values , 0.25 ) ;   final  double  q3 =  getPercentile  ( values , 0.75 ) ;   final  double  iqr =  q3 - q1 ;   final  double  binWidth =   2 * iqr *  Math . pow  ( size ,  - 0.33 ) ;   final   double  [ ]  range =  getRange  ( values ) ;   int  nBin =  (  int )  (    range [ 0 ] / binWidth + 1 ) ;  if  (  nBin > maxBinNumber )   nBin = maxBinNumber ; else  if  (  nBin < minBinNumber )   nBin = minBinNumber ;  return nBin ; }   private static final  int getNBins  (   final   double  [ ] values )  {  return  getNBins  ( values , 8 , 256 ) ; }   private static final   int  [ ] histogram  (   final  double data  [ ] ,   final  int nBins )  {   final   double  [ ]  range =  getRange  ( data ) ;   final  double  binWidth =   range [ 0 ] / nBins ;   final   int  [ ]  hist =  new  int  [ nBins ] ;   int  index ;  if  (  nBins > 0 )  {  for (   int  i = 0 ;  i <  data . length ;  i ++ )  {   index =  Math . min  (  (  int )  Math . floor  (   (   data [ i ] -  range [ 1 ] ) / binWidth ) ,  nBins - 1 ) ;    hist [ index ] ++ ; } }  return hist ; }   public static final  double otsuThreshold  (   final   double  [ ] data )  {  return  otsuThreshold  ( data ,  getNBins  ( data ) ) ; }   private static final  double otsuThreshold  (   final   double  [ ] data ,   final  int nBins )  {   final   int  [ ]  hist =  histogram  ( data , nBins ) ;   final  int  thresholdIndex =  otsuThresholdIndex  ( hist ,  data . length ) ;   final   double  [ ]  range =  getRange  ( data ) ;   final  double  binWidth =   range [ 0 ] / nBins ;  return   range [ 1 ] +  binWidth * thresholdIndex ; }   private static final  int otsuThresholdIndex  (   final   int  [ ] hist ,   final  int nPoints )  {   final  int  total = nPoints ;   double  sum = 0 ;  for (   int  t = 0 ;  t <  hist . length ;  t ++ )   sum +=  t *  hist [ t ] ;   double  sumB = 0 ;   int  wB = 0 ;   int  wF = 0 ;   double  varMax = 0 ;   int  threshold = 0 ;  for (   int  t = 0 ;  t <  hist . length ;  t ++ )  {   wB +=  hist [ t ] ;  if  (  wB == 0 )  continue ;   wF =  total - wB ;  if  (  wF == 0 )  break ;   sumB +=  (  t *  hist [ t ] ) ;   final  double  mB =  sumB / wB ;   final  double  mF =   (  sum - sumB ) / wF ;   final  double  varBetween =    wB * wF *  (  mB - mF ) *  (  mB - mF ) ;  if  (  varBetween > varMax )  {   varMax = varBetween ;   threshold = t ; } }  return threshold ; }   public static final String getUnitsFor  (   final Dimension dimension ,   final String spaceUnits ,   final String timeUnits )  {  String  units = "no unit" ;  switch  ( dimension )  {   case ANGLE :   units = "Radians" ;  break ;   case INTENSITY :   units = "Counts" ;  break ;   case INTENSITY_SQUARED :   units = "Counts^2" ;  break ;   case NONE :   units = "" ;  break ;   case POSITION :   case LENGTH :   units = spaceUnits ;  break ;   case QUALITY :   units = "Quality" ;  break ;   case TIME :   units = timeUnits ;  break ;   case VELOCITY :   units =   spaceUnits + "/" + timeUnits ;  break ;   case RATE :   units =  "/" + timeUnits ;  break ;   default :  break ;   case STRING :  return null ; }  return units ; }   public static final String getCurrentTimeString  ( )  {  return  DATE_FORMAT . format  (  new Date  ( ) ) ; }   public static final Interval getIntervalWithTime  (   final  ImgPlus  <  ? > img ,   final Settings settings )  {   final   long  [ ]  max =  new  long  [  img . numDimensions  ( ) ] ;   final   long  [ ]  min =  new  long  [  img . numDimensions  ( ) ] ;   final  int  xindex =  TMUtils . findXAxisIndex  ( img ) ;    min [ xindex ] =  settings . xstart ;    max [ xindex ] =  settings . xend ;   final  int  yindex =  TMUtils . findYAxisIndex  ( img ) ;    min [ yindex ] =  settings . ystart ;    max [ yindex ] =  settings . yend ;   final  int  zindex =  TMUtils . findZAxisIndex  ( img ) ;  if  (  zindex >= 0 )  {    min [ zindex ] =  settings . zstart ;    max [ zindex ] =  settings . zend ; }   final  int  cindex =  TMUtils . findCAxisIndex  ( img ) ;  if  (  cindex >= 0 )  {  Integer  c =  ( Integer )   settings . detectorSettings . get  ( KEY_TARGET_CHANNEL ) ;  if  (  null == c )   c = 1 ;    min [ cindex ] =  c - 1 ;    max [ cindex ] =  min [ cindex ] ; }   final  int  tindex =  TMUtils . findTAxisIndex  ( img ) ;  if  (  tindex >= 0 )  {    min [ tindex ] =  settings . tstart ;    max [ tindex ] =  settings . tend ; }   final FinalInterval  interval =  new FinalInterval  ( min , max ) ;  return interval ; }   public static final Interval getInterval  (   final  ImgPlus  <  ? > img ,   final Settings settings )  {   final   long  [ ]  max =  new  long  [  img . numDimensions  ( ) ] ;   final   long  [ ]  min =  new  long  [  img . numDimensions  ( ) ] ;   final  int  xindex =  TMUtils . findXAxisIndex  ( img ) ;    min [ xindex ] =  settings . xstart ;    max [ xindex ] =  settings . xend ;   final  int  yindex =  TMUtils . findYAxisIndex  ( img ) ;    min [ yindex ] =  settings . ystart ;    max [ yindex ] =  settings . yend ;   final  int  zindex =  TMUtils . findZAxisIndex  ( img ) ;  if  (  zindex >= 0 )  {    min [ zindex ] =  settings . zstart ;    max [ zindex ] =  settings . zend ; }   final  int  cindex =  TMUtils . findCAxisIndex  ( img ) ;  if  (  cindex >= 0 )  {  Integer  c =  ( Integer )   settings . detectorSettings . get  ( KEY_TARGET_CHANNEL ) ;  if  (  null == c )   c = 1 ;    min [ cindex ] =  c - 1 ;    max [ cindex ] =  min [ cindex ] ; }   final  int  tindex =  TMUtils . findTAxisIndex  ( img ) ;   final   long  [ ]  intervalMin ;   final   long  [ ]  intervalMax ;  if  (  tindex >= 0 )  {   intervalMin =  new  long  [   min . length - 1 ] ;   intervalMax =  new  long  [   min . length - 1 ] ;   int  nindex =  - 1 ;  for (   int  d = 0 ;  d <  min . length ;  d ++ )  {  if  (  d == tindex )  continue ;   nindex ++ ;    intervalMin [ nindex ] =  Math . max  ( 0l ,  min [ d ] ) ;    intervalMax [ nindex ] =  Math . min  (  img . max  ( d ) ,  max [ d ] ) ; } } else  {   intervalMin = min ;   intervalMax = max ; }   final FinalInterval  interval =  new FinalInterval  ( intervalMin , intervalMax ) ;  return interval ; }   public static Context getContext  ( )  {  return  ( Context )  IJ . runPlugIn  ( "org.scijava.Context" , "" ) ; }   public static void declareAllFeatures  (   final Settings settings )  {   settings . clearSpotAnalyzerFactories  ( ) ;   final SpotAnalyzerProvider  spotAnalyzerProvider =  new SpotAnalyzerProvider  (  settings . imp ) ;   final  List  < String >  spotAnalyzerKeys =  spotAnalyzerProvider . getKeys  ( ) ;  for (  final String key : spotAnalyzerKeys )  {   final  SpotAnalyzerFactory  <  ? >  spotFeatureAnalyzer =  spotAnalyzerProvider . getFactory  ( key ) ;   settings . addSpotAnalyzerFactory  ( spotFeatureAnalyzer ) ; }   settings . clearEdgeAnalyzers  ( ) ;   final EdgeAnalyzerProvider  edgeAnalyzerProvider =  new EdgeAnalyzerProvider  ( ) ;   final  List  < String >  edgeAnalyzerKeys =  edgeAnalyzerProvider . getKeys  ( ) ;  for (  final String key : edgeAnalyzerKeys )  {   final EdgeAnalyzer  edgeAnalyzer =  edgeAnalyzerProvider . getFactory  ( key ) ;   settings . addEdgeAnalyzer  ( edgeAnalyzer ) ; }   settings . clearTrackAnalyzers  ( ) ;   final TrackAnalyzerProvider  trackAnalyzerProvider =  new TrackAnalyzerProvider  ( ) ;   final  List  < String >  trackAnalyzerKeys =  trackAnalyzerProvider . getKeys  ( ) ;  for (  final String key : trackAnalyzerKeys )  {   final TrackAnalyzer  trackAnalyzer =  trackAnalyzerProvider . getFactory  ( key ) ;   settings . addTrackAnalyzer  ( trackAnalyzer ) ; } }   public static File proposeTrackMateSaveFile  (   final Settings settings ,   final Logger logger )  {  File  folder ,  file ;  if  (    null !=  settings . imp &&  null !=   settings . imp . getOriginalFileInfo  ( ) &&  null !=    settings . imp . getOriginalFileInfo  ( ) . directory )  {   folder =  new File  (    settings . imp . getOriginalFileInfo  ( ) . directory ) ;    settings . imageFolder =    settings . imp . getOriginalFileInfo  ( ) . directory ; } else  {   folder =  new File  (  System . getProperty  ( "user.dir" ) ) ;   logger . error  (   "Warning: The source image does not match a file on the system." + "TrackMate won't be able to reload it when opening this XML file.\n" + "To fix this, save the source image to a TIF file before saving the TrackMate session.\n" ) ;    settings . imageFolder = "" ; }  try  {   file =  new File  (     folder . getPath  ( ) +  File . separator +   settings . imp . getShortTitle  ( ) + ".xml" ) ; }  catch (   final  NullPointerException npe )  {   file =  new File  (    folder . getPath  ( ) +  File . separator + "TrackMateData.xml" ) ; }  return file ; }   private TMUtils  ( )  { } }