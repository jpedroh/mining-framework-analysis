  package     strat . mining . stratum . proxy . worker ;   import   java . util . Date ;  import   java . util . Set ;  import      strat . mining . stratum . proxy . exception . ChangeExtranonceNotSupportedException ;  import      strat . mining . stratum . proxy . exception . TooManyWorkersException ;  import      strat . mining . stratum . proxy . json . MiningNotifyNotification ;  import      strat . mining . stratum . proxy . json . MiningSetDifficultyNotification ;  import      strat . mining . stratum . proxy . json . MiningSubmitRequest ;  import      strat . mining . stratum . proxy . json . MiningSubmitResponse ;  import      strat . mining . stratum . proxy . model . Share ;  import      strat . mining . stratum . proxy . pool . Pool ;  import      strat . mining . stratum . proxy . utils . Timer ;  import       strat . mining . stratum . proxy . utils . Timer . Task ;  import      strat . mining . stratum . proxy . network . Connection ; 
<<<<<<<
  public class WorkerConnection  extends StratumConnection  {   private static final Logger  LOGGER =  LoggerFactory . getLogger  (  WorkerConnection . class ) ;   private Pool  pool ;   private StratumProxyManager  manager ;   private Task  subscribeTimeoutTask ;   private Integer  subscribeReceiveTimeout =  Constants . DEFAULT_SUBSCRIBE_RECEIVE_TIMEOUT ;   private Date  isActiveSince ;   private String  extranonce1Tail ;   private Integer  extranonce2Size ;   private  Set  < String >  authorizedWorkers ;   private boolean  isSetExtranonceNotificationSupported = false ;   private  Deque  < Share >  lastAcceptedShares ;   private  Deque  < Share >  lastRejectedShares ;   private Integer  samplingHashesPeriod =   Constants . DEFAULT_WORKER_CONNECTION_HASHRATE_SAMPLING_PERIOD * 1000 ;   public WorkerConnection  (  Socket socket ,  StratumProxyManager manager )  {  super  ( socket ) ;    this . manager = manager ;    this . authorizedWorkers =  Collections . synchronizedSet  (  new  HashSet  < String >  ( ) ) ;   lastAcceptedShares =  new  ConcurrentLinkedDeque  < Share >  ( ) ;   lastRejectedShares =  new  ConcurrentLinkedDeque  < Share >  ( ) ; }    @ Override public void startReading  ( )  {   super . startReading  ( ) ;   subscribeTimeoutTask =  new Task  ( )  {   public void run  ( )  {   LOGGER . warn  ( "No subscribe request received from {} in {} ms. Closing connection." ,  getConnectionName  ( ) , subscribeReceiveTimeout ) ;   close  ( ) ; } } ;    Timer . getInstance  ( ) . schedule  ( subscribeTimeoutTask , subscribeReceiveTimeout ) ; }    @ Override protected void onParsingError  (  String line ,  Throwable throwable )  {   LOGGER . error  ( "Parsing error on worker connection {}. Failed to parse line {}." ,  getConnectionName  ( ) , line , throwable ) ; }    @ Override protected void onDisconnectWithError  (  Throwable cause )  {   manager . onWorkerDisconnection  ( this , cause ) ; }    @ Override protected void onNotify  (  MiningNotifyNotification notify )  { }    @ Override protected void onSetDifficulty  (  MiningSetDifficultyNotification setDifficulty )  { }    @ Override protected void onSetExtranonce  (  MiningSetExtranonceNotification setExtranonce )  { }    @ Override protected void onClientReconnect  (  ClientReconnectNotification clientReconnect )  { }    @ Override protected void onAuthorizeRequest  (  MiningAuthorizeRequest request )  {  MiningAuthorizeResponse  response =  new MiningAuthorizeResponse  ( ) ;   response . setId  (  request . getId  ( ) ) ;  try  {   manager . onAuthorizeRequest  ( this , request ) ;   response . setIsAuthorized  ( true ) ;   authorizedWorkers . add  (  request . getUsername  ( ) ) ; }  catch (   AuthorizationException e )  {   response . setIsAuthorized  ( false ) ;  JsonRpcError  error =  new JsonRpcError  ( ) ;   error . setCode  (    JsonRpcError . ErrorCode . UNAUTHORIZED_WORKER . getCode  ( ) ) ;   error . setMessage  (  "The worker is not authorized. " +  e . getMessage  ( ) ) ;   response . setErrorRpc  ( error ) ;   LOGGER . warn  ( "User connection not authorized. {}" ,  e . getMessage  ( ) ) ; }   sendResponse  ( response ) ; }    @ Override protected void onSubscribeRequest  (  MiningSubscribeRequest request )  {  if  (  subscribeTimeoutTask != null )  {   subscribeTimeoutTask . cancel  ( ) ; }  JsonRpcError  error = null ;  try  {   pool =  manager . onSubscribeRequest  ( this , request ) ; }  catch (   NoPoolAvailableException e )  {   LOGGER . error  ( "No pool available for the connection {}. Sending error and close the connection." ,  getConnectionName  ( ) ) ;   error =  new JsonRpcError  ( ) ;   error . setCode  (    JsonRpcError . ErrorCode . UNKNOWN . getCode  ( ) ) ;   error . setMessage  ( "No pool available on this proxy." ) ; }  if  (  error == null )  {  try  {   extranonce1Tail =  pool . getFreeTail  ( ) ;   extranonce2Size =  pool . getWorkerExtranonce2Size  ( ) ; }  catch (   TooManyWorkersException e )  {   LOGGER . error  ( "Too many connections on pool {} for the connection {}. Sending error and close the connection." ,  pool . getName  ( ) ,  getConnectionName  ( ) , e ) ;   error =  new JsonRpcError  ( ) ;   error . setCode  (    JsonRpcError . ErrorCode . UNKNOWN . getCode  ( ) ) ;   error . setMessage  ( "Too many connection on the pool." ) ; } }  MiningSubscribeResponse  response =  new MiningSubscribeResponse  ( ) ;   response . setId  (  request . getId  ( ) ) ;  if  (  error != null )  {   response . setErrorRpc  ( error ) ; } else  {   response . setExtranonce1  (   pool . getExtranonce1  ( ) + extranonce1Tail ) ;   response . setExtranonce2Size  ( extranonce2Size ) ;   response . setSubscriptionDetails  (  getSubscibtionDetails  ( ) ) ;   isActiveSince =  new Date  ( ) ; }   sendResponse  ( response ) ;  if  (  error == null )  {   sendInitialNotifications  ( ) ; } }    @ Override protected void onSubmitRequest  (  MiningSubmitRequest request )  {  MiningSubmitResponse  response =  new MiningSubmitResponse  ( ) ;   response . setId  (  request . getId  ( ) ) ;  JsonRpcError  error = null ;  if  (  authorizedWorkers . contains  (  request . getWorkerName  ( ) ) )  {   request . setExtranonce2  (  extranonce1Tail +  request . getExtranonce2  ( ) ) ;   manager . onSubmitRequest  ( this , request ) ; } else  {   error =  new JsonRpcError  ( ) ;   error . setCode  (    JsonRpcError . ErrorCode . UNAUTHORIZED_WORKER . getCode  ( ) ) ;   error . setMessage  ( "Submit failed. Worker not authorized on this connection." ) ;   response . setErrorRpc  ( error ) ;   sendResponse  ( response ) ; } }    @ Override protected void onExtranonceSubscribeRequest  (  MiningExtranonceSubscribeRequest request )  {    this . isSetExtranonceNotificationSupported = true ; }    @ Override protected void onGetVersionRequest  (  ClientGetVersionRequest request )  {   LOGGER . warn  ( "Worker {} send a GetVersion request. This should not happen." ,  getConnectionName  ( ) ) ; }   public void onPoolSubmitResponse  (  MiningSubmitRequest workerRequest ,  MiningSubmitResponse poolResponse )  {  if  (    poolResponse . getIsAccepted  ( ) != null &&  poolResponse . getIsAccepted  ( ) )  {   LOGGER . info  ( "Accepted share (diff: {}) from {}@{} on {}. Yeah !!!!" ,   pool != null ?  pool . getDifficulty  ( ) : "Unknown" ,  workerRequest . getWorkerName  ( ) ,  getConnectionName  ( ) ,  pool . getName  ( ) ) ; } else  {   LOGGER . info  ( "REJECTED share (diff: {}) from {}@{} on {}. Booo !!!!. Error: {}" ,   pool != null ?  pool . getDifficulty  ( ) : "Unknown" ,  workerRequest . getWorkerName  ( ) ,  getConnectionName  ( ) ,  pool . getName  ( ) ,  poolResponse . getJsonError  ( ) ) ; }  MiningSubmitResponse  workerResponse =  new MiningSubmitResponse  ( ) ;   workerResponse . setId  (  workerRequest . getId  ( ) ) ;   workerResponse . setIsAccepted  (  poolResponse . getIsAccepted  ( ) ) ;   workerResponse . setError  (  poolResponse . getError  ( ) ) ;   sendResponse  ( workerResponse ) ; }   public void onPoolExtranonceChange  ( )  throws ChangeExtranonceNotSupportedException  {  if  ( isSetExtranonceNotificationSupported )  {  MiningSetExtranonceNotification  extranonceNotif =  new MiningSetExtranonceNotification  ( ) ;   extranonceNotif . setExtranonce1  (   pool . getExtranonce1  ( ) + extranonce1Tail ) ;   extranonceNotif . setExtranonce2Size  ( extranonce2Size ) ;   sendNotification  ( extranonceNotif ) ; } else  {  throw  new ChangeExtranonceNotSupportedException  ( "Change extranonce not supported." ) ; } }    @ Override protected void onAuthorizeResponse  (  MiningAuthorizeRequest request ,  MiningAuthorizeResponse response )  {   LOGGER . warn  ( "Worker {} send an Authorize response. This should not happen." ,  getConnectionName  ( ) ) ; }    @ Override protected void onSubscribeResponse  (  MiningSubscribeRequest request ,  MiningSubscribeResponse response )  {   LOGGER . warn  ( "Worker {} send a Subscribe response. This should not happen." ,  getConnectionName  ( ) ) ; }    @ Override protected void onSubmitResponse  (  MiningSubmitRequest request ,  MiningSubmitResponse response )  {   LOGGER . warn  ( "Worker {} send a Submit response. This should not happen." ,  getConnectionName  ( ) ) ; }    @ Override protected void onExtranonceSubscribeResponse  (  MiningExtranonceSubscribeRequest request ,  MiningExtranonceSubscribeResponse response )  {   LOGGER . warn  ( "Worker {} send an Extranonce subscribe response. This should not happen." ,  getConnectionName  ( ) ) ; }    @ Override protected void onGetVersionResponse  (  ClientGetVersionRequest request ,  ClientGetVersionResponse response )  { }   private  List  < Object > getSubscibtionDetails  ( )  {   List  < Object >  details =  new  ArrayList  < Object >  ( ) ;   List  < Object >  setDifficultySubscribe =  new  ArrayList  < >  ( ) ;   setDifficultySubscribe . add  (  MiningSetDifficultyNotification . METHOD_NAME ) ;   setDifficultySubscribe . add  ( "b4b6693b72a50c7116db18d6497cac52" ) ;   details . add  ( setDifficultySubscribe ) ;   List  < Object >  notifySubscribe =  new  ArrayList  < Object >  ( ) ;   notifySubscribe . add  (  MiningNotifyNotification . METHOD_NAME ) ;   notifySubscribe . add  ( "ae6812eb4cd7735a302a8a9dd95cf71f" ) ;   details . add  ( notifySubscribe ) ;  return details ; }   public Pool getPool  ( )  {  return pool ; }   private void sendInitialNotifications  ( )  {  if  ( isSetExtranonceNotificationSupported )  {  MiningSetExtranonceNotification  extranonceNotif =  new MiningSetExtranonceNotification  ( ) ;   extranonceNotif . setExtranonce1  (   pool . getExtranonce1  ( ) + extranonce1Tail ) ;   extranonceNotif . setExtranonce2Size  ( extranonce2Size ) ;   sendNotification  ( extranonceNotif ) ;   LOGGER . debug  ( "Initial extranonce sent to {}." ,  getConnectionName  ( ) ) ; }  Double  difficulty =  pool . getDifficulty  ( ) ;  if  (  difficulty != null )  {  MiningSetDifficultyNotification  setDifficulty =  new MiningSetDifficultyNotification  ( ) ;   setDifficulty . setDifficulty  ( difficulty ) ;   sendNotification  ( setDifficulty ) ;   LOGGER . debug  ( "Initial difficulty sent to {}." ,  getConnectionName  ( ) ) ; }  MiningNotifyNotification  notify =  pool . getCurrentJob  ( ) ;  if  (  notify != null )  {   sendNotification  ( notify ) ;   LOGGER . debug  ( "Initial job sent to {}." ,  getConnectionName  ( ) ) ; } }   public void rebindToPool  (  Pool newPool )  throws TooManyWorkersException , ChangeExtranonceNotSupportedException  {  if  ( isSetExtranonceNotificationSupported )  {   LOGGER . info  ( "Rebind connection {} from pool {} to pool {} with setExtranonce notification." ,  getConnectionName  ( ) ,  pool . getName  ( ) ,  newPool . getName  ( ) ) ;   pool . releaseTail  ( extranonce1Tail ) ;   extranonce1Tail =  newPool . getFreeTail  ( ) ;   extranonce2Size =  newPool . getWorkerExtranonce2Size  ( ) ;   pool = newPool ;   sendInitialNotifications  ( ) ; } else  {  throw  new ChangeExtranonceNotSupportedException  ( "Change extranonce not supported." ) ; } }    @ Override public void close  ( )  {   super . close  ( ) ;  if  (  pool != null )  {   pool . releaseTail  ( extranonce1Tail ) ; } }   public  Set  < String > getAuthorizedWorkers  ( )  {  return  Collections . unmodifiableSet  ( authorizedWorkers ) ; }   public  double getAcceptedHashrate  ( )  {   HashrateUtils . purgeShareList  ( lastAcceptedShares , samplingHashesPeriod ) ;  return  HashrateUtils . getHashrateFromShareList  ( lastAcceptedShares , samplingHashesPeriod ) ; }   public  double getRejectedHashrate  ( )  {   HashrateUtils . purgeShareList  ( lastRejectedShares , samplingHashesPeriod ) ;  return  HashrateUtils . getHashrateFromShareList  ( lastRejectedShares , samplingHashesPeriod ) ; }   public void updateShareLists  (  Share share ,  boolean isAccepted )  {  if  ( isAccepted )  {   lastAcceptedShares . addLast  ( share ) ;   HashrateUtils . purgeShareList  ( lastAcceptedShares , samplingHashesPeriod ) ; } else  {   lastRejectedShares . addLast  ( share ) ;   HashrateUtils . purgeShareList  ( lastRejectedShares , samplingHashesPeriod ) ; } }   public void setSamplingHashesPeriod  (  Integer samplingHashesPeriod )  {    this . samplingHashesPeriod =  samplingHashesPeriod * 1000 ; }   public Date getActiveSince  ( )  {  return isActiveSince ; }   public boolean isSetExtranonceNotificationSupported  ( )  {  return isSetExtranonceNotificationSupported ; } }
=======
  public interface WorkerConnection  extends  Connection  {   public Pool getPool  ( ) ;   public boolean isConnected  ( ) ;   public void rebindToPool  (  Pool newPool )  throws TooManyWorkersException , ChangeExtranonceNotSupportedException ;   public void onPoolExtranonceChange  ( )  throws ChangeExtranonceNotSupportedException ;   public void onPoolDifficultyChanged  (  MiningSetDifficultyNotification notification ) ;   public void onPoolNotify  (  MiningNotifyNotification notification ) ;   public void updateShareLists  (  Share share ,  boolean isAccepted ) ;   public void onPoolSubmitResponse  (  MiningSubmitRequest workerRequest ,  MiningSubmitResponse poolResponse ) ;   public void setSamplingHashesPeriod  (  Integer samplingHashesPeriod ) ;   public  double getRejectedHashrate  ( ) ;   public  double getAcceptedHashrate  ( ) ;   public  Set  < String > getAuthorizedWorkers  ( ) ;   public Date getActiveSince  ( ) ; }
>>>>>>>
