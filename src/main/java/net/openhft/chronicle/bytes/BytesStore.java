  package    net . openhft . chronicle . bytes ;   import      net . openhft . chronicle . bytes . algo . OptimisedBytesStoreHash ;  import      net . openhft . chronicle . bytes . algo . VanillaBytesStoreHash ;  import      net . openhft . chronicle . bytes . internal . BytesInternal ;  import      net . openhft . chronicle . bytes . internal . HeapBytesStore ;  import      net . openhft . chronicle . bytes . internal . NativeBytesStore ;  import     net . openhft . chronicle . core . Jvm ;  import      net . openhft . chronicle . core . io . IORuntimeException ;  import      net . openhft . chronicle . core . io . ReferenceCounted ;  import    org . jetbrains . annotations . NotNull ;  import    org . jetbrains . annotations . Nullable ;  import   javax . crypto . Cipher ;  import   java . io . IOException ;  import   java . io . OutputStream ;  import   java . nio . BufferOverflowException ;  import   java . nio . BufferUnderflowException ;  import   java . nio . ByteBuffer ;  import    java . nio . charset . StandardCharsets ;  import   java . util . Objects ;  import static    java . lang . Math . min ;  import static       net . openhft . chronicle . bytes . internal . ReferenceCountedUtil . throwExceptionIfReleased ;  import static       net . openhft . chronicle . core . util . ObjectUtils . requireNonNull ;    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public interface BytesStore  <  B  extends  BytesStore  < B , U > ,  U >  extends  RandomDataInput ,  RandomDataOutput  < B > , ReferenceCounted , CharSequence  {   static BytesStore from  (    @ NotNull CharSequence cs )  throws IllegalStateException  {  if  (  cs instanceof BytesStore )  return  from  (  ( BytesStore ) cs ) ;  return  from  (  cs . toString  ( ) ) ; }   static BytesStore from  (    @ NotNull BytesStore cs )  throws IllegalStateException  {  return  cs . copy  ( ) ; }   static BytesStore from  (    @ NotNull String cs )  {  return  BytesStore . wrap  (  cs . getBytes  (  StandardCharsets . ISO_8859_1 ) ) ; }   static  <  T >  BytesStore  <  ? , T > forFields  (  Object o ,  String groupName ,   int padding )  {  return  HeapBytesStore . forFields  ( o , groupName , padding ) ; }   static  BytesStore  <  ? ,   byte  [ ] > wrap  (    byte  [ ] bytes )  {  return  HeapBytesStore . wrap  ( bytes ) ; }    @ NotNull static  BytesStore  <  ? , ByteBuffer > wrap  (    @ NotNull ByteBuffer bb )  {  return   bb . isDirect  ( ) ?  NativeBytesStore . wrap  ( bb ) :  HeapBytesStore . wrap  ( bb ) ; }   static  BytesStore  <  ? , Void > nativeStore  (   long capacity )  {  return  NativeBytesStore . nativeStore  ( capacity ) ; }   static  BytesStore  <  ? , Void > nativeStoreWithFixedCapacity  (   long capacity )  {  return  NativeBytesStore . nativeStoreWithFixedCapacity  ( capacity ) ; }   static  BytesStore  <  ? , Void > lazyNativeBytesStoreWithFixedCapacity  (   long capacity )  {  return  NativeBytesStore . lazyNativeBytesStoreWithFixedCapacity  ( capacity ) ; }   static  BytesStore  <  ? , ByteBuffer > elasticByteBuffer  (   int size ,   long maxSize )  {  return  NativeBytesStore . elasticByteBuffer  ( size , maxSize ) ; }   static  BytesStore  <  ? , Void > nativeStoreFrom  (    byte  [ ] bytes )  {   Objects . requireNonNull  ( bytes ) ;  return  NativeBytesStore . from  ( bytes ) ; }    @ NotNull static PointerBytesStore nativePointer  ( )  {  return  new PointerBytesStore  ( ) ; }    @ NotNull static PointerBytesStore wrap  (   long address ,   long length )  {    @ NotNull PointerBytesStore  pbs =  nativePointer  ( ) ;   pbs . set  ( address , length ) ;  return pbs ; }   static BytesStore empty  ( )  {  return  NoBytesStore . noBytesStore  ( ) ; }    @ Override boolean isDirectMemory  ( ) ;   BytesStore  < B , U > copy  ( )  throws IllegalStateException ;    @ Override  @ NotNull default  Bytes  < U > bytesForRead  ( )  throws IllegalStateException  {  try  {   Bytes  < U >  ret =  bytesForWrite  ( ) ;   ret . readLimit  (  writeLimit  ( ) ) ;   ret . writeLimit  (  realCapacity  ( ) ) ;   ret . readPosition  (  start  ( ) ) ;  return ret ; }  catch (   BufferUnderflowException | BufferOverflowException e )  {  throw  new IllegalStateException  ( e ) ; } }    @ Override  @ NotNull default  Bytes  < U > bytesForWrite  ( )  throws IllegalStateException  {  try  {  return  new  VanillaBytes  < >  ( this ,  writePosition  ( ) ,  writeLimit  ( ) ) ; }  catch (   IllegalArgumentException e )  {  throw  new AssertionError  ( e ) ; } }   default boolean isClear  ( )  {  return true ; }    @ Override default  long realCapacity  ( )  {  return  capacity  ( ) ; }    @ Override  long capacity  ( ) ;    @ Nullable U underlyingObject  ( ) ;   default boolean inside  (   long offset )  {  return    start  ( ) <= offset &&  offset <  safeLimit  ( ) ; }   default boolean inside  (   long offset ,   long buffer )  {  return    start  ( ) <= offset &&   offset + buffer <  safeLimit  ( ) ; }   default  long safeLimit  ( )  {  return  capacity  ( ) ; }   default  long copyTo  (    @ NotNull BytesStore store )  throws IllegalStateException  {   requireNonNull  ( store ) ;   throwExceptionIfReleased  ( this ) ;   throwExceptionIfReleased  ( store ) ;   long  readPos =  readPosition  ( ) ;   long  writePos =  store . writePosition  ( ) ;   long  copy =  min  (  readRemaining  ( ) ,  store . capacity  ( ) ) ;   long  i = 0 ;  try  {  for ( ;  i <  copy - 7 ;  i += 8 )   store . writeLong  (  writePos + i ,  readLong  (  readPos + i ) ) ;  for ( ;  i < copy ;  i ++ )   store . writeByte  (  writePos + i ,  readByte  (  readPos + i ) ) ; }  catch (   BufferOverflowException | BufferUnderflowException e )  {  throw  new AssertionError  ( e ) ; }  return copy ; }   default void copyTo  (    @ NotNull OutputStream out )  throws IOException , IllegalStateException  {   BytesInternal . copy  ( this , out ) ; }    @ Override  @ NotNull default B zeroOut  (   long start ,   long end )  throws IllegalStateException  {  if  (  end <= start )  return  ( B ) this ;  if  (  start <  start  ( ) )   start =  start  ( ) ;  if  (  end >  capacity  ( ) )   end =  capacity  ( ) ;   long  i = start ;  try  {  for ( ;  i <  end - 7 ;  i += 8L )   writeLong  ( i , 0L ) ;  for ( ;  i < end ;  i ++ )   writeByte  ( i , 0 ) ; }  catch (   BufferOverflowException | IllegalArgumentException | ArithmeticException e )  {  throw  new AssertionError  ( e ) ; }  return  ( B ) this ; }    @ Override default  int length  ( )  {  return  (  int )  Math . min  (  Integer . MAX_VALUE ,  readRemaining  ( ) ) ; }    @ Override default  char charAt  (   int index )  throws IndexOutOfBoundsException  {  try  {  return  (  char )  readUnsignedByte  (   readPosition  ( ) + index ) ; }  catch (   BufferUnderflowException e )  {  throw  new IndexOutOfBoundsException  (    (   readPosition  ( ) + index ) + " >= " +  readLimit  ( ) ) ; }  catch (   IllegalStateException e )  {  throw  Jvm . rethrow  ( e ) ; } }    @ NotNull  @ Override default CharSequence subSequence  (   int start ,   int end )  {  throw  new UnsupportedOperationException  ( "todo" ) ; }    @ NotNull default String toDebugString  ( )  throws IllegalStateException  {  try  {  return  toDebugString  ( 512 ) ; }  catch (   ArithmeticException e )  {  throw  new AssertionError  ( e ) ; } }    @ NotNull default String toDebugString  (   long maxLength )  throws IllegalStateException , ArithmeticException  {  return  BytesInternal . toDebugString  ( this , maxLength ) ; }    @ Nullable default BytesStore bytesStore  ( )  {  return this ; }   default boolean equalBytes  (    @ NotNull BytesStore bytesStore ,   long length )  throws BufferUnderflowException , IllegalStateException  {  return    length == 8 &&   bytesStore . length  ( ) >= 8 ?   readLong  (  readPosition  ( ) ) ==  bytesStore . readLong  (  bytesStore . readPosition  ( ) ) :  BytesInternal . equalBytesAny  ( this , bytesStore , length ) ; }   default  int byteCheckSum  ( )  throws IORuntimeException , BufferUnderflowException , IllegalStateException  {  try  {  return  byteCheckSum  (  readPosition  ( ) ,  readLimit  ( ) ) ; }  catch (   BufferUnderflowException e )  {  throw  new AssertionError  ( e ) ; } }   default  int byteCheckSum  (   long start ,   long end )  throws BufferUnderflowException , IllegalStateException  {   int  sum = 0 ;  for (   long  i = start ;  i < end ;  i ++ )  {   sum +=  readByte  ( i ) ; }  return  sum & 0xFF ; }   default boolean endsWith  (   char c )  throws IllegalStateException  {  try  {  return    readRemaining  ( ) > 0 &&   readUnsignedByte  (   readLimit  ( ) - 1 ) == c ; }  catch (   BufferUnderflowException e )  {  throw  new AssertionError  ( e ) ; } }   default boolean startsWith  (   char c )  throws IllegalStateException  {  try  {  return    readRemaining  ( ) > 0 &&   readUnsignedByte  (  readPosition  ( ) ) == c ; }  catch (   BufferUnderflowException e )  {  throw  new AssertionError  ( e ) ; } }   default boolean contentEquals  (    @ Nullable BytesStore bytesStore )  throws IllegalStateException  {  return   bytesStore != null &&  BytesInternal . contentEqual  ( this , bytesStore ) ; }   default boolean startsWith  (    @ Nullable BytesStore bytesStore )  throws IllegalStateException  {  return   bytesStore != null &&  BytesInternal . startsWith  ( this , bytesStore ) ; }    @ NotNull default String to8bitString  ( )  {  return  BytesInternal . to8bitString  ( this ) ; }   default  int addAndGetUnsignedByteNotAtomic  (   long offset ,   int adding )  throws BufferUnderflowException , IllegalStateException  {  try  {   int  r =   (   readUnsignedByte  ( offset ) + adding ) & 0xFF ;   writeByte  ( offset ,  (  byte ) r ) ;  return r ; }  catch (   BufferOverflowException e )  {  throw  new AssertionError  ( e ) ; } }   default  short addAndGetShortNotAtomic  (   long offset ,   short adding )  throws BufferUnderflowException , IllegalStateException  {  try  {   short  r =  (  short )  (   readShort  ( offset ) + adding ) ;   writeByte  ( offset , r ) ;  return r ; }  catch (   BufferOverflowException | IllegalArgumentException | ArithmeticException e )  {  throw  new AssertionError  ( e ) ; } }   default  int addAndGetIntNotAtomic  (   long offset ,   int adding )  throws BufferUnderflowException , IllegalStateException  {  try  {   int  r =   readInt  ( offset ) + adding ;   writeInt  ( offset , r ) ;  return r ; }  catch (   BufferOverflowException e )  {  throw  new AssertionError  ( e ) ; } }   default  double addAndGetDoubleNotAtomic  (   long offset ,   double adding )  throws BufferUnderflowException , IllegalStateException  {  try  {   double  r =   readDouble  ( offset ) + adding ;   writeDouble  ( offset , r ) ;  return r ; }  catch (   BufferOverflowException e )  {  throw  new AssertionError  ( e ) ; } }   default  float addAndGetFloatNotAtomic  (   long offset ,   float adding )  throws BufferUnderflowException , IllegalStateException  {  try  {   float  r =   readFloat  ( offset ) + adding ;   writeFloat  ( offset , r ) ;  return r ; }  catch (   BufferOverflowException e )  {  throw  new AssertionError  ( e ) ; } }  void move  (   long from ,   long to ,   long length )  throws BufferUnderflowException , IllegalStateException , ArithmeticException ;   default void writeMaxLong  (   long offset ,   long atLeast )  throws BufferUnderflowException , IllegalStateException  {  try  {  for ( ; ; )  {   long  v =  readVolatileLong  ( offset ) ;  if  (  v >= atLeast )  return ;  if  (  compareAndSwapLong  ( offset , v , atLeast ) )  return ;   Jvm . nanoPause  ( ) ; } }  catch (   BufferOverflowException e )  {  throw  new AssertionError  ( e ) ; } }   default void writeMaxInt  (   long offset ,   int atLeast )  throws BufferUnderflowException , IllegalStateException  {  try  {  for ( ; ; )  {   int  v =  readVolatileInt  ( offset ) ;  if  (  v >= atLeast )  return ;  if  (  compareAndSwapInt  ( offset , v , atLeast ) )  return ;   Jvm . nanoPause  ( ) ; } }  catch (   BufferOverflowException e )  {  throw  new AssertionError  ( e ) ; } }   default boolean isEmpty  ( )  {  return   readRemaining  ( ) == 0 ; }   default void cipher  (    @ NotNull Cipher cipher ,    @ NotNull Bytes outBytes ,    @ NotNull ByteBuffer using1 ,    @ NotNull ByteBuffer using2 )  throws IllegalStateException  {   long  readPos =  outBytes . readPosition  ( ) ;  try  {   long  writePos =  outBytes . writePosition  ( ) ;  BytesStore  inBytes ;   long  size =  readRemaining  ( ) ;  if  (  this . isDirectMemory  ( ) )  {   inBytes = this ; } else  {   inBytes =  BytesStore . nativeStore  ( size ) ;   this . copyTo  ( inBytes ) ; }   BytesInternal . assignBytesStoreToByteBuffer  ( inBytes , using1 ) ;   int  outputSize =  cipher . getOutputSize  (  Math . toIntExact  ( size ) ) ;   outBytes . ensureCapacity  (  writePos + outputSize ) ;   outBytes . readPositionRemaining  ( writePos , outputSize ) ;   BytesInternal . assignBytesStoreToByteBuffer  ( outBytes , using2 ) ;   int  len =  cipher . update  ( using1 , using2 ) ;   len +=  cipher . doFinal  ( using1 , using2 ) ;  assert  len ==  using2 . position  ( ) ;   outBytes . writePosition  (  writePos +  using2 . position  ( ) ) ; }  catch (    @ NotNull  Exception e )  {  throw  new IllegalStateException  ( e ) ; }  finally  {  try  {   outBytes . readPosition  ( readPos ) ; }  catch (   BufferUnderflowException e )  {  throw  new IllegalStateException  ( e ) ; } } }   default void cipher  (    @ NotNull Cipher cipher ,    @ NotNull Bytes outBytes )  throws IllegalStateException  {   cipher  ( cipher , outBytes ,   BytesInternal . BYTE_BUFFER_TL . get  ( ) ,   BytesInternal . BYTE_BUFFER2_TL . get  ( ) ) ; }   default boolean readWrite  ( )  {  return true ; }   default  long hash  (   long length )  {  return    bytesStore  ( ) instanceof NativeBytesStore ?   OptimisedBytesStoreHash . INSTANCE . applyAsLong  ( this , length ) :   VanillaBytesStoreHash . INSTANCE . applyAsLong  ( this , length ) ; }   default boolean isEqual  (   long start ,   long length ,  String s )  {  if  (   s == null ||   s . length  ( ) != length )  return false ;   int  length2 =  (  int ) length ;  for (   int  i = 0 ;  i < length2 ;  i ++ )  if  (   s . charAt  ( i ) !=  readUnsignedByte  (  start + i ) )  return false ;  return true ; } }