  package    net . openhft . chronicle . bytes ;   import      net . openhft . chronicle . bytes . internal . BytesInternal ;  import      net . openhft . chronicle . bytes . internal . EmbeddedBytes ;  import     net . openhft . chronicle . core . Maths ;  import      net . openhft . chronicle . core . annotation . NonNegative ;  import      net . openhft . chronicle . core . annotation . UsedViaReflection ;  import      net . openhft . chronicle . core . io . IORuntimeException ;  import      net . openhft . chronicle . core . io . ReferenceOwner ;  import      net . openhft . chronicle . core . util . ObjectUtils ;  import      net . openhft . chronicle . core . util . StringUtils ;  import    org . jetbrains . annotations . NotNull ;  import    org . jetbrains . annotations . Nullable ;  import   java . io . IOException ;  import   java . io . InputStream ;  import   java . io . OutputStream ;  import   java . math . BigDecimal ;  import   java . math . BigInteger ;  import   java . nio . BufferOverflowException ;  import   java . nio . BufferUnderflowException ;  import   java . nio . ByteBuffer ;  import   java . nio . ReadOnlyBufferException ;  import    java . nio . charset . StandardCharsets ;  import static       net . openhft . chronicle . bytes . internal . ReferenceCountedUtil . throwExceptionIfReleased ;  import static       net . openhft . chronicle . core . util . Longs . requireNonNegative ;  import static       net . openhft . chronicle . core . util . ObjectUtils . requireNonNull ;    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public interface Bytes  <  U >  extends   BytesStore  <  Bytes  < U > , U > ,  BytesIn  < U > ,  BytesOut  < U >  {   long  MAX_CAPACITY =   Long . MAX_VALUE &  ~ 0xF ;   int  MAX_HEAP_CAPACITY =   Integer . MAX_VALUE &  ~ 0xF ;   int  DEFAULT_BYTE_BUFFER_CAPACITY = 256 ;    @ NotNull static  Bytes  < ByteBuffer > elasticByteBuffer  ( )  {  return  elasticByteBuffer  ( DEFAULT_BYTE_BUFFER_CAPACITY ) ; }    @ NotNull static  Bytes  < ByteBuffer > elasticByteBuffer  (    @ NonNegative  int initialCapacity )  {  return  elasticByteBuffer  ( initialCapacity , MAX_HEAP_CAPACITY ) ; }    @ NotNull static  Bytes  < ByteBuffer > elasticByteBuffer  (    @ NonNegative final  int initialCapacity ,    @ NonNegative final  int maxCapacity )  {   requireNonNegative  ( initialCapacity ) ;   requireNonNegative  ( maxCapacity ) ;    @ NotNull  BytesStore  <  ? , ByteBuffer >  bs =  BytesStore . elasticByteBuffer  ( initialCapacity , maxCapacity ) ;  try  {  try  {  return  bs . bytesForWrite  ( ) ; }  finally  {   bs . release  (  ReferenceOwner . INIT ) ; } }  catch (   IllegalStateException ise )  {  throw  new AssertionError  ( ise ) ; } }    @ NotNull static  Bytes  < ByteBuffer > elasticHeapByteBuffer  (    @ NonNegative  int initialCapacity )  {   requireNonNegative  ( initialCapacity ) ;    @ NotNull  BytesStore  <  ? , ByteBuffer >  bs =  BytesStore . wrap  (  ByteBuffer . allocate  ( initialCapacity ) ) ;  try  {  return  NativeBytes . wrapWithNativeBytes  ( bs ,  Bytes . MAX_HEAP_CAPACITY ) ; }  catch (   IllegalArgumentException | IllegalStateException e )  {  throw  new AssertionError  ( e ) ; }  finally  {  try  {   bs . release  ( INIT ) ; }  catch (   IllegalStateException ise )  {  throw  new AssertionError  ( ise ) ; } } }    @ NotNull static  Bytes  < ByteBuffer > elasticHeapByteBuffer  ( )  {  return  elasticHeapByteBuffer  ( 128 ) ; }   static  <  T >  Bytes  < T > forFieldGroup  (    @ NotNull final T object ,    @ NotNull final String groupName )  {   requireNonNull  ( object ) ;   requireNonNull  ( groupName ) ;    @ NotNull  BytesStore  <  ? , T >  bs =  BytesStore . forFields  ( object , groupName , 1 ) ;  try  {   final  EmbeddedBytes  < T >  bytes =  EmbeddedBytes . wrap  ( bs ) ;  return  bytes . writeLimit  (  bs . writeLimit  ( ) ) ; }  catch (   IllegalArgumentException | IllegalStateException e )  {  throw  new AssertionError  ( e ) ; }  finally  {  try  {   bs . release  ( INIT ) ; }  catch (   IllegalStateException ise )  {  throw  new AssertionError  ( ise ) ; } } }    @ NotNull static  Bytes  < ByteBuffer > wrapForRead  (    @ NotNull final ByteBuffer byteBuffer )  {   requireNonNull  ( byteBuffer ) ;   BytesStore  <  ? , ByteBuffer >  bs =  BytesStore . wrap  ( byteBuffer ) ;  try  {  try  {   Bytes  < ByteBuffer >  bbb =  bs . bytesForRead  ( ) ;   bbb . readLimit  (  byteBuffer . limit  ( ) ) ;   bbb . readPosition  (  byteBuffer . position  ( ) ) ;  return bbb ; }  finally  {   bs . release  ( INIT ) ; } }  catch (   IllegalStateException | BufferUnderflowException ise )  {  throw  new AssertionError  ( ise ) ; } }    @ NotNull static  Bytes  < ByteBuffer > wrapForWrite  (    @ NotNull final ByteBuffer byteBuffer )  {   requireNonNull  ( byteBuffer ) ;   BytesStore  <  ? , ByteBuffer >  bs =  BytesStore . wrap  ( byteBuffer ) ;  try  {  try  {   Bytes  < ByteBuffer >  bbb =  bs . bytesForWrite  ( ) ;   bbb . writePosition  (  byteBuffer . position  ( ) ) ;   bbb . writeLimit  (  byteBuffer . limit  ( ) ) ;  return bbb ; }  finally  {   bs . release  ( INIT ) ; } }  catch (   IllegalStateException | BufferOverflowException ise )  {  throw  new AssertionError  ( ise ) ; } }    @ NotNull static  Bytes  <   byte  [ ] > wrapForRead  (    @ NotNull   byte  [ ] byteArray )  {   requireNonNull  ( byteArray ) ;    @ NotNull  BytesStore  <  ? ,   byte  [ ] >  bs =  BytesStore . wrap  ( byteArray ) ;  try  {  try  {  return  bs . bytesForRead  ( ) ; }  finally  {   bs . release  ( INIT ) ; } }  catch (   IllegalStateException ise )  {  throw  new AssertionError  ( ise ) ; } }    @ NotNull static  Bytes  <   byte  [ ] > wrapForWrite  (    @ NotNull   byte  [ ] byteArray )  {   requireNonNull  ( byteArray ) ;   final BytesStore  bs =  BytesStore . wrap  ( byteArray ) ;  try  {  try  {  return  bs . bytesForWrite  ( ) ; }  finally  {   bs . release  ( INIT ) ; } }  catch (   IllegalStateException ise )  {  throw  new AssertionError  ( ise ) ; } }    @ NotNull static  Bytes  <   byte  [ ] > from  (    @ NotNull CharSequence text )  {   requireNonNull  ( text ) ;  return  from  (  text . toString  ( ) ) ; }   static  Bytes  < Void > fromDirect  (    @ NotNull CharSequence text )  {   requireNonNull  ( text ) ;  return   NativeBytes . nativeBytes  (  text . length  ( ) ) . append  ( text ) ; }    @ NotNull static  Bytes  <   byte  [ ] > directFrom  (    @ NotNull String text )  {  BytesStore  from =  BytesStore . from  ( text ) ;  try  {  try  {  return  from . bytesForRead  ( ) ; }  finally  {   from . release  ( INIT ) ; } }  catch (   IllegalStateException ise )  {  throw  new AssertionError  ( ise ) ; } }    @ NotNull static  Bytes  <   byte  [ ] > from  (    @ NotNull String text )  {  return  wrapForRead  (  text . getBytes  (  StandardCharsets . ISO_8859_1 ) ) ; }    @ UsedViaReflection static  Bytes  <   byte  [ ] > valueOf  (  String text )  {  return  from  ( text ) ; }    @ NotNull static  VanillaBytes  < Void > allocateDirect  (    @ NonNegative  long capacity )  throws IllegalArgumentException  {    @ NotNull  BytesStore  <  ? , Void >  bs =  BytesStore . nativeStoreWithFixedCapacity  (  requireNonNegative  ( capacity ) ) ;  try  {  try  {  return  new  NativeBytes  < >  ( bs ) ; }  finally  {   bs . release  ( INIT ) ; } }  catch (   IllegalStateException ise )  {  throw  new AssertionError  ( ise ) ; } }    @ NotNull static  NativeBytes  < Void > allocateElasticDirect  ( )  {  return  NativeBytes . nativeBytes  ( ) ; }    @ NotNull static  NativeBytes  < Void > allocateElasticDirect  (    @ NonNegative  long initialCapacity )  throws IllegalArgumentException  {  return  NativeBytes . nativeBytes  (  requireNonNegative  ( initialCapacity ) ) ; }    @ NotNull static OnHeapBytes allocateElasticOnHeap  ( )  {  return  allocateElasticOnHeap  ( 32 ) ; }    @ NotNull static OnHeapBytes allocateElasticOnHeap  (    @ NonNegative  int initialCapacity )  {   requireNonNegative  ( initialCapacity ) ;   BytesStore  <  ? ,   byte  [ ] >  wrap =  BytesStore . wrap  (  new  byte  [ initialCapacity ] ) ;  try  {  try  {  return  new OnHeapBytes  ( wrap , true ) ; }  finally  {   wrap . release  ( INIT ) ; } }  catch (   IllegalStateException | IllegalArgumentException ise )  {  throw  new AssertionError  ( ise ) ; } }    @ NotNull static String toString  (    @ NotNull final  Bytes  <  ? > buffer )  throws BufferUnderflowException , IllegalStateException , IllegalArgumentException  {  return  toString  ( buffer , MAX_HEAP_CAPACITY ) ; }    @ NotNull static String toString  (    @ NotNull final  Bytes  <  ? > buffer ,   final  long maxLen )  throws BufferUnderflowException , IllegalStateException , IllegalArgumentException  {   requireNonNegative  ( maxLen ) ;  if  (   buffer . refCount  ( ) < 1 )  return "<unknown>" ;  ReferenceOwner  toString =  ReferenceOwner . temporary  ( "toString" ) ;   buffer . reserve  ( toString ) ;  try  {  if  (   buffer . readRemaining  ( ) == 0 )  return "" ;   final  long  length =  Math . min  (  maxLen + 1 ,  buffer . readRemaining  ( ) ) ;    @ NotNull final StringBuilder  builder =  new StringBuilder  ( ) ;  try  {   buffer . readWithLength  ( length ,  b ->  {  while  (   buffer . readRemaining  ( ) > 0 )  {  if  (   builder . length  ( ) >= maxLen )  {   builder . append  ( "..." ) ;  break ; }   builder . append  (  (  char )  buffer . readByte  ( ) ) ; } } ) ; }  catch (   Exception e )  {    builder . append  ( ' ' ) . append  ( e ) ; }  return  builder . toString  ( ) ; }  finally  {   buffer . release  ( toString ) ; } }    @ NotNull static String toString  (    @ NotNull final Bytes buffer ,    @ NonNegative final  long position ,    @ NonNegative final  long length )  {   requireNonNull  ( buffer ) ;   requireNonNegative  ( position ) ;   requireNonNegative  ( length ) ;  try  {   final  long  pos =  buffer . readPosition  ( ) ;   final  long  limit =  buffer . readLimit  ( ) ;   buffer . readPositionRemaining  ( position , length ) ;  try  {    @ NotNull final StringBuilder  builder =  new StringBuilder  ( ) ;  while  (   buffer . readRemaining  ( ) > 0 )  {   builder . append  (  (  char )  buffer . readByte  ( ) ) ; }  return  builder . toString  ( ) ; }  finally  {   buffer . readLimit  ( limit ) ;   buffer . readPosition  ( pos ) ; } }  catch (   Exception e )  {  return  e . toString  ( ) ; } }    @ NotNull static VanillaBytes allocateDirect  (    @ NotNull   byte  [ ] bytes )  throws IllegalArgumentException  {   VanillaBytes  < Void >  result =  allocateDirect  (  bytes . length ) ;  try  {   result . write  ( bytes ) ; }  catch (   BufferOverflowException | IllegalStateException e )  {  throw  new AssertionError  ( e ) ; }  return result ; }    @ NotNull static Bytes fromHexString  (    @ NotNull String s )  {  return  BytesInternal . fromHexString  ( s ) ; }    @ Deprecated  ( ) static  int indexOf  (   final  @ NotNull BytesStore source ,   final  @ NotNull BytesStore other ,   int fromSourceOffset )  throws IllegalStateException  {   throwExceptionIfReleased  ( source ) ;   throwExceptionIfReleased  ( other ) ;   long  sourceOffset =  source . readPosition  ( ) ;   long  otherOffset =  other . readPosition  ( ) ;   long  sourceCount =  source . readRemaining  ( ) ;   long  otherCount =  other . readRemaining  ( ) ;  if  (  fromSourceOffset >= sourceCount )  {  return  Math . toIntExact  (   otherCount == 0 ? sourceCount :  - 1 ) ; }  if  (  fromSourceOffset < 0 )  {   fromSourceOffset = 0 ; }  if  (  otherCount == 0 )  {  return fromSourceOffset ; }  try  {   byte  firstByte =  other . readByte  ( otherOffset ) ;   long  max =  sourceOffset +  (  sourceCount - otherCount ) ;  for (   long  i =  sourceOffset + fromSourceOffset ;  i <= max ;  i ++ )  {  if  (   source . readByte  ( i ) != firstByte )  {  while  (    ++ i <= max &&   source . readByte  ( i ) != firstByte ) ; }  if  (  i <= max )  {   long  j =  i + 1 ;   long  end =   j + otherCount - 1 ;  for (   long  k =  otherOffset + 1 ;   j < end &&   source . readByte  ( j ) ==  other . readByte  ( k ) ;  j ++ ,  k ++ )  { }  if  (  j == end )  {  return  Math . toIntExact  (  i - sourceOffset ) ; } } }  return  - 1 ; }  catch (   BufferUnderflowException e )  {  throw  new AssertionError  ( e ) ; } }    @ NotNull default  Bytes  < U > unchecked  (  boolean unchecked )  throws IllegalStateException  {   throwExceptionIfReleased  ( this ) ;  if  ( unchecked )  {  if  (  isElastic  ( ) )    BytesUtil . WarnUncheckedElasticBytes . warn  ( ) ;   Bytes  < U >  underlyingBytes =     start  ( ) == 0 &&   bytesStore  ( ) . isDirectMemory  ( ) ?  new  UncheckedNativeBytes  < >  ( this ) :  new  UncheckedBytes  < >  ( this ) ;   release  ( INIT ) ;  return underlyingBytes ; }  return this ; }   default boolean unchecked  ( )  {  return false ; }    @ Override default  long safeLimit  ( )  {  return   bytesStore  ( ) . safeLimit  ( ) ; }    @ Override default boolean isClear  ( )  {  return    start  ( ) ==  readPosition  ( ) &&   writeLimit  ( ) ==  capacity  ( ) ; }    @ Override default  long realCapacity  ( )  {  return  BytesStore . super . realCapacity  ( ) ; }    @ Override  BytesStore  <  Bytes  < U > , U > copy  ( )  throws IllegalStateException ;    @ NotNull default String toHexString  ( )  {  return  toHexString  ( 1024 ) ; }    @ NotNull default String toHexString  (   long maxLength )  {  return  toHexString  (  readPosition  ( ) , maxLength ) ; }    @ NotNull default String toHexString  (   long offset ,   long maxLength )  {   requireNonNegative  ( offset ) ;   requireNonNegative  ( maxLength ) ;   final  long  maxLength2 =  Math . min  ( maxLength ,   readLimit  ( ) - offset ) ;   final String  ret =  BytesInternal . toHexString  ( this , offset , maxLength2 ) ;  return   maxLength2 <   readLimit  ( ) - offset ?  ret + "... truncated" : ret ; }  boolean isElastic  ( ) ;   default void ensureCapacity  (    @ NonNegative  long desiredCapacity )  throws IllegalArgumentException , IllegalStateException  {   requireNonNegative  ( desiredCapacity ) ;  if  (  desiredCapacity >  capacity  ( ) )  throw  new IllegalArgumentException  (   isElastic  ( ) ? "todo" : "not elastic" ) ; }    @ NotNull  @ Override default  Bytes  < U > bytesForRead  ( )  throws IllegalStateException  {  try  {  return   isClear  ( ) ?  BytesStore . super . bytesForRead  ( ) :  new  SubBytes  < >  ( this ,  readPosition  ( ) ,   readLimit  ( ) +  start  ( ) ) ; }  catch (   IllegalArgumentException | BufferUnderflowException e )  {  throw  new AssertionError  ( e ) ; } }    @ Override  @ Nullable BytesStore bytesStore  ( ) ;   default boolean isEqual  (    @ Nullable String other )  throws IllegalStateException  {  return  StringUtils . isEqual  ( this , other ) ; }    @ NotNull  Bytes  < U > compact  ( )  throws IllegalStateException ;    @ Override default  long copyTo  (    @ NotNull final BytesStore targetByteStore )  throws IllegalStateException  {  return  BytesStore . super . copyTo  ( targetByteStore ) ; }    @ Override default void copyTo  (    @ NotNull OutputStream outputStream )  throws IOException , IllegalStateException  {   BytesStore . super . copyTo  ( outputStream ) ; }    @ Override default boolean sharedMemory  ( )  {  return   bytesStore  ( ) . sharedMemory  ( ) ; }   default void unwrite  (   long fromOffset ,   int count )  throws BufferUnderflowException , BufferOverflowException , IllegalStateException  {   long  wp =  writePosition  ( ) ;  if  (  wp < fromOffset )  return ;   write  ( fromOffset , this ,  fromOffset + count ,   wp - fromOffset - count ) ;   writePosition  (  wp - count ) ; }    @ NotNull default BigDecimal readBigDecimal  ( )  throws ArithmeticException , BufferUnderflowException , IllegalStateException  {   throwExceptionIfReleased  ( this ) ;  return  new BigDecimal  (  readBigInteger  ( ) ,  Maths . toUInt31  (  readStopBit  ( ) ) ) ; }    @ NotNull default BigInteger readBigInteger  ( )  throws ArithmeticException , BufferUnderflowException , IllegalStateException  {   throwExceptionIfReleased  ( this ) ;   int  length =  Maths . toUInt31  (  readStopBit  ( ) ) ;  if  (  length == 0 )  {  if  (  lenient  ( ) )  {  return  BigInteger . ZERO ; } else  {  throw  new BufferUnderflowException  ( ) ; } }    byte  [ ]  bytes =  new  byte  [ length ] ;   read  ( bytes ) ;  return  new BigInteger  ( bytes ) ; }   default  long indexOf  (    @ NotNull Bytes source )  throws IllegalStateException  {  return  indexOf  ( this , source , 0 ) ; }   default  int indexOf  (    @ NotNull BytesStore source ,   int fromIndex )  throws IllegalStateException  {  return  indexOf  ( this , source , fromIndex ) ; }    @ Override  @ NotNull  Bytes  < U > clear  ( )  throws IllegalStateException ;    @ Override default boolean readWrite  ( )  {  return   bytesStore  ( ) . readWrite  ( ) ; }   default void readWithLength  (   long length ,    @ NotNull  BytesOut  < U > bytesOut )  throws BufferUnderflowException , IORuntimeException , BufferOverflowException , IllegalStateException  {   requireNonNegative  ( length ) ;  if  (  length >  readRemaining  ( ) )  throw  new BufferUnderflowException  ( ) ;   long  limit0 =  readLimit  ( ) ;   long  limit =   readPosition  ( ) + length ;  boolean  lenient =  lenient  ( ) ;  try  {   lenient  ( true ) ;   readLimit  ( limit ) ;   bytesOut . write  ( this ) ; }  finally  {   readLimit  ( limit0 ) ;   readPosition  ( limit ) ;   lenient  ( lenient ) ; } }   default  <  T  extends ReadBytesMarshallable > T readMarshallableLength16  (    @ NotNull final  Class  < T > clazz ,    @ Nullable final T using )  throws BufferUnderflowException , IllegalStateException  {   final T  object =   (  using == null ) ?  ObjectUtils . newInstance  ( clazz ) : using ;   int  length =  readUnsignedShort  ( ) ;   long  limit =  readLimit  ( ) ;   long  end =   readPosition  ( ) + length ;  boolean  lenient =  lenient  ( ) ;  try  {   lenient  ( true ) ;   readLimit  ( end ) ;   object . readMarshallable  ( this ) ; }  finally  {   readPosition  ( end ) ;   readLimit  ( limit ) ;   lenient  ( lenient ) ; }  return object ; }   default void writeMarshallableLength16  (    @ NotNull final WriteBytesMarshallable marshallable )  throws IllegalArgumentException , BufferOverflowException , IllegalStateException , BufferUnderflowException  {   requireNonNull  ( marshallable ) ;   long  position =  writePosition  ( ) ;  try  {   writeUnsignedShort  ( 0 ) ;   marshallable . writeMarshallable  ( this ) ;   long  length =    writePosition  ( ) - position - 2 ;  if  (  length >=  1 << 16 )  throw  new IllegalStateException  (    "Marshallable " +  marshallable . getClass  ( ) + " too long was " + length ) ;   writeUnsignedShort  ( position ,  (  int ) length ) ; }  catch (   ArithmeticException e )  {  throw  new AssertionError  ( e ) ; } }   default Bytes write  (    @ NotNull final InputStream inputStream )  throws IOException , BufferOverflowException , IllegalStateException  {   requireNonNull  ( inputStream ) ;  for ( ; ; )  {   int  read ;   read =  inputStream . read  ( ) ;  if  (  read ==  - 1 )  break ;   writeByte  (  (  byte ) read ) ; }  return this ; } }