  package    net . openhft . chronicle . bytes ;   import      net . openhft . chronicle . bytes . internal . BytesInternal ;  import     net . openhft . chronicle . core . Maths ;  import      net . openhft . chronicle . core . io . IORuntimeException ;  import    org . jetbrains . annotations . NotNull ;  import    org . jetbrains . annotations . Nullable ;  import   java . nio . BufferUnderflowException ;  import   java . nio . ByteBuffer ;  import static       net . openhft . chronicle . bytes . internal . ReferenceCountedUtil . throwExceptionIfReleased ;  import static       net . openhft . chronicle . core . util . ObjectUtils . requireNonNull ;   public interface RandomDataInput  extends  RandomCommon  {   String  [ ]  charToString =  createCharToString  ( ) ;    @ NotNull static  String  [ ] createCharToString  ( )  {    @ NotNull  String  [ ]  charToString =  new String  [ 256 ] ;    charToString [ 0 ] = "\u0660" ;  for (   int  i = 1 ;  i < 21 ;  i ++ )    charToString [ i ] =  Character . toString  (  (  char )  (  i + 0x2487 ) ) ;  for (   int  i = ' ' ;  i < 256 ;  i ++ )    charToString [ i ] =  Character . toString  (  (  char ) i ) ;  for (   int  i = 21 ;  i < ' ' ;  i ++ )    charToString [ i ] =  "\\u00" +   Integer . toHexString  ( i ) . toUpperCase  ( ) ;  for (   int  i = 0x80 ;  i < 0xA0 ;  i ++ )    charToString [ i ] =  "\\u00" +   Integer . toHexString  ( i ) . toUpperCase  ( ) ;  return charToString ; }   default  int peekVolatileInt  ( )  throws BufferUnderflowException , IllegalStateException  {  return  readVolatileInt  (  readPosition  ( ) ) ; }   default boolean readBoolean  (   long offset )  throws BufferUnderflowException , IllegalStateException  {  return  BytesUtil . byteToBoolean  (  readByte  ( offset ) ) ; }   byte readByte  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   default  int readUnsignedByte  (   long offset )  throws BufferUnderflowException , IllegalStateException  {  return   readByte  ( offset ) & 0xFF ; }   int peekUnsignedByte  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   short readShort  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   default  int readUnsignedShort  (   long offset )  throws BufferUnderflowException , IllegalStateException  {  return   readShort  ( offset ) & 0xFFFF ; }   default  int readUnsignedInt24  (   long offset )  throws BufferUnderflowException , IllegalStateException  {  return   readUnsignedShort  ( offset ) |  (   readUnsignedByte  ( offset ) << 16 ) ; }   int readInt  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   default  long readUnsignedInt  (   long offset )  throws BufferUnderflowException , IllegalStateException  {  return   readInt  ( offset ) & 0xFFFFFFFFL ; }   long readLong  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   float readFloat  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   double readDouble  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   default String printable  (   long offset )  throws BufferUnderflowException , IllegalStateException  {  return  charToString [  readUnsignedByte  ( offset ) ] ; }   byte readVolatileByte  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   short readVolatileShort  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   int readVolatileInt  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   default  float readVolatileFloat  (   long offset )  throws BufferUnderflowException , IllegalStateException  {  return  Float . intBitsToFloat  (  readVolatileInt  ( offset ) ) ; }   long readVolatileLong  (   long offset )  throws BufferUnderflowException , IllegalStateException ;   default  double readVolatileDouble  (   long offset )  throws BufferUnderflowException , IllegalStateException  {  return  Double . longBitsToDouble  (  readVolatileLong  ( offset ) ) ; }   default  long parseLong  (   long offset )  throws BufferUnderflowException , IllegalStateException  {  return  BytesInternal . parseLong  ( this , offset ) ; }  void nativeRead  (   long position ,   long address ,   long size )  throws BufferUnderflowException , IllegalStateException ;   default  int copyTo  (    @ NotNull   byte  [ ] bytes )  throws BufferUnderflowException , IllegalStateException  {   requireNonNull  ( bytes ) ;   throwExceptionIfReleased  ( this ) ;   int  len =  (  int )  Math . min  (  bytes . length ,  readRemaining  ( ) ) ;  for (   int  i = 0 ;  i < len ;  i ++ )    bytes [ i ] =  readByte  (   start  ( ) + i ) ;  return len ; }   default  int copyTo  (    @ NotNull ByteBuffer bb )  throws BufferUnderflowException , IllegalStateException  {   requireNonNull  ( bb ) ;   throwExceptionIfReleased  ( this ) ;   int  pos =  bb . position  ( ) ;   int  len =  (  int )  Math . min  (  bb . remaining  ( ) ,  readRemaining  ( ) ) ;   int  i ;  for (  i = 0 ;  i <  len - 7 ;  i += 8 )   bb . putLong  (  pos + i ,  readLong  (   start  ( ) + i ) ) ;  for ( ;  i < len ;  i ++ )   bb . put  (  pos + i ,  readByte  (   start  ( ) + i ) ) ;  return len ; }   default  long readIncompleteLong  (   long offset )  throws IllegalStateException  {   long  left =   readLimit  ( ) - offset ;   long  l ;  try  {  if  (  left >= 8 )  return  readLong  ( offset ) ;  if  (  left == 4 )  return  readInt  ( offset ) ;   l = 0 ;  for (   int  i = 0 ,  remaining =  (  int ) left ;  i < remaining ;  i ++ )  {   l |=   (  long )  readUnsignedByte  (  offset + i ) <<  (  i * 8 ) ; } }  catch (   BufferUnderflowException e )  {  throw  new AssertionError  ( e ) ; }  return l ; }    @ Override  long realCapacity  ( ) ;   default  int addAndGetInt  (   long offset ,   int adding )  throws BufferUnderflowException , IllegalStateException  {  return  BytesInternal . addAndGetInt  ( this , offset , adding ) ; }   default  long addAndGetLong  (   long offset ,   long adding )  throws BufferUnderflowException , IllegalStateException  {  return  BytesInternal . addAndGetLong  ( this , offset , adding ) ; }   default  float addAndGetFloat  (   long offset ,   float adding )  throws BufferUnderflowException , IllegalStateException  {  return  BytesInternal . addAndGetFloat  ( this , offset , adding ) ; }   default  double addAndGetDouble  (   long offset ,   double adding )  throws BufferUnderflowException , IllegalStateException  {  return  BytesInternal . addAndGetDouble  ( this , offset , adding ) ; }    @ SuppressWarnings  ( "rawtypes" )  @ NotNull default BytesStore subBytes  (   long start ,   long length )  throws BufferUnderflowException , IllegalStateException  {  return  BytesInternal . subBytes  ( this , start , length ) ; }   default  long findByte  (   byte stopByte )  throws IllegalStateException  {  return  BytesInternal . findByte  ( this , stopByte ) ; }   default  <  T  extends Appendable & CharSequence >  long readUtf8  (   long offset ,    @ NotNull T sb )  throws IORuntimeException , IllegalArgumentException , BufferUnderflowException , ArithmeticException , IllegalStateException  {   AppendableUtil . setLength  ( sb , 0 ) ;   long  utfLen ;  if  (   (  utfLen =  readByte  (  offset ++ ) ) < 0 )  {   utfLen &= 0x7FL ;   long  b ;   int  count = 7 ;  while  (   (  b =  readByte  (  offset ++ ) ) < 0 )  {   utfLen |=   (  b & 0x7FL ) << count ;   count += 7 ; }  if  (  b != 0 )  {  if  (  count > 56 )  throw  new IORuntimeException  ( "Cannot read more than 9 stop bits of positive value" ) ;   utfLen |=  (  b << count ) ; } else  {  if  (  count > 63 )  throw  new IORuntimeException  ( "Cannot read more than 10 stop bits of negative value" ) ;   utfLen =  ~ utfLen ; } }  if  (  utfLen ==  - 1 )  return  ~ offset ;   int  len =  Maths . toUInt31  ( utfLen ) ;   BytesInternal . parseUtf8  ( this , offset , sb , true , len ) ;  return  offset + utfLen ; }   default  <  T  extends Appendable & CharSequence >  long readUtf8Limited  (   long offset ,   final  @ NotNull T sb ,   final  int maxUtf8Len )  throws IORuntimeException , IllegalArgumentException , BufferUnderflowException , IllegalStateException  {   AppendableUtil . setLength  ( sb , 0 ) ;   long  utfLen ;  if  (   (  utfLen =  readByte  (  offset ++ ) ) < 0 )  {   utfLen &= 0x7FL ;   long  b ;   int  count = 7 ;  while  (   (  b =  readByte  (  offset ++ ) ) < 0 )  {   utfLen |=   (  b & 0x7FL ) << count ;   count += 7 ; }  if  (  b != 0 )  {  if  (  count > 56 )  throw  new IORuntimeException  ( "Cannot read more than 9 stop bits of positive value" ) ;   utfLen |=  (  b << count ) ; } else  {  if  (  count > 63 )  throw  new IORuntimeException  ( "Cannot read more than 10 stop bits of negative value" ) ;   utfLen =  ~ utfLen ; } }  if  (  utfLen ==  - 1 )  return  ~ offset ;  if  (  utfLen > maxUtf8Len )  throw  new IllegalStateException  (      "Attempted to read a char sequence of " + "utf8 size " + utfLen + ", when only " + maxUtf8Len + " allowed" ) ;   BytesInternal . parseUtf8  ( this , offset , sb , true ,  (  int ) utfLen ) ;  return  offset + utfLen ; }    @ Nullable default String readUtf8Limited  (   long offset ,   int maxUtf8Len )  throws BufferUnderflowException , IORuntimeException , IllegalArgumentException , IllegalStateException  {  return  BytesInternal . readUtf8  ( this , offset , maxUtf8Len ) ; }   default boolean compareUtf8  (   long offset ,    @ Nullable CharSequence other )  throws IORuntimeException , BufferUnderflowException , IllegalStateException  {  return  BytesInternal . compareUtf8  ( this , offset , other ) ; }    @ NotNull default   byte  [ ] toByteArray  ( )  throws IllegalStateException  {  return  BytesInternal . toByteArray  ( this ) ; }   default  long read  (   long offsetInRDI ,    @ NotNull   byte  [ ] bytes ,   int offset ,   int length )  throws IllegalStateException  {   requireNonNull  ( bytes ) ;  try  {   int  len =  (  int )  Math . min  ( length ,   readLimit  ( ) - offsetInRDI ) ;  for (   int  i = 0 ;  i < len ;  i ++ )    bytes [  offset + i ] =  readByte  (  offsetInRDI + i ) ;  return len ; }  catch (   BufferUnderflowException e )  {  throw  new AssertionError  ( e ) ; } }   default ByteBuffer toTemporaryDirectByteBuffer  ( )  throws IllegalArgumentException , ArithmeticException , IllegalStateException  {   throwExceptionIfReleased  ( this ) ;   int  len =  Maths . toUInt31  (  readRemaining  ( ) ) ;  try  {  ByteBuffer  bb =  ByteBuffer . allocateDirect  ( len ) ;   copyTo  ( bb ) ;   bb . clear  ( ) ;  return bb ; }  catch (   BufferUnderflowException e )  {  throw  new AssertionError  ( e ) ; } }   default  int fastHash  (   long offset ,   int length )  throws BufferUnderflowException , IllegalStateException  {   long  hash = 0 ;   int  i = 0 ;  if  (  length >= 4 )  {   hash =  readInt  (  offset + i ) ;   i += 4 ; }  for ( ;  i <  length - 3 ;  i += 4 )  {   hash *= 0x6d0f27bd ;   hash +=  readInt  (  offset + i ) ; }  if  (  i <  length - 1 )  {   hash *= 0x6d0f27bdL ;   hash +=  readShort  (  offset + i ) ;   i += 2 ; }  if  (  i < length )   hash +=  readByte  (  offset + i ) ;   hash *= 0x855dd4db ;  return  (  int )  (  hash ^  (  hash >> 32 ) ) ; }   default boolean canReadDirect  (   long length )  {  return   isDirectMemory  ( ) &&   readRemaining  ( ) >= length ; } }