  package    net . openhft . chronicle . bytes ;   import     net . openhft . chronicle . core . OS ;  import     net . openhft . chronicle . core . ReferenceCounted ;  import     net . openhft . chronicle . core . ReferenceCounter ;  import    org . jetbrains . annotations . NotNull ;  import    org . jetbrains . annotations . Nullable ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import   java . io . File ;  import   java . io . FileNotFoundException ;  import   java . io . IOException ;  import   java . io . RandomAccessFile ;  import    java . lang . ref . WeakReference ;  import    java . nio . channels . FileChannel ;  import    java . nio . channels . FileLock ;  import   java . util . ArrayList ;  import   java . util . List ;  import     java . util . concurrent . atomic . AtomicBoolean ;   public class MappedFile  implements  ReferenceCounted  {   private static final Logger  LOG =  LoggerFactory . getLogger  (  MappedFile . class ) ;    @ NotNull private final RandomAccessFile  raf ;   private final FileChannel  fileChannel ;   private final  long  chunkSize ;   private final  long  overlapSize ;   private final  List  <  WeakReference  < MappedBytesStore > >  stores =  new  ArrayList  < >  ( ) ;   private final ReferenceCounter  refCount =  ReferenceCounter . onReleased  (  this :: performRelease ) ;   private final AtomicBoolean  closed =  new AtomicBoolean  ( ) ;   private final  long  capacity ;   private final  @ NotNull File  file ;  MappedFile  (    @ NotNull File file ,   long chunkSize ,   long overlapSize )  throws FileNotFoundException  {    this . file = file ;    this . raf =  new RandomAccessFile  ( file , "rw" ) ;    this . fileChannel =  raf . getChannel  ( ) ;    this . chunkSize =  OS . mapAlign  ( chunkSize ) ;    this . overlapSize =   overlapSize == 0 ? 0 :  OS . mapAlign  ( overlapSize ) ;   capacity =  1L << 40 ;    this . file = file ; }    @ NotNull public static MappedFile mappedFile  (    @ NotNull File file ,   long chunkSize )  throws FileNotFoundException  {  return  mappedFile  ( file , chunkSize ,  OS . pageSize  ( ) ) ; }    @ NotNull public static MappedFile mappedFile  (    @ NotNull String filename ,   long chunkSize )  throws FileNotFoundException  {  return  mappedFile  ( filename , chunkSize ,  OS . pageSize  ( ) ) ; }    @ NotNull public static MappedFile mappedFile  (    @ NotNull String filename ,   long chunkSize ,   long overlapSize )  throws FileNotFoundException  {  return  mappedFile  (  new File  ( filename ) , chunkSize , overlapSize ) ; }    @ NotNull public static MappedFile mappedFile  (    @ NotNull File file ,   long chunkSize ,   long overlapSize )  throws FileNotFoundException  {  return  new MappedFile  ( file , chunkSize , overlapSize ) ; }    @ Nullable public MappedBytesStore acquireByteStore  (   long position )  throws IOException , IllegalArgumentException , IllegalStateException  {  return  acquireByteStore  ( position ,  MappedBytesStore :: new ) ; }    @ Nullable public  <  T  extends MappedBytesStore > T acquireByteStore  (   long position ,   MappedBytesStoreFactory  < T > mappedBytesStoreFactory )  throws IOException , IllegalArgumentException , IllegalStateException  {  if  (  closed . get  ( ) )  throw  new IOException  ( "Closed" ) ;   int  chunk =  (  int )  (  position / chunkSize ) ;  synchronized  ( stores )  {  while  (   stores . size  ( ) <= chunk )  {   stores . add  ( null ) ; }   WeakReference  < MappedBytesStore >  mbsRef =  stores . get  ( chunk ) ;  if  (  mbsRef != null )  {  T  mbs =  ( T )  mbsRef . get  ( ) ;  if  (   mbs != null &&  mbs . tryReserve  ( ) )  {  return mbs ; } }   long  minSize =    (  chunk + 1L ) * chunkSize + overlapSize ;   long  size =  fileChannel . size  ( ) ;  if  (  size < minSize )  {  try  (  FileLock lock =  fileChannel . lock  ( ) )  {   size =  fileChannel . size  ( ) ;  if  (  size < minSize )  {   raf . setLength  ( minSize ) ; } } }   long  start =  System . nanoTime  ( ) ;   long  mappedSize =  chunkSize + overlapSize ;   long  address =  OS . map  ( fileChannel ,   FileChannel . MapMode . READ_WRITE ,  chunk * chunkSize , mappedSize ) ;  T  mbs2 =  mappedBytesStoreFactory . create  ( this ,  chunk * chunkSize , address , mappedSize , chunkSize ) ;   stores . set  ( chunk ,  new  WeakReference  < >  ( mbs2 ) ) ;   mbs2 . reserve  ( ) ;   LOG . warn  (  String . format  ( "Took %,d us to acquire chunk %,d" ,   (   System . nanoTime  ( ) - start ) / 1000 , chunk ) ) ;  return mbs2 ; } }   public Bytes acquireBytesForRead  (   long position )  throws IOException , IllegalStateException , IllegalArgumentException  {  MappedBytesStore  mbs =  acquireByteStore  ( position ) ;  Bytes  bytes =  mbs . bytesForRead  ( ) ;   bytes . readPosition  ( position ) ;   mbs . release  ( ) ;  return bytes ; }   public void acquireBytesForRead  (   long position ,    @ NotNull VanillaBytes bytes )  throws IOException , IllegalStateException , IllegalArgumentException  {  MappedBytesStore  mbs =  acquireByteStore  ( position ) ;   bytes . bytesStore  ( mbs , position ,   mbs . capacity  ( ) - position ) ; }   public Bytes acquireBytesForWrite  (   long position )  throws IOException , IllegalStateException , IllegalArgumentException  {  MappedBytesStore  mbs =  acquireByteStore  ( position ) ;  Bytes  bytes =  mbs . bytesForWrite  ( ) ;   bytes . writePosition  ( position ) ;   mbs . release  ( ) ;  return bytes ; }   public void acquireBytesForWrite  (   long position ,    @ NotNull VanillaBytes bytes )  throws IOException , IllegalStateException , IllegalArgumentException  {  MappedBytesStore  mbs =  acquireByteStore  ( position ) ;   bytes . bytesStore  ( mbs , position ,   mbs . capacity  ( ) - position ) ;   bytes . writePosition  ( position ) ; }    @ Override public void reserve  ( )  throws IllegalStateException  {   refCount . reserve  ( ) ; }    @ Override public void release  ( )  throws IllegalStateException  {   refCount . release  ( ) ; }    @ Override public  long refCount  ( )  {  return  refCount . get  ( ) ; }   public void close  ( )  {  if  (  !  closed . compareAndSet  ( false , true ) )  return ;  try  {  synchronized  ( stores )  {   ReferenceCounted . releaseAll  (  ( List ) stores ) ; }   release  ( ) ; }  catch (   IllegalStateException e )  {   LOG . error  ( "" , e ) ; } }   private void performRelease  ( )  {  for (   int  i = 0 ;  i <  stores . size  ( ) ;  i ++ )  {   WeakReference  < MappedBytesStore >  storeRef =  stores . get  ( i ) ;  if  (  storeRef == null )  continue ;  MappedBytesStore  mbs =  storeRef . get  ( ) ;  if  (  mbs != null )  {   long  count =  mbs . refCount  ( ) ;  if  (  count > 0 )  {  try  {   mbs . release  ( ) ; }  catch (   IllegalStateException e )  {   LOG . error  ( "" , e ) ; }  if  (  count > 1 )  continue ; } }   stores . set  ( i , null ) ; }  try  {   fileChannel . close  ( ) ; }  catch (   IOException e )  {   LOG . error  ( "" , e ) ; } }    @ NotNull public String referenceCounts  ( )  {  StringBuilder  sb =  new StringBuilder  ( ) ;    sb . append  ( "refCount: " ) . append  (  refCount  ( ) ) ;  for (  WeakReference  < MappedBytesStore > store : stores )  {   long  count = 0 ;  if  (  store != null )  {  MappedBytesStore  mbs =  store . get  ( ) ;  if  (  mbs != null )   count =  mbs . refCount  ( ) ; }    sb . append  ( ", " ) . append  ( count ) ; }  return  sb . toString  ( ) ; }   public  long capacity  ( )  {  return capacity ; }   public  long overlapSize  ( )  {  return overlapSize ; }   public  long chunkSize  ( )  {  return chunkSize ; }   public File file  ( )  {  return file ; } }