  package    net . openhft . chronicle . bytes ;   import      net . openhft . chronicle . core . io . ClosedIllegalStateException ;  import      net . openhft . chronicle . core . util . ObjectUtils ;  import    org . jetbrains . annotations . NotNull ;  import    java . lang . reflect . Proxy ;  import   java . nio . BufferOverflowException ;  import   java . nio . BufferUnderflowException ;  import static       net . openhft . chronicle . bytes . internal . ReferenceCountedUtil . throwExceptionIfReleased ;    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public interface BytesOut  <  U >  extends   StreamingDataOutput  <  Bytes  < U > > ,  ByteStringAppender  <  Bytes  < U > > ,  BytesPrepender  <  Bytes  < U > > ,  BytesComment  <  BytesOut  < U > >  {    @ NotNull default  <  T > T bytesMethodWriter  (    @ NotNull  Class  < T > tClass ,  Class ...  additional )  throws IllegalArgumentException  {   throwExceptionIfReleased  ( this ) ;   Class  [ ]  interfaces =  ObjectUtils . addAll  ( tClass , additional ) ;  return  ( T )  Proxy . newProxyInstance  (  tClass . getClassLoader  ( ) , interfaces ,  new BinaryBytesMethodWriterInvocationHandler  (  MethodEncoderLookup . BY_ANNOTATION , this ) ) ; }  void writeMarshallableLength16  (  WriteBytesMarshallable marshallable )  throws IllegalArgumentException , BufferOverflowException , IllegalStateException , BufferUnderflowException ;   default void writeObject  (  Class componentType ,  Object obj )  throws IllegalArgumentException , BufferOverflowException , ArithmeticException , IllegalStateException , BufferUnderflowException  {  if  (  !  componentType . isInstance  ( obj ) )  throw  new IllegalArgumentException  (    "Cannot serialize " +  obj . getClass  ( ) + " as an " + componentType ) ;  if  (  obj instanceof BytesMarshallable )  {    (  ( BytesMarshallable ) obj ) . writeMarshallable  ( this ) ;  return ; }  if  (  obj instanceof Enum )  {   writeEnum  (  ( Enum ) obj ) ;  return ; }  if  (  obj instanceof BytesStore )  {  BytesStore  bs =  ( BytesStore ) obj ;   writeStopBit  (  bs . readRemaining  ( ) ) ;   write  ( bs ) ;  return ; }  switch  (  componentType . getName  ( ) )  {   case "java.lang.String" :   writeUtf8  (  ( String ) obj ) ;  return ;   case "java.lang.Double" :   writeDouble  (  ( Double ) obj ) ;  return ;   case "java.lang.Long" :   writeLong  (  ( Long ) obj ) ;  return ;   case "java.lang.Integer" :   writeInt  (  ( Integer ) obj ) ;  return ;   default :  throw  new UnsupportedOperationException  (  "Not supported " + componentType ) ; } } }