  package   net . zhuoweizhang . raspberryjuice ;   import  java . io .  * ;  import  java . net .  * ;  import  java . util .  * ;  import  org . bukkit .  * ;  import   org . bukkit . entity .  * ;  import   org . bukkit . block .  * ;  import     org . bukkit . event . player . PlayerInteractEvent ;  import     org . bukkit . event . player . AsyncPlayerChatEvent ;   public class RemoteSession  {   private final LocationType  locationType ;   private Location  origin ;   private Socket  socket ;   private BufferedReader  in ;   private BufferedWriter  out ;   private Thread  inThread ;   private Thread  outThread ;   private  ArrayDeque  < String >  inQueue =  new  ArrayDeque  < String >  ( ) ;   private  ArrayDeque  < String >  outQueue =  new  ArrayDeque  < String >  ( ) ;   public boolean  running = true ;   public boolean  pendingRemoval = false ;   public RaspberryJuicePlugin  plugin ;   protected  ArrayDeque  < PlayerInteractEvent >  interactEventQueue =  new  ArrayDeque  < PlayerInteractEvent >  ( ) ;   protected  ArrayDeque  < AsyncPlayerChatEvent >  chatPostedQueue =  new  ArrayDeque  < AsyncPlayerChatEvent >  ( ) ;   private  int  maxCommandsPerTick = 9000 ;   private boolean  closed = false ;   private Player  attachedPlayer = null ;   public RemoteSession  (  RaspberryJuicePlugin plugin ,  Socket socket )  throws IOException  {    this . socket = socket ;    this . plugin = plugin ;    this . locationType =  plugin . getLocationType  ( ) ;   init  ( ) ; }   public void init  ( )  throws IOException  {   socket . setTcpNoDelay  ( true ) ;   socket . setKeepAlive  ( true ) ;   socket . setTrafficClass  ( 0x10 ) ;    this . in =  new BufferedReader  (  new InputStreamReader  (  socket . getInputStream  ( ) ) ) ;    this . out =  new BufferedWriter  (  new OutputStreamWriter  (  socket . getOutputStream  ( ) ) ) ;   startThreads  ( ) ;    plugin . getLogger  ( ) . info  (   "Opened connection to" +  socket . getRemoteSocketAddress  ( ) + "." ) ; }   protected void startThreads  ( )  {   inThread =  new Thread  (  new InputThread  ( ) ) ;   inThread . start  ( ) ;   outThread =  new Thread  (  new OutputThread  ( ) ) ;   outThread . start  ( ) ; }   public Location getOrigin  ( )  {  return origin ; }   public void setOrigin  (  Location origin )  {    this . origin = origin ; }   public Socket getSocket  ( )  {  return socket ; }   public void queuePlayerInteractEvent  (  PlayerInteractEvent event )  {   interactEventQueue . add  ( event ) ; }   public void queueChatPostedEvent  (  AsyncPlayerChatEvent event )  {   chatPostedQueue . add  ( event ) ; }   public void tick  ( )  {  if  (  origin == null )  {  switch  ( locationType )  {   case ABSOLUTE :    this . origin =  new Location  (    plugin . getServer  ( ) . getWorlds  ( ) . get  ( 0 ) , 0 , 0 , 0 ) ;  break ;   case RELATIVE :    this . origin =     plugin . getServer  ( ) . getWorlds  ( ) . get  ( 0 ) . getSpawnLocation  ( ) ;  break ;   default :  throw  new IllegalArgumentException  (  "Unknown location type " + locationType ) ; } }   int  processedCount = 0 ;  String  message ;  while  (   (  message =  inQueue . poll  ( ) ) != null )  {   handleLine  ( message ) ;   processedCount ++ ;  if  (  processedCount >= maxCommandsPerTick )  {    plugin . getLogger  ( ) . warning  (     "Over " + maxCommandsPerTick + " commands were queued - deferring " +  inQueue . size  ( ) + " to next tick" ) ;  break ; } }  if  (   ! running &&   inQueue . size  ( ) <= 0 )  {   pendingRemoval = true ; } }   protected void handleLine  (  String line )  {  String  methodName =  line . substring  ( 0 ,  line . indexOf  ( "(" ) ) ;   String  [ ]  args =   line . substring  (   line . indexOf  ( "(" ) + 1 ,   line . length  ( ) - 1 ) . split  ( "," ) ;   handleCommand  ( methodName , args ) ; }   protected void handleCommand  (  String c ,   String  [ ] args )  {  try  {  Server  server =  plugin . getServer  ( ) ;  World  world =  origin . getWorld  ( ) ;  if  (  c . equals  ( "world.getBlock" ) )  {  Location  loc =  parseRelativeBlockLocation  (  args [ 0 ] ,  args [ 1 ] ,  args [ 2 ] ) ;   send  (  world . getBlockTypeIdAt  ( loc ) ) ; } else  if  (  c . equals  ( "world.getBlocks" ) )  {  Location  loc1 =  parseRelativeBlockLocation  (  args [ 0 ] ,  args [ 1 ] ,  args [ 2 ] ) ;  Location  loc2 =  parseRelativeBlockLocation  (  args [ 3 ] ,  args [ 4 ] ,  args [ 5 ] ) ;   send  (  getBlocks  ( loc1 , loc2 ) ) ; } else  if  (  c . equals  ( "world.getBlockWithData" ) )  {  Location  loc =  parseRelativeBlockLocation  (  args [ 0 ] ,  args [ 1 ] ,  args [ 2 ] ) ;   send  (    world . getBlockTypeIdAt  ( loc ) + "," +   world . getBlockAt  ( loc ) . getData  ( ) ) ; } else  if  (  c . equals  ( "world.setBlock" ) )  {  Location  loc =  parseRelativeBlockLocation  (  args [ 0 ] ,  args [ 1 ] ,  args [ 2 ] ) ;   updateBlock  ( world , loc ,  Integer . parseInt  (  args [ 3 ] ) ,  (    args . length > 4 ?  Byte . parseByte  (  args [ 4 ] ) :  (  byte ) 0 ) ) ; } else  if  (  c . equals  ( "world.setBlocks" ) )  {  Location  loc1 =  parseRelativeBlockLocation  (  args [ 0 ] ,  args [ 1 ] ,  args [ 2 ] ) ;  Location  loc2 =  parseRelativeBlockLocation  (  args [ 3 ] ,  args [ 4 ] ,  args [ 5 ] ) ;   int  blockType =  Integer . parseInt  (  args [ 6 ] ) ;   byte  data =    args . length > 7 ?  Byte . parseByte  (  args [ 7 ] ) :  (  byte ) 0 ;   setCuboid  ( loc1 , loc2 , blockType , data ) ; } else  if  (  c . equals  ( "world.getPlayerIds" ) )  {  StringBuilder  bdr =  new StringBuilder  ( ) ;  for ( Player p :  Bukkit . getOnlinePlayers  ( ) )  {   bdr . append  (  p . getEntityId  ( ) ) ;   bdr . append  ( "|" ) ; }   bdr . deleteCharAt  (   bdr . length  ( ) - 1 ) ;   send  (  bdr . toString  ( ) ) ; } else  if  (  c . equals  ( "world.getPlayerId" ) )  {  Player  p =  plugin . getNamedPlayer  (  args [ 0 ] ) ;  if  (  p != null )  {   send  (  p . getEntityId  ( ) ) ; } else  {    plugin . getLogger  ( ) . info  (   "Player [" +  args [ 0 ] + "] not found." ) ;   send  ( "Fail" ) ; } } else  if  (  c . equals  ( "chat.post" ) )  {  String  chatMessage = "" ;   int  count ;  for (  count = 0 ;  count <  args . length ;  count ++ )  {   chatMessage =   chatMessage +  args [ count ] + "," ; }   chatMessage =  chatMessage . substring  ( 0 ,   chatMessage . length  ( ) - 1 ) ;   server . broadcastMessage  ( chatMessage ) ; } else  if  (  c . equals  ( "events.clear" ) )  {   interactEventQueue . clear  ( ) ;   chatPostedQueue . clear  ( ) ; } else  if  (  c . equals  ( "events.block.hits" ) )  {  StringBuilder  b =  new StringBuilder  ( ) ;  PlayerInteractEvent  event ;  while  (   (  event =  interactEventQueue . poll  ( ) ) != null )  {  Block  block =  event . getClickedBlock  ( ) ;  Location  loc =  block . getLocation  ( ) ;   b . append  (  blockLocationToRelative  ( loc ) ) ;   b . append  ( "," ) ;   b . append  (  blockFaceToNotch  (  event . getBlockFace  ( ) ) ) ;   b . append  ( "," ) ;   b . append  (   event . getPlayer  ( ) . getEntityId  ( ) ) ;  if  (   interactEventQueue . size  ( ) > 0 )  {   b . append  ( "|" ) ; } }   send  (  b . toString  ( ) ) ; } else  if  (  c . equals  ( "events.chat.posts" ) )  {  StringBuilder  b =  new StringBuilder  ( ) ;  AsyncPlayerChatEvent  event ;  while  (   (  event =  chatPostedQueue . poll  ( ) ) != null )  {   b . append  (   event . getPlayer  ( ) . getEntityId  ( ) ) ;   b . append  ( "," ) ;   b . append  (  event . getMessage  ( ) ) ;  if  (   chatPostedQueue . size  ( ) > 0 )  {   b . append  ( "|" ) ; } }   send  (  b . toString  ( ) ) ; } else  if  (  c . equals  ( "player.getTile" ) )  {  String  name = null ;  if  (   args . length > 0 )  {   name =  args [ 0 ] ; }  Player  currentPlayer =  getCurrentPlayer  ( name ) ;   send  (  blockLocationToRelative  (  currentPlayer . getLocation  ( ) ) ) ; } else  if  (  c . equals  ( "player.setTile" ) )  {  String  name = null ,  x =  args [ 0 ] ,  y =  args [ 1 ] ,  z =  args [ 2 ] ;  if  (   args . length > 3 )  {   name =  args [ 0 ] ;   x =  args [ 1 ] ;   y =  args [ 2 ] ;   z =  args [ 3 ] ; }  Player  currentPlayer =  getCurrentPlayer  ( name ) ;  Location  loc =  currentPlayer . getLocation  ( ) ;   currentPlayer . teleport  (  parseRelativeBlockLocation  ( x , y , z ,  loc . getPitch  ( ) ,  loc . getYaw  ( ) ) ) ; } else  if  (  c . equals  ( "player.getAbsPos" ) )  {  String  name = null ;  if  (   args . length > 0 )  {   name =  args [ 0 ] ; }  Player  currentPlayer =  getCurrentPlayer  ( name ) ;   send  (  currentPlayer . getLocation  ( ) ) ; } else  if  (  c . equals  ( "player.setAbsPos" ) )  {  String  name = null ,  x =  args [ 0 ] ,  y =  args [ 1 ] ,  z =  args [ 2 ] ;  if  (   args . length > 3 )  {   name =  args [ 0 ] ;   x =  args [ 1 ] ;   y =  args [ 2 ] ;   z =  args [ 3 ] ; }  Player  currentPlayer =  getCurrentPlayer  ( name ) ;  Location  loc =  currentPlayer . getLocation  ( ) ;   loc . setX  (  Double . parseDouble  ( x ) ) ;   loc . setY  (  Double . parseDouble  ( y ) ) ;   loc . setZ  (  Double . parseDouble  ( z ) ) ;   currentPlayer . teleport  ( loc ) ; } else  if  (  c . equals  ( "player.getPos" ) )  {  String  name = null ;  if  (   args . length > 0 )  {   name =  args [ 0 ] ; }  Player  currentPlayer =  getCurrentPlayer  ( name ) ;   send  (  locationToRelative  (  currentPlayer . getLocation  ( ) ) ) ; } else  if  (  c . equals  ( "player.setPos" ) )  {  String  name = null ,  x =  args [ 0 ] ,  y =  args [ 1 ] ,  z =  args [ 2 ] ;  if  (   args . length > 3 )  {   name =  args [ 0 ] ;   x =  args [ 1 ] ;   y =  args [ 2 ] ;   z =  args [ 3 ] ; }  Player  currentPlayer =  getCurrentPlayer  ( name ) ;  Location  loc =  currentPlayer . getLocation  ( ) ;   currentPlayer . teleport  (  parseRelativeLocation  ( x , y , z ,  loc . getPitch  ( ) ,  loc . getYaw  ( ) ) ) ; } else  if  (  c . equals  ( "player.getDirection" ) )  {  String  name = null ;  if  (   args . length > 0 )  {   name =  args [ 0 ] ; }  Player  currentPlayer =  getCurrentPlayer  ( name ) ;   send  (    currentPlayer . getLocation  ( ) . getDirection  ( ) . toString  ( ) ) ; } else  if  (  c . equals  ( "player.getRotation" ) )  {  String  name = null ;  if  (   args . length > 0 )  {   name =  args [ 0 ] ; }  Player  currentPlayer =  getCurrentPlayer  ( name ) ;   send  (   currentPlayer . getLocation  ( ) . getYaw  ( ) ) ; } else  if  (  c . equals  ( "player.getPitch" ) )  {  String  name = null ;  if  (   args . length > 0 )  {   name =  args [ 0 ] ; }  Player  currentPlayer =  getCurrentPlayer  ( name ) ;   send  (   currentPlayer . getLocation  ( ) . getPitch  ( ) ) ; } else  if  (  c . equals  ( "world.getHeight" ) )  {   send  (   world . getHighestBlockYAt  (  parseRelativeBlockLocation  (  args [ 0 ] , "0" ,  args [ 1 ] ) ) -  origin . getBlockY  ( ) ) ; } else  if  (  c . equals  ( "entity.getTile" ) )  {  Player  entity =  plugin . getEntity  (  Integer . parseInt  (  args [ 0 ] ) ) ;  if  (  entity != null )  {   send  (  blockLocationToRelative  (  entity . getLocation  ( ) ) ) ; } else  {    plugin . getLogger  ( ) . info  (   "Entity [" +  args [ 0 ] + "] not found." ) ;   send  ( "Fail" ) ; } } else  if  (  c . equals  ( "entity.setTile" ) )  {  String  x =  args [ 1 ] ,  y =  args [ 2 ] ,  z =  args [ 3 ] ;  Player  entity =  plugin . getEntity  (  Integer . parseInt  (  args [ 0 ] ) ) ;  if  (  entity != null )  {  Location  loc =  entity . getLocation  ( ) ;   entity . teleport  (  parseRelativeBlockLocation  ( x , y , z ,  loc . getPitch  ( ) ,  loc . getYaw  ( ) ) ) ; } else  {    plugin . getLogger  ( ) . info  (   "Entity [" +  args [ 0 ] + "] not found." ) ;   send  ( "Fail" ) ; } } else  if  (  c . equals  ( "entity.getPos" ) )  {  Player  entity =  plugin . getEntity  (  Integer . parseInt  (  args [ 0 ] ) ) ;  if  (  entity != null )  {   send  (  locationToRelative  (  entity . getLocation  ( ) ) ) ; } else  {    plugin . getLogger  ( ) . info  (   "Entity [" +  args [ 0 ] + "] not found." ) ;   send  ( "Fail" ) ; } } else  if  (  c . equals  ( "entity.setPos" ) )  {  String  x =  args [ 1 ] ,  y =  args [ 2 ] ,  z =  args [ 3 ] ;  Player  entity =  plugin . getEntity  (  Integer . parseInt  (  args [ 0 ] ) ) ;  if  (  entity != null )  {  Location  loc =  entity . getLocation  ( ) ;   entity . teleport  (  parseRelativeLocation  ( x , y , z ,  loc . getPitch  ( ) ,  loc . getYaw  ( ) ) ) ; } else  {    plugin . getLogger  ( ) . info  (   "Entity [" +  args [ 0 ] + "] not found." ) ;   send  ( "Fail" ) ; } } else  if  (  c . equals  ( "entity.getDirection" ) )  {  Player  entity =  plugin . getEntity  (  Integer . parseInt  (  args [ 0 ] ) ) ;  if  (  entity != null )  {   send  (    entity . getLocation  ( ) . getDirection  ( ) . toString  ( ) ) ; } else  {    plugin . getLogger  ( ) . info  (   "Entity [" +  args [ 0 ] + "] not found." ) ;   send  ( "Fail" ) ; } } else  if  (  c . equals  ( "entity.getRotation" ) )  {  Player  entity =  plugin . getEntity  (  Integer . parseInt  (  args [ 0 ] ) ) ;  if  (  entity != null )  {   send  (   entity . getLocation  ( ) . getYaw  ( ) ) ; } else  {    plugin . getLogger  ( ) . info  (   "Entity [" +  args [ 0 ] + "] not found." ) ;   send  ( "Fail" ) ; } } else  if  (  c . equals  ( "entity.getPitch" ) )  {  Player  entity =  plugin . getEntity  (  Integer . parseInt  (  args [ 0 ] ) ) ;  if  (  entity != null )  {   send  (   entity . getLocation  ( ) . getPitch  ( ) ) ; } else  {    plugin . getLogger  ( ) . info  (   "Entity [" +  args [ 0 ] + "] not found." ) ;   send  ( "Fail" ) ; } } else  if  (  c . equals  ( "world.setSign" ) )  {  Location  loc =  parseRelativeBlockLocation  (  args [ 0 ] ,  args [ 1 ] ,  args [ 2 ] ) ;  Block  thisBlock =  world . getBlockAt  ( loc ) ;   int  blockType =  Integer . parseInt  (  args [ 3 ] ) ;   byte  blockData =  Byte . parseByte  (  args [ 4 ] ) ;  if  (   (   thisBlock . getTypeId  ( ) != blockType ) ||  (   thisBlock . getData  ( ) != blockData ) )  {   thisBlock . setTypeIdAndData  ( blockType , blockData , true ) ; }  if  (   thisBlock . getState  ( ) instanceof Sign )  {  Sign  sign =  ( Sign )  thisBlock . getState  ( ) ;  for (   int  i = 5 ;    i - 5 < 4 &&  i <  args . length ;  i ++ )  {   sign . setLine  (  i - 5 ,  args [ i ] ) ; }   sign . update  ( ) ; } } else 
<<<<<<<
 {    plugin . getLogger  ( ) . warning  (  c + " is not supported." ) ;   send  ( "Fail" ) ; }
=======
 if  (  c . equals  ( "world.spawnEntity" ) )  {  Location  loc =  parseRelativeBlockLocation  (  args [ 0 ] ,  args [ 1 ] ,  args [ 2 ] ) ;   world . spawnEntity  ( loc ,  EntityType . fromId  (  Integer . parseInt  (  args [ 3 ] ) ) ) ; } else  {    plugin . getLogger  ( ) . warning  (  c + " is not supported." ) ;   send  ( "Fail" ) ; }
>>>>>>>
 }  catch (   Exception e )  {    plugin . getLogger  ( ) . warning  ( "Error occured handling command" ) ;   e . printStackTrace  ( ) ;   send  ( "Fail" ) ; } }   private void setCuboid  (  Location pos1 ,  Location pos2 ,   int blockType ,   byte data )  {   int  minX ,  maxX ,  minY ,  maxY ,  minZ ,  maxZ ;  World  world =  pos1 . getWorld  ( ) ;   minX =    pos1 . getBlockX  ( ) <  pos2 . getBlockX  ( ) ?  pos1 . getBlockX  ( ) :  pos2 . getBlockX  ( ) ;   maxX =    pos1 . getBlockX  ( ) >=  pos2 . getBlockX  ( ) ?  pos1 . getBlockX  ( ) :  pos2 . getBlockX  ( ) ;   minY =    pos1 . getBlockY  ( ) <  pos2 . getBlockY  ( ) ?  pos1 . getBlockY  ( ) :  pos2 . getBlockY  ( ) ;   maxY =    pos1 . getBlockY  ( ) >=  pos2 . getBlockY  ( ) ?  pos1 . getBlockY  ( ) :  pos2 . getBlockY  ( ) ;   minZ =    pos1 . getBlockZ  ( ) <  pos2 . getBlockZ  ( ) ?  pos1 . getBlockZ  ( ) :  pos2 . getBlockZ  ( ) ;   maxZ =    pos1 . getBlockZ  ( ) >=  pos2 . getBlockZ  ( ) ?  pos1 . getBlockZ  ( ) :  pos2 . getBlockZ  ( ) ;  for (   int  x = minX ;  x <= maxX ;  ++ x )  {  for (   int  z = minZ ;  z <= maxZ ;  ++ z )  {  for (   int  y = minY ;  y <= maxY ;  ++ y )  {   updateBlock  ( world , x , y , z , blockType , data ) ; } } } }   private String getBlocks  (  Location pos1 ,  Location pos2 )  {  StringBuilder  blockData =  new StringBuilder  ( ) ;   int  minX ,  maxX ,  minY ,  maxY ,  minZ ,  maxZ ;  World  world =  pos1 . getWorld  ( ) ;   minX =    pos1 . getBlockX  ( ) <  pos2 . getBlockX  ( ) ?  pos1 . getBlockX  ( ) :  pos2 . getBlockX  ( ) ;   maxX =    pos1 . getBlockX  ( ) >=  pos2 . getBlockX  ( ) ?  pos1 . getBlockX  ( ) :  pos2 . getBlockX  ( ) ;   minY =    pos1 . getBlockY  ( ) <  pos2 . getBlockY  ( ) ?  pos1 . getBlockY  ( ) :  pos2 . getBlockY  ( ) ;   maxY =    pos1 . getBlockY  ( ) >=  pos2 . getBlockY  ( ) ?  pos1 . getBlockY  ( ) :  pos2 . getBlockY  ( ) ;   minZ =    pos1 . getBlockZ  ( ) <  pos2 . getBlockZ  ( ) ?  pos1 . getBlockZ  ( ) :  pos2 . getBlockZ  ( ) ;   maxZ =    pos1 . getBlockZ  ( ) >=  pos2 . getBlockZ  ( ) ?  pos1 . getBlockZ  ( ) :  pos2 . getBlockZ  ( ) ;  for (   int  y = minY ;  y <= maxY ;  ++ y )  {  for (   int  x = minX ;  x <= maxX ;  ++ x )  {  for (   int  z = minZ ;  z <= maxZ ;  ++ z )  {   blockData . append  (    new Integer  (  world . getBlockTypeIdAt  ( x , y , z ) ) . toString  ( ) + "," ) ; } } }  return  blockData . substring  ( 0 ,    blockData . length  ( ) > 0 ?   blockData . length  ( ) - 1 : 0 ) ; }   private void updateBlock  (  World world ,  Location loc ,   int blockType ,   byte blockData )  {  Block  thisBlock =  world . getBlockAt  ( loc ) ;   updateBlock  ( thisBlock , blockType , blockData ) ; }   private void updateBlock  (  World world ,   int x ,   int y ,   int z ,   int blockType ,   byte blockData )  {  Block  thisBlock =  world . getBlockAt  ( x , y , z ) ;   updateBlock  ( thisBlock , blockType , blockData ) ; }   private void updateBlock  (  Block thisBlock ,   int blockType ,   byte blockData )  {  if  (   (   thisBlock . getTypeId  ( ) != blockType ) ||  (   thisBlock . getData  ( ) != blockData ) )  {   thisBlock . setTypeIdAndData  ( blockType , blockData , true ) ; } }   public Player getCurrentPlayer  (  String name )  {  Player  player =  plugin . getNamedPlayer  ( name ) ;  if  (  player == null )  {   player = attachedPlayer ;  if  (  player == null )  {   player =  plugin . getHostPlayer  ( ) ;   attachedPlayer = player ; } }  return player ; }   public Location parseRelativeBlockLocation  (  String xstr ,  String ystr ,  String zstr )  {   int  x =  (  int )  Double . parseDouble  ( xstr ) ;   int  y =  (  int )  Double . parseDouble  ( ystr ) ;   int  z =  (  int )  Double . parseDouble  ( zstr ) ;  return  parseLocation  (  origin . getWorld  ( ) , x , y , z ,  origin . getBlockX  ( ) ,  origin . getBlockY  ( ) ,  origin . getBlockZ  ( ) ) ; }   public Location parseRelativeLocation  (  String xstr ,  String ystr ,  String zstr )  {   double  x =  Double . parseDouble  ( xstr ) ;   double  y =  Double . parseDouble  ( ystr ) ;   double  z =  Double . parseDouble  ( zstr ) ;  return  parseLocation  (  origin . getWorld  ( ) , x , y , z ,  origin . getX  ( ) ,  origin . getY  ( ) ,  origin . getZ  ( ) ) ; }   public Location parseRelativeBlockLocation  (  String xstr ,  String ystr ,  String zstr ,   float pitch ,   float yaw )  {  Location  loc =  parseRelativeBlockLocation  ( xstr , ystr , zstr ) ;   loc . setPitch  ( pitch ) ;   loc . setYaw  ( yaw ) ;  return loc ; }   public Location parseRelativeLocation  (  String xstr ,  String ystr ,  String zstr ,   float pitch ,   float yaw )  {  Location  loc =  parseRelativeLocation  ( xstr , ystr , zstr ) ;   loc . setPitch  ( pitch ) ;   loc . setYaw  ( yaw ) ;  return loc ; }   public String blockLocationToRelative  (  Location loc )  {  return  parseLocation  (  loc . getBlockX  ( ) ,  loc . getBlockY  ( ) ,  loc . getBlockZ  ( ) ,  origin . getBlockX  ( ) ,  origin . getBlockY  ( ) ,  origin . getBlockZ  ( ) ) ; }   public String locationToRelative  (  Location loc )  {  return  parseLocation  (  loc . getX  ( ) ,  loc . getY  ( ) ,  loc . getZ  ( ) ,  origin . getX  ( ) ,  origin . getY  ( ) ,  origin . getZ  ( ) ) ; }   private String parseLocation  (   double x ,   double y ,   double z ,   double originX ,   double originY ,   double originZ )  {  return      (  x - originX ) + "," +  (  y - originY ) + "," +  (  z - originZ ) ; }   private Location parseLocation  (  World world ,   double x ,   double y ,   double z ,   double originX ,   double originY ,   double originZ )  {  return  new Location  ( world ,  originX + x ,  originY + y ,  originZ + z ) ; }   private String parseLocation  (   int x ,   int y ,   int z ,   int originX ,   int originY ,   int originZ )  {  return      (  x - originX ) + "," +  (  y - originY ) + "," +  (  z - originZ ) ; }   private Location parseLocation  (  World world ,   int x ,   int y ,   int z ,   int originX ,   int originY ,   int originZ )  {  return  new Location  ( world ,  originX + x ,  originY + y ,  originZ + z ) ; }   public void send  (  Object a )  {   send  (  a . toString  ( ) ) ; }   public void send  (  String a )  {  if  ( pendingRemoval )  return ;  synchronized  ( outQueue )  {   outQueue . add  ( a ) ; } }   public void close  ( )  {  if  ( closed )  return ;   running = false ;   pendingRemoval = true ;  try  {   inThread . join  ( 2000 ) ;   outThread . join  ( 2000 ) ; }  catch (   InterruptedException e )  {    plugin . getLogger  ( ) . warning  ( "Failed to stop in/out thread" ) ;   e . printStackTrace  ( ) ; }  try  {   socket . close  ( ) ; }  catch (   Exception e )  {   e . printStackTrace  ( ) ; }    plugin . getLogger  ( ) . info  (   "Closed connection to" +  socket . getRemoteSocketAddress  ( ) + "." ) ; }   public void kick  (  String reason )  {  try  {   out . write  ( reason ) ;   out . flush  ( ) ; }  catch (   Exception e )  { }   close  ( ) ; }   private class InputThread  implements  Runnable  {   public void run  ( )  {    plugin . getLogger  ( ) . info  ( "Starting input thread" ) ;  while  ( running )  {  try  {  String  newLine =  in . readLine  ( ) ;  if  (  newLine == null )  {   running = false ; } else  {   inQueue . add  ( newLine ) ; } }  catch (   Exception e )  {  if  ( running )  {  if  (   e . getMessage  ( ) . equals  ( "Connection reset" ) )  {    plugin . getLogger  ( ) . info  ( "Connection reset" ) ; } else  {   e . printStackTrace  ( ) ; }   running = false ; } } }  try  {   in . close  ( ) ; }  catch (   Exception e )  {    plugin . getLogger  ( ) . warning  ( "Failed to close in buffer" ) ;   e . printStackTrace  ( ) ; } } }   private class OutputThread  implements  Runnable  {   public void run  ( )  {    plugin . getLogger  ( ) . info  ( "Starting output thread!" ) ;  while  ( running )  {  try  {  String  line ;  while  (   (  line =  outQueue . poll  ( ) ) != null )  {   out . write  ( line ) ;   out . write  ( '\n' ) ; }   out . flush  ( ) ;   Thread . yield  ( ) ;   Thread . sleep  ( 1L ) ; }  catch (   Exception e )  {  if  ( running )  {   e . printStackTrace  ( ) ;   running = false ; } } }  try  {   out . close  ( ) ; }  catch (   Exception e )  {    plugin . getLogger  ( ) . warning  ( "Failed to close out buffer" ) ;   e . printStackTrace  ( ) ; } } }   public static  int blockFaceToNotch  (  BlockFace face )  {  switch  ( face )  {   case DOWN :  return 0 ;   case UP :  return 1 ;   case NORTH :  return 2 ;   case SOUTH :  return 3 ;   case WEST :  return 4 ;   case EAST :  return 5 ;   default :  return 7 ; } } }