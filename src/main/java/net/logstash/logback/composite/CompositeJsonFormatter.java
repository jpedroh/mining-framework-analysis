  package    net . logstash . logback . composite ;   import   java . io . IOException ;  import   java . io . OutputStream ;  import   java . io . Writer ;  import   java . util . ServiceConfigurationError ;  import     net . logstash . logback . decorate . JsonFactoryDecorator ;  import     net . logstash . logback . decorate . JsonGeneratorDecorator ;  import     net . logstash . logback . decorate . NullJsonFactoryDecorator ;  import     net . logstash . logback . decorate . NullJsonGeneratorDecorator ;  import     com . fasterxml . jackson . core . JsonEncoding ;  import     com . fasterxml . jackson . core . JsonFactory ;  import     com . fasterxml . jackson . core . JsonGenerator ;  import     com . fasterxml . jackson . databind . ObjectMapper ;  import     com . fasterxml . jackson . databind . SerializationFeature ;  import      ch . qos . logback . access . spi . IAccessEvent ;  import      ch . qos . logback . classic . spi . ILoggingEvent ;  import      ch . qos . logback . core . spi . ContextAware ;  import      ch . qos . logback . core . spi . ContextAwareBase ;  import      ch . qos . logback . core . spi . DeferredProcessingAware ;  import      ch . qos . logback . core . spi . LifeCycle ;   public abstract class CompositeJsonFormatter  <  Event  extends DeferredProcessingAware >  extends ContextAwareBase  implements  LifeCycle  {   private JsonFactory  jsonFactory ;   private JsonFactoryDecorator  jsonFactoryDecorator =  new NullJsonFactoryDecorator  ( ) ;   private JsonGeneratorDecorator  jsonGeneratorDecorator =  new NullJsonGeneratorDecorator  ( ) ;   private  JsonProviders  < Event >  jsonProviders =  new  JsonProviders  < Event >  ( ) ;   private JsonEncoding  encoding =  JsonEncoding . UTF8 ;   private boolean  findAndRegisterJacksonModules = true ;   private volatile boolean  started ;   public CompositeJsonFormatter  (  ContextAware declaredOrigin )  {  super  ( declaredOrigin ) ; }    @ Override public void start  ( )  {  if  (   jsonProviders . getProviders  ( ) . isEmpty  ( ) )  {   addError  ( "No providers configured" ) ; }   jsonFactory =  createJsonFactory  ( ) ;   jsonProviders . setContext  ( context ) ;   jsonProviders . setJsonFactory  ( jsonFactory ) ;   jsonProviders . start  ( ) ;   started = true ; }    @ Override public void stop  ( )  {   jsonProviders . stop  ( ) ;   started = false ; }    @ Override public boolean isStarted  ( )  {  return started ; }   private JsonFactory createJsonFactory  ( )  {  ObjectMapper  objectMapper =   new ObjectMapper  ( ) . disable  (  SerializationFeature . FAIL_ON_EMPTY_BEANS ) ;  if  ( findAndRegisterJacksonModules )  {  try  {   objectMapper . findAndRegisterModules  ( ) ; }  catch (   ServiceConfigurationError serviceConfigurationError )  {   addError  ( "Error occurred while dynamically loading jackson modules" , serviceConfigurationError ) ; } }  JsonFactory  jsonFactory =    objectMapper . getFactory  ( ) . disable  (   JsonGenerator . Feature . FLUSH_PASSED_TO_STREAM ) . disable  (   JsonGenerator . Feature . AUTO_CLOSE_TARGET ) ;  return   this . jsonFactoryDecorator . decorate  ( jsonFactory ) ; }   public void writeEventToOutputStream  (  Event event ,  OutputStream outputStream )  throws IOException  {  try  (  JsonGenerator generator =  createGenerator  ( outputStream ) )  {   writeEventToGenerator  ( generator , event ) ; } }   public void writeEventToWriter  (  Event event ,  Writer writer )  throws IOException  {  try  (  JsonGenerator generator =  createGenerator  ( writer ) )  {   writeEventToGenerator  ( generator , event ) ; } }   protected void writeEventToGenerator  (  JsonGenerator generator ,  Event event )  throws IOException  {  if  (  !  isStarted  ( ) )  {  throw  new IllegalStateException  ( "Encoding attempted before starting." ) ; }   generator . writeStartObject  ( ) ;   jsonProviders . writeTo  ( generator , event ) ;   generator . writeEndObject  ( ) ;   generator . flush  ( ) ; }   protected void prepareForDeferredProcessing  (  Event event )  {   event . prepareForDeferredProcessing  ( ) ;   jsonProviders . prepareForDeferredProcessing  ( event ) ; }   private JsonGenerator createGenerator  (  OutputStream outputStream )  throws IOException  {  return   this . jsonGeneratorDecorator . decorate  (  jsonFactory . createGenerator  ( outputStream , encoding ) ) ; }   private JsonGenerator createGenerator  (  Writer writer )  throws IOException  {  return   this . jsonGeneratorDecorator . decorate  (  jsonFactory . createGenerator  ( writer ) ) ; }   public JsonFactory getJsonFactory  ( )  {  return jsonFactory ; }   public JsonFactoryDecorator getJsonFactoryDecorator  ( )  {  return jsonFactoryDecorator ; }   public void setJsonFactoryDecorator  (  JsonFactoryDecorator jsonFactoryDecorator )  {    this . jsonFactoryDecorator = jsonFactoryDecorator ; }   public JsonGeneratorDecorator getJsonGeneratorDecorator  ( )  {  return jsonGeneratorDecorator ; }   public void setJsonGeneratorDecorator  (  JsonGeneratorDecorator jsonGeneratorDecorator )  {    this . jsonGeneratorDecorator = jsonGeneratorDecorator ; }   public  JsonProviders  < Event > getProviders  ( )  {  return jsonProviders ; }   public String getEncoding  ( )  {  return  encoding . getJavaName  ( ) ; }   public void setEncoding  (  String encodingName )  {  for ( JsonEncoding encoding :  JsonEncoding . values  ( ) )  {  if  (    encoding . getJavaName  ( ) . equals  ( encodingName ) ||   encoding . name  ( ) . equals  ( encodingName ) )  {    this . encoding = encoding ;  return ; } }  throw  new IllegalArgumentException  (  "Unknown encoding " + encodingName ) ; }   public void setProviders  (   JsonProviders  < Event > jsonProviders )  {    this . jsonProviders = jsonProviders ; }   public boolean isFindAndRegisterJacksonModules  ( )  {  return findAndRegisterJacksonModules ; }   public void setFindAndRegisterJacksonModules  (  boolean findAndRegisterJacksonModules )  {    this . findAndRegisterJacksonModules = findAndRegisterJacksonModules ; } }