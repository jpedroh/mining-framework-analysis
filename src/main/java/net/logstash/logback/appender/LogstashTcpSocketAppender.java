  package    net . logstash . logback . appender ;   import   java . io . BufferedOutputStream ;  import   java . io . IOException ;  import   java . io . OutputStream ;  import   java . net . ConnectException ;  import   java . net . InetAddress ;  import   java . net . Socket ;  import   java . net . UnknownHostException ;  import    java . util . concurrent . BlockingQueue ;  import    java . util . concurrent . ExecutionException ;  import    java . util . concurrent . Future ;  import    java . util . concurrent . LinkedBlockingQueue ;  import    java . util . concurrent . RejectedExecutionException ;  import    java . util . concurrent . TimeUnit ;  import   javax . net . SocketFactory ;  import     ch . qos . logback . classic . ClassicConstants ;  import      ch . qos . logback . classic . net . LoggingEventPreSerializationTransformer ;  import      ch . qos . logback . classic . net . SocketAppender ;  import      ch . qos . logback . classic . spi . ILoggingEvent ;  import     ch . qos . logback . core . AppenderBase ;  import     ch . qos . logback . core . CoreConstants ;  import      ch . qos . logback . core . encoder . Encoder ;  import      ch . qos . logback . core . net . DefaultSocketConnector ;  import      ch . qos . logback . core . net . SocketConnector ;  import      ch . qos . logback . core . spi . PreSerializationTransformer ;  import      ch . qos . logback . core . status . ErrorStatus ;  import      ch . qos . logback . core . util . CloseUtil ;  import      ch . qos . logback . core . util . Duration ;   public class LogstashTcpSocketAppender  extends  AppenderBase  < ILoggingEvent >  implements  Runnable ,  SocketConnector . ExceptionHandler  {   private static final  PreSerializationTransformer  < ILoggingEvent >  PST =  new LoggingEventPreSerializationTransformer  ( ) ;   public static final  int  DEFAULT_PORT = 4560 ;   public static final  int  DEFAULT_RECONNECTION_DELAY = 30000 ;   public static final  int  DEFAULT_QUEUE_SIZE = 10000 ;   private static final  int  DEFAULT_ACCEPT_CONNECTION_DELAY = 5000 ;   private static final  int  DEFAULT_EVENT_DELAY_TIMEOUT = 100 ;   private String  remoteHost ;   private  int  port = DEFAULT_PORT ;   private InetAddress  address ;   private Duration  reconnectionDelay =  new Duration  ( DEFAULT_RECONNECTION_DELAY ) ;   private  int  acceptConnectionTimeout = DEFAULT_ACCEPT_CONNECTION_DELAY ;   private Duration  eventDelayLimit =  new Duration  ( DEFAULT_EVENT_DELAY_TIMEOUT ) ;   private  int  queueSize = DEFAULT_QUEUE_SIZE ;   private  BlockingQueue  < ILoggingEvent >  queue ;   private String  peerId ;   private  Future  <  ? >  task ;   private  Future  < Socket >  connectorTask ;   private volatile Socket  socket ;   protected  Encoder  < ILoggingEvent >  encoder ;   public  Encoder  < ILoggingEvent > getEncoder  ( )  {  return encoder ; }   public void setEncoder  (   Encoder  < ILoggingEvent > encoder )  {    this . encoder = encoder ; }   public  PreSerializationTransformer  < ILoggingEvent > getPST  ( )  {  return PST ; }   protected void encoderInit  (  OutputStream outputStream )  {  if  (   encoder != null &&  outputStream != null )  {  try  {   encoder . init  ( outputStream ) ; }  catch (   IOException ioe )  {    this . started = false ;   addStatus  (  new ErrorStatus  (   "Failed to initialize encoder for appender named [" + name + "]." , this , ioe ) ) ; } } }   protected void encoderClose  (  OutputStream outputStream )  {  if  (   encoder != null &&  outputStream != null )  {  try  {   encoder . close  ( ) ; }  catch (   IOException ioe )  {    this . started = false ;   addStatus  (  new ErrorStatus  (   "Failed to write footer for appender named [" + name + "]." , this , ioe ) ) ; } } }   public void start  ( )  {  if  (  isStarted  ( ) )  return ;   int  errorCount = 0 ;  if  (  encoder == null )  {   errorCount ++ ;   addError  (   "No encoder was configured for appender " + name + "." ) ; }  if  (  port <= 0 )  {   errorCount ++ ;   addError  (   "No port was configured for appender " + name + ". For more information, please visit http://logback.qos.ch/codes.html#socket_no_port" ) ; }  if  (  remoteHost == null )  {   errorCount ++ ;   addError  (   "No remote host was configured for appender " + name + ". For more information, please visit http://logback.qos.ch/codes.html#socket_no_host" ) ; }  if  (  errorCount == 0 )  {  try  {   address =  InetAddress . getByName  ( remoteHost ) ; }  catch (   UnknownHostException ex )  {   addError  (  "unknown host: " + remoteHost ) ;   errorCount ++ ; } }  if  (  errorCount == 0 )  {   encoder . start  ( ) ;   queue =  new  LinkedBlockingQueue  < ILoggingEvent >  ( queueSize ) ;   peerId =     "remote peer " + remoteHost + ":" + port + ": " ;   task =    getContext  ( ) . getExecutorService  ( ) . submit  ( this ) ;   super . start  ( ) ; } }    @ Override public void stop  ( )  {  if  (  !  isStarted  ( ) )  return ;   CloseUtil . closeQuietly  ( socket ) ;   task . cancel  ( true ) ;  if  (  connectorTask != null )   connectorTask . cancel  ( true ) ;   super . stop  ( ) ; }    @ Override protected void append  (  ILoggingEvent event )  {  if  (   event == null ||  !  isStarted  ( ) )  return ;  try  {   final boolean  inserted =  queue . offer  ( event ,  eventDelayLimit . getMilliseconds  ( ) ,  TimeUnit . MILLISECONDS ) ;  if  (  ! inserted )  {   addInfo  (   "Dropping event due to timeout limit of [" + eventDelayLimit + "] being exceeded" ) ; } }  catch (   InterruptedException e )  {   addError  ( "Interrupted while appending event to SocketAppender" , e ) ; } }   public final void run  ( )  {  try  {  while  (  !   Thread . currentThread  ( ) . isInterrupted  ( ) )  {  SocketConnector  connector =  createConnector  ( address , port , 0 ,  reconnectionDelay . getMilliseconds  ( ) ) ;   connectorTask =  activateConnector  ( connector ) ;  if  (  connectorTask == null )  break ;   socket =  waitForConnectorToReturnASocket  ( ) ;  if  (  socket == null )  break ;   dispatchEvents  ( ) ; } }  catch (   InterruptedException ex )  {  assert true ; }   addInfo  ( "shutting down" ) ; }   private SocketConnector createConnector  (  InetAddress address ,   int port ,   int initialDelay ,   long retryDelay )  {  SocketConnector  connector =  newConnector  ( address , port , initialDelay , retryDelay ) ;   connector . setExceptionHandler  ( this ) ;   connector . setSocketFactory  (  getSocketFactory  ( ) ) ;  return connector ; }   private  Future  < Socket > activateConnector  (  SocketConnector connector )  {  try  {  return    getContext  ( ) . getExecutorService  ( ) . submit  ( connector ) ; }  catch (   RejectedExecutionException ex )  {  return null ; } }   private Socket waitForConnectorToReturnASocket  ( )  throws InterruptedException  {  try  {  Socket  s =  connectorTask . get  ( ) ;   connectorTask = null ;  return s ; }  catch (   ExecutionException e )  {  return null ; } }   private void dispatchEvents  ( )  throws InterruptedException  {  OutputStream  outputStream = null ;  try  {   socket . setSoTimeout  ( acceptConnectionTimeout ) ;   outputStream =  new BufferedOutputStream  (  socket . getOutputStream  ( ) ) ;   encoderInit  ( outputStream ) ;   socket . setSoTimeout  ( 0 ) ;   addInfo  (  peerId + "connection established" ) ;   int  counter = 0 ;  while  ( true )  {  ILoggingEvent  event =  queue . take  ( ) ;    this . encoder . doEncode  ( event ) ;   outputStream . flush  ( ) ;  if  (   ++ counter >=  CoreConstants . OOS_RESET_FREQUENCY )  {   outputStream . flush  ( ) ;   counter = 0 ; } } }  catch (   IOException ex )  {   addInfo  (   peerId + "connection failed: " + ex ) ; }  finally  {  if  (  outputStream != null )  {   encoderClose  ( outputStream ) ; }   CloseUtil . closeQuietly  ( socket ) ;   socket = null ;   addInfo  (  peerId + "connection closed" ) ; } }   public void connectionFailed  (  SocketConnector connector ,  Exception ex )  {  if  (  ex instanceof InterruptedException )  {   addInfo  ( "connector interrupted" ) ; } else  if  (  ex instanceof ConnectException )  {   addInfo  (  peerId + "connection refused" ) ; } else  {   addInfo  (  peerId + ex ) ; } }   protected SocketConnector newConnector  (  InetAddress address ,   int port ,   long initialDelay ,   long retryDelay )  {  return  new DefaultSocketConnector  ( address , port , initialDelay , retryDelay ) ; }   protected SocketFactory getSocketFactory  ( )  {  return  SocketFactory . getDefault  ( ) ; }   public void setRemoteHost  (  String host )  {   remoteHost = host ; }   public String getRemoteHost  ( )  {  return remoteHost ; }   public void setPort  (   int port )  {    this . port = port ; }   public  int getPort  ( )  {  return port ; }   public void setReconnectionDelay  (  Duration delay )  {    this . reconnectionDelay = delay ; }   public Duration getReconnectionDelay  ( )  {  return reconnectionDelay ; }   public void setEventDelayLimit  (  Duration eventDelayLimit )  {    this . eventDelayLimit = eventDelayLimit ; }   public Duration getEventDelayLimit  ( )  {  return eventDelayLimit ; }  void setAcceptConnectionTimeout  (   int acceptConnectionTimeout )  {    this . acceptConnectionTimeout = acceptConnectionTimeout ; }   public  int getQueueSize  ( )  {  return queueSize ; }   public void setQueueSize  (   int queueSize )  {  if  (  queue != null )  {  throw  new IllegalStateException  ( "Queue size must be set before initialization" ) ; }    this . queueSize = queueSize ; } }