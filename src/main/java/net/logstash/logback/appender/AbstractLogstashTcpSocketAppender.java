  package    net . logstash . logback . appender ;   import   java . io . BufferedOutputStream ;  import   java . io . IOException ;  import   java . io . InputStream ;  import   java . io . OutputStream ;  import   java . net . InetAddress ;  import   java . net . InetSocketAddress ;  import   java . net . Socket ;  import   java . net . SocketTimeoutException ;  import   java . net . UnknownHostException ;  import    java . nio . charset . Charset ;  import    java . nio . charset . StandardCharsets ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . Formatter ;  import   java . util . List ;  import   java . util . Optional ;  import    java . util . concurrent . BlockingQueue ;  import    java . util . concurrent . Callable ;  import    java . util . concurrent . CountDownLatch ;  import    java . util . concurrent . Future ;  import    java . util . concurrent . RejectedExecutionException ;  import    java . util . concurrent . ScheduledFuture ;  import    java . util . concurrent . TimeUnit ;  import   javax . net . SocketFactory ;  import    javax . net . ssl . SSLContext ;  import    javax . net . ssl . SSLSocket ;  import    javax . net . ssl . SSLSocketFactory ;  import      net . logstash . logback . appender . destination . DelegateDestinationConnectionStrategy ;  import      net . logstash . logback . appender . destination . DestinationConnectionStrategy ;  import      net . logstash . logback . appender . destination . DestinationParser ;  import      net . logstash . logback . appender . destination . PreferPrimaryDestinationConnectionStrategy ;  import      net . logstash . logback . appender . listener . TcpAppenderListener ;  import     net . logstash . logback . encoder . SeparatorParser ;  import     net . logstash . logback . encoder . StreamingEncoder ;  import    com . lmax . disruptor . EventHandler ;  import    com . lmax . disruptor . LifecycleAware ;  import    com . lmax . disruptor . RingBuffer ;  import      ch . qos . logback . core . encoder . Encoder ;  import       ch . qos . logback . core . joran . spi . DefaultClass ;  import       ch . qos . logback . core . net . ssl . ConfigurableSSLSocketFactory ;  import       ch . qos . logback . core . net . ssl . SSLConfigurableSocket ;  import       ch . qos . logback . core . net . ssl . SSLConfiguration ;  import       ch . qos . logback . core . net . ssl . SSLParametersConfiguration ;  import      ch . qos . logback . core . spi . DeferredProcessingAware ;  import      ch . qos . logback . core . util . CloseUtil ;  import      ch . qos . logback . core . util . Duration ;   public abstract class AbstractLogstashTcpSocketAppender  <  Event  extends DeferredProcessingAware ,  Listener  extends  TcpAppenderListener  < Event > >  extends  AsyncDisruptorAppender  < Event , Listener >  {   protected static final String  HOST_NAME_FORMAT = "%3$s" ;   protected static final String  PORT_FORMAT = "%4$d" ;   public static final String  DEFAULT_THREAD_NAME_FORMAT =        "logback-appender-" + APPENDER_NAME_FORMAT + "-" + HOST_NAME_FORMAT + ":" + PORT_FORMAT + "-" + THREAD_INDEX_FORMAT ;   public static final  int  DEFAULT_PORT = 4560 ;   public static final  int  DEFAULT_RECONNECTION_DELAY = 30000 ;   public static final  int  DEFAULT_WRITE_TIMEOUT = 0 ;   public static final  int  DEFAULT_QUEUE_SIZE = DEFAULT_RING_BUFFER_SIZE ;   public static final  int  DEFAULT_CONNECTION_TIMEOUT = 5000 ;   public static final  int  DEFAULT_WRITE_BUFFER_SIZE = 8192 ;   private static final NotConnectedException  NOT_CONNECTED_EXCEPTION =  new NotConnectedException  ( ) ;   private static final ShutdownInProgressException  SHUTDOWN_IN_PROGRESS_EXCEPTION =  new ShutdownInProgressException  ( ) ;  static  {   NOT_CONNECTED_EXCEPTION . setStackTrace  (  new StackTraceElement  [ ]  {  new StackTraceElement  (    AbstractLogstashTcpSocketAppender . TcpSendingEventHandler . class . getName  ( ) , "onEvent(..)" , null ,  - 1 ) } ) ;   SHUTDOWN_IN_PROGRESS_EXCEPTION . setStackTrace  (  new StackTraceElement  [ ]  {  new StackTraceElement  (    AbstractLogstashTcpSocketAppender . TcpSendingEventHandler . class . getName  ( ) , "onEvent(..)" , null ,  - 1 ) } ) ; }   private  List  < InetSocketAddress >  destinations =  new  ArrayList  < >  ( 2 ) ;   private volatile  int  connectedDestinationIndex = 0 ;   private volatile InetSocketAddress  connectedDestination ;   private DestinationConnectionStrategy  connectionStrategy =  new PreferPrimaryDestinationConnectionStrategy  ( ) ;   private Duration  reconnectionDelay =  new Duration  ( DEFAULT_RECONNECTION_DELAY ) ;   private  int  acceptConnectionTimeout = DEFAULT_CONNECTION_TIMEOUT ;   private String  peerId ;   private  Encoder  < Event >  encoder ;   private  int  writeBufferSize = DEFAULT_WRITE_BUFFER_SIZE ;   private SocketFactory  socketFactory ;   private SSLConfiguration  sslConfiguration ;   private Duration  keepAliveDuration ;   private String  keepAliveMessage =  System . getProperty  ( "line.separator" ) ;   private Charset  keepAliveCharset =  StandardCharsets . UTF_8 ;   private   byte  [ ]  keepAliveBytes ;   private Duration  writeTimeout =  new Duration  ( DEFAULT_WRITE_TIMEOUT ) ;   private volatile CountDownLatch  shutdownLatch ;   private class TcpSendingEventHandler  implements   EventHandler  <  LogEvent  < Event > > , LifecycleAware  {   private static final  int  MAX_REPEAT_CONNECTION_ERROR_LOG = 5 ;   private static final  int  MAX_REPEAT_WRITE_ATTEMPTS = 5 ;   private volatile Socket  socket ;   private volatile OutputStream  outputStream ;   private volatile  long  lastSendStartNanoTime ;   private volatile  long  lastSendEndNanoTime ;   private   long  [ ]  destinationAttemptStartTimes ;   private  ScheduledFuture  <  ? >  keepAliveFuture ;   private KeepAliveRunnable  keepAliveRunnable ;   private  ScheduledFuture  <  ? >  writeTimeoutFuture ;   private WriteTimeoutRunnable  writeTimeoutRunnable ;   private  Future  <  ? >  readerFuture ;   private class KeepAliveRunnable  implements  Runnable  {   private  int  previousDestinationIndex = connectedDestinationIndex ;    @ Override public void run  ( )  {   long  lastSendEnd = lastSendEndNanoTime ;   long  currentNanoTime =  System . nanoTime  ( ) ;  if  (  hasKeepAliveDurationElapsed  ( lastSendEnd , currentNanoTime ) )  {     getDisruptor  ( ) . getRingBuffer  ( ) . tryPublishEvent  (  getEventTranslator  ( ) , null ) ;   scheduleKeepAlive  ( currentNanoTime ) ; } else  {   scheduleKeepAlive  ( lastSendEnd ) ; }  if  (  previousDestinationIndex != connectedDestinationIndex )  {   updateCurrentThreadName  ( ) ; }   previousDestinationIndex = connectedDestinationIndex ; } }   private class ReaderCallable  implements   Callable  < Void >  {   private final InputStream  inputStream ;  ReaderCallable  (  InputStream inputStream )  {  super  ( ) ;    this . inputStream = inputStream ; }    @ Override public Void call  ( )  throws Exception  {   updateCurrentThreadName  ( ) ;  try  {  while  ( true )  {  try  {  if  (   inputStream . read  ( ) ==  - 1 )  {  return null ; } }  catch (   SocketTimeoutException e )  { }  catch (   Exception e )  {  throw e ; } } }  finally  {  if  (  !   Thread . currentThread  ( ) . isInterrupted  ( ) )  {    getExecutorService  ( ) . submit  (   ( ) ->  {     getDisruptor  ( ) . getRingBuffer  ( ) . tryPublishEvent  (  getEventTranslator  ( ) , null ) ; } ) ; } } } }   private class WriteTimeoutRunnable  implements  Runnable  {   private volatile  long  lastDetectedStartNanoTime ;    @ Override public void run  ( )  {   long  lastSendStart = lastSendStartNanoTime ;   long  lastSendEnd = lastSendEndNanoTime ;  if  (   lastSendStart > lastSendEnd &&  lastSendStart != lastDetectedStartNanoTime )  {   long  elapsedSendTimeInMillis =   TimeUnit . NANOSECONDS . toMillis  (   System . nanoTime  ( ) - lastSendStart ) ;  if  (  elapsedSendTimeInMillis >  writeTimeout . getMilliseconds  ( ) )  {   lastDetectedStartNanoTime = lastSendStart ;   addWarn  (      peerId + "Detected write timeout after " + elapsedSendTimeInMillis + "ms.  Write timeout=" +  getWriteTimeout  ( ) + ".  Closing socket to force reconnect" ) ;   closeSocket  ( ) ; } } } }    @ Override public void onEvent  (   LogEvent  < Event > logEvent ,   long sequence ,  boolean endOfBatch )  throws Exception  {  Exception  sendFailureException = null ;  for (   int  i = 0 ;  i < MAX_REPEAT_WRITE_ATTEMPTS ;  i ++ )  {  Socket  socket =  this . socket ;  OutputStream  outputStream =  this . outputStream ;  if  (   socket == null &&  (   !  isStarted  ( ) ||   Thread . currentThread  ( ) . isInterrupted  ( ) ) )  {   sendFailureException = SHUTDOWN_IN_PROGRESS_EXCEPTION ;  break ; }   Future  <  ? >  readerFuture =  this . readerFuture ;  if  (   readerFuture . isDone  ( ) ||  socket == null )  {   addInfo  (  peerId + "destination terminated the connection. Reconnecting." ) ;   reopenSocket  ( ) ;  try  {   readerFuture . get  ( ) ;   sendFailureException = NOT_CONNECTED_EXCEPTION ; }  catch (   Exception e )  {   sendFailureException = e ; }  continue ; }  try  {   writeEvent  ( socket , outputStream , logEvent , endOfBatch ) ;  return ; }  catch (   Exception e )  {   sendFailureException = e ;   addWarn  (    peerId + "unable to send event: " +  e . getMessage  ( ) + " Reconnecting." , e ) ;   reopenSocket  ( ) ; } }  if  (   logEvent . event != null )  {   fireEventSendFailure  (  logEvent . event , sendFailureException ) ; } }   private void writeEvent  (  Socket socket ,  OutputStream outputStream ,   LogEvent  < Event > logEvent ,  boolean endOfBatch )  throws IOException  {   long  startWallTime =  System . currentTimeMillis  ( ) ;   long  startNanoTime =  System . nanoTime  ( ) ;   lastSendStartNanoTime = startNanoTime ;  if  (   logEvent . event != null )  {   encode  (  logEvent . event , outputStream ) ; } else  if  (  hasKeepAliveDurationElapsed  ( lastSendEndNanoTime , startNanoTime ) )  {   outputStream . write  ( keepAliveBytes ) ; }  if  ( endOfBatch )  {   outputStream . flush  ( ) ; }   long  endNanoTime =  System . nanoTime  ( ) ;   lastSendEndNanoTime = endNanoTime ;  if  (   logEvent . event != null )  {   fireEventSent  ( socket ,  logEvent . event ,  endNanoTime - startNanoTime ) ; }  if  (  connectionStrategy . shouldReconnect  ( startWallTime , connectedDestinationIndex ,  destinations . size  ( ) ) )  {   addInfo  (  peerId + "reestablishing connection." ) ;   outputStream . flush  ( ) ;   reopenSocket  ( ) ; } }    @ SuppressWarnings  ( "unchecked" ) private void encode  (  Event event ,  OutputStream outputStream )  throws IOException  {  if  (  encoder instanceof StreamingEncoder )  {    (  (  StreamingEncoder  < Event > ) encoder ) . encode  ( event , outputStream ) ; } else  {    byte  [ ]  data =  encoder . encode  ( event ) ;  if  (  data != null )  {   outputStream . write  ( data ) ; } } }   private boolean hasKeepAliveDurationElapsed  (   long lastSentNanoTime ,   long currentNanoTime )  {  return   isKeepAliveEnabled  ( ) &&   lastSentNanoTime +   TimeUnit . MILLISECONDS . toNanos  (  keepAliveDuration . getMilliseconds  ( ) ) < currentNanoTime ; }    @ Override public void onStart  ( )  {    this . destinationAttemptStartTimes =  new  long  [  destinations . size  ( ) ] ;   openSocket  ( ) ;   scheduleKeepAlive  (  System . nanoTime  ( ) ) ;   scheduleWriteTimeout  ( ) ; }    @ Override public void onShutdown  ( )  {   unscheduleWriteTimeout  ( ) ;   unscheduleKeepAlive  ( ) ;   closeEncoder  ( ) ;   closeSocket  ( ) ; }   private synchronized void reopenSocket  ( )  {   closeSocket  ( ) ;   openSocket  ( ) ; }   private synchronized void openSocket  ( )  {   int  errorCount = 0 ;   int  destinationIndex = connectedDestinationIndex ;  while  (   isStarted  ( ) &&  !   Thread . currentThread  ( ) . isInterrupted  ( ) )  {   destinationIndex =  connectionStrategy . selectNextDestinationIndex  ( destinationIndex ,  destinations . size  ( ) ) ;   long  startWallTime =  System . currentTimeMillis  ( ) ;  Socket  tempSocket = null ;  OutputStream  tempOutputStream = null ;  InetSocketAddress  currentDestination =  destinations . get  ( destinationIndex ) ;  try  {   peerId =   "Log destination " + currentDestination + ": " ;   final  long  millisSinceLastAttempt =  startWallTime -  destinationAttemptStartTimes [ destinationIndex ] ;  if  (  millisSinceLastAttempt <  reconnectionDelay . getMilliseconds  ( ) )  {   final  long  sleepTime =   reconnectionDelay . getMilliseconds  ( ) - millisSinceLastAttempt ;  if  (  errorCount <  MAX_REPEAT_CONNECTION_ERROR_LOG *  destinations . size  ( ) )  {   addWarn  (    peerId + "Waiting " + sleepTime + "ms before attempting reconnection." ) ; }  try  {   shutdownLatch . await  ( sleepTime ,  TimeUnit . MILLISECONDS ) ;  if  (  !  isStarted  ( ) )  {  return ; } }  catch (   InterruptedException ie )  {    Thread . currentThread  ( ) . interrupt  ( ) ;   addWarn  (  peerId + "connection interrupted. Will no longer attempt reconnection." ) ;  return ; }   startWallTime =  System . currentTimeMillis  ( ) ; }    destinationAttemptStartTimes [ destinationIndex ] = startWallTime ;   tempSocket =  socketFactory . createSocket  ( ) ;   tempSocket . setSoTimeout  ( acceptConnectionTimeout ) ;   tempSocket . connect  (  new InetSocketAddress  (  getHostString  ( currentDestination ) ,  currentDestination . getPort  ( ) ) , acceptConnectionTimeout ) ;  if  (  tempSocket instanceof SSLSocket )  {    (  ( SSLSocket ) tempSocket ) . startHandshake  ( ) ; }   tempOutputStream =   writeBufferSize > 0 ?  new BufferedOutputStream  (  tempSocket . getOutputStream  ( ) , writeBufferSize ) :  tempSocket . getOutputStream  ( ) ;   addInfo  (  peerId + "connection established." ) ;    this . socket = tempSocket ;    this . outputStream = tempOutputStream ;  boolean  shouldUpdateThreadName =  (  destinationIndex != connectedDestinationIndex ) ;   connectedDestinationIndex = destinationIndex ;   connectedDestination = currentDestination ;   connectionStrategy . connectSuccess  ( startWallTime , destinationIndex ,  destinations . size  ( ) ) ;  if  ( shouldUpdateThreadName )  {   updateCurrentThreadName  ( ) ; }    this . readerFuture =  scheduleReaderCallable  (  new ReaderCallable  (  tempSocket . getInputStream  ( ) ) ) ;   fireConnectionOpened  (  this . socket ) ;  return ; }  catch (   Exception e )  {   CloseUtil . closeQuietly  ( tempOutputStream ) ;   CloseUtil . closeQuietly  ( tempSocket ) ;   connectionStrategy . connectFailed  ( startWallTime , destinationIndex ,  destinations . size  ( ) ) ;   fireConnectionFailed  ( currentDestination , e ) ;  if  (   errorCount ++ <  MAX_REPEAT_CONNECTION_ERROR_LOG *  destinations . size  ( ) )  {   addWarn  (  peerId + "connection failed." , e ) ; } } } }   private synchronized void closeSocket  ( )  {   connectedDestination = null ;   CloseUtil . closeQuietly  ( outputStream ) ;   outputStream = null ;   CloseUtil . closeQuietly  ( socket ) ;   fireConnectionClosed  ( socket ) ;   socket = null ;  if  (   this . readerFuture != null )  {    this . readerFuture . cancel  ( true ) ; } }   private void closeEncoder  ( )  {   encoder . stop  ( ) ; }   private synchronized void scheduleKeepAlive  (   long basedOnNanoTime )  {  if  (   isKeepAliveEnabled  ( ) &&  !   Thread . currentThread  ( ) . isInterrupted  ( ) )  {  if  (  keepAliveRunnable == null )  {   keepAliveRunnable =  new KeepAliveRunnable  ( ) ; }   long  delay =    TimeUnit . MILLISECONDS . toNanos  (  keepAliveDuration . getMilliseconds  ( ) ) -  (   System . nanoTime  ( ) - basedOnNanoTime ) ;  try  {   keepAliveFuture =   getExecutorService  ( ) . schedule  ( keepAliveRunnable , delay ,  TimeUnit . NANOSECONDS ) ; }  catch (   RejectedExecutionException e )  {   keepAliveFuture = null ; } } }   private synchronized void unscheduleKeepAlive  ( )  {  if  (  keepAliveFuture != null )  {   keepAliveFuture . cancel  ( true ) ;  try  {   keepAliveFuture . get  ( ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   Exception e )  { } } }   private synchronized void scheduleWriteTimeout  ( )  {  if  (   isWriteTimeoutEnabled  ( ) &&  !   Thread . currentThread  ( ) . isInterrupted  ( ) )  {  if  (  writeTimeoutRunnable == null )  {   writeTimeoutRunnable =  new WriteTimeoutRunnable  ( ) ; }   long  delay =  writeTimeout . getMilliseconds  ( ) ;  try  {   writeTimeoutFuture =   getExecutorService  ( ) . scheduleWithFixedDelay  ( writeTimeoutRunnable , delay , delay ,  TimeUnit . MILLISECONDS ) ; }  catch (   RejectedExecutionException e )  {   writeTimeoutFuture = null ; } } }   private synchronized void unscheduleWriteTimeout  ( )  {  if  (  writeTimeoutFuture != null )  {   writeTimeoutFuture . cancel  ( true ) ;  try  {   writeTimeoutFuture . get  ( ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   Exception e )  { } } } }   private static class UnconnectedConfigurableSSLSocketFactory  extends ConfigurableSSLSocketFactory  {   private final SSLParametersConfiguration  parameters ;   private final SSLSocketFactory  delegate ;  UnconnectedConfigurableSSLSocketFactory  (  SSLParametersConfiguration parameters ,  SSLSocketFactory delegate )  {  super  ( parameters , delegate ) ;    this . parameters = parameters ;    this . delegate = delegate ; }    @ Override public Socket createSocket  ( )  throws IOException  {  SSLSocket  socket =  ( SSLSocket )  delegate . createSocket  ( ) ;   parameters . configure  (  new SSLConfigurableSocket  ( socket ) ) ;  return socket ; } }   public AbstractLogstashTcpSocketAppender  ( )  {  super  ( ) ;   setEventHandler  (  new TcpSendingEventHandler  ( ) ) ;   setThreadNameFormat  ( DEFAULT_THREAD_NAME_FORMAT ) ; }    @ Override public boolean isStarted  ( )  {  CountDownLatch  latch =  this . shutdownLatch ;  return   latch != null &&   latch . getCount  ( ) != 0 ; }    @ Override public synchronized void start  ( )  {  if  (  isStarted  ( ) )  {  return ; }   int  errorCount = 0 ;  if  (  encoder == null )  {   errorCount ++ ;   addError  ( "No encoder was configured. Use <encoder> to specify the fully qualified class name of the encoder to use" ) ; }  if  (  destinations . isEmpty  ( ) )  {   errorCount ++ ;   addError  ( "No destination was configured. Use <destination> to add one or more destinations to the appender" ) ; }  if  (   errorCount == 0 &&  socketFactory == null )  {  if  (  sslConfiguration == null )  {   socketFactory =  SocketFactory . getDefault  ( ) ; } else  {  try  {  SSLContext  sslContext =   getSsl  ( ) . createContext  ( this ) ;  SSLParametersConfiguration  parameters =   getSsl  ( ) . getParameters  ( ) ;   parameters . setContext  (  getContext  ( ) ) ;   socketFactory =  new UnconnectedConfigurableSSLSocketFactory  ( parameters ,  sslContext . getSocketFactory  ( ) ) ; }  catch (   Exception e )  {   addError  ( "Unable to create ssl context" , e ) ;   errorCount ++ ; } } }  if  (   keepAliveMessage != null &&  keepAliveCharset != null )  {   keepAliveBytes =  keepAliveMessage . getBytes  ( keepAliveCharset ) ; }  if  (  errorCount == 0 )  {   encoder . setContext  (  getContext  ( ) ) ;  if  (  !  encoder . isStarted  ( ) )  {   encoder . start  ( ) ; }   int  threadPoolCoreSize =   getThreadPoolCoreSize  ( ) + 1 ;  if  (  keepAliveDuration != null )  {   threadPoolCoreSize ++ ; }  if  (  isWriteTimeoutEnabled  ( ) )  {   threadPoolCoreSize ++ ; }   setThreadPoolCoreSize  ( threadPoolCoreSize ) ;    this . shutdownLatch =  new CountDownLatch  ( 1 ) ;   super . start  ( ) ; } }    @ Override public synchronized void stop  ( )  {  if  (  !  isStarted  ( ) )  {  return ; }    this . shutdownLatch . countDown  ( ) ;   super . stop  ( ) ; }   protected  Future  <  ? > scheduleReaderCallable  (   Callable  < Void > readerCallable )  {  return   getExecutorService  ( ) . submit  ( readerCallable ) ; }   protected void fireEventSent  (  Socket socket ,  Event event ,   long durationInNanos )  {  for ( Listener listener : listeners )  {   listener . eventSent  ( this , socket , event , durationInNanos ) ; } }   protected void fireEventSendFailure  (  Event event ,  Throwable reason )  {  for ( Listener listener : listeners )  {   listener . eventSendFailure  ( this , event , reason ) ; } }   protected void fireConnectionOpened  (  Socket socket )  {  for ( Listener listener : listeners )  {   listener . connectionOpened  ( this , socket ) ; } }   protected void fireConnectionClosed  (  Socket socket )  {  for ( Listener listener : listeners )  {   listener . connectionClosed  ( this , socket ) ; } }   protected void fireConnectionFailed  (  InetSocketAddress address ,  Throwable throwable )  {  for ( Listener listener : listeners )  {   listener . connectionFailed  ( this , address , throwable ) ; } }   public  Encoder  < Event > getEncoder  ( )  {  return encoder ; }   public void setEncoder  (   Encoder  < Event > encoder )  {    this . encoder = encoder ; }   public SocketFactory getSocketFactory  ( )  {  return socketFactory ; }   public void setSocketFactory  (  SocketFactory socketFactory )  {    this . socketFactory = socketFactory ; }   public void addDestination  (   final String destination )  throws IllegalArgumentException  {   List  < InetSocketAddress >  parsedDestinations =  DestinationParser . parse  ( destination , DEFAULT_PORT ) ;   addDestinations  (  parsedDestinations . toArray  (  new InetSocketAddress  [ 0 ] ) ) ; }   public void addDestinations  (  InetSocketAddress ...  destinations )  throws IllegalArgumentException  {  if  (  destinations == null )  {  return ; }  for ( InetSocketAddress destination : destinations )  {  try  {   InetAddress . getByName  (  getHostString  ( destination ) ) ; }  catch (   UnknownHostException ex )  {   addWarn  (     "Invalid destination '" +  getHostString  ( destination ) + "': host unknown (was '" +  getHostString  ( destination ) + "')." ) ; }    this . destinations . add  ( destination ) ; } }   protected String getHostString  (  InetSocketAddress destination )  {  return  destination . getHostString  ( ) ; }   protected void updateCurrentThreadName  ( )  {    Thread . currentThread  ( ) . setName  (  calculateThreadName  ( ) ) ; }    @ Override protected  List  < Object > getThreadNameFormatParams  ( )  {   List  < Object >  superThreadNameFormatParams =  super . getThreadNameFormatParams  ( ) ;   List  < Object >  threadNameFormatParams =  new  ArrayList  < Object >  (   superThreadNameFormatParams . size  ( ) + 2 ) ;   threadNameFormatParams . addAll  ( superThreadNameFormatParams ) ;  InetSocketAddress  currentDestination =   this . destinations . get  ( connectedDestinationIndex ) ;   threadNameFormatParams . add  (  getHostString  ( currentDestination ) ) ;   threadNameFormatParams . add  (  currentDestination . getPort  ( ) ) ;  return threadNameFormatParams ; }   public  List  < InetSocketAddress > getDestinations  ( )  {  return  Collections . unmodifiableList  ( destinations ) ; }   public void setReconnectionDelay  (  Duration delay )  {  if  (   delay == null ||   delay . getMilliseconds  ( ) <= 0 )  {  throw  new IllegalArgumentException  ( "reconnectionDelay must be > 0" ) ; }    this . reconnectionDelay = delay ; }   public Duration getReconnectionDelay  ( )  {  return reconnectionDelay ; }   public void setSecondaryConnectionTTL  (  Duration secondaryConnectionTTL )  {  if  (  connectionStrategy instanceof PreferPrimaryDestinationConnectionStrategy )  {    (  ( PreferPrimaryDestinationConnectionStrategy ) connectionStrategy ) . setSecondaryConnectionTTL  ( secondaryConnectionTTL ) ; } else  {  throw  new IllegalStateException  (  String . format  ( "When setting the secondaryConnectionTTL, the strategy must be a %s.  It is currently a %s" ,  PreferPrimaryDestinationConnectionStrategy . class , connectionStrategy ) ) ; } }   public Duration getSecondaryConnectionTTL  ( )  {  if  (  connectionStrategy instanceof PreferPrimaryDestinationConnectionStrategy )  {  return   (  ( PreferPrimaryDestinationConnectionStrategy ) connectionStrategy ) . getSecondaryConnectionTTL  ( ) ; }  return null ; }  void setAcceptConnectionTimeout  (   int acceptConnectionTimeout )  {    this . acceptConnectionTimeout = acceptConnectionTimeout ; }   public  int getWriteBufferSize  ( )  {  return writeBufferSize ; }   public void setWriteBufferSize  (   int writeBufferSize )  {    this . writeBufferSize = writeBufferSize ; }   public  int getQueueSize  ( )  {  return  getRingBufferSize  ( ) ; }   public void setQueueSize  (   int queueSize )  {   setRingBufferSize  ( queueSize ) ; }   public SSLConfiguration getSsl  ( )  {  return sslConfiguration ; }   public void setSsl  (  SSLConfiguration sslConfiguration )  {    this . sslConfiguration = sslConfiguration ; }   public Duration getKeepAliveDuration  ( )  {  return keepAliveDuration ; }   public void setKeepAliveDuration  (  Duration keepAliveDuration )  {    this . keepAliveDuration = keepAliveDuration ; }   public String getKeepAliveMessage  ( )  {  return keepAliveMessage ; }   public void setKeepAliveMessage  (  String keepAliveMessage )  {    this . keepAliveMessage =  SeparatorParser . parseSeparator  ( keepAliveMessage ) ; }   public boolean isKeepAliveEnabled  ( )  {  return    this . keepAliveDuration != null &&   this . keepAliveMessage != null ; }   public boolean isWriteTimeoutEnabled  ( )  {  return    this . writeTimeout . getMilliseconds  ( ) > 0 ; }   public Charset getKeepAliveCharset  ( )  {  return keepAliveCharset ; }   public void setKeepAliveCharset  (  Charset keepAliveCharset )  {    this . keepAliveCharset = keepAliveCharset ; }    @ Override public void setThreadNameFormat  (  String threadNameFormat )  {   super . setThreadNameFormat  ( threadNameFormat ) ; }   public DestinationConnectionStrategy getConnectionStrategy  ( )  {  return connectionStrategy ; }    @ DefaultClass  (  DelegateDestinationConnectionStrategy . class ) public void setConnectionStrategy  (  DestinationConnectionStrategy destinationConnectionStrategy )  {    this . connectionStrategy = destinationConnectionStrategy ; }   public  Optional  < InetSocketAddress > getConnectedDestination  ( )  {  return  Optional . ofNullable  (  this . connectedDestination ) ; }   public Duration getWriteTimeout  ( )  {  return writeTimeout ; }   public void setWriteTimeout  (  Duration writeTimeout )  {    this . writeTimeout =   writeTimeout == null ?  new Duration  ( DEFAULT_WRITE_TIMEOUT ) : writeTimeout ; } }