  package    net . logstash . logback . encoder ;   import   java . io . IOException ;  import   java . io . OutputStream ;  import    java . nio . charset . Charset ;  import     net . logstash . logback . composite . CompositeJsonFormatter ;  import     net . logstash . logback . composite . JsonProviders ;  import     net . logstash . logback . decorate . JsonFactoryDecorator ;  import     net . logstash . logback . decorate . JsonGeneratorDecorator ;  import     net . logstash . logback . util . ReusableByteBuffer ;  import     net . logstash . logback . util . ReusableByteBuffers ;  import      ch . qos . logback . core . encoder . Encoder ;  import      ch . qos . logback . core . encoder . EncoderBase ;  import      ch . qos . logback . core . encoder . LayoutWrappingEncoder ;  import      ch . qos . logback . core . pattern . PatternLayoutBase ;  import      ch . qos . logback . core . spi . DeferredProcessingAware ;   public abstract class CompositeJsonEncoder  <  Event  extends DeferredProcessingAware >  extends  EncoderBase  < Event >  implements   StreamingEncoder  < Event >  {   private static final   byte  [ ]  EMPTY_BYTES =  new  byte  [ 0 ] ;   private  int  minBufferSize = 1024 ;   private ReusableByteBuffers  bufferPool ;   private  Encoder  < Event >  prefix ;   private  Encoder  < Event >  suffix ;   private final  CompositeJsonFormatter  < Event >  formatter ;   private String  lineSeparator =  System . lineSeparator  ( ) ;   private   byte  [ ]  lineSeparatorBytes ;   private Charset  charset ;   public CompositeJsonEncoder  ( )  {  super  ( ) ;    this . formatter =  createFormatter  ( ) ; }   protected abstract  CompositeJsonFormatter  < Event > createFormatter  ( ) ;    @ Override public void encode  (  Event event ,  OutputStream outputStream )  throws IOException  {  if  (  !  isStarted  ( ) )  {  throw  new IllegalStateException  ( "Encoder is not started" ) ; }   encode  ( prefix , event , outputStream ) ;   formatter . writeEventToOutputStream  ( event , outputStream ) ;   encode  ( suffix , event , outputStream ) ;   outputStream . write  ( lineSeparatorBytes ) ; }    @ Override public   byte  [ ] encode  (  Event event )  {  if  (  !  isStarted  ( ) )  {  throw  new IllegalStateException  ( "Encoder is not started" ) ; }  ReusableByteBuffer  buffer =  bufferPool . getBuffer  ( ) ;  try  {   encode  ( event , buffer ) ;  return  buffer . toByteArray  ( ) ; }  catch (   IOException e )  {   addWarn  (  "Error encountered while encoding log event. Event: " + event , e ) ;  return EMPTY_BYTES ; }  finally  {   bufferPool . releaseBuffer  ( buffer ) ; } }   private void encode  (   Encoder  < Event > encoder ,  Event event ,  OutputStream outputStream )  throws IOException  {  if  (  encoder != null )  {    byte  [ ]  data =  encoder . encode  ( event ) ;  if  (  data != null )  {   outputStream . write  ( data ) ; } } }    @ Override public void start  ( )  {  if  (  isStarted  ( ) )  {  return ; }   super . start  ( ) ;    this . bufferPool =  new ReusableByteBuffers  (  this . minBufferSize ) ;   formatter . setContext  (  getContext  ( ) ) ;   formatter . start  ( ) ;   charset =  Charset . forName  (  formatter . getEncoding  ( ) ) ;   lineSeparatorBytes =    this . lineSeparator == null ? EMPTY_BYTES :   this . lineSeparator . getBytes  ( charset ) ;   startWrapped  ( prefix ) ;   startWrapped  ( suffix ) ; }    @ SuppressWarnings  (  { "unchecked" , "rawtypes" } ) private void startWrapped  (   Encoder  < Event > wrapped )  {  if  (  wrapped instanceof LayoutWrappingEncoder )  {   LayoutWrappingEncoder  < Event >  layoutWrappedEncoder =  (  LayoutWrappingEncoder  < Event > ) wrapped ;   layoutWrappedEncoder . setCharset  ( charset ) ;  if  (   layoutWrappedEncoder . getLayout  ( ) instanceof PatternLayoutBase )  {  PatternLayoutBase  layout =  ( PatternLayoutBase )  layoutWrappedEncoder . getLayout  ( ) ;   layout . setPostCompileProcessor  ( null ) ;   layout . start  ( ) ; } }  if  (   wrapped != null &&  !  wrapped . isStarted  ( ) )  {   wrapped . start  ( ) ; } }    @ Override public void stop  ( )  {  if  (  isStarted  ( ) )  {   super . stop  ( ) ;   formatter . stop  ( ) ;   stopWrapped  ( prefix ) ;   stopWrapped  ( suffix ) ; } }   private void stopWrapped  (   Encoder  < Event > wrapped )  {  if  (   wrapped != null &&  wrapped . isStarted  ( ) )  {   wrapped . stop  ( ) ; } }    @ Override public   byte  [ ] headerBytes  ( )  {  return EMPTY_BYTES ; }    @ Override public   byte  [ ] footerBytes  ( )  {  return EMPTY_BYTES ; }   public  JsonProviders  < Event > getProviders  ( )  {  return  formatter . getProviders  ( ) ; }   public void setProviders  (   JsonProviders  < Event > jsonProviders )  {   formatter . setProviders  ( jsonProviders ) ; }   public JsonFactoryDecorator getJsonFactoryDecorator  ( )  {  return  formatter . getJsonFactoryDecorator  ( ) ; }   public void setJsonFactoryDecorator  (  JsonFactoryDecorator jsonFactoryDecorator )  {   formatter . setJsonFactoryDecorator  ( jsonFactoryDecorator ) ; }   public JsonGeneratorDecorator getJsonGeneratorDecorator  ( )  {  return  formatter . getJsonGeneratorDecorator  ( ) ; }   public String getEncoding  ( )  {  return  formatter . getEncoding  ( ) ; }   public void setEncoding  (  String encodingName )  {   formatter . setEncoding  ( encodingName ) ; }   public void setFindAndRegisterJacksonModules  (  boolean findAndRegisterJacksonModules )  {   formatter . setFindAndRegisterJacksonModules  ( findAndRegisterJacksonModules ) ; }   public void setJsonGeneratorDecorator  (  JsonGeneratorDecorator jsonGeneratorDecorator )  {   formatter . setJsonGeneratorDecorator  ( jsonGeneratorDecorator ) ; }   public String getLineSeparator  ( )  {  return lineSeparator ; }   public void setLineSeparator  (  String lineSeparator )  {    this . lineSeparator =  SeparatorParser . parseSeparator  ( lineSeparator ) ; }   public  int getMinBufferSize  ( )  {  return minBufferSize ; }   public void setMinBufferSize  (   int minBufferSize )  {    this . minBufferSize = minBufferSize ; }   protected  CompositeJsonFormatter  < Event > getFormatter  ( )  {  return formatter ; }   public  Encoder  < Event > getPrefix  ( )  {  return prefix ; }   public void setPrefix  (   Encoder  < Event > prefix )  {    this . prefix = prefix ; }   public  Encoder  < Event > getSuffix  ( )  {  return suffix ; }   public void setSuffix  (   Encoder  < Event > suffix )  {    this . suffix = suffix ; } }