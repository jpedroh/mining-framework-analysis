  package silvertip ;   import   java . io . IOException ;  import    java . nio . channels . SelectionKey ;  import    java . nio . channels . Selector ;  import   java . util . ArrayList ;  import   java . util . Iterator ;  import   java . util . List ;  import    java . util . concurrent . TimeUnit ;   public class Events  {   private  List  < EventSource >  sources =  new  ArrayList  < EventSource >  ( ) ;   private Selector  selector ;   private boolean  stopped ;   public static Events open  ( )  throws IOException  {  return  new Events  (  Selector . open  ( ) ) ; }   public Events  (  Selector selector )  {    this . selector = selector ; }   public void register  (  EventSource source )  throws IOException  {  SelectionKey  result =  source . register  ( selector ,  SelectionKey . OP_READ ) ;   result . attach  ( source ) ;   sources . add  ( source ) ; }   public void dispatch  (   long timeout )  throws IOException  {  while  (  !  isStopped  ( ) )  {  if  (  !  process  ( timeout ) )  break ; } }   public boolean process  (   long timeout )  throws IOException  {  while  (  timeout > 0 )  {   long  start =  System . nanoTime  ( ) ;   int  numKeys =  selector . select  ( timeout ) ;   long  end =  System . nanoTime  ( ) ;   unregisterClosed  ( ) ;  if  (   selector . keys  ( ) . isEmpty  ( ) )  return false ;  if  (  numKeys > 0 )  {   dispatchMessages  ( ) ;  break ; }   timeout -=   TimeUnit . NANOSECONDS . toMillis  (  end - start ) ;  if  (  timeout <= 0 )  {   timeout  ( ) ;  break ; } }  return true ; }   public boolean processNow  ( )  throws IOException  {   int  numKeys =  selector . selectNow  ( ) ;   unregisterClosed  ( ) ;  if  (   selector . keys  ( ) . isEmpty  ( ) )  return false ;  if  (  numKeys > 0 )   dispatchMessages  ( ) ;  return true ; }   public boolean isStopped  ( )  {  return stopped ; }   private void unregisterClosed  ( )  {   Iterator  < EventSource >  it =  sources . iterator  ( ) ;  while  (  it . hasNext  ( ) )  {  EventSource  source =  it . next  ( ) ;  if  (  source . isClosed  ( ) )  {   source . unregister  ( ) ;   it . remove  ( ) ; } } }   private void timeout  ( )  {   Iterator  < EventSource >  it =  sources . iterator  ( ) ;  while  (  it . hasNext  ( ) )  {  EventSource  source =  it . next  ( ) ;   source . timeout  ( ) ; } }   private void dispatchMessages  ( )  throws IOException  {   List  < EventSource >  newSources =  new  ArrayList  < EventSource >  ( ) ;   Iterator  < SelectionKey >  it =   selector . selectedKeys  ( ) . iterator  ( ) ;  while  (  it . hasNext  ( ) )  {  SelectionKey  key =  it . next  ( ) ;  EventSource  source =  ( EventSource )  key . attachment  ( ) ;  if  (  key . isValid  ( ) )  {  if  (  key . isAcceptable  ( ) )  {  EventSource  newSource =  source . accept  ( key ) ;  if  (  newSource != null )   newSources . add  ( newSource ) ; else   key . cancel  ( ) ; }  if  (  key . isValid  ( ) )  {  if  (  key . isReadable  ( ) )   source . read  ( key ) ; else  if  (  key . isWritable  ( ) )   source . write  ( key ) ; } else  if  (  key . isWritable  ( ) )   source . write  ( key ) ; }   it . remove  ( ) ; }  for ( EventSource source : newSources )   register  ( source ) ; }   public void stop  ( )  {   stopped = true ;   selector . wakeup  ( ) ; } }