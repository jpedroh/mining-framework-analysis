  package   bdv . viewer . state ;   import static    bdv . viewer . DisplayMode . FUSED ;  import static    bdv . viewer . DisplayMode . SINGLE ;  import static    bdv . viewer . Interpolation . NEARESTNEIGHBOR ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . List ;  import   java . util . SortedSet ;  import   java . util . TreeSet ;  import     bdv . tools . bookmarks . bookmark . Bookmark ;  import   bdv . util . MipmapTransforms ;  import   bdv . viewer . DisplayMode ;  import   bdv . viewer . Interpolation ;  import   bdv . viewer . Source ;  import   bdv . viewer . SourceAndConverter ;  import    net . imglib2 . realtransform . AffineTransform3D ;   public class ViewerState  {   private final  ArrayList  <  SourceState  <  ? > >  sources ;   private final  List  <  SourceState  <  ? > >  unmodifiableSources ;   private final  ArrayList  < SourceGroup >  groups ;   private final  List  < SourceGroup >  unmodifiableGroups ;   private  int  numTimepoints ;   private Bookmark  activeBookmark ;   private final AffineTransform3D  viewerTransform ;   private Interpolation  interpolation ;   private DisplayMode  displayMode ;   private  int  currentSource ;   private  int  currentGroup ;   private  int  currentTimepoint ;   public ViewerState  (   final  List  <  SourceAndConverter  <  ? > > sources ,   final  List  < SourceGroup > sourceGroups ,   final  int numTimePoints )  {    this . sources =  new  ArrayList  < >  (  sources . size  ( ) ) ;  for (  final  SourceAndConverter  <  ? > source : sources )    this . sources . add  (  SourceState . create  ( source , this ) ) ;   unmodifiableSources =  Collections . unmodifiableList  (  this . sources ) ;   groups =   (  sourceGroups == null ) ?  new  ArrayList  < >  ( ) :  new  ArrayList  < >  ( sourceGroups ) ;   unmodifiableGroups =  Collections . unmodifiableList  (  this . groups ) ;    this . numTimepoints = numTimePoints ;   viewerTransform =  new AffineTransform3D  ( ) ;   interpolation = NEARESTNEIGHBOR ;   displayMode = SINGLE ;   currentSource =   sources . isEmpty  ( ) ?  - 1 : 0 ;   currentGroup =   groups . isEmpty  ( ) ?  - 1 : 0 ;   currentTimepoint = 0 ; }   protected ViewerState  (   final ViewerState s )  {   sources =  new  ArrayList  < >  (   s . sources . size  ( ) ) ;  for (  final  SourceState  <  ? > source :  s . sources )    this . sources . add  (  source . copy  ( this ) ) ;   unmodifiableSources =  Collections . unmodifiableList  ( sources ) ;   groups =  new  ArrayList  < >  (   s . groups . size  ( ) ) ;  for (  final SourceGroup group :  s . groups )   groups . add  (  group . copy  ( ) ) ;   unmodifiableGroups =  Collections . unmodifiableList  ( groups ) ;   numTimepoints =  s . numTimepoints ;   viewerTransform =   s . viewerTransform . copy  ( ) ;   interpolation =  s . interpolation ;   displayMode =  s . displayMode ;   currentSource =  s . currentSource ;   currentGroup =  s . currentGroup ;   currentTimepoint =  s . currentTimepoint ;  if  (   s . activeBookmark != null )   activeBookmark =   s . activeBookmark . copy  ( ) ; }   public synchronized ViewerState copy  ( )  {  return  new ViewerState  ( this ) ; }   public synchronized void getViewerTransform  (   final AffineTransform3D t )  {   t . set  ( viewerTransform ) ; }   public synchronized void setViewerTransform  (   final AffineTransform3D t )  {   viewerTransform . set  ( t ) ; }   public synchronized  int getCurrentSource  ( )  {  return currentSource ; }   public synchronized void setCurrentSource  (   final  int index )  {   final  int  minIndex =   sources . isEmpty  ( ) ?  - 1 : 0 ;  if  (   index >= minIndex &&  index <  sources . size  ( ) )  {    sources . get  ( currentSource ) . setCurrent  ( false ) ;   currentSource = index ;    sources . get  ( currentSource ) . setCurrent  ( true ) ; } }   public synchronized void setCurrentSource  (   final  Source  <  ? > source )  {   final  int  i =  getSourceIndex  ( source ) ;  if  (  i >= 0 )   setCurrentSource  ( i ) ; }   public synchronized  int getCurrentGroup  ( )  {  return currentGroup ; }   public synchronized void setCurrentGroup  (   final  int index )  {  if  (   index >= 0 &&  index <  groups . size  ( ) )  {    groups . get  ( currentGroup ) . setCurrent  ( false ) ;   currentGroup = index ;    groups . get  ( currentGroup ) . setCurrent  ( true ) ; } }   public synchronized Interpolation getInterpolation  ( )  {  return interpolation ; }   public synchronized void setInterpolation  (   final Interpolation method )  {   interpolation = method ; }   public synchronized  @ Deprecated boolean isSingleSourceMode  ( )  {  return  displayMode == SINGLE ; }   public synchronized  @ Deprecated void setSingleSourceMode  (   final boolean singleSourceMode )  {  if  ( singleSourceMode )   setDisplayMode  ( SINGLE ) ; else   setDisplayMode  ( FUSED ) ; }   public synchronized void setDisplayMode  (   final DisplayMode mode )  {   displayMode = mode ; }   public synchronized DisplayMode getDisplayMode  ( )  {  return displayMode ; }   public synchronized  int getCurrentTimepoint  ( )  {  return currentTimepoint ; }   public synchronized void setCurrentTimepoint  (   final  int timepoint )  {   currentTimepoint = timepoint ; }   public synchronized Bookmark getActiveBookmark  ( )  {  return activeBookmark ; }   public synchronized void setActiveBookmark  (   final Bookmark bookmark )  {   activeBookmark = bookmark ; }   public  List  <  SourceState  <  ? > > getSources  ( )  {  return unmodifiableSources ; }   public  int numSources  ( )  {  return  sources . size  ( ) ; }   public  List  < SourceGroup > getSourceGroups  ( )  {  return unmodifiableGroups ; }   public  int numSourceGroups  ( )  {  return  groups . size  ( ) ; }   public synchronized void addSource  (   final  SourceAndConverter  <  ? > source )  {   sources . add  (  SourceState . create  ( source , this ) ) ;  if  (  currentSource < 0 )   currentSource = 0 ; }   public synchronized void removeSource  (   final  Source  <  ? > source )  {  for (   int  i = 0 ;  i <  sources . size  ( ) ; )  {   final  SourceState  <  ? >  s =  sources . get  ( i ) ;  if  (   s . getSpimSource  ( ) == source )   removeSource  ( i ) ; else   i ++ ; } }   protected void removeSource  (   final  int index )  {   sources . remove  ( index ) ;  if  (  sources . isEmpty  ( ) )   currentSource =  - 1 ; else  if  (  currentSource == index )   currentSource = 0 ; else  if  (  currentSource > index )   -- currentSource ;  for (  final SourceGroup group : groups )  {   final  SortedSet  < Integer >  ids =  group . getSourceIds  ( ) ;   final  ArrayList  < Integer >  oldids =  new  ArrayList  < >  ( ids ) ;   ids . clear  ( ) ;  for (  final  int id : oldids )  {  if  (  id < index )   ids . add  ( id ) ; else  if  (  id > index )   ids . add  (  id - 1 ) ; } } }   public synchronized boolean isSourceVisible  (   final  int index )  {  switch  ( displayMode )  {   case SINGLE :  return   (  index == currentSource ) &&  isPresent  ( index ) ;   case GROUP :  return     groups . get  ( currentGroup ) . getSourceIds  ( ) . contains  ( index ) &&  isPresent  ( index ) ;   case FUSED :  return    sources . get  ( index ) . isActive  ( ) &&  isPresent  ( index ) ;   case FUSEDGROUP :   default :  for (  final SourceGroup group : groups )  if  (    group . isActive  ( ) &&   group . getSourceIds  ( ) . contains  ( index ) &&  isPresent  ( index ) )  return true ;  return false ; } }   private boolean isPresent  (   final  int sourceId )  {  return    sources . get  ( sourceId ) . getSpimSource  ( ) . isPresent  ( currentTimepoint ) ; }   public synchronized  List  < Integer > getVisibleSourceIndices  ( )  {   final  ArrayList  < Integer >  visible =  new  ArrayList  < >  ( ) ;  switch  ( displayMode )  {   case SINGLE :  if  (   currentSource >= 0 &&  isPresent  ( currentSource ) )   visible . add  ( currentSource ) ;  break ;   case GROUP :  for (  final  int sourceId :   groups . get  ( currentGroup ) . getSourceIds  ( ) )  if  (  isPresent  ( sourceId ) )   visible . add  ( sourceId ) ;  break ;   case FUSED :  for (   int  i = 0 ;  i <  sources . size  ( ) ;  ++ i )  if  (    sources . get  ( i ) . isActive  ( ) &&  isPresent  ( i ) )   visible . add  ( i ) ;  break ;   case FUSEDGROUP :   final  TreeSet  < Integer >  gactive =  new  TreeSet  < >  ( ) ;  for (  final SourceGroup group : groups )  if  (  group . isActive  ( ) )   gactive . addAll  (  group . getSourceIds  ( ) ) ;  for (  final  int sourceId :  new  ArrayList  < >  ( gactive ) )  if  (  isPresent  ( sourceId ) )   visible . add  ( sourceId ) ;  break ; }  return visible ; }   public synchronized  int getBestMipMapLevel  (   final AffineTransform3D screenScaleTransform ,   final  int sourceIndex )  {   final AffineTransform3D  screenTransform =  new AffineTransform3D  ( ) ;   getViewerTransform  ( screenTransform ) ;   screenTransform . preConcatenate  ( screenScaleTransform ) ;   final  Source  <  ? >  source =   sources . get  ( sourceIndex ) . getSpimSource  ( ) ;  return  MipmapTransforms . getBestMipMapLevel  ( screenTransform , source , currentTimepoint ) ; }   public synchronized  int getNumTimepoints  ( )  {  return numTimepoints ; }   public synchronized void setNumTimepoints  (   final  int numTimepoints )  {    this . numTimepoints = numTimepoints ; }   public void kill  ( )  {   sources . clear  ( ) ;   groups . clear  ( ) ; }   private  int getSourceIndex  (   final  Source  <  ? > source )  {  for (   int  i = 0 ;  i <  sources . size  ( ) ;  ++ i )  {   final  SourceState  <  ? >  s =  sources . get  ( i ) ;  if  (   s . getSpimSource  ( ) == source )  return i ; }  return  - 1 ; }   public ViewerState  (   final  List  <  SourceAndConverter  <  ? > > sources ,   final  int numTimePoints )  {  this  ( sources , null , numTimePoints ) ; }   public synchronized void setCurrentGroup  (   final SourceGroup group )  {   final  int  i =  getGroupIndex  ( group ) ;  if  (  i >= 0 )   setCurrentGroup  ( i ) ; }   public synchronized void addGroup  (   final SourceGroup group )  {  if  (  !  groups . contains  ( group ) )  {   groups . add  ( group ) ;  if  (  currentGroup < 0 )   currentGroup = 0 ; } }   public synchronized void removeGroup  (   final SourceGroup group )  {   final  int  i =  groups . indexOf  ( group ) ;  if  (  i >= 0 )   removeGroup  ( i ) ; }   protected void removeGroup  (   final  int index )  {   groups . remove  ( index ) ;  if  (  groups . isEmpty  ( ) )   currentGroup =  - 1 ; else  if  (  currentGroup == index )   currentGroup = 0 ; else  if  (  currentGroup > index )   -- currentGroup ; }   private  int getGroupIndex  (   final SourceGroup group )  {  return  groups . indexOf  ( group ) ; } }