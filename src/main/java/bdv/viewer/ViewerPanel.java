  package  bdv . viewer ;   import static     bdv . viewer . VisibilityAndGrouping . Event . CURRENT_SOURCE_CHANGED ;  import static     bdv . viewer . VisibilityAndGrouping . Event . DISPLAY_MODE_CHANGED ;  import static     bdv . viewer . VisibilityAndGrouping . Event . GROUP_ACTIVITY_CHANGED ;  import static     bdv . viewer . VisibilityAndGrouping . Event . GROUP_NAME_CHANGED ;  import static     bdv . viewer . VisibilityAndGrouping . Event . NUM_SOURCES_CHANGED ;  import static     bdv . viewer . VisibilityAndGrouping . Event . SOURCE_ACTVITY_CHANGED ;  import static     bdv . viewer . VisibilityAndGrouping . Event . VISIBILITY_CHANGED ;  import   java . awt . BorderLayout ;  import   java . awt . Color ;  import   java . awt . Component ;  import   java . awt . Dimension ;  import   java . awt . Font ;  import   java . awt . Graphics ;  import   java . awt . Graphics2D ;  import    java . awt . event . ActionEvent ;  import    java . awt . event . ActionListener ;  import    java . awt . event . ComponentAdapter ;  import    java . awt . event . ComponentEvent ;  import    java . awt . event . MouseEvent ;  import    java . awt . event . MouseListener ;  import    java . awt . event . MouseMotionListener ;  import    java . lang . reflect . InvocationTargetException ;  import   java . util . ArrayList ;  import   java . util . List ;  import    java . util . concurrent . CopyOnWriteArrayList ;  import    java . util . concurrent . ExecutorService ;  import    java . util . concurrent . Executors ;  import    java . util . concurrent . ScheduledExecutorService ;  import    java . util . concurrent . ThreadFactory ;  import     java . util . concurrent . atomic . AtomicInteger ;  import   javax . swing . Action ;  import   javax . swing . ActionMap ;  import   javax . swing . Box ;  import   javax . swing . BoxLayout ;  import   javax . swing . DefaultBoundedRangeModel ;  import   javax . swing . JButton ;  import   javax . swing . JPanel ;  import   javax . swing . JSlider ;  import   javax . swing . Timer ;  import    javax . swing . border . EmptyBorder ;  import    javax . swing . event . ChangeEvent ;  import    javax . swing . event . ChangeListener ;  import   org . jdom2 . Element ;  import  bdv . BigDataViewerActions ;  import   bdv . cache . CacheControl ;  import     bdv . tools . bookmarks . bookmark . Bookmark ;  import     bdv . tools . bookmarks . bookmark . DynamicBookmark ;  import   bdv . util . Affine3DHelpers ;  import   bdv . util . InvokeOnEDT ;  import   bdv . util . Prefs ;  import    bdv . viewer . animate . AbstractTransformAnimator ;  import    bdv . viewer . animate . MessageOverlayAnimator ;  import    bdv . viewer . animate . OverlayAnimator ;  import    bdv . viewer . animate . RotationAnimator ;  import    bdv . viewer . animate . TextOverlayAnimator ;  import     bdv . viewer . animate . TextOverlayAnimator . TextPosition ;  import    bdv . viewer . overlay . MultiBoxOverlayRenderer ;  import    bdv . viewer . overlay . ScaleBarOverlayRenderer ;  import    bdv . viewer . overlay . SourceInfoOverlayRenderer ;  import    bdv . viewer . render . MultiResolutionRenderer ;  import    bdv . viewer . render . TransformAwareBufferedImageOverlayRenderer ;  import    bdv . viewer . state . SourceGroup ;  import    bdv . viewer . state . SourceState ;  import    bdv . viewer . state . ViewerState ;  import    bdv . viewer . state . XmlIoViewerState ;  import   net . imglib2 . Positionable ;  import   net . imglib2 . RealLocalizable ;  import   net . imglib2 . RealPoint ;  import   net . imglib2 . RealPositionable ;  import    net . imglib2 . realtransform . AffineTransform3D ;  import    net . imglib2 . ui . InteractiveDisplayCanvasComponent ;  import    net . imglib2 . ui . OverlayRenderer ;  import    net . imglib2 . ui . PainterThread ;  import    net . imglib2 . ui . TransformEventHandler ;  import    net . imglib2 . ui . TransformListener ;  import    net . imglib2 . util . LinAlgHelpers ;  import static     bdv . viewer . VisibilityAndGrouping . Event . NUM_GROUPS_CHANGED ;   public class ViewerPanel  extends JPanel  implements  OverlayRenderer ,  TransformListener  < AffineTransform3D > ,  PainterThread . Paintable ,  VisibilityAndGrouping . UpdateListener , RequestRepaint  {   private static final  long  serialVersionUID = 1L ;   protected final ViewerState  state ;   protected final MultiResolutionRenderer  imageRenderer ;   protected final TransformAwareBufferedImageOverlayRenderer  renderTarget ;   protected final MultiBoxOverlayRenderer  multiBoxOverlayRenderer ;   protected final SourceInfoOverlayRenderer  sourceInfoOverlayRenderer ;   protected final ScaleBarOverlayRenderer  scaleBarOverlayRenderer ;   protected final AffineTransform3D  viewerTransform ;   protected final  InteractiveDisplayCanvasComponent  < AffineTransform3D >  display ;   protected final JSlider  timeSlider ;   protected ThreadGroup  threadGroup ;   protected final PainterThread  painterThread ;   protected final ExecutorService  renderingExecutorService ;   protected final MouseCoordinateListener  mouseCoordinates ;   protected final VisibilityAndGrouping  visibilityAndGrouping ;   protected final  CopyOnWriteArrayList  <  TransformListener  < AffineTransform3D > >  transformListeners ;   protected final  CopyOnWriteArrayList  <  TransformListener  < AffineTransform3D > >  lastRenderTransformListeners ;   protected final  CopyOnWriteArrayList  < TimePointListener >  timePointListeners ;   protected AbstractTransformAnimator  currentAnimator = null ;   protected final  ArrayList  < OverlayAnimator >  overlayAnimators ;   protected final MessageOverlayAnimator  msgOverlay ;   protected final  ViewerOptions . Values  options ;   protected final JButton  previousKeyframeButton ;   protected final JButton  addKeyframeButton ;   protected final JButton  nextKeyframeButton ;   protected final  List  < ActiveBookmarkChangedListener >  activeBookmarkChangedListeners =  new  ArrayList  < >  ( ) ;   protected final ScheduledExecutorService  scheduledExecutorService =  Executors . newSingleThreadScheduledExecutor  ( ) ;   protected final Timer  playTimer =  new Timer  ( 0 ,  this :: onPlayTimerTick ) ;   protected final ActionMap  actionMap ;   public ViewerPanel  (   final  List  <  SourceAndConverter  <  ? > > sources ,   final  int numTimePoints ,   final CacheControl cacheControl ,   final ActionMap actionMap )  {  this  ( sources , numTimePoints , cacheControl ,  ViewerOptions . options  ( ) , actionMap ) ; }   public ViewerPanel  (   final  List  <  SourceAndConverter  <  ? > > sources ,   final  int numTimepoints ,   final CacheControl cacheControl ,   final ViewerOptions optional ,   final ActionMap actionMap )  {  super  (  new BorderLayout  ( ) , false ) ;   setPreferredSize  (  new Dimension  ( 600 , 500 ) ) ;   options =  optional . values ;    this . actionMap = actionMap ;   final  int  numGroups = 10 ;   final  ArrayList  < SourceGroup >  groups =  new  ArrayList  < >  ( numGroups ) ;  for (   int  i = 0 ;  i < numGroups ;  ++ i )   groups . add  (  new SourceGroup  (  "group " +  Integer . toString  (  i + 1 ) , null ) ) ;   state =  new ViewerState  ( sources , groups , numTimepoints ) ;  for (   int  i =   Math . min  ( numGroups ,  sources . size  ( ) ) - 1 ;  i >= 0 ;  -- i )     state . getSourceGroups  ( ) . get  ( i ) . addSource  ( i ) ;  if  (  !  sources . isEmpty  ( ) )   state . setCurrentSource  ( 0 ) ;   multiBoxOverlayRenderer =  new MultiBoxOverlayRenderer  ( ) ;   sourceInfoOverlayRenderer =  new SourceInfoOverlayRenderer  ( ) ;   scaleBarOverlayRenderer =   Prefs . showScaleBar  ( ) ?  new ScaleBarOverlayRenderer  ( ) : null ;   threadGroup =  new ThreadGroup  (  this . toString  ( ) ) ;   painterThread =  new PainterThread  ( threadGroup , this ) ;   viewerTransform =  new AffineTransform3D  ( ) ;   renderTarget =  new TransformAwareBufferedImageOverlayRenderer  ( ) ;   renderTarget . setCanvasSize  (  options . getWidth  ( ) ,  options . getHeight  ( ) ) ;   renderingExecutorService =  Executors . newFixedThreadPool  (  options . getNumRenderingThreads  ( ) ,  new RenderThreadFactory  ( ) ) ;   imageRenderer =  new MultiResolutionRenderer  ( renderTarget , painterThread ,  options . getScreenScales  ( ) ,  options . getTargetRenderNanos  ( ) ,  options . isDoubleBuffered  ( ) ,  options . getNumRenderingThreads  ( ) , renderingExecutorService ,  options . isUseVolatileIfAvailable  ( ) ,  options . getAccumulateProjectorFactory  ( ) , cacheControl ) ;   mouseCoordinates =  new MouseCoordinateListener  ( ) ;   display =  new  InteractiveDisplayCanvasComponent  < >  (  options . getWidth  ( ) ,  options . getHeight  ( ) ,  options . getTransformEventHandlerFactory  ( ) ) ;   add  ( display ,  BorderLayout . CENTER ) ;   display . addTransformListener  ( this ) ;   display . addOverlayRenderer  ( renderTarget ) ;   display . addOverlayRenderer  ( this ) ;   display . addHandler  ( mouseCoordinates ) ;   display . addComponentListener  (  new ComponentAdapter  ( )  {    @ Override public void componentResized  (   final ComponentEvent e )  {   requestRepaint  ( ) ;   display . removeComponentListener  ( this ) ; } } ) ;  JPanel  sliderPanel =  new JPanel  ( ) ;   sliderPanel . setLayout  (  new BoxLayout  ( sliderPanel ,  BoxLayout . X_AXIS ) ) ;   sliderPanel . add  (  Box . createRigidArea  (  new Dimension  ( 5 , 5 ) ) ) ;   previousKeyframeButton =  new JButton  ( "<<" ) ;   previousKeyframeButton . setToolTipText  ( "Go to previous keyframe" ) ;   previousKeyframeButton . addActionListener  (  new ActionListener  ( )  {    @ Override public void actionPerformed  (  ActionEvent e )  {   final Action  action =  actionMap . get  (  BigDataViewerActions . PREVIOUS_KEYFRAME ) ;  if  (  action != null )   action . actionPerformed  ( e ) ; } } ) ;   sliderPanel . add  ( previousKeyframeButton ) ;   sliderPanel . add  (  Box . createRigidArea  (  new Dimension  ( 5 , 5 ) ) ) ;   addKeyframeButton =  new JButton  ( "+" ) ;   addKeyframeButton . setToolTipText  ( "Add a new keyframe" ) ;   addKeyframeButton . addActionListener  (  new ActionListener  ( )  {    @ Override public void actionPerformed  (  ActionEvent e )  {   final Action  action =  actionMap . get  (  BigDataViewerActions . ADD_KEYFRAME ) ;  if  (  action != null )   action . actionPerformed  ( e ) ; } } ) ;   sliderPanel . add  ( addKeyframeButton ) ;   sliderPanel . add  (  Box . createRigidArea  (  new Dimension  ( 5 , 5 ) ) ) ;   nextKeyframeButton =  new JButton  ( ">>" ) ;   nextKeyframeButton . setToolTipText  ( "Go to next keyframe" ) ;   nextKeyframeButton . addActionListener  (  new ActionListener  ( )  {    @ Override public void actionPerformed  (  ActionEvent e )  {   final Action  action =  actionMap . get  (  BigDataViewerActions . NEXT_KEYFRAME ) ;  if  (  action != null )   action . actionPerformed  ( e ) ; } } ) ;   sliderPanel . add  ( nextKeyframeButton ) ;   sliderPanel . add  (  Box . createRigidArea  (  new Dimension  ( 5 , 5 ) ) ) ;   sliderPlay =  new JPlaySlider  ( ) ;   sliderPlay . setPreferredSize  (  new Dimension  ( 200 , 50 ) ) ;   sliderPlay . setMinimumSize  (  new Dimension  ( 200 , 50 ) ) ;   sliderPlay . setMaximumSize  (  new Dimension  ( 200 , 50 ) ) ;   sliderPlay . setAlignmentX  (  Component . LEFT_ALIGNMENT ) ;   sliderPanel . add  ( sliderPlay ) ;   sliderPlay . addChangeListener  (  new ChangeListener  ( )  {    @ Override public void stateChanged  (   final ChangeEvent e )  {  if  (   sliderPlay . getValue  ( ) == 0 )  {   stopPlayExecuter  ( ) ;  return ; }   final  int  periode =  1000 /  (  1 *  Math . abs  (  sliderPlay . getValue  ( ) ) ) ;   playTimer . setDelay  ( periode ) ;   playTimer . start  ( ) ; } } ) ;   sliderPlay . addComponentListener  (  new ComponentAdapter  ( )  {    @ Override public void componentHidden  (  ComponentEvent e )  {   stopPlayExecuter  ( ) ; } } ) ;   rigidArea =  Box . createRigidArea  (  new Dimension  ( 5 , 5 ) ) ;   sliderPanel . add  ( rigidArea ) ;   timeKeyframePanel =  new JPanel  ( ) ;   timeKeyframePanel . setBorder  (  new EmptyBorder  ( 5 , 0 , 5 , 0 ) ) ;   sliderPanel . add  ( timeKeyframePanel ) ;   timeKeyframePanel . setLayout  (  new BoxLayout  ( timeKeyframePanel ,  BoxLayout . Y_AXIS ) ) ;   timeSlider =  new JSlider  ( 0 ,  numTimepoints - 1 , 0 ) ;   timeSlider . setMinimumSize  (  new Dimension  ( 36 , 26 ) ) ;   timeSlider . setMaximumSize  (  new Dimension  ( 32767 , 26 ) ) ;   timeKeyframePanel . add  ( timeSlider ) ;   keyframePanel =  new JKeyFramePanel  ( timeSlider ) ;   timeKeyframePanel . add  ( keyframePanel ) ;   timeSlider . addChangeListener  (  new ChangeListener  ( )  {    @ Override public void stateChanged  (   final ChangeEvent e )  {  if  (   e . getSource  ( ) . equals  ( timeSlider ) )   setTimepoint  (  timeSlider . getValue  ( ) ) ; } } ) ;   add  ( display ,  BorderLayout . CENTER ) ;  if  (  numTimepoints > 1 )   add  ( sliderPanel ,  BorderLayout . SOUTH ) ;   visibilityAndGrouping =  new VisibilityAndGrouping  ( state ) ;   visibilityAndGrouping . addUpdateListener  ( this ) ;   transformListeners =  new  CopyOnWriteArrayList  < >  ( ) ;   lastRenderTransformListeners =  new  CopyOnWriteArrayList  < >  ( ) ;   timePointListeners =  new  CopyOnWriteArrayList  < >  ( ) ;   msgOverlay =  options . getMsgOverlay  ( ) ;   overlayAnimators =  new  ArrayList  < >  ( ) ;   overlayAnimators . add  ( msgOverlay ) ;   overlayAnimators . add  (  new TextOverlayAnimator  ( "Press <F1> for help." , 3000 ,  TextPosition . CENTER ) ) ;   display . addComponentListener  (  new ComponentAdapter  ( )  {    @ Override public void componentResized  (   final ComponentEvent e )  {   requestRepaint  ( ) ;   display . removeComponentListener  ( this ) ; } } ) ;   painterThread . start  ( ) ; }   public void stopPlayExecuter  ( )  {   playTimer . stop  ( ) ; }   private void onPlayTimerTick  (  ActionEvent event )  {   final  int  changeValue =  Integer . signum  (  sliderPlay . getValue  ( ) ) ;   final  int  newTimepoint =   state . getCurrentTimepoint  ( ) + changeValue ;   final  int  numTimepoints =  state . getNumTimepoints  ( ) ;  if  (  newTimepoint < 0 )  {   setTimepoint  ( 0 ) ;   stopPlayExecuter  ( ) ;   sliderPlay . setValue  ( 0 ) ; } else  if  (  newTimepoint >  numTimepoints - 1 )  {   setTimepoint  (  numTimepoints - 1 ) ;   stopPlayExecuter  ( ) ;   sliderPlay . setValue  ( 0 ) ; } else  {   setTimepoint  ( newTimepoint ) ; } }   public void setKeyframeButtonEnable  (  boolean enable )  {   previousKeyframeButton . setEnabled  ( enable ) ;   addKeyframeButton . setEnabled  ( enable ) ;   nextKeyframeButton . setEnabled  ( enable ) ; }   public KeyFramePopupMenu getKeyFramePopupMenu  ( )  {  return   this . keyframePanel . getKeyFramePopupMenuPopupMenu  ( ) ; }   public void addSource  (   final  SourceAndConverter  <  ? > sourceAndConverter )  {  synchronized  ( visibilityAndGrouping )  {   state . addSource  ( sourceAndConverter ) ;   visibilityAndGrouping . update  ( NUM_SOURCES_CHANGED ) ; }   requestRepaint  ( ) ; }   public void removeSource  (   final  Source  <  ? > source )  {  synchronized  ( visibilityAndGrouping )  {   state . removeSource  ( source ) ;   visibilityAndGrouping . update  ( NUM_SOURCES_CHANGED ) ; }   requestRepaint  ( ) ; }   public  <  P  extends RealLocalizable & RealPositionable > void displayToGlobalCoordinates  (   final   double  [ ] gPos )  {  assert   gPos . length >= 3 ;   viewerTransform . applyInverse  ( gPos , gPos ) ; }   public  <  P  extends RealLocalizable & RealPositionable > void displayToGlobalCoordinates  (   final P gPos )  {  assert   gPos . numDimensions  ( ) >= 3 ;   viewerTransform . applyInverse  ( gPos , gPos ) ; }   public void displayToGlobalCoordinates  (   final  double x ,   final  double y ,   final RealPositionable gPos )  {  assert   gPos . numDimensions  ( ) >= 3 ;   final RealPoint  lPos =  new RealPoint  ( 3 ) ;   lPos . setPosition  ( x , 0 ) ;   lPos . setPosition  ( y , 1 ) ;   viewerTransform . applyInverse  ( gPos , lPos ) ; }   public void getGlobalMouseCoordinates  (   final RealPositionable gPos )  {  assert   gPos . numDimensions  ( ) == 3 ;   final RealPoint  lPos =  new RealPoint  ( 3 ) ;   mouseCoordinates . getMouseCoordinates  ( lPos ) ;   viewerTransform . applyInverse  ( gPos , lPos ) ; }   public synchronized void getMouseCoordinates  (   final Positionable p )  {  assert   p . numDimensions  ( ) == 2 ;   mouseCoordinates . getMouseCoordinates  ( p ) ; }    @ Override public void paint  ( )  {   imageRenderer . paint  ( state ) ;   display . repaint  ( ) ;  synchronized  ( this )  {  if  (  currentAnimator != null )  {   final  TransformEventHandler  < AffineTransform3D >  handler =  display . getTransformEventHandler  ( ) ;   final AffineTransform3D  transform =  currentAnimator . getCurrent  (  System . currentTimeMillis  ( ) ) ;   handler . setTransform  ( transform ) ;   transformChanged  ( transform ) ;  if  (  currentAnimator . isComplete  ( ) )   currentAnimator = null ; } } }    @ Override public void requestRepaint  ( )  {   imageRenderer . requestRepaint  ( ) ; }    @ Override public void drawOverlays  (   final Graphics g )  {  boolean  requiresRepaint = false ;  if  (  Prefs . showMultibox  ( ) )  {   multiBoxOverlayRenderer . setViewerState  ( state ) ;   multiBoxOverlayRenderer . updateVirtualScreenSize  (  display . getWidth  ( ) ,  display . getHeight  ( ) ) ;   multiBoxOverlayRenderer . paint  (  ( Graphics2D ) g ) ;   requiresRepaint =  multiBoxOverlayRenderer . isHighlightInProgress  ( ) ; }  if  (  Prefs . showTextOverlay  ( ) )  {   sourceInfoOverlayRenderer . setViewerState  ( state ) ;   sourceInfoOverlayRenderer . paint  (  ( Graphics2D ) g ) ;   final RealPoint  gPos =  new RealPoint  ( 3 ) ;   getGlobalMouseCoordinates  ( gPos ) ;   final String  mousePosGlobalString =  String . format  ( "(%6.1f,%6.1f,%6.1f)" ,  gPos . getDoublePosition  ( 0 ) ,  gPos . getDoublePosition  ( 1 ) ,  gPos . getDoublePosition  ( 2 ) ) ;   g . setFont  (  new Font  ( "Monospaced" ,  Font . PLAIN , 12 ) ) ;   g . setColor  (  Color . white ) ;   g . drawString  ( mousePosGlobalString ,   (  int )   g . getClipBounds  ( ) . getWidth  ( ) - 170 , 25 ) ; }  if  (  Prefs . showScaleBar  ( ) )  {   scaleBarOverlayRenderer . setViewerState  ( state ) ;   scaleBarOverlayRenderer . paint  (  ( Graphics2D ) g ) ; }   final  long  currentTimeMillis =  System . currentTimeMillis  ( ) ;   final  ArrayList  < OverlayAnimator >  overlayAnimatorsToRemove =  new  ArrayList  < >  ( ) ;  for (  final OverlayAnimator animator : overlayAnimators )  {   animator . paint  (  ( Graphics2D ) g , currentTimeMillis ) ;   requiresRepaint |=  animator . requiresRepaint  ( ) ;  if  (  animator . isComplete  ( ) )   overlayAnimatorsToRemove . add  ( animator ) ; }   overlayAnimators . removeAll  ( overlayAnimatorsToRemove ) ;  if  ( requiresRepaint )   display . repaint  ( ) ; }    @ Override public synchronized void transformChanged  (   final AffineTransform3D transform )  {   viewerTransform . set  ( transform ) ;   state . setViewerTransform  ( transform ) ;  for (  final  TransformListener  < AffineTransform3D > l : transformListeners )   l . transformChanged  ( viewerTransform ) ;   requestRepaint  ( ) ; }    @ Override public void visibilityChanged  (   final  VisibilityAndGrouping . Event e )  {  switch  (  e . id )  {   case CURRENT_SOURCE_CHANGED :   multiBoxOverlayRenderer . highlight  (  visibilityAndGrouping . getCurrentSource  ( ) ) ;   display . repaint  ( ) ;  break ;   case DISPLAY_MODE_CHANGED :   showMessage  (   visibilityAndGrouping . getDisplayMode  ( ) . getName  ( ) ) ;   display . repaint  ( ) ;  break ;   case GROUP_NAME_CHANGED :   display . repaint  ( ) ;  break ;   case SOURCE_ACTVITY_CHANGED :  break ;   case GROUP_ACTIVITY_CHANGED :  break ;   case VISIBILITY_CHANGED :   requestRepaint  ( ) ;  break ; } }   private final static  double  c =  Math . cos  (   Math . PI / 4 ) ;   private Component  rigidArea ;   private JPlaySlider  sliderPlay ;   private Component  rigidArea_1 ;   private JPanel  timeKeyframePanel ;   private JKeyFramePanel  keyframePanel ;   public static enum AlignPlane  {  XY  ( "XY" , 2 ,  new  double  [ ]  { 1 , 0 , 0 , 0 } ) ,  ZY  ( "ZY" , 0 ,  new  double  [ ]  { c , 0 ,  - c , 0 } ) ,  XZ  ( "XZ" , 1 ,  new  double  [ ]  { c , c , 0 , 0 } )  ;   private final String  name ;   public String getName  ( )  {  return name ; }   private final   double  [ ]  qAlign ;   private final  int  coerceAffineDimension ;   private AlignPlane  (   final String name ,   final  int coerceAffineDimension ,   final   double  [ ] qAlign )  {    this . name = name ;    this . coerceAffineDimension = coerceAffineDimension ;    this . qAlign = qAlign ; } }   protected synchronized void align  (   final AlignPlane plane )  {   final  SourceState  <  ? >  source =   state . getSources  ( ) . get  (  state . getCurrentSource  ( ) ) ;   final AffineTransform3D  sourceTransform =  new AffineTransform3D  ( ) ;    source . getSpimSource  ( ) . getSourceTransform  (  state . getCurrentTimepoint  ( ) , 0 , sourceTransform ) ;   final   double  [ ]  qSource =  new  double  [ 4 ] ;   Affine3DHelpers . extractRotationAnisotropic  ( sourceTransform , qSource ) ;   final   double  [ ]  qTmpSource =  new  double  [ 4 ] ;   Affine3DHelpers . extractApproximateRotationAffine  ( sourceTransform , qSource ,  plane . coerceAffineDimension ) ;   LinAlgHelpers . quaternionMultiply  ( qSource ,  plane . qAlign , qTmpSource ) ;   final   double  [ ]  qTarget =  new  double  [ 4 ] ;   LinAlgHelpers . quaternionInvert  ( qTmpSource , qTarget ) ;   final AffineTransform3D  transform =   display . getTransformEventHandler  ( ) . getTransform  ( ) ;   double  centerX ;   double  centerY ;  if  (  mouseCoordinates . isMouseInsidePanel  ( ) )  {   centerX =  mouseCoordinates . getX  ( ) ;   centerY =  mouseCoordinates . getY  ( ) ; } else  {   centerY =   getHeight  ( ) / 2.0 ;   centerX =   getWidth  ( ) / 2.0 ; }   currentAnimator =  new RotationAnimator  ( transform , centerX , centerY , qTarget , 300 ) ;   currentAnimator . setTime  (  System . currentTimeMillis  ( ) ) ;   transformChanged  ( transform ) ; }   public synchronized void setTransformAnimator  (   final AbstractTransformAnimator animator )  {   currentAnimator = animator ;   currentAnimator . setTime  (  System . currentTimeMillis  ( ) ) ;   requestRepaint  ( ) ; }   public synchronized void toggleInterpolation  ( )  {   final  int  i =   state . getInterpolation  ( ) . ordinal  ( ) ;   final  int  n =   Interpolation . values  ( ) . length ;   final Interpolation  mode =   Interpolation . values  ( ) [   (  i + 1 ) % n ] ;   setInterpolation  ( mode ) ; }   public synchronized void setDisplayMode  (   final DisplayMode displayMode )  {   visibilityAndGrouping . setDisplayMode  ( displayMode ) ; }   public synchronized void setCurrentViewerTransform  (   final AffineTransform3D viewerTransform )  {    display . getTransformEventHandler  ( ) . setTransform  ( viewerTransform ) ;   transformChanged  ( viewerTransform ) ; }   public synchronized void setTimepoint  (   final  int timepoint )  {  if  (   state . getCurrentTimepoint  ( ) != timepoint )  {   state . setCurrentTimepoint  ( timepoint ) ;   timeSlider . setValue  ( timepoint ) ;  for (  final TimePointListener l : timePointListeners )   l . timePointChanged  ( timepoint ) ;   requestRepaint  ( ) ; } }   public synchronized void nextTimePoint  ( )  {  if  (   state . getNumTimepoints  ( ) > 1 )   timeSlider . setValue  (   timeSlider . getValue  ( ) + 1 ) ; }   public synchronized void previousTimePoint  ( )  {  if  (   state . getNumTimepoints  ( ) > 1 )   timeSlider . setValue  (   timeSlider . getValue  ( ) - 1 ) ; }   public void setNumTimepoints  (   final  int numTimepoints )  {  try  {   InvokeOnEDT . invokeAndWait  (   ( ) ->  setNumTimepointsSynchronized  ( numTimepoints ) ) ; }  catch (   InvocationTargetException | InterruptedException e )  {   e . printStackTrace  ( ) ; } }   private synchronized void setNumTimepointsSynchronized  (   final  int numTimepoints )  {  if  (   numTimepoints < 1 ||   state . getNumTimepoints  ( ) == numTimepoints )  return ; else  if  (   numTimepoints == 1 &&   state . getNumTimepoints  ( ) > 1 )   remove  ( timeSlider ) ; else  if  (   numTimepoints > 1 &&   state . getNumTimepoints  ( ) == 1 )   add  ( timeSlider ,  BorderLayout . SOUTH ) ;   state . setNumTimepoints  ( numTimepoints ) ;  if  (   state . getCurrentTimepoint  ( ) >= numTimepoints )  {   final  int  timepoint =  numTimepoints - 1 ;   state . setCurrentTimepoint  ( timepoint ) ;  for (  final TimePointListener l : timePointListeners )   l . timePointChanged  ( timepoint ) ; }   timeSlider . setModel  (  new DefaultBoundedRangeModel  (  state . getCurrentTimepoint  ( ) , 0 , 0 ,  numTimepoints - 1 ) ) ;   revalidate  ( ) ;   requestRepaint  ( ) ; }   public synchronized Bookmark getActiveBookmark  ( )  {  return  state . getActiveBookmark  ( ) ; }   public synchronized void setActiveBookmark  (   final Bookmark bookmark )  {  Bookmark  previousBookmark =   this . state . getActiveBookmark  ( ) ;    this . state . setActiveBookmark  ( bookmark ) ;   final boolean  enableKeyframeButtons =  bookmark instanceof DynamicBookmark ;   setKeyframeButtonEnable  ( enableKeyframeButtons ) ;  if  (  bookmark instanceof DynamicBookmark )  {   keyframePanel . setDynamicBookmarks  (  ( DynamicBookmark ) bookmark ) ; } else  {   keyframePanel . setDynamicBookmarks  ( null ) ; }  for ( ActiveBookmarkChangedListener l :  this . activeBookmarkChangedListeners )  {   l . activeBookmarkChanged  ( previousBookmark , bookmark ) ; }   display . repaint  ( ) ; }   public void addActiveBookmarkChangedListener  (  ActiveBookmarkChangedListener listener )  {   activeBookmarkChangedListeners . add  ( listener ) ; }   public void removeActiveBookmarkChangedListener  (  ActiveBookmarkChangedListener listener )  {   activeBookmarkChangedListeners . remove  ( listener ) ; }   public ViewerState getState  ( )  {  return  state . copy  ( ) ; }   public  InteractiveDisplayCanvasComponent  < AffineTransform3D > getDisplay  ( )  {  return display ; }   public void showMessage  (   final String msg )  {   msgOverlay . add  ( msg ) ;   display . repaint  ( ) ; }   public void addOverlayAnimator  (   final OverlayAnimator animator )  {   overlayAnimators . add  ( animator ) ;   display . repaint  ( ) ; }   public void addRenderTransformListener  (   final  TransformListener  < AffineTransform3D > listener )  {   renderTarget . addTransformListener  ( listener ) ; }   public void addRenderTransformListener  (   final  TransformListener  < AffineTransform3D > listener ,   final  int index )  {   renderTarget . addTransformListener  ( listener , index ) ; }   public void addTransformListener  (   final  TransformListener  < AffineTransform3D > listener )  {   addTransformListener  ( listener ,  Integer . MAX_VALUE ) ; }   public void addTransformListener  (   final  TransformListener  < AffineTransform3D > listener ,   final  int index )  {  synchronized  ( transformListeners )  {   final  int  s =  transformListeners . size  ( ) ;   transformListeners . add  (   index < 0 ? 0 :   index > s ? s : index , listener ) ;   listener . transformChanged  ( viewerTransform ) ; } }   public void removeTransformListener  (   final  TransformListener  < AffineTransform3D > listener )  {  synchronized  ( transformListeners )  {   transformListeners . remove  ( listener ) ; }   renderTarget . removeTransformListener  ( listener ) ; }   public void addTimePointListener  (   final TimePointListener listener )  {   addTimePointListener  ( listener ,  Integer . MAX_VALUE ) ; }   public void addTimePointListener  (   final TimePointListener listener ,   final  int index )  {  synchronized  ( timePointListeners )  {   final  int  s =  timePointListeners . size  ( ) ;   timePointListeners . add  (   index < 0 ? 0 :   index > s ? s : index , listener ) ;   listener . timePointChanged  (  state . getCurrentTimepoint  ( ) ) ; } }   public void removeTimePointListener  (   final TimePointListener listener )  {  synchronized  ( timePointListeners )  {   timePointListeners . remove  ( listener ) ; } }   protected class MouseCoordinateListener  implements  MouseMotionListener , MouseListener  {   private  int  x ;   private  int  y ;   private boolean  isInside ;   public synchronized void getMouseCoordinates  (   final Positionable p )  {   p . setPosition  ( x , 0 ) ;   p . setPosition  ( y , 1 ) ; }    @ Override public synchronized void mouseDragged  (   final MouseEvent e )  {   x =  e . getX  ( ) ;   y =  e . getY  ( ) ; }    @ Override public synchronized void mouseMoved  (   final MouseEvent e )  {   x =  e . getX  ( ) ;   y =  e . getY  ( ) ;   display . repaint  ( ) ; }   public synchronized  int getX  ( )  {  return x ; }   public synchronized  int getY  ( )  {  return y ; }   public synchronized boolean isMouseInsidePanel  ( )  {  return isInside ; }    @ Override public synchronized void mouseEntered  (   final MouseEvent e )  {   isInside = true ; }    @ Override public synchronized void mouseExited  (   final MouseEvent e )  {   isInside = false ; }    @ Override public void mouseClicked  (   final MouseEvent e )  { }    @ Override public void mousePressed  (   final MouseEvent e )  { }    @ Override public void mouseReleased  (   final MouseEvent e )  { } }   public synchronized Element stateToXml  ( )  {  return   new XmlIoViewerState  ( ) . toXml  ( state ) ; }   public synchronized void stateFromXml  (   final Element parent )  {   final XmlIoViewerState  io =  new XmlIoViewerState  ( ) ;   io . restoreFromXml  (  parent . getChild  (  io . getTagName  ( ) ) , state ) ; }    @ Override public void setCanvasSize  (   final  int width ,   final  int height )  { }   public VisibilityAndGrouping getVisibilityAndGrouping  ( )  {  return visibilityAndGrouping ; }   public  ViewerOptions . Values getOptionValues  ( )  {  return options ; }   public SourceInfoOverlayRenderer getSourceInfoOverlayRenderer  ( )  {  return sourceInfoOverlayRenderer ; }   public void stop  ( )  {   painterThread . interrupt  ( ) ;  try  {   painterThread . join  ( 0 ) ; }  catch (   final  InterruptedException e )  {   e . printStackTrace  ( ) ; }   renderingExecutorService . shutdown  ( ) ;   state . kill  ( ) ;   imageRenderer . kill  ( ) ; }   protected static final AtomicInteger  panelNumber =  new AtomicInteger  ( 1 ) ;   protected class RenderThreadFactory  implements  ThreadFactory  {   private final String  threadNameFormat =  String . format  ( "bdv-panel-%d-thread-%%d" ,  panelNumber . getAndIncrement  ( ) ) ;   private final AtomicInteger  threadNumber =  new AtomicInteger  ( 1 ) ;    @ Override public Thread newThread  (   final Runnable r )  {   final Thread  t =  new Thread  ( threadGroup , r ,  String . format  ( threadNameFormat ,  threadNumber . getAndIncrement  ( ) ) , 0 ) ;  if  (  t . isDaemon  ( ) )   t . setDaemon  ( false ) ;  if  (   t . getPriority  ( ) !=  Thread . NORM_PRIORITY )   t . setPriority  (  Thread . NORM_PRIORITY ) ;  return t ; } }   protected final  CopyOnWriteArrayList  < InterpolationModeListener >  interpolationModeListeners ; 
<<<<<<<
=======
  public ViewerPanel  (   final  List  <  SourceAndConverter  <  ? > > sources ,   final  int numTimepoints ,   final CacheControl cacheControl ,   final ViewerOptions optional )  {  super  (  new BorderLayout  ( ) , false ) ;   options =  optional . values ;   final  int  numGroups =  options . getNumSourceGroups  ( ) ;   final  ArrayList  < SourceGroup >  groups =  new  ArrayList  < >  ( numGroups ) ;  for (   int  i = 0 ;  i < numGroups ;  ++ i )   groups . add  (  new SourceGroup  (  "group " +  Integer . toString  (  i + 1 ) ) ) ;   state =  new ViewerState  ( sources , groups , numTimepoints ) ;  for (   int  i =   Math . min  ( numGroups ,  sources . size  ( ) ) - 1 ;  i >= 0 ;  -- i )     state . getSourceGroups  ( ) . get  ( i ) . addSource  ( i ) ;  if  (  !  sources . isEmpty  ( ) )   state . setCurrentSource  ( 0 ) ;   multiBoxOverlayRenderer =  new MultiBoxOverlayRenderer  ( ) ;   sourceInfoOverlayRenderer =  new SourceInfoOverlayRenderer  ( ) ;   scaleBarOverlayRenderer =   Prefs . showScaleBar  ( ) ?  new ScaleBarOverlayRenderer  ( ) : null ;   threadGroup =  new ThreadGroup  (  this . toString  ( ) ) ;   painterThread =  new PainterThread  ( threadGroup , this ) ;   viewerTransform =  new AffineTransform3D  ( ) ;   display =  new  InteractiveDisplayCanvasComponent  < >  (  options . getWidth  ( ) ,  options . getHeight  ( ) ,  options . getTransformEventHandlerFactory  ( ) ) ;   display . addTransformListener  ( this ) ;   renderTarget =  new TransformAwareBufferedImageOverlayRenderer  ( ) ;   renderTarget . setCanvasSize  (  options . getWidth  ( ) ,  options . getHeight  ( ) ) ;   display . addOverlayRenderer  ( renderTarget ) ;   display . addOverlayRenderer  ( this ) ;   renderingExecutorService =  Executors . newFixedThreadPool  (  options . getNumRenderingThreads  ( ) ,  new RenderThreadFactory  ( ) ) ;   imageRenderer =  new MultiResolutionRenderer  ( renderTarget , painterThread ,  options . getScreenScales  ( ) ,  options . getTargetRenderNanos  ( ) ,  options . isDoubleBuffered  ( ) ,  options . getNumRenderingThreads  ( ) , renderingExecutorService ,  options . isUseVolatileIfAvailable  ( ) ,  options . getAccumulateProjectorFactory  ( ) , cacheControl ) ;   mouseCoordinates =  new MouseCoordinateListener  ( ) ;   display . addHandler  ( mouseCoordinates ) ;   sliderTime =  new JSlider  (  SwingConstants . HORIZONTAL , 0 ,  numTimepoints - 1 , 0 ) ;   sliderTime . addChangeListener  (  new ChangeListener  ( )  {    @ Override public void stateChanged  (   final ChangeEvent e )  {  if  (   e . getSource  ( ) . equals  ( sliderTime ) )   setTimepoint  (  sliderTime . getValue  ( ) ) ; } } ) ;   add  ( display ,  BorderLayout . CENTER ) ;  if  (  numTimepoints > 1 )   add  ( sliderTime ,  BorderLayout . SOUTH ) ;   visibilityAndGrouping =  new VisibilityAndGrouping  ( state ) ;   visibilityAndGrouping . addUpdateListener  ( this ) ;   transformListeners =  new  CopyOnWriteArrayList  < >  ( ) ;   lastRenderTransformListeners =  new  CopyOnWriteArrayList  < >  ( ) ;   timePointListeners =  new  CopyOnWriteArrayList  < >  ( ) ;   interpolationModeListeners =  new  CopyOnWriteArrayList  < >  ( ) ;   msgOverlay =  options . getMsgOverlay  ( ) ;   overlayAnimators =  new  ArrayList  < >  ( ) ;   overlayAnimators . add  ( msgOverlay ) ;   overlayAnimators . add  (  new TextOverlayAnimator  ( "Press <F1> for help." , 3000 ,  TextPosition . CENTER ) ) ;   display . addComponentListener  (  new ComponentAdapter  ( )  {    @ Override public void componentResized  (   final ComponentEvent e )  {   requestRepaint  ( ) ;   display . removeComponentListener  ( this ) ; } } ) ;   painterThread . start  ( ) ; }
>>>>>>>
   public void addGroup  (   final SourceGroup group )  {  synchronized  ( visibilityAndGrouping )  {   state . addGroup  ( group ) ;   visibilityAndGrouping . update  ( NUM_GROUPS_CHANGED ) ; }   requestRepaint  ( ) ; }   public void removeGroup  (   final SourceGroup group )  {  synchronized  ( visibilityAndGrouping )  {   state . removeGroup  ( group ) ;   visibilityAndGrouping . update  ( NUM_GROUPS_CHANGED ) ; }   requestRepaint  ( ) ; }   public synchronized void setInterpolation  (   final Interpolation mode )  {   final Interpolation  interpolation =  state . getInterpolation  ( ) ;  if  (  mode != interpolation )  {   state . setInterpolation  ( mode ) ;   showMessage  (  mode . getName  ( ) ) ;  for (  final InterpolationModeListener l : interpolationModeListeners )   l . interpolationModeChanged  (  state . getInterpolation  ( ) ) ;   requestRepaint  ( ) ; } }   public void addInterpolationModeListener  (   final InterpolationModeListener listener )  {   interpolationModeListeners . add  ( listener ) ; }   public void removeInterpolationModeListener  (   final InterpolationModeListener listener )  {   interpolationModeListeners . remove  ( listener ) ; } }