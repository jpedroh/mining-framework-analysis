  package   io . scif . img ;   import   io . scif . FormatException ;  import   io . scif . Metadata ;  import   io . scif . Plane ;  import   io . scif . Reader ;  import    io . scif . config . SCIFIOConfig ;  import    io . scif . filters . ChannelFiller ;  import    io . scif . filters . MinMaxFilter ;  import    io . scif . filters . PlaneSeparator ;  import    io . scif . filters . ReaderFilter ;  import     io . scif . img . cell . SCIFIOCellImgFactory ;  import     io . scif . img . converters . PlaneConverter ;  import     io . scif . img . converters . PlaneConverterService ;  import    io . scif . services . InitializeService ;  import    io . scif . util . FormatTools ;  import   java . io . File ;  import   java . io . IOException ;  import   java . util . ArrayList ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Set ;  import   net . imagej . ImgPlus ;  import    net . imagej . axis . Axes ;  import    net . imagej . axis . AxisType ;  import    net . imagej . axis . CalibratedAxis ;  import    net . imglib2 . exception . IncompatibleTypeException ;  import    net . imglib2 . img . Img ;  import    net . imglib2 . img . ImgFactory ;  import     net . imglib2 . img . basictypeaccess . PlanarAccess ;  import    net . imglib2 . type . NativeType ;  import    net . imglib2 . type . Type ;  import     net . imglib2 . type . numeric . RealType ;  import   org . scijava . Context ;  import    org . scijava . app . StatusService ;  import    org . scijava . plugin . Parameter ;   public class ImgOpener  extends AbstractImgIOComponent  {    @ Parameter private StatusService  statusService ;    @ Parameter private PlaneConverterService  pcService ;    @ Parameter private InitializeService  initializeService ;   public ImgOpener  ( )  {  super  ( ) ; }   public ImgOpener  (   final Context ctx )  {  super  ( ctx ) ; }   public  List  <  SCIFIOImgPlus  <  ? > > openImgs  (   final String source )  throws ImgIOException  {  return  openImgs  ( source ,  ( SCIFIOConfig ) null ) ; }   public  <  T  extends  RealType  < T > &  NativeType  < T > >  List  <  SCIFIOImgPlus  < T > > openImgs  (   final String source ,   final T type )  throws ImgIOException  {  return  openImgs  ( source , type , null ) ; }   public  List  <  SCIFIOImgPlus  <  ? > > openImgs  (   final String source ,  SCIFIOConfig config )  throws ImgIOException  {  if  (  config == null )  {   config =   new SCIFIOConfig  ( ) . imgOpenerSetComputeMinMax  ( true ) ; }   final Reader  r =  createReader  ( source , config ) ;  return  openImgs  ( r , config ) ; }   public  <  T  extends  RealType  < T > &  NativeType  < T > >  List  <  SCIFIOImgPlus  < T > > openImgs  (   final String source ,   final T type ,  SCIFIOConfig config )  throws ImgIOException  {  if  (  config == null )  {   config =   new SCIFIOConfig  ( ) . imgOpenerSetComputeMinMax  ( true ) ; }   final Reader  r =  createReader  ( source , config ) ;  return  openImgs  ( r , type , config ) ; }   public  <  T  extends  RealType  < T > &  NativeType  < T > >  List  <  SCIFIOImgPlus  < T > > openImgs  (   final String source ,   final  ImgFactory  < T > imgFactory )  throws ImgIOException  {  return  openImgs  ( source , imgFactory ,  ( SCIFIOConfig ) null ) ; }   public  <  T  extends  RealType  < T > &  NativeType  < T > >  List  <  SCIFIOImgPlus  < T > > openImgs  (   final String source ,   final  ImgFactory  < T > imgFactory ,  SCIFIOConfig config )  throws ImgIOException  {  if  (  config == null )  {   config =   new SCIFIOConfig  ( ) . imgOpenerSetComputeMinMax  ( true ) ; }   final Reader  r =  createReader  ( source , config ) ;  return  openImgs  ( r , imgFactory , config ) ; }   public  List  <  SCIFIOImgPlus  <  ? > > openImgs  (   final Reader reader )  throws ImgIOException  {  return  openImgs  ( reader , null ) ; }    @ SuppressWarnings  (  { "unchecked" , "rawtypes" } ) public  List  <  SCIFIOImgPlus  <  ? > > openImgs  (   final Reader reader ,  SCIFIOConfig config )  throws ImgIOException  {   final RealType  t =  getType  ( reader ) ;  if  (  config == null )  {   config =   new SCIFIOConfig  ( ) . imgOpenerSetComputeMinMax  ( true ) ; }   final ImgFactoryHeuristic  heuristic =  getHeuristic  ( config ) ;  ImgFactory  imgFactory ;  try  {  if  (  t instanceof NativeType )  {   imgFactory =  heuristic . createFactory  (  reader . getMetadata  ( ) ,  config . imgOpenerGetImgModes  ( ) ,  ( NativeType ) t ) ; } else  return null ; }  catch (   final  IncompatibleTypeException e )  {  throw  new ImgIOException  ( e ) ; }  return  openImgs  ( reader , imgFactory , config ) ; }   public  <  T  extends  RealType  < T > &  NativeType  < T > >  List  <  SCIFIOImgPlus  < T > > openImgs  (   final Reader reader ,   final T type ,  SCIFIOConfig config )  throws ImgIOException  {  if  (  config == null )  {   config =   new SCIFIOConfig  ( ) . imgOpenerSetComputeMinMax  ( true ) ; }   final ImgFactoryHeuristic  heuristic =  getHeuristic  ( config ) ;   ImgFactory  < T >  imgFactory ;  try  {   imgFactory =  heuristic . createFactory  (  reader . getMetadata  ( ) ,  config . imgOpenerGetImgModes  ( ) , type ) ; }  catch (   final  IncompatibleTypeException e )  {  throw  new ImgIOException  ( e ) ; }  return  openImgs  ( reader , imgFactory , config ) ; }   public  <  T  extends  RealType  < T > >  List  <  SCIFIOImgPlus  < T > > openImgs  (  Reader reader ,   final  ImgFactory  < T > imgFactory ,  SCIFIOConfig config )  throws ImgIOException  {  if  (  !   ReaderFilter . class . isAssignableFrom  (  reader . getClass  ( ) ) )  {   reader =  new ReaderFilter  ( reader ) ; }   final  List  <  SCIFIOImgPlus  < T > >  imgPluses =  new  ArrayList  < >  ( ) ;  Range  imageRange = null ;  if  (  config == null )  {   config =   new SCIFIOConfig  ( ) . imgOpenerSetComputeMinMax  ( true ) ; }  if  (  config . imgOpenerIsOpenAllImages  ( ) )  {   imageRange =  new Range  (  "0-" +  (    reader . getMetadata  ( ) . getImageCount  ( ) - 1 ) ) ; } else  {   imageRange =  config . imgOpenerGetRange  ( ) ; }  for (  final Long imageIndex : imageRange )  {   final   long  [ ]  dimLengths =   utils  ( ) . getConstrainedLengths  (  reader . getMetadata  ( ) ,  i  ( imageIndex ) , config ) ;  if  (   SCIFIOCellImgFactory . class . isAssignableFrom  (  imgFactory . getClass  ( ) ) )  {    (  (  SCIFIOCellImgFactory  <  ? > ) imgFactory ) . setReader  ( reader ,  i  ( imageIndex ) ) ;    (  (  SCIFIOCellImgFactory  <  ? > ) imgFactory ) . setSubRegion  (  config . imgOpenerGetRegion  ( ) ) ; }   final  Img  < T >  img =  imgFactory . create  ( dimLengths ) ;   final  SCIFIOImgPlus  < T >  imgPlus =  makeImgPlus  ( img , reader ,  i  ( imageIndex ) ) ;  String  id =  reader . getCurrentFile  ( ) ;   imgPlus . setSource  ( id ) ;   imgPlus . initializeColorTables  (  i  (  reader . getPlaneCount  (  i  ( imageIndex ) ) ) ) ;  if  (  !  config . imgOpenerIsComputeMinMax  ( ) )  {   final   long  [ ]  defaultMinMax =  FormatTools . defaultMinMax  (   reader . getMetadata  ( ) . get  (  i  ( imageIndex ) ) ) ;  for (   int  c = 0 ;  c <  imgPlus . getCompositeChannelCount  ( ) ;  c ++ )  {   imgPlus . setChannelMinimum  ( c ,  defaultMinMax [ 0 ] ) ;   imgPlus . setChannelMaximum  ( c ,  defaultMinMax [ 1 ] ) ; } }   final Metadata  meta =  reader . getMetadata  ( ) ;   imgPlus . setMetadata  ( meta ) ;   imgPlus . setImageMetadata  (  meta . get  (  i  ( imageIndex ) ) ) ;  if  (  !   SCIFIOCellImgFactory . class . isAssignableFrom  (  imgFactory . getClass  ( ) ) )  {   final  float  startTime =  System . currentTimeMillis  ( ) ;   final  long  planeCount =  reader . getPlaneCount  (  i  ( imageIndex ) ) ;  try  {   readPlanes  ( reader ,  i  ( imageIndex ) , imgPlus , config ) ; }  catch (   final  FormatException e )  {  throw  new ImgIOException  ( e ) ; }  catch (   final  IOException e )  {  throw  new ImgIOException  ( e ) ; }   final  long  endTime =  System . currentTimeMillis  ( ) ;   final  float  time =   (  endTime - startTime ) / 1000f ;   statusService . showStatus  (   id == null ? "Image" :      id + ": read " + planeCount + " planes in " + time + "s" ) ; }   imgPluses . add  ( imgPlus ) ; }  if  (   SCIFIOCellImgFactory . class . isAssignableFrom  (  imgFactory . getClass  ( ) ) )  {   statusService . showStatus  ( "Created CellImg for dynamic loading" ) ; } else  {  try  {   reader . close  ( ) ; }  catch (   final  IOException e )  {  throw  new ImgIOException  ( e ) ; } }  return imgPluses ; }    @ SuppressWarnings  ( "rawtypes" ) private RealType getType  (   final Reader r )  {  return   utils  ( ) . makeType  (    r . getMetadata  ( ) . get  ( 0 ) . getPixelType  ( ) ) ; }   private ImgFactoryHeuristic getHeuristic  (   final SCIFIOConfig imgOptions )  {  ImgFactoryHeuristic  heuristic =  imgOptions . imgOpenerGetImgFactoryHeuristic  ( ) ;  if  (  heuristic == null )   heuristic =  new DefaultImgFactoryHeuristic  ( ) ;  return heuristic ; }   private Reader createReader  (   final String source ,   final SCIFIOConfig config )  throws ImgIOException  {   final boolean  computeMinMax =  config . imgOpenerIsComputeMinMax  ( ) ;   statusService . showStatus  (  "Initializing " + source ) ;  ReaderFilter  r = null ;  try  {   r =  initializeService . initializeReader  ( source , config ) ;   r . enable  (  ChannelFiller . class ) ;    r . enable  (  PlaneSeparator . class ) . separate  (  axesToSplit  ( r ) ) ;  if  ( computeMinMax )   r . enable  (  MinMaxFilter . class ) ; }  catch (   final  FormatException e )  {  throw  new ImgIOException  ( e ) ; }  catch (   final  IOException e )  {  throw  new ImgIOException  ( e ) ; }  return r ; }   private  AxisType  [ ] axesToSplit  (   final ReaderFilter r )  {   final  Set  < AxisType >  axes =  new  HashSet  < >  ( ) ;   final Metadata  meta =   r . getTail  ( ) . getMetadata  ( ) ;  for (  final CalibratedAxis t :   meta . get  ( 0 ) . getAxesPlanar  ( ) )  {   final AxisType  type =  t . type  ( ) ;  if  (  !  (   type ==  Axes . X ||  type ==  Axes . Y ) )  {   axes . add  ( type ) ; } }   axes . add  (  Axes . CHANNEL ) ;  return  axes . toArray  (  new AxisType  [  axes . size  ( ) ] ) ; }   private  AxisType  [ ] getAxisTypes  (   final  int imageIndex ,   final Metadata m )  {   final  AxisType  [ ]  types =  new AxisType  [    m . get  ( imageIndex ) . getAxes  ( ) . size  ( ) ] ;  for (   int  i = 0 ;  i <  types . length ;  i ++ )  {    types [ i ] =    m . get  ( imageIndex ) . getAxis  ( i ) . type  ( ) ; }  return types ; }   private   double  [ ] getCalibration  (   final  int imageIndex ,   final Metadata m )  {   final   double  [ ]  calibration =  new  double  [    m . get  ( imageIndex ) . getAxes  ( ) . size  ( ) ] ;  for (   int  i = 0 ;  i <  calibration . length ;  i ++ )  {    calibration [ i ] =  FormatTools . getScale  ( m , imageIndex ,    m . get  ( imageIndex ) . getAxis  ( i ) . type  ( ) ) ; }  return calibration ; }   private  <  T  extends  RealType  < T > >  SCIFIOImgPlus  < T > makeImgPlus  (   final  Img  < T > img ,   final Reader r ,   final  int imageIndex )  {   final String  id =  r . getCurrentFile  ( ) ;  String  name = null ;  if  (  id != null )  {   final File  idFile =  new File  ( id ) ;   name =   idFile . exists  ( ) ?  idFile . getName  ( ) : id ; }  if  (  name == null )   name =  "Image: " +  r . getFormatName  ( ) ;   final   double  [ ]  cal =  getCalibration  ( imageIndex ,  r . getMetadata  ( ) ) ;   final  AxisType  [ ]  dimTypes =  getAxisTypes  ( imageIndex ,  r . getMetadata  ( ) ) ;   final Reader  base ;   base =  unwrap  ( r ) ;   final Metadata  meta =  r . getMetadata  ( ) ;   final  int  rgbChannelCount =     base . getMetadata  ( ) . get  ( 0 ) . isMultichannel  ( ) ?  (  int )    base . getMetadata  ( ) . get  ( 0 ) . getAxisLength  (  Axes . CHANNEL ) : 1 ;   final  int  validBits =   meta . get  ( 0 ) . getBitsPerPixel  ( ) ;   final  SCIFIOImgPlus  < T >  imgPlus =  new  SCIFIOImgPlus  < >  ( img , name , dimTypes , cal ) ;   final String  metaName =   meta . get  ( imageIndex ) . getName  ( ) ;  if  (  metaName != null )   imgPlus . setName  ( metaName ) ;   imgPlus . setValidBits  ( validBits ) ;   int  compositeChannelCount = rgbChannelCount ;  if  (  rgbChannelCount == 1 )  {   final String  colorMode =  ( String )   meta . getTable  ( ) . get  ( "Color mode" ) ;  if  (  "composite" . equals  ( colorMode ) )  {   compositeChannelCount =  (  int )   meta . get  ( 0 ) . getAxisLength  (  Axes . CHANNEL ) ; } }   imgPlus . setCompositeChannelCount  ( compositeChannelCount ) ;   setCalibrationUnits  ( imgPlus , meta , imageIndex ) ;  return imgPlus ; }   private  <  T  extends  RealType  < T > > void setCalibrationUnits  (   final  SCIFIOImgPlus  < T > imgPlus ,   final Metadata m ,   final  int imageIndex )  {  for (  final CalibratedAxis axis :   m . get  ( imageIndex ) . getAxes  ( ) )  {   final  int  index =  imgPlus . dimensionIndex  (  axis . type  ( ) ) ;  if  (  index >= 0 )  {    imgPlus . axis  ( index ) . setUnit  (  axis . unit  ( ) ) ; } } }   private Reader unwrap  (   final Reader r )  {  if  (  !  (  r instanceof ReaderFilter ) )  return r ;   final ReaderFilter  rf =  ( ReaderFilter ) r ;  return  rf . getTail  ( ) ; }   private  <  T  extends  RealType  < T > > void readPlanes  (   final Reader r ,   final  int imageIndex ,   final  ImgPlus  < T > imgPlus ,   final SCIFIOConfig config )  throws FormatException , IOException  {   final  PlanarAccess  <  ? >  planarAccess =   utils  ( ) . getPlanarAccess  ( imgPlus ) ;    @ SuppressWarnings  ( "rawtypes" ) final RealType  inputType =   utils  ( ) . makeType  (    r . getMetadata  ( ) . get  ( 0 ) . getPixelType  ( ) ) ;   final T  outputType =  imgPlus . firstElement  ( ) ;   final boolean  compatibleTypes =   outputType . getClass  ( ) . isAssignableFrom  (  inputType . getClass  ( ) ) ;   final boolean  isPlanar =   planarAccess != null && compatibleTypes ;   final boolean  isArray =     utils  ( ) . getArrayAccess  ( imgPlus ) != null && compatibleTypes ;   final ImageRegion  region =  config . imgOpenerGetRegion  ( ) ;   final Metadata  m =  r . getMetadata  ( ) ;   final   long  [ ]  planarMin =  new  long  [    m . get  ( imageIndex ) . getAxesPlanar  ( ) . size  ( ) ] ;   final   long  [ ]  planarLength =  new  long  [    m . get  ( imageIndex ) . getAxesPlanar  ( ) . size  ( ) ] ;   final  Range  [ ]  npRanges =  new Range  [    m . get  ( imageIndex ) . getAxesNonPlanar  ( ) . size  ( ) ] ;   final   long  [ ]  npIndices =  new  long  [  npRanges . length ] ;   int  index = 0 ;  for (  final CalibratedAxis planarAxis :   m . get  ( imageIndex ) . getAxesPlanar  ( ) )  {  if  (   region != null &&  region . hasRange  (  planarAxis . type  ( ) ) )  {    planarMin [ index ] =   region . getRange  (  planarAxis . type  ( ) ) . head  ( ) ;    planarLength [ index ] =     region . getRange  (  planarAxis . type  ( ) ) . tail  ( ) -  planarMin [ index ] + 1 ; } else  {    planarMin [ index ] = 0 ;    planarLength [ index ] =   m . get  ( imageIndex ) . getAxisLength  ( planarAxis ) ; }   index ++ ; }   index = 0 ;  for (  final CalibratedAxis npAxis :   m . get  ( imageIndex ) . getAxesNonPlanar  ( ) )  {  if  (   region != null &&  region . hasRange  (  npAxis . type  ( ) ) )  {    npRanges [  index ++ ] =  region . getRange  (  npAxis . type  ( ) ) ; } else  {    npRanges [  index ++ ] =  new Range  ( 0l ,    m . get  ( imageIndex ) . getAxisLength  (  npAxis . type  ( ) ) - 1 ) ; } }  PlaneConverter  converter =  config . imgOpenerGetPlaneConverter  ( ) ;  if  (  converter == null )  {  if  ( isArray )  {   converter =  pcService . getArrayConverter  ( ) ; } else  if  ( isPlanar )  {   converter =  pcService . getPlanarConverter  ( ) ; } else   converter =  pcService . getDefaultConverter  ( ) ; }   read  ( imageIndex , imgPlus , r , config , converter , planarMin , planarLength , npRanges , npIndices ) ;  if  (  config . imgOpenerIsComputeMinMax  ( ) )   populateMinMax  ( r , imgPlus , imageIndex ) ; }    @ SuppressWarnings  ( "rawtypes" ) private void read  (   final  int imageIndex ,   final ImgPlus imgPlus ,   final Reader r ,   final SCIFIOConfig config ,   final PlaneConverter converter ,   final   long  [ ] planarMin ,   final   long  [ ] planarLength ,   final  Range  [ ] npRanges ,   final   long  [ ] npIndices )  throws FormatException , IOException  {   read  ( imageIndex , imgPlus , r , config , converter , null , planarMin , planarLength , npRanges , npIndices , 0 ,  new  int  [ ]  { 0 } ) ; }    @ SuppressWarnings  (  { "unchecked" , "rawtypes" } ) private Plane read  (   final  int imageIndex ,   final ImgPlus imgPlus ,   final Reader r ,   final SCIFIOConfig config ,   final PlaneConverter converter ,  Plane tmpPlane ,   final   long  [ ] planarMin ,   final   long  [ ] planarLength ,   final  Range  [ ] npRanges ,   final   long  [ ] npIndices ,   final  int depth ,   final   int  [ ] planeCount )  throws FormatException , IOException  {  if  (  depth <  npRanges . length )  {   final  int  npPosition =    npRanges . length - 1 - depth ;  for (   int  i = 0 ;  i <   npRanges [ npPosition ] . size  ( ) ;  i ++ )  {    npIndices [ npPosition ] =   npRanges [ npPosition ] . get  ( i ) ;   tmpPlane =  read  ( imageIndex , imgPlus , r , config , converter , tmpPlane , planarMin , planarLength , npRanges , npIndices ,  depth + 1 , planeCount ) ; } } else  {   final  int  planeIndex =  (  int )  FormatTools . positionToRaster  ( 0 , r , npIndices ) ;  if  (  config . imgOpenerIsComputeMinMax  ( ) )  {   populateMinMax  ( r , imgPlus , imageIndex ) ; }  if  (  tmpPlane == null )  {   tmpPlane =  r . openPlane  ( imageIndex , planeIndex , planarMin , planarLength ) ; } else  {   tmpPlane =  r . openPlane  ( imageIndex , planeIndex , tmpPlane , planarMin , planarLength , config ) ; }   converter . populatePlane  ( r , imageIndex ,  planeCount [ 0 ] ,  tmpPlane . getBytes  ( ) , imgPlus , config ) ;   imgPlus . setColorTable  (  tmpPlane . getColorTable  ( ) ,  planeCount [ 0 ] ) ;    planeCount [ 0 ] ++ ; }  return tmpPlane ; }   private void populateMinMax  (   final Reader r ,   final  ImgPlus  <  ? > imgPlus ,   final  int imageIndex )  {   final  int  sizeC =  (  int )    r . getMetadata  ( ) . get  ( imageIndex ) . getAxisLength  (  Axes . CHANNEL ) ;   final ReaderFilter  rf =  ( ReaderFilter ) r ;   final MinMaxFilter  minMax =  rf . enable  (  MinMaxFilter . class ) ;  for (   int  c = 0 ;  c < sizeC ;  c ++ )  {   final Double  min =  minMax . getAxisKnownMinimum  ( imageIndex ,  Axes . CHANNEL , c ) ;   final Double  max =  minMax . getAxisKnownMinimum  ( imageIndex ,  Axes . CHANNEL , c ) ;   imgPlus . setChannelMinimum  ( c ,   min == null ?  Double . NaN : min ) ;   imgPlus . setChannelMaximum  ( c ,   max == null ?  Double . NaN : max ) ; } }   private  int i  (   final  long l )  {  if  (  l >  Integer . MAX_VALUE )  {  throw  new IllegalArgumentException  (  "Value too large: " + l ) ; }  if  (  l <  Integer . MIN_VALUE )  {  throw  new IllegalArgumentException  (  "Value too small: " + l ) ; }  return  (  int ) l ; }    @ Deprecated public  <  T  extends  RealType  < T > &  NativeType  < T > >  List  <  SCIFIOImgPlus  < T > > openImgs  (   final String source ,   final  ImgFactory  < T > imgFactory ,   final T type )  throws ImgIOException  {  return  openImgs  ( source ,  imgFactory . imgFactory  ( type ) ) ; }    @ Deprecated public  <  T  extends  RealType  < T > >  List  <  SCIFIOImgPlus  < T > > openImgs  (  Reader reader ,   final T type ,   final  ImgFactory  < T > imgFactory ,   final SCIFIOConfig config )  throws ImgIOException  { 
<<<<<<<
=======
 for (  final Long imageIndex : imageRange )  {   final   long  [ ]  dimLengths =   utils  ( ) . getConstrainedLengths  (  reader . getMetadata  ( ) ,  i  ( imageIndex ) , config ) ;  if  (   SCIFIOCellImgFactory . class . isAssignableFrom  (  imgFactory . getClass  ( ) ) )  {    (  (  SCIFIOCellImgFactory  <  ? > ) imgFactory ) . setReader  ( reader ,  i  ( imageIndex ) ) ;    (  (  SCIFIOCellImgFactory  <  ? > ) imgFactory ) . setSubRegion  (  config . imgOpenerGetRegion  ( ) ) ; }   final  Img  < T >  img =  imgFactory . create  ( dimLengths , type ) ;   final  SCIFIOImgPlus  < T >  imgPlus =  makeImgPlus  ( img , reader ,  i  ( imageIndex ) ) ;  String  id =  reader . getCurrentFile  ( ) ;   imgPlus . setSource  ( id ) ;   imgPlus . initializeColorTables  (  i  (  reader . getPlaneCount  (  i  ( imageIndex ) ) ) ) ;  if  (  !  config . imgOpenerIsComputeMinMax  ( ) )  {   final   long  [ ]  defaultMinMax =  FormatTools . defaultMinMax  (   reader . getMetadata  ( ) . get  (  i  ( imageIndex ) ) ) ;  for (   int  c = 0 ;  c <  imgPlus . getCompositeChannelCount  ( ) ;  c ++ )  {   imgPlus . setChannelMinimum  ( c ,  defaultMinMax [ 0 ] ) ;   imgPlus . setChannelMaximum  ( c ,  defaultMinMax [ 1 ] ) ; } }   final Metadata  meta =  reader . getMetadata  ( ) ;   imgPlus . setMetadata  ( meta ) ;   imgPlus . setImageMetadata  (  meta . get  (  i  ( imageIndex ) ) ) ;   imgPlus . setROIsAndTablesProperties  ( meta ,  i  ( imageIndex ) ) ;  if  (  !   SCIFIOCellImgFactory . class . isAssignableFrom  (  imgFactory . getClass  ( ) ) )  {   final  float  startTime =  System . currentTimeMillis  ( ) ;   final  long  planeCount =  reader . getPlaneCount  (  i  ( imageIndex ) ) ;  try  {   readPlanes  ( reader ,  i  ( imageIndex ) , type , imgPlus , config ) ; }  catch (   final  FormatException e )  {  throw  new ImgIOException  ( e ) ; }  catch (   final  IOException e )  {  throw  new ImgIOException  ( e ) ; }   final  long  endTime =  System . currentTimeMillis  ( ) ;   final  float  time =   (  endTime - startTime ) / 1000f ;   statusService . showStatus  (   id == null ? "Image" :      id + ": read " + planeCount + " planes in " + time + "s" ) ; }   imgPluses . add  ( imgPlus ) ; }
>>>>>>>
  return  openImgs  ( reader ,  imgFactory . imgFactory  ( type ) , config ) ; }    @ Deprecated public  SCIFIOImgPlus  <  ? > openImg  (   final String source )  throws ImgIOException  {  return   openImgs  ( source ) . get  ( 0 ) ; }    @ Deprecated public  <  T  extends  RealType  < T > &  NativeType  < T > >  SCIFIOImgPlus  < T > openImg  (   final String source ,   final T type )  throws ImgIOException  {  return   openImgs  ( source , type ) . get  ( 0 ) ; }    @ Deprecated public  SCIFIOImgPlus  <  ? > openImg  (   final String source ,   final SCIFIOConfig config )  throws ImgIOException  {  return   openImgs  ( source , config ) . get  ( 0 ) ; }    @ Deprecated public  <  T  extends  RealType  < T > &  NativeType  < T > >  SCIFIOImgPlus  < T > openImg  (   final String source ,   final T type ,   final SCIFIOConfig config )  throws ImgIOException  {  return   openImgs  ( source , type , config ) . get  ( 0 ) ; }    @ Deprecated public  <  T  extends  RealType  < T > &  NativeType  < T > >  SCIFIOImgPlus  < T > openImg  (   final String source ,   final  ImgFactory  < T > imgFactory )  throws ImgIOException  {  return   openImgs  ( source , imgFactory ) . get  ( 0 ) ; }    @ Deprecated public  <  T  extends  RealType  < T > &  NativeType  < T > >  SCIFIOImgPlus  < T > openImg  (   final String source ,   final  ImgFactory  < T > imgFactory ,   final SCIFIOConfig config )  throws ImgIOException  {  return   openImgs  ( source , imgFactory , config ) . get  ( 0 ) ; }    @ Deprecated public  <  T  extends  RealType  < T > &  NativeType  < T > >  SCIFIOImgPlus  < T > openImg  (   final String source ,   final  ImgFactory  < T > imgFactory ,   final T type )  throws ImgIOException  {  return   openImgs  ( source , imgFactory , type ) . get  ( 0 ) ; }    @ Deprecated public  SCIFIOImgPlus  <  ? > openImg  (   final Reader reader ,   final SCIFIOConfig config )  throws ImgIOException  {  return   openImgs  ( reader , config ) . get  ( 0 ) ; }    @ Deprecated public  <  T  extends  RealType  < T > &  NativeType  < T > >  SCIFIOImgPlus  < T > openImg  (   final Reader reader ,   final T type ,   final SCIFIOConfig config )  throws ImgIOException  {  return   openImgs  ( reader , type , config ) . get  ( 0 ) ; }    @ Deprecated public  <  T  extends  RealType  < T > >  SCIFIOImgPlus  < T > openImg  (   final Reader reader ,   final T type ,   final  ImgFactory  < T > imgFactory ,   final SCIFIOConfig config )  throws ImgIOException  {  return   openImgs  ( reader , type , imgFactory , config ) . get  ( 0 ) ; } }