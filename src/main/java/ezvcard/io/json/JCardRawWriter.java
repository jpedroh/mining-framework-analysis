  package   ezvcard . io . json ;   import static    ezvcard . util . StringUtils . NEWLINE ;  import   java . io . Closeable ;  import   java . io . Flushable ;  import   java . io . IOException ;  import   java . io . Writer ;  import   java . util . List ;  import   java . util . Map ;  import     com . fasterxml . jackson . core . JsonFactory ;  import     com . fasterxml . jackson . core . JsonGenerator ;  import      com . fasterxml . jackson . core . JsonGenerator . Feature ;  import  ezvcard . Messages ;  import  ezvcard . VCardDataType ;  import   ezvcard . parameter . VCardParameters ;  import   ezvcard . util . StringUtils ;   public class JCardRawWriter  implements  Closeable , Flushable  {   private final Writer  writer ;   private final boolean  wrapInArray ;   private JsonGenerator  generator ;   private boolean  indent = false ;   private boolean  open = false ;   public JCardRawWriter  (  Writer writer ,  boolean wrapInArray )  {    this . writer = writer ;    this . wrapInArray = wrapInArray ; }   public boolean isIndent  ( )  {  return indent ; }   public void setIndent  (  boolean indent )  {    this . indent = indent ; }   public void writeStartVCard  ( )  throws IOException  {  if  (  generator == null )  {   init  ( ) ; }  if  ( open )  {   writeEndVCard  ( ) ; }   generator . writeStartArray  ( ) ;   indent  ( 0 ) ;   generator . writeString  ( "vcard" ) ;   generator . writeStartArray  ( ) ;   open = true ; }   public void writeEndVCard  ( )  throws IOException  {  if  (  ! open )  {  throw  new IllegalStateException  (   Messages . INSTANCE . getExceptionMessage  ( 1 ) ) ; }   generator . writeEndArray  ( ) ;   generator . writeEndArray  ( ) ;   open = false ; }   public void writeProperty  (  String propertyName ,  VCardDataType dataType ,  JCardValue value )  throws IOException  {   writeProperty  ( null , propertyName ,  new VCardParameters  ( ) , dataType , value ) ; }   public void writeProperty  (  String group ,  String propertyName ,  VCardParameters parameters ,  VCardDataType dataType ,  JCardValue value )  throws IOException  {  if  (  ! open )  {  throw  new IllegalStateException  (   Messages . INSTANCE . getExceptionMessage  ( 1 ) ) ; }   generator . writeStartArray  ( ) ;   indent  ( 2 ) ;   generator . writeString  ( propertyName ) ;   generator . writeStartObject  ( ) ;  for (   Map . Entry  < String ,  List  < String > > entry : parameters )  {  String  name =   entry . getKey  ( ) . toLowerCase  ( ) ;   List  < String >  values =  entry . getValue  ( ) ;  if  (  values . isEmpty  ( ) )  {  continue ; }  if  (   values . size  ( ) == 1 )  {   generator . writeStringField  ( name ,  values . get  ( 0 ) ) ; } else  {   generator . writeArrayFieldStart  ( name ) ;  for ( String paramValue : values )  {   generator . writeString  ( paramValue ) ; }   generator . writeEndArray  ( ) ; } }  if  (  group != null )  {   generator . writeStringField  ( "group" , group ) ; }   generator . writeEndObject  ( ) ;   generator . writeString  (   (  dataType == null ) ? "unknown" :   dataType . getName  ( ) . toLowerCase  ( ) ) ;  if  (   value . getValues  ( ) . isEmpty  ( ) )  {   generator . writeString  ( "" ) ; } else  {  for ( JsonValue jsonValue :  value . getValues  ( ) )  {   writeValue  ( jsonValue ) ; } }   generator . writeEndArray  ( ) ; }   private void writeValue  (  JsonValue jsonValue )  throws IOException  {  if  (  jsonValue . isNull  ( ) )  {   generator . writeNull  ( ) ;  return ; }  Object  val =  jsonValue . getValue  ( ) ;  if  (  val != null )  {  if  (  val instanceof Byte )  {   generator . writeNumber  (  ( Byte ) val ) ; } else  if  (  val instanceof Short )  {   generator . writeNumber  (  ( Short ) val ) ; } else  if  (  val instanceof Integer )  {   generator . writeNumber  (  ( Integer ) val ) ; } else  if  (  val instanceof Long )  {   generator . writeNumber  (  ( Long ) val ) ; } else  if  (  val instanceof Float )  {   generator . writeNumber  (  ( Float ) val ) ; } else  if  (  val instanceof Double )  {   generator . writeNumber  (  ( Double ) val ) ; } else  if  (  val instanceof Boolean )  {   generator . writeBoolean  (  ( Boolean ) val ) ; } else  {   generator . writeString  (  val . toString  ( ) ) ; }  return ; }   List  < JsonValue >  array =  jsonValue . getArray  ( ) ;  if  (  array != null )  {   generator . writeStartArray  ( ) ;  for ( JsonValue element : array )  {   writeValue  ( element ) ; }   generator . writeEndArray  ( ) ;  return ; }   Map  < String , JsonValue >  object =  jsonValue . getObject  ( ) ;  if  (  object != null )  {   generator . writeStartObject  ( ) ;  for (   Map . Entry  < String , JsonValue > entry :  object . entrySet  ( ) )  {   generator . writeFieldName  (  entry . getKey  ( ) ) ;   writeValue  (  entry . getValue  ( ) ) ; }   generator . writeEndObject  ( ) ;  return ; } }   private void indent  (   int spaces )  throws IOException  {  if  (  ! indent )  {  return ; }   generator . writeRaw  ( NEWLINE ) ;   generator . writeRaw  (  StringUtils . repeat  ( ' ' , spaces ) ) ; }   public void flush  ( )  throws IOException  {  if  (  generator == null )  {  return ; }   generator . flush  ( ) ; }   public void closeJsonStream  ( )  throws IOException  {  if  (  generator == null )  {  return ; }  while  ( open )  {   writeEndVCard  ( ) ; }  if  ( wrapInArray )  {   indent  ( 0 ) ;   generator . writeEndArray  ( ) ; }  if  ( closeGenerator )  {   generator . close  ( ) ; } }   public void close  ( )  throws IOException  {  if  (  generator == null )  {  return ; }   closeJsonStream  ( ) ;  if  (  writer != null )  {   writer . close  ( ) ; } }   private void init  ( )  throws IOException  {  JsonFactory  factory =  new JsonFactory  ( ) ;   factory . configure  (  Feature . AUTO_CLOSE_TARGET , false ) ;   generator =  factory . createGenerator  ( writer ) ;  if  ( wrapInArray )  {   generator . writeStartArray  ( ) ;   indent  ( 0 ) ; } }   private boolean  closeGenerator = true ;   public JCardRawWriter  (  JsonGenerator generator )  {    this . writer = null ;    this . generator = generator ;    this . closeGenerator = false ;    this . wrapInArray = false ; } }