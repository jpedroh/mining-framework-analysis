  package    jj2000 . j2k . entropy . decoder ;   import    jj2000 . j2k . decoder . DecoderSpecs ;  import    jj2000 . j2k . entropy . StdEntropyCoderOptions ;  import    jj2000 . j2k . image . DataBlk ;  import    jj2000 . j2k . image . DataBlkInt ;  import    jj2000 . j2k . util . ArrayUtil ;  import    jj2000 . j2k . util . FacilityManager ;  import    jj2000 . j2k . util . MsgLogger ;  import    jj2000 . j2k . wavelet . Subband ;  import     jj2000 . j2k . wavelet . synthesis . SubbandSyn ;   public class StdEntropyDecoder  extends EntropyDecoder  implements  StdEntropyCoderOptions  {   private final static boolean  DO_TIMING = false ;   private  long  time  [ ] ;   private ByteToBitInput  bin ;   private MQDecoder  mq ;   private DecoderSpecs  decSpec ;   private  int  options ;   private final boolean  doer ;   private final boolean  verber ;   private static final  int  ZC_LUT_BITS = 8 ;   private static final  int  ZC_LUT_LH  [ ] =  new  int  [  1 << ZC_LUT_BITS ] ;   private static final  int  ZC_LUT_HL  [ ] =  new  int  [  1 << ZC_LUT_BITS ] ;   private static final  int  ZC_LUT_HH  [ ] =  new  int  [  1 << ZC_LUT_BITS ] ;   private static final  int  SC_LUT_BITS = 9 ;   private static final  int  SC_LUT  [ ] =  new  int  [  1 << SC_LUT_BITS ] ;   private static final  int  SC_LUT_MASK =   (  1 << 4 ) - 1 ;   private static final  int  SC_SPRED_SHIFT = 31 ;   private static final  int  INT_SIGN_BIT =  1 << 31 ;   private static final  int  MR_LUT_BITS = 9 ;   private static final  int  MR_LUT  [ ] =  new  int  [  1 << MR_LUT_BITS ] ;   private static final  int  NUM_CTXTS = 19 ;   private static final  int  RLC_CTXT = 1 ;   private static final  int  UNIF_CTXT = 0 ;   private static final  int  MQ_INIT  [ ] =  { 46 , 3 , 4 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ;   private static final  int  SEG_SYMBOL = 10 ;   private final  int  state  [ ] ;   private static final  int  STATE_SEP = 16 ;   private static final  int  STATE_SIG_R1 =  1 << 15 ;   private static final  int  STATE_VISITED_R1 =  1 << 14 ;   private static final  int  STATE_NZ_CTXT_R1 =  1 << 13 ;   private static final  int  STATE_H_L_SIGN_R1 =  1 << 12 ;   private static final  int  STATE_H_R_SIGN_R1 =  1 << 11 ;   private static final  int  STATE_V_U_SIGN_R1 =  1 << 10 ;   private static final  int  STATE_V_D_SIGN_R1 =  1 << 9 ;   private static final  int  STATE_PREV_MR_R1 =  1 << 8 ;   private static final  int  STATE_H_L_R1 =  1 << 7 ;   private static final  int  STATE_H_R_R1 =  1 << 6 ;   private static final  int  STATE_V_U_R1 =  1 << 5 ;   private static final  int  STATE_V_D_R1 =  1 << 4 ;   private static final  int  STATE_D_UL_R1 =  1 << 3 ;   private static final  int  STATE_D_UR_R1 =  1 << 2 ;   private static final  int  STATE_D_DL_R1 =  1 << 1 ;   private static final  int  STATE_D_DR_R1 = 1 ;   private static final  int  STATE_SIG_R2 =  STATE_SIG_R1 << STATE_SEP ;   private static final  int  STATE_VISITED_R2 =  STATE_VISITED_R1 << STATE_SEP ;   private static final  int  STATE_NZ_CTXT_R2 =  STATE_NZ_CTXT_R1 << STATE_SEP ;   private static final  int  STATE_H_L_SIGN_R2 =  STATE_H_L_SIGN_R1 << STATE_SEP ;   private static final  int  STATE_H_R_SIGN_R2 =  STATE_H_R_SIGN_R1 << STATE_SEP ;   private static final  int  STATE_V_U_SIGN_R2 =  STATE_V_U_SIGN_R1 << STATE_SEP ;   private static final  int  STATE_V_D_SIGN_R2 =  STATE_V_D_SIGN_R1 << STATE_SEP ;   private static final  int  STATE_PREV_MR_R2 =  STATE_PREV_MR_R1 << STATE_SEP ;   private static final  int  STATE_H_L_R2 =  STATE_H_L_R1 << STATE_SEP ;   private static final  int  STATE_H_R_R2 =  STATE_H_R_R1 << STATE_SEP ;   private static final  int  STATE_V_U_R2 =  STATE_V_U_R1 << STATE_SEP ;   private static final  int  STATE_V_D_R2 =  STATE_V_D_R1 << STATE_SEP ;   private static final  int  STATE_D_UL_R2 =  STATE_D_UL_R1 << STATE_SEP ;   private static final  int  STATE_D_UR_R2 =  STATE_D_UR_R1 << STATE_SEP ;   private static final  int  STATE_D_DL_R2 =  STATE_D_DL_R1 << STATE_SEP ;   private static final  int  STATE_D_DR_R2 =  STATE_D_DR_R1 << STATE_SEP ;   private static final  int  SIG_MASK_R1R2 =  STATE_SIG_R1 | STATE_SIG_R2 ;   private static final  int  VSTD_MASK_R1R2 =  STATE_VISITED_R1 | STATE_VISITED_R2 ;   private static final  int  RLC_MASK_R1R2 =      STATE_SIG_R1 | STATE_SIG_R2 | STATE_VISITED_R1 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 ;   private static final  int  ZC_MASK =   (  1 << 8 ) - 1 ;   private static final  int  SC_SHIFT_R1 = 4 ;   private static final  int  SC_SHIFT_R2 =  SC_SHIFT_R1 + STATE_SEP ;   private static final  int  SC_MASK =   (  1 << SC_LUT_BITS ) - 1 ;   private static final  int  MR_MASK =   (  1 << 9 ) - 1 ;   private DecLyrdCBlk  srcblk ;   private  int  mQuit ;  static  {   int  i ,  j ;   double  val ,  deltaMSE ;   int  inter_sc_lut  [ ] ;   int  ds ,  us ,  rs ,  ls ;   int  dsgn ,  usgn ,  rsgn ,  lsgn ;   int  h ,  v ;    ZC_LUT_LH [ 0 ] = 2 ;  for (  i = 1 ;  i < 16 ;  i ++ )  {    ZC_LUT_LH [ i ] = 4 ; }  for (  i = 0 ;  i < 4 ;  i ++ )  {    ZC_LUT_LH [  1 << i ] = 3 ; }  for (  i = 0 ;  i < 16 ;  i ++ )  {    ZC_LUT_LH [  STATE_V_U_R1 | i ] = 5 ;    ZC_LUT_LH [  STATE_V_D_R1 | i ] = 5 ;    ZC_LUT_LH [   STATE_V_U_R1 | STATE_V_D_R1 | i ] = 6 ; }    ZC_LUT_LH [ STATE_H_L_R1 ] = 7 ;    ZC_LUT_LH [ STATE_H_R_R1 ] = 7 ;  for (  i = 1 ;  i < 16 ;  i ++ )  {    ZC_LUT_LH [  STATE_H_L_R1 | i ] = 8 ;    ZC_LUT_LH [  STATE_H_R_R1 | i ] = 8 ; }  for (  i = 1 ;  i < 4 ;  i ++ )  {  for (  j = 0 ;  j < 16 ;  j ++ )  {    ZC_LUT_LH [   STATE_H_L_R1 |  (  i << 4 ) | j ] = 9 ;    ZC_LUT_LH [   STATE_H_R_R1 |  (  i << 4 ) | j ] = 9 ; } }  for (  i = 0 ;  i < 64 ;  i ++ )  {    ZC_LUT_LH [   STATE_H_L_R1 | STATE_H_R_R1 | i ] = 10 ; }    ZC_LUT_HL [ 0 ] = 2 ;  for (  i = 1 ;  i < 16 ;  i ++ )  {    ZC_LUT_HL [ i ] = 4 ; }  for (  i = 0 ;  i < 4 ;  i ++ )  {    ZC_LUT_HL [  1 << i ] = 3 ; }  for (  i = 0 ;  i < 16 ;  i ++ )  {    ZC_LUT_HL [  STATE_H_L_R1 | i ] = 5 ;    ZC_LUT_HL [  STATE_H_R_R1 | i ] = 5 ;    ZC_LUT_HL [   STATE_H_L_R1 | STATE_H_R_R1 | i ] = 6 ; }    ZC_LUT_HL [ STATE_V_U_R1 ] = 7 ;    ZC_LUT_HL [ STATE_V_D_R1 ] = 7 ;  for (  i = 1 ;  i < 16 ;  i ++ )  {    ZC_LUT_HL [  STATE_V_U_R1 | i ] = 8 ;    ZC_LUT_HL [  STATE_V_D_R1 | i ] = 8 ; }  for (  i = 1 ;  i < 4 ;  i ++ )  {  for (  j = 0 ;  j < 16 ;  j ++ )  {    ZC_LUT_HL [    (  i << 6 ) | STATE_V_U_R1 | j ] = 9 ;    ZC_LUT_HL [    (  i << 6 ) | STATE_V_D_R1 | j ] = 9 ; } }  for (  i = 0 ;  i < 4 ;  i ++ )  {  for (  j = 0 ;  j < 16 ;  j ++ )  {    ZC_LUT_HL [     (  i << 6 ) | STATE_V_U_R1 | STATE_V_D_R1 | j ] = 10 ; } }    int  [ ]  twoBits =  { 3 , 5 , 6 , 9 , 10 , 12 } ;    int  [ ]  oneBit =  { 1 , 2 , 4 , 8 } ;    int  [ ]  twoLeast =  { 3 , 5 , 6 , 7 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } ;    int  [ ]  threeLeast =  { 7 , 11 , 13 , 14 , 15 } ;    ZC_LUT_HH [ 0 ] = 2 ;  for (  i = 0 ;  i <  oneBit . length ;  i ++ )    ZC_LUT_HH [   oneBit [ i ] << 4 ] = 3 ;  for (  i = 0 ;  i <  twoLeast . length ;  i ++ )    ZC_LUT_HH [   twoLeast [ i ] << 4 ] = 4 ;  for (  i = 0 ;  i <  oneBit . length ;  i ++ )    ZC_LUT_HH [  oneBit [ i ] ] = 5 ;  for (  i = 0 ;  i <  oneBit . length ;  i ++ )  for (  j = 0 ;  j <  oneBit . length ;  j ++ )    ZC_LUT_HH [   (   oneBit [ i ] << 4 ) |  oneBit [ j ] ] = 6 ;  for (  i = 0 ;  i <  twoLeast . length ;  i ++ )  for (  j = 0 ;  j <  oneBit . length ;  j ++ )    ZC_LUT_HH [   (   twoLeast [ i ] << 4 ) |  oneBit [ j ] ] = 7 ;  for (  i = 0 ;  i <  twoBits . length ;  i ++ )    ZC_LUT_HH [  twoBits [ i ] ] = 8 ;  for (  j = 0 ;  j <  twoBits . length ;  j ++ )  for (  i = 1 ;  i < 16 ;  i ++ )    ZC_LUT_HH [   (  i << 4 ) |  twoBits [ j ] ] = 9 ;  for (  i = 0 ;  i < 16 ;  i ++ )  for (  j = 0 ;  j <  threeLeast . length ;  j ++ )    ZC_LUT_HH [   (  i << 4 ) |  threeLeast [ j ] ] = 10 ;   inter_sc_lut =  new  int  [ 36 ] ;    inter_sc_lut [   (  2 << 3 ) | 2 ] = 15 ;    inter_sc_lut [   (  2 << 3 ) | 1 ] = 14 ;    inter_sc_lut [   (  2 << 3 ) | 0 ] = 13 ;    inter_sc_lut [   (  1 << 3 ) | 2 ] = 12 ;    inter_sc_lut [   (  1 << 3 ) | 1 ] = 11 ;    inter_sc_lut [   (  1 << 3 ) | 0 ] =  12 | INT_SIGN_BIT ;    inter_sc_lut [   (  0 << 3 ) | 2 ] =  13 | INT_SIGN_BIT ;    inter_sc_lut [   (  0 << 3 ) | 1 ] =  14 | INT_SIGN_BIT ;    inter_sc_lut [   (  0 << 3 ) | 0 ] =  15 | INT_SIGN_BIT ;  for (  i = 0 ;  i <   (  1 << SC_LUT_BITS ) - 1 ;  i ++ )  {   ds =  i & 0x01 ;   us =   (  i >> 1 ) & 0x01 ;   rs =   (  i >> 2 ) & 0x01 ;   ls =   (  i >> 3 ) & 0x01 ;   dsgn =   (  i >> 5 ) & 0x01 ;   usgn =   (  i >> 6 ) & 0x01 ;   rsgn =   (  i >> 7 ) & 0x01 ;   lsgn =   (  i >> 8 ) & 0x01 ;   h =   ls *  (  1 -  2 * lsgn ) +  rs *  (  1 -  2 * rsgn ) ;   h =   (  h >=  - 1 ) ? h :  - 1 ;   h =   (  h <= 1 ) ? h : 1 ;   v =   us *  (  1 -  2 * usgn ) +  ds *  (  1 -  2 * dsgn ) ;   v =   (  v >=  - 1 ) ? v :  - 1 ;   v =   (  v <= 1 ) ? v : 1 ;    SC_LUT [ i ] =  inter_sc_lut [    (  h + 1 ) << 3 |  (  v + 1 ) ] ; }   inter_sc_lut = null ;    MR_LUT [ 0 ] = 16 ;  for (  i = 1 ;  i <  (  1 <<  (  MR_LUT_BITS - 1 ) ) ;  i ++ )  {    MR_LUT [ i ] = 17 ; }  for ( ;  i <  (  1 << MR_LUT_BITS ) ;  i ++ )  {    MR_LUT [ i ] = 18 ; } }   public StdEntropyDecoder  (  CodedCBlkDataSrcDec src ,  DecoderSpecs decSpec ,  boolean doer ,  boolean verber ,   int mQuit )  {  super  ( src ) ;    this . decSpec = decSpec ;    this . doer = doer ;    this . verber = verber ;    this . mQuit = mQuit ;  if  ( DO_TIMING )  {   time =  new  long  [  src . getNumComps  ( ) ] ;   System . runFinalizersOnExit  ( true ) ; }   state =  new  int  [   (    decSpec . cblks . getMaxCBlkWidth  ( ) + 2 ) *  (    (    decSpec . cblks . getMaxCBlkHeight  ( ) + 1 ) / 2 + 2 ) ] ; }   public void finalize  ( )  throws Throwable  {  if  ( DO_TIMING )  {   int  c ;  StringBuffer  sb ;   sb =  new StringBuffer  (  "StdEntropyDecoder decompression wall " + "clock time:" ) ;  for (  c = 0 ;  c <  time . length ;  c ++ )  {   sb . append  ( "\n  component " ) ;   sb . append  ( c ) ;   sb . append  ( ": " ) ;   sb . append  (  time [ c ] ) ;   sb . append  ( " ms" ) ; }    FacilityManager . getMsgLogger  ( ) . printmsg  (  MsgLogger . INFO ,  sb . toString  ( ) ) ; }   super . finalize  ( ) ; }   public DataBlk getCodeBlock  (   int c ,   int m ,   int n ,  SubbandSyn sb ,  DataBlk cblk )  {   long  stime = 0L ;   int  zc_lut  [ ] ;   int  out_data  [ ] ;   int  npasses ;   int  curbp ;  boolean  error ;   int  tslen ;   int  tsidx ;  ByteInputBuffer  in = null ;  boolean  isterm ;   srcblk =  src . getCodeBlock  ( c , m , n , sb , 1 ,  - 1 , srcblk ) ;  if  ( DO_TIMING )   stime =  System . currentTimeMillis  ( ) ;   options =   (  ( Integer )   decSpec . ecopts . getTileCompVal  ( tIdx , c ) ) . intValue  ( ) ;   ArrayUtil . intArraySet  ( state , 0 ) ;  if  (  cblk == null )  {   cblk =  new DataBlkInt  ( ) ; }    cblk . progressive =  srcblk . prog ;    cblk . ulx =  srcblk . ulx ;    cblk . uly =  srcblk . uly ;    cblk . w =  srcblk . w ;    cblk . h =  srcblk . h ;    cblk . offset = 0 ;    cblk . scanw =  cblk . w ;   out_data =  (   int  [ ] )  cblk . getData  ( ) ;  if  (   out_data == null ||   out_data . length <   srcblk . w *  srcblk . h )  {   out_data =  new  int  [   srcblk . w *  srcblk . h ] ;   cblk . setData  ( out_data ) ; } else  {   ArrayUtil . intArraySet  ( out_data , 0 ) ; }  if  (    srcblk . nl <= 0 ||   srcblk . nTrunc <= 0 )  {  return cblk ; }   tslen =   (   srcblk . tsLengths == null ) ?  srcblk . dl :   srcblk . tsLengths [ 0 ] ;   tsidx = 0 ;   npasses =  srcblk . nTrunc ;  if  (  mq == null )  {   in =  new ByteInputBuffer  (  srcblk . data , 0 , tslen ) ;   mq =  new MQDecoder  ( in , NUM_CTXTS , MQ_INIT ) ; } else  {   mq . nextSegment  (  srcblk . data , 0 , tslen ) ;   mq . resetCtxts  ( ) ; }   error = false ;  if  (   (  options & OPT_BYPASS ) != 0 )  {  if  (  bin == null )  {  if  (  in == null )   in =  mq . getByteInputBuffer  ( ) ;   bin =  new ByteToBitInput  ( in ) ; } }  switch  (  sb . orientation )  {   case  Subband . WT_ORIENT_HL :   zc_lut = ZC_LUT_HL ;  break ;   case  Subband . WT_ORIENT_LH :   case  Subband . WT_ORIENT_LL :   zc_lut = ZC_LUT_LH ;  break ;   case  Subband . WT_ORIENT_HH :   zc_lut = ZC_LUT_HH ;  break ;   default :  throw  new Error  ( "JJ2000 internal error" ) ; }   curbp =  30 -  srcblk . skipMSBP ;  if  (   mQuit !=  - 1 &&   (   mQuit * 3 - 2 ) < npasses )  {   npasses =   mQuit * 3 - 2 ; }  if  (   curbp >= 0 &&  npasses > 0 )  {   isterm =    (  options & OPT_TERM_PASS ) != 0 ||  (    (  options & OPT_BYPASS ) != 0 &&   (   31 - NUM_NON_BYPASS_MS_BP -  srcblk . skipMSBP ) >= curbp ) ;   error =  cleanuppass  ( cblk , mq , curbp , state , zc_lut , isterm ) ;   npasses -- ;  if  (   ! error ||  ! doer )   curbp -- ; }  if  (   ! error ||  ! doer )  {  while  (   curbp >= 0 &&  npasses > 0 )  {  if  (    (  options & OPT_BYPASS ) != 0 &&  (  curbp <   31 - NUM_NON_BYPASS_MS_BP -  srcblk . skipMSBP ) )  {   bin . setByteArray  ( null ,  - 1 ,   srcblk . tsLengths [  ++ tsidx ] ) ;   isterm =   (  options & OPT_TERM_PASS ) != 0 ;   error =  rawSigProgPass  ( cblk , bin , curbp , state , isterm ) ;   npasses -- ;  if  (   npasses <= 0 ||  (  error && doer ) )  break ;  if  (   (  options & OPT_TERM_PASS ) != 0 )  {   bin . setByteArray  ( null ,  - 1 ,   srcblk . tsLengths [  ++ tsidx ] ) ; }   isterm =    (  options & OPT_TERM_PASS ) != 0 ||  (    (  options & OPT_BYPASS ) != 0 &&  (    31 - NUM_NON_BYPASS_MS_BP -  srcblk . skipMSBP > curbp ) ) ;   error =  rawMagRefPass  ( cblk , bin , curbp , state , isterm ) ; } else  {  if  (   (  options & OPT_TERM_PASS ) != 0 )  {   mq . nextSegment  ( null ,  - 1 ,   srcblk . tsLengths [  ++ tsidx ] ) ; }   isterm =   (  options & OPT_TERM_PASS ) != 0 ;   error =  sigProgPass  ( cblk , mq , curbp , state , zc_lut , isterm ) ;   npasses -- ;  if  (   npasses <= 0 ||  (  error && doer ) )  break ;  if  (   (  options & OPT_TERM_PASS ) != 0 )  {   mq . nextSegment  ( null ,  - 1 ,   srcblk . tsLengths [  ++ tsidx ] ) ; }   isterm =    (  options & OPT_TERM_PASS ) != 0 ||  (    (  options & OPT_BYPASS ) != 0 &&  (    31 - NUM_NON_BYPASS_MS_BP -  srcblk . skipMSBP > curbp ) ) ;   error =  magRefPass  ( cblk , mq , curbp , state , isterm ) ; }   npasses -- ;  if  (   npasses <= 0 ||  (  error && doer ) )  break ;  if  (    (  options & OPT_TERM_PASS ) != 0 ||  (    (  options & OPT_BYPASS ) != 0 &&  (  curbp <   31 - NUM_NON_BYPASS_MS_BP -  srcblk . skipMSBP ) ) )  {   mq . nextSegment  ( null ,  - 1 ,   srcblk . tsLengths [  ++ tsidx ] ) ; }   isterm =    (  options & OPT_TERM_PASS ) != 0 ||  (    (  options & OPT_BYPASS ) != 0 &&   (   31 - NUM_NON_BYPASS_MS_BP -  srcblk . skipMSBP ) >= curbp ) ;   error =  cleanuppass  ( cblk , mq , curbp , state , zc_lut , isterm ) ;   npasses -- ;  if  ( error )  break ;   curbp -- ; } }  if  (  error && doer )  {  if  ( verber )  {    FacilityManager . getMsgLogger  ( ) . printmsg  (  MsgLogger . WARNING ,           "Error detected at bit-plane " + curbp + " in code-block (" + m + "," + n + "), sb_idx " +  sb . sbandIdx + ", res. level " +  sb . resLvl + ". Concealing..." ) ; }   conceal  ( cblk , curbp ) ; }  if  ( DO_TIMING )    time [ c ] +=   System . currentTimeMillis  ( ) - stime ;  return cblk ; }   public DataBlk getInternCodeBlock  (   int c ,   int m ,   int n ,  SubbandSyn sb ,  DataBlk cblk )  {  return  getCodeBlock  ( c , m , n , sb , cblk ) ; }   private boolean sigProgPass  (  DataBlk cblk ,  MQDecoder mq ,   int bp ,   int state  [ ] ,   int zc_lut  [ ] ,  boolean isterm )  {   int  j ,  sj ;   int  k ,  sk ;   int  dscanw ;   int  sscanw ;   int  jstep ;   int  kstep ;   int  stopsk ;   int  csj ;   int  setmask ;   int  sym ;   int  ctxt ;   int  data  [ ] ;   int  s ;  boolean  causal ;   int  nstripes ;   int  sheight ;   int  off_ul ,  off_ur ,  off_dr ,  off_dl ;  boolean  error ;   dscanw =  cblk . scanw ;   sscanw =   cblk . w + 2 ;   jstep =    sscanw * STRIPE_HEIGHT / 2 -  cblk . w ;   kstep =   dscanw * STRIPE_HEIGHT -  cblk . w ;   int  one =  1 << bp ;   int  half =  one >> 1 ;   setmask =  one | half ;   data =  (   int  [ ] )  cblk . getData  ( ) ;   nstripes =   (    cblk . h + STRIPE_HEIGHT - 1 ) / STRIPE_HEIGHT ;   causal =   (  options & OPT_VERT_STR_CAUSAL ) != 0 ;   off_ul =   - sscanw - 1 ;   off_ur =   - sscanw + 1 ;   off_dr =  sscanw + 1 ;   off_dl =  sscanw - 1 ;   sk =  cblk . offset ;   sj =  sscanw + 1 ;  for (  s =  nstripes - 1 ;  s >= 0 ;  s -- ,  sk += kstep ,  sj += jstep )  {   sheight =   (  s != 0 ) ? STRIPE_HEIGHT :   cblk . h -   (  nstripes - 1 ) * STRIPE_HEIGHT ;   stopsk =  sk +  cblk . w ;  for ( ;  sk < stopsk ;  sk ++ ,  sj ++ )  {   j = sj ;   csj =  state [ j ] ;  if  (   (   (   (  ~ csj ) &  (  csj << 2 ) ) & SIG_MASK_R1R2 ) != 0 )  {   k = sk ;  if  (   (  csj &  (  STATE_SIG_R1 | STATE_NZ_CTXT_R1 ) ) == STATE_NZ_CTXT_R1 )  {  if  (   mq . decodeSymbol  (  zc_lut [  csj & ZC_MASK ] ) != 0 )  {   ctxt =  SC_LUT [   (  csj >>> SC_SHIFT_R1 ) & SC_MASK ] ;   sym =   mq . decodeSymbol  (  ctxt & SC_LUT_MASK ) ^  (  ctxt >>> SC_SPRED_SHIFT ) ;    data [ k ] =   (  sym << 31 ) | setmask ;  if  (  ! causal )  {    state [  j + off_ul ] |=  STATE_NZ_CTXT_R2 | STATE_D_DR_R2 ;    state [  j + off_ur ] |=  STATE_NZ_CTXT_R2 | STATE_D_DL_R2 ; }  if  (  sym != 0 )  {   csj |=     STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 | STATE_V_U_SIGN_R2 ;  if  (  ! causal )  {    state [  j - sscanw ] |=   STATE_NZ_CTXT_R2 | STATE_V_D_R2 | STATE_V_D_SIGN_R2 ; }    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_H_L_SIGN_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_H_R_SIGN_R1 | STATE_D_UR_R2 ; } else  {   csj |=    STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 ;  if  (  ! causal )  {    state [  j - sscanw ] |=  STATE_NZ_CTXT_R2 | STATE_V_D_R2 ; }    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_D_UR_R2 ; } } else  {   csj |= STATE_VISITED_R1 ; } }  if  (  sheight < 2 )  {    state [ j ] = csj ;  continue ; }  if  (   (  csj &  (  STATE_SIG_R2 | STATE_NZ_CTXT_R2 ) ) == STATE_NZ_CTXT_R2 )  {   k += dscanw ;  if  (   mq . decodeSymbol  (  zc_lut [   (  csj >>> STATE_SEP ) & ZC_MASK ] ) != 0 )  {   ctxt =  SC_LUT [   (  csj >>> SC_SHIFT_R2 ) & SC_MASK ] ;   sym =   mq . decodeSymbol  (  ctxt & SC_LUT_MASK ) ^  (  ctxt >>> SC_SPRED_SHIFT ) ;    data [ k ] =   (  sym << 31 ) | setmask ;    state [  j + off_dl ] |=  STATE_NZ_CTXT_R1 | STATE_D_UR_R1 ;    state [  j + off_dr ] |=  STATE_NZ_CTXT_R1 | STATE_D_UL_R1 ;  if  (  sym != 0 )  {   csj |=     STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 | STATE_V_D_SIGN_R1 ;    state [  j + sscanw ] |=   STATE_NZ_CTXT_R1 | STATE_V_U_R1 | STATE_V_U_SIGN_R1 ;    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 | STATE_H_L_SIGN_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 | STATE_H_R_SIGN_R2 ; } else  {   csj |=    STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 ;    state [  j + sscanw ] |=  STATE_NZ_CTXT_R1 | STATE_V_U_R1 ;    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 ; } } else  {   csj |= STATE_VISITED_R2 ; } }    state [ j ] = csj ; }  if  (  sheight < 3 )  continue ;   j += sscanw ;   csj =  state [ j ] ;  if  (   (   (   (  ~ csj ) &  (  csj << 2 ) ) & SIG_MASK_R1R2 ) != 0 )  {   k =  sk +  (  dscanw << 1 ) ;  if  (   (  csj &  (  STATE_SIG_R1 | STATE_NZ_CTXT_R1 ) ) == STATE_NZ_CTXT_R1 )  {  if  (   mq . decodeSymbol  (  zc_lut [  csj & ZC_MASK ] ) != 0 )  {   ctxt =  SC_LUT [   (  csj >>> SC_SHIFT_R1 ) & SC_MASK ] ;   sym =   mq . decodeSymbol  (  ctxt & SC_LUT_MASK ) ^  (  ctxt >>> SC_SPRED_SHIFT ) ;    data [ k ] =   (  sym << 31 ) | setmask ;    state [  j + off_ul ] |=  STATE_NZ_CTXT_R2 | STATE_D_DR_R2 ;    state [  j + off_ur ] |=  STATE_NZ_CTXT_R2 | STATE_D_DL_R2 ;  if  (  sym != 0 )  {   csj |=     STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 | STATE_V_U_SIGN_R2 ;    state [  j - sscanw ] |=   STATE_NZ_CTXT_R2 | STATE_V_D_R2 | STATE_V_D_SIGN_R2 ;    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_H_L_SIGN_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_H_R_SIGN_R1 | STATE_D_UR_R2 ; } else  {   csj |=    STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 ;    state [  j - sscanw ] |=  STATE_NZ_CTXT_R2 | STATE_V_D_R2 ;    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_D_UR_R2 ; } } else  {   csj |= STATE_VISITED_R1 ; } }  if  (  sheight < 4 )  {    state [ j ] = csj ;  continue ; }  if  (   (  csj &  (  STATE_SIG_R2 | STATE_NZ_CTXT_R2 ) ) == STATE_NZ_CTXT_R2 )  {   k += dscanw ;  if  (   mq . decodeSymbol  (  zc_lut [   (  csj >>> STATE_SEP ) & ZC_MASK ] ) != 0 )  {   ctxt =  SC_LUT [   (  csj >>> SC_SHIFT_R2 ) & SC_MASK ] ;   sym =   mq . decodeSymbol  (  ctxt & SC_LUT_MASK ) ^  (  ctxt >>> SC_SPRED_SHIFT ) ;    data [ k ] =   (  sym << 31 ) | setmask ;    state [  j + off_dl ] |=  STATE_NZ_CTXT_R1 | STATE_D_UR_R1 ;    state [  j + off_dr ] |=  STATE_NZ_CTXT_R1 | STATE_D_UL_R1 ;  if  (  sym != 0 )  {   csj |=     STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 | STATE_V_D_SIGN_R1 ;    state [  j + sscanw ] |=   STATE_NZ_CTXT_R1 | STATE_V_U_R1 | STATE_V_U_SIGN_R1 ;    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 | STATE_H_L_SIGN_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 | STATE_H_R_SIGN_R2 ; } else  {   csj |=    STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 ;    state [  j + sscanw ] |=  STATE_NZ_CTXT_R1 | STATE_V_U_R1 ;    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 ; } } else  {   csj |= STATE_VISITED_R2 ; } }    state [ j ] = csj ; } } }   error = false ;  if  (  isterm &&   (  options & OPT_PRED_TERM ) != 0 )  {   error =  mq . checkPredTerm  ( ) ; }  if  (   (  options & OPT_RESET_MQ ) != 0 )  {   mq . resetCtxts  ( ) ; }  return error ; }   private boolean rawSigProgPass  (  DataBlk cblk ,  ByteToBitInput bin ,   int bp ,   int state  [ ] ,  boolean isterm )  {   int  j ,  sj ;   int  k ,  sk ;   int  dscanw ;   int  sscanw ;   int  jstep ;   int  kstep ;   int  stopsk ;   int  csj ;   int  setmask ;   int  sym ;   int  data  [ ] ;   int  s ;  boolean  causal ;   int  nstripes ;   int  sheight ;   int  off_ul ,  off_ur ,  off_dr ,  off_dl ;  boolean  error ;   dscanw =  cblk . scanw ;   sscanw =   cblk . w + 2 ;   jstep =    sscanw * STRIPE_HEIGHT / 2 -  cblk . w ;   kstep =   dscanw * STRIPE_HEIGHT -  cblk . w ;   int  one =  1 << bp ;   int  half =  one >> 1 ;   setmask =  one | half ;   data =  (   int  [ ] )  cblk . getData  ( ) ;   nstripes =   (    cblk . h + STRIPE_HEIGHT - 1 ) / STRIPE_HEIGHT ;   causal =   (  options & OPT_VERT_STR_CAUSAL ) != 0 ;   off_ul =   - sscanw - 1 ;   off_ur =   - sscanw + 1 ;   off_dr =  sscanw + 1 ;   off_dl =  sscanw - 1 ;   sk =  cblk . offset ;   sj =  sscanw + 1 ;  for (  s =  nstripes - 1 ;  s >= 0 ;  s -- ,  sk += kstep ,  sj += jstep )  {   sheight =   (  s != 0 ) ? STRIPE_HEIGHT :   cblk . h -   (  nstripes - 1 ) * STRIPE_HEIGHT ;   stopsk =  sk +  cblk . w ;  for ( ;  sk < stopsk ;  sk ++ ,  sj ++ )  {   j = sj ;   csj =  state [ j ] ;  if  (   (   (   (  ~ csj ) &  (  csj << 2 ) ) & SIG_MASK_R1R2 ) != 0 )  {   k = sk ;  if  (   (  csj &  (  STATE_SIG_R1 | STATE_NZ_CTXT_R1 ) ) == STATE_NZ_CTXT_R1 )  {  if  (   bin . readBit  ( ) != 0 )  {   sym =  bin . readBit  ( ) ;    data [ k ] =   (  sym << 31 ) | setmask ;  if  (  ! causal )  {    state [  j + off_ul ] |=  STATE_NZ_CTXT_R2 | STATE_D_DR_R2 ;    state [  j + off_ur ] |=  STATE_NZ_CTXT_R2 | STATE_D_DL_R2 ; }  if  (  sym != 0 )  {   csj |=     STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 | STATE_V_U_SIGN_R2 ;  if  (  ! causal )  {    state [  j - sscanw ] |=   STATE_NZ_CTXT_R2 | STATE_V_D_R2 | STATE_V_D_SIGN_R2 ; }    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_H_L_SIGN_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_H_R_SIGN_R1 | STATE_D_UR_R2 ; } else  {   csj |=    STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 ;  if  (  ! causal )  {    state [  j - sscanw ] |=  STATE_NZ_CTXT_R2 | STATE_V_D_R2 ; }    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_D_UR_R2 ; } } else  {   csj |= STATE_VISITED_R1 ; } }  if  (  sheight < 2 )  {    state [ j ] = csj ;  continue ; }  if  (   (  csj &  (  STATE_SIG_R2 | STATE_NZ_CTXT_R2 ) ) == STATE_NZ_CTXT_R2 )  {   k += dscanw ;  if  (   bin . readBit  ( ) != 0 )  {   sym =  bin . readBit  ( ) ;    data [ k ] =   (  sym << 31 ) | setmask ;    state [  j + off_dl ] |=  STATE_NZ_CTXT_R1 | STATE_D_UR_R1 ;    state [  j + off_dr ] |=  STATE_NZ_CTXT_R1 | STATE_D_UL_R1 ;  if  (  sym != 0 )  {   csj |=     STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 | STATE_V_D_SIGN_R1 ;    state [  j + sscanw ] |=   STATE_NZ_CTXT_R1 | STATE_V_U_R1 | STATE_V_U_SIGN_R1 ;    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 | STATE_H_L_SIGN_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 | STATE_H_R_SIGN_R2 ; } else  {   csj |=    STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 ;    state [  j + sscanw ] |=  STATE_NZ_CTXT_R1 | STATE_V_U_R1 ;    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 ; } } else  {   csj |= STATE_VISITED_R2 ; } }    state [ j ] = csj ; }  if  (  sheight < 3 )  continue ;   j += sscanw ;   csj =  state [ j ] ;  if  (   (   (   (  ~ csj ) &  (  csj << 2 ) ) & SIG_MASK_R1R2 ) != 0 )  {   k =  sk +  (  dscanw << 1 ) ;  if  (   (  csj &  (  STATE_SIG_R1 | STATE_NZ_CTXT_R1 ) ) == STATE_NZ_CTXT_R1 )  {  if  (   bin . readBit  ( ) != 0 )  {   sym =  bin . readBit  ( ) ;    data [ k ] =   (  sym << 31 ) | setmask ;    state [  j + off_ul ] |=  STATE_NZ_CTXT_R2 | STATE_D_DR_R2 ;    state [  j + off_ur ] |=  STATE_NZ_CTXT_R2 | STATE_D_DL_R2 ;  if  (  sym != 0 )  {   csj |=     STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 | STATE_V_U_SIGN_R2 ;    state [  j - sscanw ] |=   STATE_NZ_CTXT_R2 | STATE_V_D_R2 | STATE_V_D_SIGN_R2 ;    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_H_L_SIGN_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_H_R_SIGN_R1 | STATE_D_UR_R2 ; } else  {   csj |=    STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 ;    state [  j - sscanw ] |=  STATE_NZ_CTXT_R2 | STATE_V_D_R2 ;    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_D_UR_R2 ; } } else  {   csj |= STATE_VISITED_R1 ; } }  if  (  sheight < 4 )  {    state [ j ] = csj ;  continue ; }  if  (   (  csj &  (  STATE_SIG_R2 | STATE_NZ_CTXT_R2 ) ) == STATE_NZ_CTXT_R2 )  {   k += dscanw ;  if  (   bin . readBit  ( ) != 0 )  {   sym =  bin . readBit  ( ) ;    data [ k ] =   (  sym << 31 ) | setmask ;    state [  j + off_dl ] |=  STATE_NZ_CTXT_R1 | STATE_D_UR_R1 ;    state [  j + off_dr ] |=  STATE_NZ_CTXT_R1 | STATE_D_UL_R1 ;  if  (  sym != 0 )  {   csj |=     STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 | STATE_V_D_SIGN_R1 ;    state [  j + sscanw ] |=   STATE_NZ_CTXT_R1 | STATE_V_U_R1 | STATE_V_U_SIGN_R1 ;    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 | STATE_H_L_SIGN_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 | STATE_H_R_SIGN_R2 ; } else  {   csj |=    STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 ;    state [  j + sscanw ] |=  STATE_NZ_CTXT_R1 | STATE_V_U_R1 ;    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 ; } } else  {   csj |= STATE_VISITED_R2 ; } }    state [ j ] = csj ; } } }   error = false ;  if  ( isterm )  {   error =  bin . checkBytePadding  ( ) ; }  return error ; }   private boolean magRefPass  (  DataBlk cblk ,  MQDecoder mq ,   int bp ,   int state  [ ] ,  boolean isterm )  {   int  j ,  sj ;   int  k ,  sk ;   int  dscanw ;   int  sscanw ;   int  jstep ;   int  kstep ;   int  stopsk ;   int  csj ;   int  setmask ;   int  resetmask ;   int  sym ;   int  data  [ ] ;   int  s ;   int  nstripes ;   int  sheight ;  boolean  error ;   dscanw =  cblk . scanw ;   sscanw =   cblk . w + 2 ;   jstep =    sscanw * STRIPE_HEIGHT / 2 -  cblk . w ;   kstep =   dscanw * STRIPE_HEIGHT -  cblk . w ;   setmask =   (  1 << bp ) >> 1 ;   resetmask =   (  - 1 ) <<  (  bp + 1 ) ;   data =  (   int  [ ] )  cblk . getData  ( ) ;   nstripes =   (    cblk . h + STRIPE_HEIGHT - 1 ) / STRIPE_HEIGHT ;   sk =  cblk . offset ;   sj =  sscanw + 1 ;  for (  s =  nstripes - 1 ;  s >= 0 ;  s -- ,  sk += kstep ,  sj += jstep )  {   sheight =   (  s != 0 ) ? STRIPE_HEIGHT :   cblk . h -   (  nstripes - 1 ) * STRIPE_HEIGHT ;   stopsk =  sk +  cblk . w ;  for ( ;  sk < stopsk ;  sk ++ ,  sj ++ )  {   j = sj ;   csj =  state [ j ] ;  if  (   (   (   (  csj >>> 1 ) &  (  ~ csj ) ) & VSTD_MASK_R1R2 ) != 0 )  {   k = sk ;  if  (   (  csj &  (  STATE_SIG_R1 | STATE_VISITED_R1 ) ) == STATE_SIG_R1 )  {   sym =  mq . decodeSymbol  (  MR_LUT [  csj & MR_MASK ] ) ;    data [ k ] &= resetmask ;    data [ k ] |=   (  sym << bp ) | setmask ;   csj |= STATE_PREV_MR_R1 ; }  if  (  sheight < 2 )  {    state [ j ] = csj ;  continue ; }  if  (   (  csj &  (  STATE_SIG_R2 | STATE_VISITED_R2 ) ) == STATE_SIG_R2 )  {   k += dscanw ;   sym =  mq . decodeSymbol  (  MR_LUT [   (  csj >>> STATE_SEP ) & MR_MASK ] ) ;    data [ k ] &= resetmask ;    data [ k ] |=   (  sym << bp ) | setmask ;   csj |= STATE_PREV_MR_R2 ; }    state [ j ] = csj ; }  if  (  sheight < 3 )  continue ;   j += sscanw ;   csj =  state [ j ] ;  if  (   (   (   (  csj >>> 1 ) &  (  ~ csj ) ) & VSTD_MASK_R1R2 ) != 0 )  {   k =  sk +  (  dscanw << 1 ) ;  if  (   (  csj &  (  STATE_SIG_R1 | STATE_VISITED_R1 ) ) == STATE_SIG_R1 )  {   sym =  mq . decodeSymbol  (  MR_LUT [  csj & MR_MASK ] ) ;    data [ k ] &= resetmask ;    data [ k ] |=   (  sym << bp ) | setmask ;   csj |= STATE_PREV_MR_R1 ; }  if  (  sheight < 4 )  {    state [ j ] = csj ;  continue ; }  if  (   (   state [ j ] &  (  STATE_SIG_R2 | STATE_VISITED_R2 ) ) == STATE_SIG_R2 )  {   k += dscanw ;   sym =  mq . decodeSymbol  (  MR_LUT [   (  csj >>> STATE_SEP ) & MR_MASK ] ) ;    data [ k ] &= resetmask ;    data [ k ] |=   (  sym << bp ) | setmask ;   csj |= STATE_PREV_MR_R2 ; }    state [ j ] = csj ; } } }   error = false ;  if  (  isterm &&   (  options & OPT_PRED_TERM ) != 0 )  {   error =  mq . checkPredTerm  ( ) ; }  if  (   (  options & OPT_RESET_MQ ) != 0 )  {   mq . resetCtxts  ( ) ; }  return error ; }   private boolean rawMagRefPass  (  DataBlk cblk ,  ByteToBitInput bin ,   int bp ,   int state  [ ] ,  boolean isterm )  {   int  j ,  sj ;   int  k ,  sk ;   int  dscanw ;   int  sscanw ;   int  jstep ;   int  kstep ;   int  stopsk ;   int  csj ;   int  setmask ;   int  resetmask ;   int  sym ;   int  data  [ ] ;   int  s ;   int  nstripes ;   int  sheight ;  boolean  error ;   dscanw =  cblk . scanw ;   sscanw =   cblk . w + 2 ;   jstep =    sscanw * STRIPE_HEIGHT / 2 -  cblk . w ;   kstep =   dscanw * STRIPE_HEIGHT -  cblk . w ;   setmask =   (  1 << bp ) >> 1 ;   resetmask =   (  - 1 ) <<  (  bp + 1 ) ;   data =  (   int  [ ] )  cblk . getData  ( ) ;   nstripes =   (    cblk . h + STRIPE_HEIGHT - 1 ) / STRIPE_HEIGHT ;   sk =  cblk . offset ;   sj =  sscanw + 1 ;  for (  s =  nstripes - 1 ;  s >= 0 ;  s -- ,  sk += kstep ,  sj += jstep )  {   sheight =   (  s != 0 ) ? STRIPE_HEIGHT :   cblk . h -   (  nstripes - 1 ) * STRIPE_HEIGHT ;   stopsk =  sk +  cblk . w ;  for ( ;  sk < stopsk ;  sk ++ ,  sj ++ )  {   j = sj ;   csj =  state [ j ] ;  if  (   (   (   (  csj >>> 1 ) &  (  ~ csj ) ) & VSTD_MASK_R1R2 ) != 0 )  {   k = sk ;  if  (   (  csj &  (  STATE_SIG_R1 | STATE_VISITED_R1 ) ) == STATE_SIG_R1 )  {   sym =  bin . readBit  ( ) ;    data [ k ] &= resetmask ;    data [ k ] |=   (  sym << bp ) | setmask ; }  if  (  sheight < 2 )  continue ;  if  (   (  csj &  (  STATE_SIG_R2 | STATE_VISITED_R2 ) ) == STATE_SIG_R2 )  {   k += dscanw ;   sym =  bin . readBit  ( ) ;    data [ k ] &= resetmask ;    data [ k ] |=   (  sym << bp ) | setmask ; } }  if  (  sheight < 3 )  continue ;   j += sscanw ;   csj =  state [ j ] ;  if  (   (   (   (  csj >>> 1 ) &  (  ~ csj ) ) & VSTD_MASK_R1R2 ) != 0 )  {   k =  sk +  (  dscanw << 1 ) ;  if  (   (  csj &  (  STATE_SIG_R1 | STATE_VISITED_R1 ) ) == STATE_SIG_R1 )  {   sym =  bin . readBit  ( ) ;    data [ k ] &= resetmask ;    data [ k ] |=   (  sym << bp ) | setmask ; }  if  (  sheight < 4 )  continue ;  if  (   (   state [ j ] &  (  STATE_SIG_R2 | STATE_VISITED_R2 ) ) == STATE_SIG_R2 )  {   k += dscanw ;   sym =  bin . readBit  ( ) ;    data [ k ] &= resetmask ;    data [ k ] |=   (  sym << bp ) | setmask ; } } } }   error = false ;  if  (  isterm &&   (  options & OPT_PRED_TERM ) != 0 )  {   error =  bin . checkBytePadding  ( ) ; }  return error ; }   private boolean cleanuppass  (  DataBlk cblk ,  MQDecoder mq ,   int bp ,   int state  [ ] ,   int zc_lut  [ ] ,  boolean isterm )  {   int  j ,  sj ;   int  k ,  sk ;   int  dscanw ;   int  sscanw ;   int  jstep ;   int  kstep ;   int  stopsk ;   int  csj ;   int  setmask ;   int  sym ;   int  rlclen ;   int  ctxt ;   int  data  [ ] ;   int  s ;  boolean  causal ;   int  nstripes ;   int  sheight ;   int  off_ul ,  off_ur ,  off_dr ,  off_dl ;  boolean  error ;   dscanw =  cblk . scanw ;   sscanw =   cblk . w + 2 ;   jstep =    sscanw * STRIPE_HEIGHT / 2 -  cblk . w ;   kstep =   dscanw * STRIPE_HEIGHT -  cblk . w ;   int  one =  1 << bp ;   int  half =  one >> 1 ;   setmask =  
<<<<<<<
one
=======
3
>>>>>>>
 
<<<<<<<
|
=======
<<
>>>>>>>
 
<<<<<<<
half
=======
 (  bp - 1 )
>>>>>>>
 ;   data =  (   int  [ ] )  cblk . getData  ( ) ;   nstripes =   (    cblk . h + STRIPE_HEIGHT - 1 ) / STRIPE_HEIGHT ;   causal =   (  options & OPT_VERT_STR_CAUSAL ) != 0 ;   off_ul =   - sscanw - 1 ;   off_ur =   - sscanw + 1 ;   off_dr =  sscanw + 1 ;   off_dl =  sscanw - 1 ;   sk =  cblk . offset ;   sj =  sscanw + 1 ;  for (  s =  nstripes - 1 ;  s >= 0 ;  s -- ,  sk += kstep ,  sj += jstep )  {   sheight =   (  s != 0 ) ? STRIPE_HEIGHT :   cblk . h -   (  nstripes - 1 ) * STRIPE_HEIGHT ;   stopsk =  sk +  cblk . w ;  for ( ;  sk < stopsk ;  sk ++ ,  sj ++ )  {   j = sj ;   csj =  state [ j ] ;  top_half :  {  if  (    csj == 0 &&   state [  j + sscanw ] == 0 &&  sheight == STRIPE_HEIGHT )  {  if  (   mq . decodeSymbol  ( RLC_CTXT ) != 0 )  {   rlclen =   mq . decodeSymbol  ( UNIF_CTXT ) << 1 ;   rlclen |=  mq . decodeSymbol  ( UNIF_CTXT ) ;   k =  sk +  rlclen * dscanw ;  if  (  rlclen > 1 )  {   j += sscanw ;   csj =  state [ j ] ; } } else  {  continue ; }  if  (   (  rlclen & 0x01 ) == 0 )  {   ctxt =  SC_LUT [   (  csj >> SC_SHIFT_R1 ) & SC_MASK ] ;   sym =   mq . decodeSymbol  (  ctxt & SC_LUT_MASK ) ^  (  ctxt >>> SC_SPRED_SHIFT ) ;    data [ k ] =   (  sym << 31 ) | setmask ;  if  (   rlclen != 0 ||  ! causal )  {    state [  j + off_ul ] |=  STATE_NZ_CTXT_R2 | STATE_D_DR_R2 ;    state [  j + off_ur ] |=  STATE_NZ_CTXT_R2 | STATE_D_DL_R2 ; }  if  (  sym != 0 )  {   csj |=     STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 | STATE_V_U_SIGN_R2 ;  if  (   rlclen != 0 ||  ! causal )  {    state [  j - sscanw ] |=   STATE_NZ_CTXT_R2 | STATE_V_D_R2 | STATE_V_D_SIGN_R2 ; }    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_H_L_SIGN_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_H_R_SIGN_R1 | STATE_D_UR_R2 ; } else  {   csj |=    STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 ;  if  (   rlclen != 0 ||  ! causal )  {    state [  j - sscanw ] |=  STATE_NZ_CTXT_R2 | STATE_V_D_R2 ; }    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_D_UR_R2 ; }  if  (   (  rlclen >> 1 ) != 0 )  {  break top_half ; } } else  {   ctxt =  SC_LUT [   (  csj >> SC_SHIFT_R2 ) & SC_MASK ] ;   sym =   mq . decodeSymbol  (  ctxt & SC_LUT_MASK ) ^  (  ctxt >>> SC_SPRED_SHIFT ) ;    data [ k ] =   (  sym << 31 ) | setmask ;    state [  j + off_dl ] |=  STATE_NZ_CTXT_R1 | STATE_D_UR_R1 ;    state [  j + off_dr ] |=  STATE_NZ_CTXT_R1 | STATE_D_UL_R1 ;  if  (  sym != 0 )  {   csj |=    STATE_SIG_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 | STATE_V_D_SIGN_R1 ;    state [  j + sscanw ] |=   STATE_NZ_CTXT_R1 | STATE_V_U_R1 | STATE_V_U_SIGN_R1 ;    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 | STATE_H_L_SIGN_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 | STATE_H_R_SIGN_R2 ; } else  {   csj |=   STATE_SIG_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 ;    state [  j + sscanw ] |=  STATE_NZ_CTXT_R1 | STATE_V_U_R1 ;    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 ; }    state [ j ] = csj ;  if  (   (  rlclen >> 1 ) != 0 )  {  continue ; }   j += sscanw ;   csj =  state [ j ] ;  break top_half ; } }  if  (   (   (   (  csj >> 1 ) | csj ) & VSTD_MASK_R1R2 ) != VSTD_MASK_R1R2 )  {   k = sk ;  if  (   (  csj &  (  STATE_SIG_R1 | STATE_VISITED_R1 ) ) == 0 )  {  if  (   mq . decodeSymbol  (  zc_lut [  csj & ZC_MASK ] ) != 0 )  {   ctxt =  SC_LUT [   (  csj >>> SC_SHIFT_R1 ) & SC_MASK ] ;   sym =   mq . decodeSymbol  (  ctxt & SC_LUT_MASK ) ^  (  ctxt >>> SC_SPRED_SHIFT ) ;    data [ k ] =   (  sym << 31 ) | setmask ;  if  (  ! causal )  {    state [  j + off_ul ] |=  STATE_NZ_CTXT_R2 | STATE_D_DR_R2 ;    state [  j + off_ur ] |=  STATE_NZ_CTXT_R2 | STATE_D_DL_R2 ; }  if  (  sym != 0 )  {   csj |=     STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 | STATE_V_U_SIGN_R2 ;  if  (  ! causal )  {    state [  j - sscanw ] |=   STATE_NZ_CTXT_R2 | STATE_V_D_R2 | STATE_V_D_SIGN_R2 ; }    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_H_L_SIGN_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_H_R_SIGN_R1 | STATE_D_UR_R2 ; } else  {   csj |=    STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 ;  if  (  ! causal )  {    state [  j - sscanw ] |=  STATE_NZ_CTXT_R2 | STATE_V_D_R2 ; }    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_D_UR_R2 ; } } }  if  (  sheight < 2 )  {   csj &=  ~  (  STATE_VISITED_R1 | STATE_VISITED_R2 ) ;    state [ j ] = csj ;  continue ; }  if  (   (  csj &  (  STATE_SIG_R2 | STATE_VISITED_R2 ) ) == 0 )  {   k += dscanw ;  if  (   mq . decodeSymbol  (  zc_lut [   (  csj >>> STATE_SEP ) & ZC_MASK ] ) != 0 )  {   ctxt =  SC_LUT [   (  csj >>> SC_SHIFT_R2 ) & SC_MASK ] ;   sym =   mq . decodeSymbol  (  ctxt & SC_LUT_MASK ) ^  (  ctxt >>> SC_SPRED_SHIFT ) ;    data [ k ] =   (  sym << 31 ) | setmask ;    state [  j + off_dl ] |=  STATE_NZ_CTXT_R1 | STATE_D_UR_R1 ;    state [  j + off_dr ] |=  STATE_NZ_CTXT_R1 | STATE_D_UL_R1 ;  if  (  sym != 0 )  {   csj |=     STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 | STATE_V_D_SIGN_R1 ;    state [  j + sscanw ] |=   STATE_NZ_CTXT_R1 | STATE_V_U_R1 | STATE_V_U_SIGN_R1 ;    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 | STATE_H_L_SIGN_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 | STATE_H_R_SIGN_R2 ; } else  {   csj |=    STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 ;    state [  j + sscanw ] |=  STATE_NZ_CTXT_R1 | STATE_V_U_R1 ;    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 ; } } } }   csj &=  ~  (  STATE_VISITED_R1 | STATE_VISITED_R2 ) ;    state [ j ] = csj ;  if  (  sheight < 3 )  continue ;   j += sscanw ;   csj =  state [ j ] ; }  if  (   (   (   (  csj >> 1 ) | csj ) & VSTD_MASK_R1R2 ) != VSTD_MASK_R1R2 )  {   k =  sk +  (  dscanw << 1 ) ;  if  (   (  csj &  (  STATE_SIG_R1 | STATE_VISITED_R1 ) ) == 0 )  {  if  (   mq . decodeSymbol  (  zc_lut [  csj & ZC_MASK ] ) != 0 )  {   ctxt =  SC_LUT [   (  csj >> SC_SHIFT_R1 ) & SC_MASK ] ;   sym =   mq . decodeSymbol  (  ctxt & SC_LUT_MASK ) ^  (  ctxt >>> SC_SPRED_SHIFT ) ;    data [ k ] =   (  sym << 31 ) | setmask ;    state [  j + off_ul ] |=  STATE_NZ_CTXT_R2 | STATE_D_DR_R2 ;    state [  j + off_ur ] |=  STATE_NZ_CTXT_R2 | STATE_D_DL_R2 ;  if  (  sym != 0 )  {   csj |=     STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 | STATE_V_U_SIGN_R2 ;    state [  j - sscanw ] |=   STATE_NZ_CTXT_R2 | STATE_V_D_R2 | STATE_V_D_SIGN_R2 ;    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_H_L_SIGN_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_H_R_SIGN_R1 | STATE_D_UR_R2 ; } else  {   csj |=    STATE_SIG_R1 | STATE_VISITED_R1 | STATE_NZ_CTXT_R2 | STATE_V_U_R2 ;    state [  j - sscanw ] |=  STATE_NZ_CTXT_R2 | STATE_V_D_R2 ;    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_L_R1 | STATE_D_UL_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_H_R_R1 | STATE_D_UR_R2 ; } } }  if  (  sheight < 4 )  {   csj &=  ~  (  STATE_VISITED_R1 | STATE_VISITED_R2 ) ;    state [ j ] = csj ;  continue ; }  if  (   (  csj &  (  STATE_SIG_R2 | STATE_VISITED_R2 ) ) == 0 )  {   k += dscanw ;  if  (   mq . decodeSymbol  (  zc_lut [   (  csj >>> STATE_SEP ) & ZC_MASK ] ) != 0 )  {   ctxt =  SC_LUT [   (  csj >>> SC_SHIFT_R2 ) & SC_MASK ] ;   sym =   mq . decodeSymbol  (  ctxt & SC_LUT_MASK ) ^  (  ctxt >>> SC_SPRED_SHIFT ) ;    data [ k ] =   (  sym << 31 ) | setmask ;    state [  j + off_dl ] |=  STATE_NZ_CTXT_R1 | STATE_D_UR_R1 ;    state [  j + off_dr ] |=  STATE_NZ_CTXT_R1 | STATE_D_UL_R1 ;  if  (  sym != 0 )  {   csj |=     STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 | STATE_V_D_SIGN_R1 ;    state [  j + sscanw ] |=   STATE_NZ_CTXT_R1 | STATE_V_U_R1 | STATE_V_U_SIGN_R1 ;    state [  j + 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 | STATE_H_L_SIGN_R2 ;    state [  j - 1 ] |=     STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 | STATE_H_R_SIGN_R2 ; } else  {   csj |=    STATE_SIG_R2 | STATE_VISITED_R2 | STATE_NZ_CTXT_R1 | STATE_V_D_R1 ;    state [  j + sscanw ] |=  STATE_NZ_CTXT_R1 | STATE_V_U_R1 ;    state [  j + 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DL_R1 | STATE_H_L_R2 ;    state [  j - 1 ] |=    STATE_NZ_CTXT_R1 | STATE_NZ_CTXT_R2 | STATE_D_DR_R1 | STATE_H_R_R2 ; } } } }   csj &=  ~  (  STATE_VISITED_R1 | STATE_VISITED_R2 ) ;    state [ j ] = csj ; } }  if  (   (  options & OPT_SEG_SYMBOLS ) != 0 )  {   sym =   mq . decodeSymbol  ( UNIF_CTXT ) << 3 ;   sym |=   mq . decodeSymbol  ( UNIF_CTXT ) << 2 ;   sym |=   mq . decodeSymbol  ( UNIF_CTXT ) << 1 ;   sym |=  mq . decodeSymbol  ( UNIF_CTXT ) ;   error =  sym != SEG_SYMBOL ; } else  {   error = false ; }  if  (  isterm &&   (  options & OPT_PRED_TERM ) != 0 )  {   error =  mq . checkPredTerm  ( ) ; }  if  (   (  options & OPT_RESET_MQ ) != 0 )  {   mq . resetCtxts  ( ) ; }  return error ; }   private void conceal  (  DataBlk cblk ,   int bp )  {   int  l ;   int  k ;   int  kmax ;   int  dk ;   int  data  [ ] ;   int  setmask ;   int  resetmask ;   setmask =  1 << bp ;   resetmask =   (  - 1 ) <<  ( bp ) ;   data =  (   int  [ ] )  cblk . getData  ( ) ;  for (  l =   cblk . h - 1 ,  k =  cblk . offset ;  l >= 0 ;  l -- )  {  for (  kmax =  k +  cblk . w ;  k < kmax ;  k ++ )  {   dk =  data [ k ] ;  if  (   (   dk & resetmask & 0x7FFFFFFF ) != 0 )  {    data [ k ] =   (  dk & resetmask ) | setmask ; } else  {    data [ k ] = 0 ; } }   k +=   cblk . scanw -  cblk . w ; } } }