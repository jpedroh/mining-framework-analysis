  package    pitt . search . semanticvectors . vectors ;   import   java . io . IOException ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . Random ;  import     java . util . concurrent . atomic . AtomicBoolean ;  import     java . util . concurrent . atomic . AtomicInteger ;  import    java . util . logging . Logger ;  import     org . apache . lucene . search . DocIdSetIterator ;  import     org . apache . lucene . store . IndexInput ;  import     org . apache . lucene . store . IndexOutput ;  import     org . apache . lucene . util . FixedBitSet ;   public class BinaryVector  implements  Vector  {   public enum BinaryNormalizationMethod  {  SPATTERCODE ,  PROBABILISTIC }   public static BinaryNormalizationMethod  NORMALIZE_METHOD =  BinaryNormalizationMethod . SPATTERCODE ;   public static void setNormalizationMethod  (  BinaryNormalizationMethod normalizationMethod )  {   logger . info  (   "Globally setting binary vector NORMALIZATION_METHOD to: '" + normalizationMethod + "'" ) ;   NORMALIZE_METHOD = normalizationMethod ; }   public static final Logger  logger =  Logger . getLogger  (   BinaryVector . class . getCanonicalName  ( ) ) ;   public VectorType getVectorType  ( )  {  return  VectorType . BINARY ; }   public static final  int  BINARY_VECTOR_DECIMAL_PLACES = 2 ;   public static final boolean  BINARY_BINDING_WITH_PERMUTE = false ;   private static  int  DEBUG_PRINT_LENGTH = 64 ;   private Random  random ;   private final  int  dimension ;   protected FixedBitSet  bitSet ;   private boolean  isSparse ;   private AtomicBoolean  unTallied =  new AtomicBoolean  ( true ) ;   private  ArrayList  < FixedBitSet >  votingRecord ;  AtomicInteger  totalNumberOfVotes =  new AtomicInteger  ( 0 ) ;   int  minimum = 0 ;   private FixedBitSet  tempSet ;   public BinaryVector  (   int dimension )  {  if  (   dimension % 64 != 0 )  {  throw  new IllegalArgumentException  (   "Dimension should be a multiple of 64: " + dimension + " will lead to trouble!" ) ; }    this . dimension = dimension ;    this . bitSet =  new FixedBitSet  ( dimension ) ;    this . isSparse = true ;    this . random =  new Random  ( ) ; }    @ SuppressWarnings  ( "unchecked" ) public BinaryVector copy  ( )  {  BinaryVector  copy =  new BinaryVector  ( dimension ) ;    copy . bitSet =  ( FixedBitSet )  bitSet . clone  ( ) ;  if  (  ! isSparse )    copy . votingRecord =  (  ArrayList  < FixedBitSet > )  votingRecord . clone  ( ) ;  if  (  tempSet != null )  {    copy . tempSet =  tempSet . clone  ( ) ; }    copy . minimum = minimum ;    copy . totalNumberOfVotes =  new AtomicInteger  (  totalNumberOfVotes . intValue  ( ) ) ;    copy . unTallied =  new AtomicBoolean  (  unTallied . get  ( ) ) ;    copy . isSparse = isSparse ;  return copy ; }   public String toString  ( )  {  StringBuilder  debugString =  new StringBuilder  ( "" ) ;  if  ( isSparse )  {   debugString . append  (   "  Sparse.  First " + DEBUG_PRINT_LENGTH + " values are:\n" ) ;  for (   int  x = 0 ;  x < DEBUG_PRINT_LENGTH ;  x ++ )   debugString . append  (   bitSet . get  ( x ) ? "1 " : "0 " ) ;   debugString . append  (   "\nCardinality " +  bitSet . cardinality  ( ) + "\n" ) ; } else  {   debugString . append  (   "  Dense.  First " + DEBUG_PRINT_LENGTH + " values are:\n" ) ;  for (   int  x = 0 ;  x < DEBUG_PRINT_LENGTH ;  x ++ )   debugString . append  (   bitSet . get  ( x ) ? "1" : "0" ) ;   debugString . append  ( "\nVOTING RECORD: \n" ) ;  for (   int  y = 0 ;  y <  votingRecord . size  ( ) ;  y ++ )  {  for (   int  x = 0 ;  x < DEBUG_PRINT_LENGTH ;  x ++ )   debugString . append  (    votingRecord . get  ( y ) . get  ( x ) ? "1 " : "0 " ) ;   debugString . append  ( "\n" ) ; }    double  [ ]  actualvals =  new  double  [ DEBUG_PRINT_LENGTH ] ;   debugString . append  ( "COUNTS    : " ) ;  for (   int  x = 0 ;  x <  votingRecord . size  ( ) ;  x ++ )  {  for (   int  y = 0 ;  y < DEBUG_PRINT_LENGTH ;  y ++ )  {  if  (   votingRecord . get  ( x ) . get  ( y ) )    actualvals [ y ] +=  Math . pow  ( 2 , x ) ; } }  for (   int  x = 0 ;  x < DEBUG_PRINT_LENGTH ;  x ++ )  {   debugString . append  (   (  int )  (   (  minimum +  actualvals [ x ] ) /  Math . pow  ( 10 , BINARY_VECTOR_DECIMAL_PLACES ) ) + " " ) ; }   debugString . append  ( "\nNORMALIZED: " ) ;   this . normalize  ( ) ;  for (   int  x = 0 ;  x < DEBUG_PRINT_LENGTH ;  x ++ )   debugString . append  (   bitSet . get  ( x ) + " " ) ;   debugString . append  ( "\n" ) ;   debugString . append  (   "\nCardinality " +  bitSet . cardinality  ( ) + "\n" ) ;   debugString . append  (   "Votes " +  totalNumberOfVotes . get  ( ) + "\n" ) ;   debugString . append  (   "Minimum " + minimum + "\n" ) ;   debugString . append  ( "\n" ) ; }  return  debugString . toString  ( ) ; }    @ Override public  int getDimension  ( )  {  return dimension ; }   public BinaryVector createZeroVector  (   int dimension )  {  if  (   dimension % 64 != 0 )  {   logger . severe  (   "Dimension should be a multiple of 64: " + dimension + " will lead to trouble!" ) ; }  return  new BinaryVector  ( dimension ) ; }    @ Override public boolean isZeroVector  ( )  {  if  ( isSparse )  {  return   bitSet . cardinality  ( ) == 0 ; } else  {  return    (  votingRecord == null ) ||  (   votingRecord . size  ( ) == 0 ) ||  (    votingRecord . size  ( ) == 1 &&    votingRecord . get  ( 0 ) . cardinality  ( ) == 0 ) ; } }    @ Override public BinaryVector generateRandomVector  (   int dimension ,   int numEntries ,  Random random )  {  if  (   dimension % 64 != 0 )  {  throw  new IllegalArgumentException  (   "Dimension should be a multiple of 64: " + dimension + " will lead to trouble!" ) ; }  if  (  numEntries !=  dimension / 2 )  {   logger . severe  (   "Attempting to create binary vector with unequal number of zeros and ones." + " Unlikely to produce meaningful results. Therefore, seedlength has been set to " + " dimension/2, as recommended for binary vectors" ) ;   numEntries =  dimension / 2 ; }  BinaryVector  randomVector =  new BinaryVector  ( dimension ) ;    randomVector . bitSet =  new FixedBitSet  ( dimension ) ;   ArrayList  < Integer >  dimensions =  new  ArrayList  < Integer >  ( ) ;  for (   int  q = 0 ;  q < dimension ;  q ++ )   dimensions . add  ( q ) ;   Collections . shuffle  ( dimensions , random ) ;  for (   int  r = 0 ;  r < numEntries ;  r ++ )  {   int  testPlace =  dimensions . get  ( r ) ;    randomVector . bitSet . set  ( testPlace ) ; }  return randomVector ; }    @ Override public  double measureOverlap  (  Vector other )  {   IncompatibleVectorsException . checkVectorsCompatible  ( this , other ) ;  if  (  isZeroVector  ( ) )  return 0 ;  BinaryVector  binaryOther =  ( BinaryVector ) other ;  if  (  binaryOther . isZeroVector  ( ) )  return 0 ;   double  hammingDistance =  BinaryVectorUtils . xorCount  (  this . bitSet ,  binaryOther . bitSet ) ;  return  2 *  (  0.5 -  (  hammingDistance /  (  double ) dimension ) ) ; }    @ Override public synchronized void superpose  (  Vector other ,   double weight ,    int  [ ] permutation )  {   IncompatibleVectorsException . checkVectorsCompatible  ( this , other ) ;  if  (  weight == 0d )  return ;  if  (  other . isZeroVector  ( ) )  return ;  BinaryVector  binaryOther =  ( BinaryVector ) other ;  boolean  flippedBitSet = false ;  if  (  weight < 0 )  {   weight =  Math . abs  ( weight ) ;    binaryOther . bitSet . flip  ( 0 ,  binaryOther . getDimension  ( ) ) ;   flippedBitSet = true ; }  if  ( isSparse )  {   elementalToSemantic  ( ) ; }  if  (  permutation != null )  {  if  (   permutation . length !=  dimension / 64 )  {  throw  new IllegalArgumentException  (      "Binary vector of dimension " + dimension + " must have permutation of length " +  dimension / 64 + " not " +  permutation . length ) ; }  BinaryVector  temp =  binaryOther . copy  ( ) ;   temp . permute  ( permutation ) ;   superposeBitSet  (  temp . bitSet , weight ) ; } else  {   superposeBitSet  (  binaryOther . bitSet , weight ) ; }  if  ( flippedBitSet )    binaryOther . bitSet . flip  ( 0 ,  binaryOther . getDimension  ( ) ) ;   unTallied . set  ( true ) ; }   protected synchronized void superposeBitSet  (  FixedBitSet incomingBitSet ,   double weight )  {   weight =  (  int )  Math . round  (  weight *  Math . pow  ( 10 , BINARY_VECTOR_DECIMAL_PLACES ) ) ;  if  (  weight == 0 )  return ;  if  (    (  long )  totalNumberOfVotes . get  ( ) +  (  long ) weight >  Integer . MAX_VALUE )  {    System . err . println  ( "Overflow error" ) ;    System . err . println  ( this ) ; } else   totalNumberOfVotes . set  (   totalNumberOfVotes . get  ( ) +  (  int ) weight ) ;   int  logFloorOfWeight =  (  int )  (  Math . floor  (   Math . log  ( weight ) /  Math . log  ( 2 ) ) ) ;  if  (  logFloorOfWeight <   votingRecord . size  ( ) - 1 )  {  while  (  logFloorOfWeight > 0 )  {   superposeBitSetFromRowFloor  ( incomingBitSet , logFloorOfWeight ) ;   weight =  weight -  (  int )  Math . pow  ( 2 , logFloorOfWeight ) ;   logFloorOfWeight =  (  int )  (  Math . floor  (   Math . log  ( weight ) /  Math . log  ( 2 ) ) ) ; } }  for (   int  x = 0 ;  x < weight ;  x ++ )   superposeBitSetFromRowFloor  ( incomingBitSet , 0 ) ; }   protected synchronized void superposeBitSetFromRowFloor  (  FixedBitSet incomingBitSet ,   int rowfloor )  {   int  max =  getMaximumSharedWeight  ( ) ;  if  (  max > 0 )  {   decrement  ( max ) ; }   tempSet . xor  ( tempSet ) ;   tempSet . xor  ( incomingBitSet ) ;  for (   int  x = rowfloor ;   x <  votingRecord . size  ( ) &&   tempSet . cardinality  ( ) > 0 ;  x ++ )  {   tempSet . and  (  votingRecord . get  ( x ) ) ; }  if  (   tempSet . cardinality  ( ) > 0 )  {   votingRecord . add  (  new FixedBitSet  ( dimension ) ) ; }    votingRecord . get  ( rowfloor ) . xor  ( incomingBitSet ) ;   tempSet . xor  ( tempSet ) ;   tempSet . xor  ( incomingBitSet ) ;  for (   int  x =  rowfloor + 1 ;  x <  votingRecord . size  ( ) ;  x ++ )  {   tempSet . andNot  (  votingRecord . get  (  x - 1 ) ) ;    votingRecord . get  ( x ) . xor  ( tempSet ) ; } }   public static String reverse  (  String str )  {  if  (   (  null == str ) ||  (   str . length  ( ) <= 1 ) )  {  return str ; }  return    new StringBuffer  ( str ) . reverse  ( ) . toString  ( ) ; }   private synchronized void setTempSetToExactMatches  (   int target )  {  if  (  target == 0 )  {   tempSet . set  ( 0 , dimension ) ;   tempSet . xor  (  votingRecord . get  ( 0 ) ) ;  for (   int  x = 1 ;  x <  votingRecord . size  ( ) ;  x ++ )   tempSet . andNot  (  votingRecord . get  ( x ) ) ; } else  {  String  inbinary =  reverse  (  Integer . toBinaryString  ( target ) ) ;   tempSet . xor  ( tempSet ) ;  try  {   tempSet . xor  (  votingRecord . get  (  inbinary . indexOf  ( "1" ) ) ) ; }  catch (   Exception e )  {   e . printStackTrace  ( ) ; }  for (   int  q = 0 ;  q <  votingRecord . size  ( ) ;  q ++ )  {  if  (   q <  inbinary . length  ( ) &&   inbinary . charAt  ( q ) == '1' )   tempSet . and  (  votingRecord . get  ( q ) ) ; else   tempSet . andNot  (  votingRecord . get  ( q ) ) ; } } }   protected synchronized FixedBitSet concludeVote  ( )  {  if  (    votingRecord . size  ( ) == 0 ||    votingRecord . size  ( ) == 1 &&    votingRecord . get  ( 0 ) . cardinality  ( ) == 0 )  return  new FixedBitSet  ( dimension ) ; else  return  concludeVote  (  totalNumberOfVotes . get  ( ) ) ; }   protected synchronized FixedBitSet concludeVote  (   int target )  {   int  target2 =  (  int )  Math . ceil  (   (  double ) target /  (  double ) 2 ) ;   target2 =  target2 - minimum ;  if  (  target2 < 0 )  {  FixedBitSet  ans =  new FixedBitSet  ( dimension ) ;   ans . set  ( 0 , dimension ) ;  return ans ; }  boolean  even =  (   target % 2 == 0 ) ;  FixedBitSet  result =  concludeVote  ( target2 ,   votingRecord . size  ( ) - 1 ) ;  if  ( even )  {   setTempSetToExactMatches  ( target2 ) ;  boolean  switcher = true ;   int  q =  tempSet . nextSetBit  ( 0 ) ;  while  (  q !=  DocIdSetIterator . NO_MORE_DOCS )  {   switcher =  ! switcher ;  if  ( switcher )   tempSet . clear  ( q ) ;  if  (   q + 1 >=  tempSet . length  ( ) )   q =  DocIdSetIterator . NO_MORE_DOCS ; else   q =  tempSet . nextSetBit  (  q + 1 ) ; }   result . andNot  ( tempSet ) ; }  return result ; }   protected synchronized FixedBitSet concludeVote  (   int target ,   int row_ceiling )  {  if  (  target == 0 )  {  FixedBitSet  atLeastZero =  new FixedBitSet  ( dimension ) ;   atLeastZero . set  ( 0 , dimension ) ;  return atLeastZero ; }   double  rowfloor =   Math . log  ( target ) /  Math . log  ( 2 ) ;   int  row_floor =  (  int )  Math . floor  ( rowfloor ) ;   int  remainder =  target -  (  int )  Math . pow  ( 2 , row_floor ) ;  if  (  row_floor >=  votingRecord . size  ( ) )  {  return  new FixedBitSet  ( dimension ) ; }  if  (   row_ceiling == 0 &&  target == 1 )  {  return  votingRecord . get  ( 0 ) ; }  if  (  remainder == 0 )  {  FixedBitSet  definitePositives =  new FixedBitSet  ( dimension ) ;  for (   int  q = row_floor ;  q <= row_ceiling ;  q ++ )   definitePositives . or  (  votingRecord . get  ( q ) ) ;  return definitePositives ; } else  {  FixedBitSet  definitePositives =  new FixedBitSet  ( dimension ) ;  for (   int  q =  row_floor + 1 ;  q <= row_ceiling ;  q ++ )   definitePositives . or  (  votingRecord . get  ( q ) ) ;  FixedBitSet  possiblePositives =  ( FixedBitSet )   votingRecord . get  ( row_floor ) . clone  ( ) ;  FixedBitSet  definitePositives2 =  concludeVote  ( remainder ,  row_floor - 1 ) ;   possiblePositives . and  ( definitePositives2 ) ;   definitePositives . or  ( possiblePositives ) ;  return definitePositives ; } }   public synchronized void decrement  ( )  {   tempSet . set  ( 0 , dimension ) ;  for (   int  q = 0 ;  q <  votingRecord . size  ( ) ;  q ++ )  {    votingRecord . get  ( q ) . xor  ( tempSet ) ;   tempSet . and  (  votingRecord . get  ( q ) ) ; } }   public synchronized void decrement  (   int weight )  {  if  (  weight == 0 )  return ;   minimum += weight ;   int  logfloor =  (  int )  (  Math . floor  (   Math . log  ( weight ) /  Math . log  ( 2 ) ) ) ;  if  (  logfloor <   votingRecord . size  ( ) - 1 )  {  while  (  logfloor > 0 )  {   selectedDecrement  ( logfloor ) ;   weight =  weight -  (  int )  Math . pow  ( 2 , logfloor ) ;   logfloor =  (  int )  (  Math . floor  (   Math . log  ( weight ) /  Math . log  ( 2 ) ) ) ; } }  for (   int  x = 0 ;  x < weight ;  x ++ )  {   decrement  ( ) ; } }   public synchronized void selectedDecrement  (   int floor )  {   tempSet . set  ( 0 , dimension ) ;  for (   int  q = floor ;  q <  votingRecord . size  ( ) ;  q ++ )  {    votingRecord . get  ( q ) . xor  ( tempSet ) ;   tempSet . and  (  votingRecord . get  ( q ) ) ; } }   protected synchronized  int getMaximumSharedWeight  ( )  {   int  thismaximum = 0 ;   tempSet . xor  ( tempSet ) ;  for (   int  x =   votingRecord . size  ( ) - 1 ;  x >= 0 ;  x -- )  {   tempSet . or  (  votingRecord . get  ( x ) ) ;  if  (   tempSet . cardinality  ( ) == dimension )  {   thismaximum +=  (  int )  Math . pow  ( 2 , x ) ;   tempSet . xor  ( tempSet ) ; } }  return thismaximum ; }   public void bind  (  Vector other ,   int direction )  {   IncompatibleVectorsException . checkVectorsCompatible  ( this , other ) ;  BinaryVector  binaryOther =  ( BinaryVector )  other . copy  ( ) ;  if  (  direction > 0 )  {   this . permute  (  PermutationUtils . getShiftPermutation  (  VectorType . BINARY , dimension , 1 ) ) ;    this . bitSet . xor  (  binaryOther . bitSet ) ; } else  {    this . bitSet . xor  (  binaryOther . bitSet ) ;   this . permute  (  PermutationUtils . getShiftPermutation  (  VectorType . BINARY , dimension ,  - 1 ) ) ; } }   public void release  (  Vector other ,   int direction )  {  if  (  ! BINARY_BINDING_WITH_PERMUTE )   bind  ( other ) ; else   bind  ( other , direction ) ; }    @ Override public void bind  (  Vector other )  {   IncompatibleVectorsException . checkVectorsCompatible  ( this , other ) ;  if  (  ! BINARY_BINDING_WITH_PERMUTE )  {  BinaryVector  binaryOther =  ( BinaryVector ) other ;    this . bitSet . xor  (  binaryOther . bitSet ) ; } else  {   bind  ( other , 1 ) ; } }    @ Override public void release  (  Vector other )  {  if  (  ! BINARY_BINDING_WITH_PERMUTE )   bind  ( other ) ; else   bind  ( other ,  - 1 ) ; }    @ Override public synchronized void normalize  ( )  {  if  (  votingRecord == null )  return ;  if  (   votingRecord . size  ( ) == 1 )  {    this . bitSet =  votingRecord . get  ( 0 ) ;  return ; }  if  (  NORMALIZE_METHOD . equals  (  BinaryNormalizationMethod . SPATTERCODE ) )  {    this . bitSet =  concludeVote  ( ) ; } else  {    this . bitSet . xor  (  this . bitSet ) ;   long  theSuperpositionSeed = 0 ;  for (   int  q = 0 ;  q <  votingRecord . size  ( ) ;  q ++ )   theSuperpositionSeed +=    votingRecord . get  ( q ) . getBits  ( ) [ 0 ] ;   random . setSeed  ( theSuperpositionSeed ) ;   int  max =  totalNumberOfVotes . get  ( ) ;   int  maxpossiblevotesonrecord = 0 ;  for (   int  q = 0 ;  q <  votingRecord . size  ( ) ;  q ++ )   maxpossiblevotesonrecord +=  Math . pow  ( 2 , q ) ;  for (   int  x = 1 ;  x <= maxpossiblevotesonrecord ;  x ++ )  {   this . setTempSetToExactMatches  ( x ) ;  if  (    this . tempSet . cardinality  ( ) == 0 )  continue ;   int  y =  tempSet . nextSetBit  ( 0 ) ;   double  votes =  minimum + x ;   double  z =   (  votes -  (  max / 2 ) ) /  (   Math . sqrt  ( max ) / 2 ) ;   double  proportion =  erf  (  z /  Math . sqrt  ( 2 ) ) ;   proportion =   (  1 + proportion ) / 2 ;  while  (  y !=  DocIdSetIterator . NO_MORE_DOCS )  {  if  (   (  random . nextDouble  ( ) ) <= proportion )    this . bitSet . set  ( y ) ;   y ++ ;  if  (  y ==  this . dimension )  break ;   y =  tempSet . nextSetBit  ( y ) ; } } }   votingRecord =  new  ArrayList  < FixedBitSet >  ( ) ;   votingRecord . add  (  ( FixedBitSet )  bitSet . clone  ( ) ) ;   totalNumberOfVotes . set  ( 1 ) ;   tempSet =  new FixedBitSet  ( dimension ) ;   minimum = 0 ; }   public  double erf  (   double z )  {   double  sign =  Math . signum  ( z ) ;   z =  Math . abs  ( z ) ;   double  a1 = 0.278393 ,  a2 = 0.230389 ,  a3 = 0.000972 ,  a4 = 0.078108 ;   double  sumterm =     1 +  a1 * z +  a2 *  Math . pow  ( z , 2 ) +  a3 *  Math . pow  ( z , 3 ) +  a4 *  Math . pow  ( z , 4 ) ;  return  sign *  (  1 -  1 /  (  Math . pow  ( sumterm , 4 ) ) ) ; }   public synchronized void normalizeBSC  ( )  {  if  (  ! isSparse )    this . bitSet =  concludeVote  ( ) ;   votingRecord =  new  ArrayList  < FixedBitSet >  ( ) ;   votingRecord . add  (  ( FixedBitSet )  bitSet . clone  ( ) ) ;   totalNumberOfVotes . set  ( 1 ) ;   tempSet =  new FixedBitSet  ( dimension ) ;   minimum = 0 ; }   public synchronized void tallyVotes  ( )  {  if  ( isSparse )   elementalToSemantic  ( ) ;  if  (  unTallied . get  ( ) )  try  {    this . bitSet =  concludeVote  ( ) ;   unTallied . set  ( false ) ; }  catch (   Exception e )  {   e . printStackTrace  ( ) ; } }    @ Override public void writeToLuceneStream  (  IndexOutput outputStream )  {  if  ( isSparse )  {   elementalToSemantic  ( ) ; }    long  [ ]  bitArray =  bitSet . getBits  ( ) ;  for (   int  i = 0 ;  i <  bitArray . length ;  i ++ )  {  try  {   outputStream . writeLong  (  bitArray [ i ] ) ; }  catch (   IOException e )  {   logger . severe  ( "Couldn't write binary vector to lucene output stream." ) ;   e . printStackTrace  ( ) ; } } }   public void writeToLuceneStream  (  IndexOutput outputStream ,   int k )  {  if  ( isSparse )  {   elementalToSemantic  ( ) ; }    long  [ ]  bitArray =  bitSet . getBits  ( ) ;  for (   int  i = 0 ;  i <  k / 64 ;  i ++ )  {  try  {   outputStream . writeLong  (  bitArray [ i ] ) ; }  catch (   IOException e )  {   logger . severe  ( "Couldn't write binary vector to lucene output stream." ) ;   e . printStackTrace  ( ) ; } } }    @ Override public void readFromLuceneStream  (  IndexInput inputStream )  {   long  bitArray  [ ] =  new  long  [  (  dimension / 64 ) ] ;  for (   int  i = 0 ;  i <  dimension / 64 ;  ++ i )  {  try  {    bitArray [ i ] =  inputStream . readLong  ( ) ; }  catch (   IOException e )  {   logger . severe  ( "Couldn't read binary vector from lucene output stream." ) ;   e . printStackTrace  ( ) ; } }    this . bitSet =  new FixedBitSet  ( bitArray , dimension ) ;    this . isSparse = true ; }    @ Override public String writeToString  ( )  {  StringBuilder  builder =  new StringBuilder  ( ) ;  for (   int  i = 0 ;  i < dimension ;  ++ i )  {   builder . append  (    this . bitSet . get  ( i ) ? "1" : "0" ) ; }  return  builder . toString  ( ) ; }   public String writeLongToString  ( )  {  StringBuilder  builder =  new StringBuilder  ( ) ;  for (   int  i = 0 ;  i <  (   bitSet . getBits  ( ) . length ) ;  ++ i )  {   builder . append  (   Long . toString  (   bitSet . getBits  ( ) [ i ] ) + "|" ) ; }  return  builder . toString  ( ) ; }    @ Override public void readFromString  (  String input )  {  if  (   input . length  ( ) != dimension )  {  throw  new IllegalArgumentException  (     "Found " +  (  input . length  ( ) ) + " possible coordinates: " + "expected " + dimension ) ; }  for (   int  i = 0 ;  i < dimension ;  ++ i )  {  if  (   input . charAt  ( i ) == '1' )   bitSet . set  ( i ) ; } }   protected void elementalToSemantic  ( )  {  if  (  ! isSparse )  {   logger . warning  (  "Tried to transform an elemental vector which is not in fact elemental." + "This may be a programming error." ) ;  return ; }   votingRecord =  new  ArrayList  < FixedBitSet >  ( ) ;   tempSet =  new FixedBitSet  ( dimension ) ;  if  (   bitSet . cardinality  ( ) != 0 )   this . superposeBitSet  (  bitSet . clone  ( ) , 1 ) ;   isSparse = false ; }   public void permute  (    int  [ ] permutation )  {  if  (   permutation . length !=   getDimension  ( ) / 64 )  {  throw  new IllegalArgumentException  (      "Binary vector of dimension " +  getDimension  ( ) + " must have permutation of length " +   getDimension  ( ) / 64 + " not " +  permutation . length ) ; }    long  [ ]  coordinates =  bitSet . getBits  ( ) ;    long  [ ]  newCoordinates =  new  long  [  coordinates . length ] ;  for (   int  i = 0 ;  i <  coordinates . length ;  ++ i )  {   int  positionToAdd = i ;   positionToAdd =  permutation [ positionToAdd ] ;    newCoordinates [ i ] =  coordinates [ positionToAdd ] ; }   bitSet =  new FixedBitSet  ( newCoordinates ,  getDimension  ( ) ) ; }   protected BinaryVector  (  FixedBitSet inSet )  {    this . dimension =  (  int )  inSet . length  ( ) ;    this . bitSet = inSet ; }   protected  int bitLength  ( )  {  return   bitSet . getBits  ( ) . length ; }   protected  int numRows  ( )  {  if  ( isSparse )  return 0 ;  return  votingRecord . size  ( ) ; }   public FixedBitSet getCoordinates  ( )  {  return  this . bitSet ; }   protected void setCoordinates  (  FixedBitSet incomingBitSet )  {    this . bitSet = incomingBitSet ; }   public static void setDebugPrintLength  (   int length )  {   DEBUG_PRINT_LENGTH = length ; } }