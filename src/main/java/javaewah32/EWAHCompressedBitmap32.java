  package javaewah32 ;   import  java . util .  * ;  import  java . io .  * ;  import  javaewah . IntIterator ;   public final class EWAHCompressedBitmap32  implements  Cloneable , Externalizable ,  Iterable  < Integer > , BitmapStorage32  {   public EWAHCompressedBitmap32  ( )  {    this . buffer =  new  int  [ defaultbuffersize ] ;    this . rlw =  new RunningLengthWord32  (  this . buffer , 0 ) ; }   public EWAHCompressedBitmap32  (   final  int buffersize )  {    this . buffer =  new  int  [ buffersize ] ;    this . rlw =  new RunningLengthWord32  (  this . buffer , 0 ) ; }   private EWAHIterator32 getEWAHIterator  ( )  {  return  new EWAHIterator32  (  this . buffer ,  this . actualsizeinwords ) ; }   public EWAHCompressedBitmap32 xor  (   final EWAHCompressedBitmap32 a )  {   final EWAHCompressedBitmap32  container =  new EWAHCompressedBitmap32  ( ) ;   container . reserve  (   this . actualsizeinwords +  a . actualsizeinwords ) ;   xor  ( a , container ) ;  return container ; }   private void xor  (   final EWAHCompressedBitmap32 a ,   final BitmapStorage32 container )  {   final EWAHIterator32  i =  a . getEWAHIterator  ( ) ;   final EWAHIterator32  j =  getEWAHIterator  ( ) ;  if  (  !  (   i . hasNext  ( ) &&  j . hasNext  ( ) ) )  {   container . setSizeInBits  (  sizeInBits  ( ) ) ; }  BufferedRunningLengthWord32  rlwi =  new BufferedRunningLengthWord32  (  i . next  ( ) ) ;  BufferedRunningLengthWord32  rlwj =  new BufferedRunningLengthWord32  (  j . next  ( ) ) ;  while  ( true )  {   final boolean  i_is_prey =   rlwi . size  ( ) <  rlwj . size  ( ) ;   final BufferedRunningLengthWord32  prey =  i_is_prey ? rlwi : rlwj ;   final BufferedRunningLengthWord32  predator =  i_is_prey ? rlwj : rlwi ;  if  (   prey . getRunningBit  ( ) == false )  {   final  int  predatorrl =  predator . getRunningLength  ( ) ;   final  int  preyrl =  prey . getRunningLength  ( ) ;   final  int  tobediscarded =   (  predatorrl >= preyrl ) ? preyrl : predatorrl ;   container . addStreamOfEmptyWords  (  predator . getRunningBit  ( ) , tobediscarded ) ;   final  int  dw_predator =   predator . dirtywordoffset +  (  i_is_prey ?  j . dirtyWords  ( ) :  i . dirtyWords  ( ) ) ;   container . addStreamOfDirtyWords  (  i_is_prey ?  j . buffer  ( ) :  i . buffer  ( ) , dw_predator ,  preyrl - tobediscarded ) ;   predator . discardFirstWords  ( preyrl ) ;   prey . discardFirstWords  ( preyrl ) ; } else  {   final  int  predatorrl =  predator . getRunningLength  ( ) ;   final  int  preyrl =  prey . getRunningLength  ( ) ;   final  int  tobediscarded =   (  predatorrl >= preyrl ) ? preyrl : predatorrl ;   container . addStreamOfEmptyWords  (  !  predator . getRunningBit  ( ) , tobediscarded ) ;   final  int  dw_predator =   predator . dirtywordoffset +  (  i_is_prey ?  j . dirtyWords  ( ) :  i . dirtyWords  ( ) ) ;   final   int  [ ]  buf =  i_is_prey ?  j . buffer  ( ) :  i . buffer  ( ) ;  for (   int  k = 0 ;  k <  preyrl - tobediscarded ;  ++ k )   container . add  (  ~  buf [  k + dw_predator ] ) ;   predator . discardFirstWords  ( preyrl ) ;   prey . discardFirstWords  ( preyrl ) ; }   final  int  predatorrl =  predator . getRunningLength  ( ) ;  if  (  predatorrl > 0 )  {  if  (   predator . getRunningBit  ( ) == false )  {   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;   final  int  tobediscarded =   (  predatorrl >= nbre_dirty_prey ) ? nbre_dirty_prey : predatorrl ;   final  int  dw_prey =   prey . dirtywordoffset +  (  i_is_prey ?  i . dirtyWords  ( ) :  j . dirtyWords  ( ) ) ;   predator . discardFirstWords  ( tobediscarded ) ;   prey . discardFirstWords  ( tobediscarded ) ;   container . addStreamOfDirtyWords  (  i_is_prey ?  i . buffer  ( ) :  j . buffer  ( ) , dw_prey , tobediscarded ) ; } else  {   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;   final  int  tobediscarded =   (  predatorrl >= nbre_dirty_prey ) ? nbre_dirty_prey : predatorrl ;   final  int  dw_prey =   prey . dirtywordoffset +  (  i_is_prey ?  i . dirtyWords  ( ) :  j . dirtyWords  ( ) ) ;   predator . discardFirstWords  ( tobediscarded ) ;   prey . discardFirstWords  ( tobediscarded ) ;   final   int  [ ]  buf =  i_is_prey ?  i . buffer  ( ) :  j . buffer  ( ) ;  for (   int  k = 0 ;  k < tobediscarded ;  ++ k )   container . add  (  ~  buf [  k + dw_prey ] ) ; } }   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;  if  (  nbre_dirty_prey > 0 )  {  for (   int  k = 0 ;  k < nbre_dirty_prey ;  ++ k )  {  if  ( i_is_prey )   container . add  (    i . buffer  ( ) [    prey . dirtywordoffset +  i . dirtyWords  ( ) + k ] ^   j . buffer  ( ) [    predator . dirtywordoffset +  j . dirtyWords  ( ) + k ] ) ; else   container . add  (    i . buffer  ( ) [    predator . dirtywordoffset +  i . dirtyWords  ( ) + k ] ^   j . buffer  ( ) [    prey . dirtywordoffset +  j . dirtyWords  ( ) + k ] ) ; }   predator . discardFirstWords  ( nbre_dirty_prey ) ; }  if  ( i_is_prey )  {  if  (  !  i . hasNext  ( ) )  {   rlwi = null ;  break ; }   rlwi . reset  (  i . next  ( ) ) ; } else  {  if  (  !  j . hasNext  ( ) )  {   rlwj = null ;  break ; }   rlwj . reset  (  j . next  ( ) ) ; } }  if  (  rlwi != null )   discharge  ( rlwi , i , container ) ;  if  (  rlwj != null )   discharge  ( rlwj , j , container ) ;   container . setSizeInBits  (  Math . max  (  sizeInBits  ( ) ,  a . sizeInBits  ( ) ) ) ; }   public EWAHCompressedBitmap32 and  (   final EWAHCompressedBitmap32 a )  {   final EWAHCompressedBitmap32  container =  new EWAHCompressedBitmap32  ( ) ;   container . reserve  (    this . actualsizeinwords >  a . actualsizeinwords ?  this . actualsizeinwords :  a . actualsizeinwords ) ;   and  ( a , container ) ;  return container ; }   private void and  (   final EWAHCompressedBitmap32 a ,   final BitmapStorage32 container )  {   final EWAHIterator32  i =  a . getEWAHIterator  ( ) ;   final EWAHIterator32  j =  getEWAHIterator  ( ) ;  if  (  !  (   i . hasNext  ( ) &&  j . hasNext  ( ) ) )  {   container . setSizeInBits  (  sizeInBits  ( ) ) ; }  BufferedRunningLengthWord32  rlwi =  new BufferedRunningLengthWord32  (  i . next  ( ) ) ;  BufferedRunningLengthWord32  rlwj =  new BufferedRunningLengthWord32  (  j . next  ( ) ) ;  while  ( true )  {   final boolean  i_is_prey =   rlwi . size  ( ) <  rlwj . size  ( ) ;   final BufferedRunningLengthWord32  prey =  i_is_prey ? rlwi : rlwj ;   final BufferedRunningLengthWord32  predator =  i_is_prey ? rlwj : rlwi ;  if  (   prey . getRunningBit  ( ) == false )  {   container . addStreamOfEmptyWords  ( false ,  prey . RunningLength ) ;   predator . discardFirstWords  (  prey . RunningLength ) ;    prey . RunningLength = 0 ; } else  {   final  int  predatorrl =  predator . getRunningLength  ( ) ;   final  int  preyrl =  prey . getRunningLength  ( ) ;   final  int  tobediscarded =   (  predatorrl >= preyrl ) ? preyrl : predatorrl ;   container . addStreamOfEmptyWords  (  predator . getRunningBit  ( ) , tobediscarded ) ;   final  int  dw_predator =   predator . dirtywordoffset +  (  i_is_prey ?  j . dirtyWords  ( ) :  i . dirtyWords  ( ) ) ;   container . addStreamOfDirtyWords  (  i_is_prey ?  j . buffer  ( ) :  i . buffer  ( ) , dw_predator ,  preyrl - tobediscarded ) ;   predator . discardFirstWords  ( preyrl ) ;    prey . RunningLength = 0 ; }   final  int  predatorrl =  predator . getRunningLength  ( ) ;  if  (  predatorrl > 0 )  {  if  (   predator . getRunningBit  ( ) == false )  {   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;   final  int  tobediscarded =   (  predatorrl >= nbre_dirty_prey ) ? nbre_dirty_prey : predatorrl ;   predator . discardFirstWords  ( tobediscarded ) ;   prey . discardFirstWords  ( tobediscarded ) ;   container . addStreamOfEmptyWords  ( false , tobediscarded ) ; } else  {   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;   final  int  dw_prey =   prey . dirtywordoffset +  (  i_is_prey ?  i . dirtyWords  ( ) :  j . dirtyWords  ( ) ) ;   final  int  tobediscarded =   (  predatorrl >= nbre_dirty_prey ) ? nbre_dirty_prey : predatorrl ;   container . addStreamOfDirtyWords  (  i_is_prey ?  i . buffer  ( ) :  j . buffer  ( ) , dw_prey , tobediscarded ) ;   predator . discardFirstWords  ( tobediscarded ) ;   prey . discardFirstWords  ( tobediscarded ) ; } }   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;  if  (  nbre_dirty_prey > 0 )  {  for (   int  k = 0 ;  k < nbre_dirty_prey ;  ++ k )  {  if  ( i_is_prey )   container . add  (    i . buffer  ( ) [    prey . dirtywordoffset +  i . dirtyWords  ( ) + k ] &   j . buffer  ( ) [    predator . dirtywordoffset +  j . dirtyWords  ( ) + k ] ) ; else   container . add  (    i . buffer  ( ) [    predator . dirtywordoffset +  i . dirtyWords  ( ) + k ] &   j . buffer  ( ) [    prey . dirtywordoffset +  j . dirtyWords  ( ) + k ] ) ; }   predator . discardFirstWords  ( nbre_dirty_prey ) ; }  if  ( i_is_prey )  {  if  (  !  i . hasNext  ( ) )  {   rlwi = null ;  break ; }   rlwi . reset  (  i . next  ( ) ) ; } else  {  if  (  !  j . hasNext  ( ) )  {   rlwj = null ;  break ; }   rlwj . reset  (  j . next  ( ) ) ; } }  if  (  rlwi != null )   dischargeAsEmpty  ( rlwi , i , container ) ;  if  (  rlwj != null )   dischargeAsEmpty  ( rlwj , j , container ) ;   container . setSizeInBits  (  Math . max  (  sizeInBits  ( ) ,  a . sizeInBits  ( ) ) ) ; }   public static EWAHCompressedBitmap32 and  (   final EWAHCompressedBitmap32 ...  bitmaps )  {   final EWAHCompressedBitmap32  container =  new EWAHCompressedBitmap32  ( ) ;   int  largestSize = 0 ;  for ( EWAHCompressedBitmap32 bitmap : bitmaps )  {   largestSize =  Math . max  (  bitmap . actualsizeinwords , largestSize ) ; }   container . reserve  (  (  int )  (  largestSize * 1.5 ) ) ;   and  ( container , bitmaps ) ;  return container ; }   public static  int andCardinality  (   final EWAHCompressedBitmap32 ...  bitmaps )  {   final BitCounter32  counter =  new BitCounter32  ( ) ;   and  ( counter , bitmaps ) ;  return  counter . getCount  ( ) ; }   private static void and  (   final BitmapStorage32 container ,   final EWAHCompressedBitmap32 ...  bitmaps )  {  if  (   bitmaps . length == 2 )  {    bitmaps [ 0 ] . and  (  bitmaps [ 1 ] , container ) ;  return ; }   final  EWAHCompressedBitmap32  [ ]  sortedBitmaps =  bitmaps . clone  ( ) ;   Arrays . sort  ( sortedBitmaps ,  new  Comparator  < EWAHCompressedBitmap32 >  ( )  {   public  int compare  (  EWAHCompressedBitmap32 a ,  EWAHCompressedBitmap32 b )  {  return    a . sizeinbits <  b . sizeinbits ?  - 1 :    a . sizeinbits ==  b . sizeinbits ? 0 : 1 ; } } ) ;   int  maxSize =   sortedBitmaps [   sortedBitmaps . length - 1 ] . sizeinbits ;   final  IteratingBufferedRunningLengthWord32  [ ]  rlws =  new IteratingBufferedRunningLengthWord32  [  bitmaps . length ] ;  for (   int  i = 0 ;  i <  sortedBitmaps . length ;  i ++ )  {  EWAHIterator32  iterator =   sortedBitmaps [ i ] . getEWAHIterator  ( ) ;  if  (  iterator . hasNext  ( ) )  {    rlws [ i ] =  new IteratingBufferedRunningLengthWord32  ( iterator ) ; } else  {  if  (  maxSize > 0 )  {   extendEmptyBits  ( container , 0 , maxSize ) ; }   container . setSizeInBits  ( maxSize ) ;  return ; } }  while  ( true )  {   int  maxZeroRl = 0 ;   int  minOneRl =  Integer . MAX_VALUE ;   int  minSize =  Integer . MAX_VALUE ;   int  numEmptyRl = 0 ;  if  (    rlws [ 0 ] . size  ( ) == 0 )  {   extendEmptyBits  ( container ,   sortedBitmaps [ 0 ] . sizeinbits , maxSize ) ;  break ; }  for ( IteratingBufferedRunningLengthWord32 rlw : rlws )  {   int  size =  rlw . size  ( ) ;   minSize =  Math . min  ( minSize , size ) ;  if  (  !  rlw . getRunningBit  ( ) )  {   int  rl =  rlw . getRunningLength  ( ) ;   maxZeroRl =  Math . max  ( maxZeroRl , rl ) ;   minOneRl = 0 ;  if  (   rl == 0 &&  size > 0 )  {   numEmptyRl ++ ; } } else  {   int  rl =  rlw . getRunningLength  ( ) ;   minOneRl =  Math . min  ( minOneRl , rl ) ;  if  (   rl == 0 &&  size > 0 )  {   numEmptyRl ++ ; } } }  if  (  maxZeroRl > 0 )  {   container . addStreamOfEmptyWords  ( false , maxZeroRl ) ;  for ( IteratingBufferedRunningLengthWord32 rlw : rlws )  {   rlw . discardFirstWords  ( maxZeroRl ) ; } } else  if  (  minOneRl > 0 )  {   container . addStreamOfEmptyWords  ( true , minOneRl ) ;  for ( IteratingBufferedRunningLengthWord32 rlw : rlws )  {   rlw . discardFirstWords  ( minOneRl ) ; } } else  {   int  index = 0 ;  if  (  numEmptyRl == 1 )  {  IteratingBufferedRunningLengthWord32  emptyRl = null ;   int  minNonEmptyRl =  Integer . MAX_VALUE ;  for ( IteratingBufferedRunningLengthWord32 rlw : rlws )  {   int  rl =  rlw . getRunningLength  ( ) ;  if  (  rl == 0 )  {  assert  emptyRl == null ;   emptyRl = rlw ; } else  {   minNonEmptyRl =  Math . min  ( minNonEmptyRl , rl ) ; } }   int  wordsToWrite =   minNonEmptyRl > minSize ? minSize : minNonEmptyRl ;  if  (  emptyRl != null )   emptyRl . writeDirtyWords  ( wordsToWrite , container ) ;   index += wordsToWrite ; }  while  (  index < minSize )  {   int  word =  ~ 0 ;  for ( IteratingBufferedRunningLengthWord32 rlw : rlws )  {  if  (   rlw . getRunningLength  ( ) <= index )  {   word &=  rlw . getDirtyWordAt  (  index -  rlw . getRunningLength  ( ) ) ; } }   container . add  ( word ) ;   index ++ ; }  for ( IteratingBufferedRunningLengthWord32 rlw : rlws )  {   rlw . discardFirstWords  ( minSize ) ; } } }   container . setSizeInBits  ( maxSize ) ; }   public boolean intersects  (   final EWAHCompressedBitmap32 a )  {  NonEmptyVirtualStorage32  nevs =  new NonEmptyVirtualStorage32  ( ) ;  try  {   this . and  ( a , nevs ) ; }  catch (    NonEmptyVirtualStorage32 . NonEmptyException nee )  {  return true ; }  return false ; }   public EWAHCompressedBitmap32 andNot  (   final EWAHCompressedBitmap32 a )  {   final EWAHCompressedBitmap32  container =  new EWAHCompressedBitmap32  ( ) ;   container . reserve  (    this . actualsizeinwords >  a . actualsizeinwords ?  this . actualsizeinwords :  a . actualsizeinwords ) ;   andNot  ( a , container ) ;  return container ; }   private void andNot  (   final EWAHCompressedBitmap32 a ,   final BitmapStorage32 container )  {   final EWAHIterator32  i =  a . getEWAHIterator  ( ) ;   final EWAHIterator32  j =  getEWAHIterator  ( ) ;  if  (  !  (   i . hasNext  ( ) &&  j . hasNext  ( ) ) )  {   container . setSizeInBits  (  sizeInBits  ( ) ) ; }  BufferedRunningLengthWord32  rlwi =  new BufferedRunningLengthWord32  (  i . next  ( ) ) ;   rlwi . setRunningBit  (  !  rlwi . getRunningBit  ( ) ) ;  BufferedRunningLengthWord32  rlwj =  new BufferedRunningLengthWord32  (  j . next  ( ) ) ;  while  ( true )  {   final boolean  i_is_prey =   rlwi . size  ( ) <  rlwj . size  ( ) ;   final BufferedRunningLengthWord32  prey =  i_is_prey ? rlwi : rlwj ;   final BufferedRunningLengthWord32  predator =  i_is_prey ? rlwj : rlwi ;  if  (   prey . getRunningBit  ( ) == false )  {   container . addStreamOfEmptyWords  ( false ,  prey . RunningLength ) ;   predator . discardFirstWords  (  prey . RunningLength ) ;    prey . RunningLength = 0 ; } else  {   final  int  predatorrl =  predator . getRunningLength  ( ) ;   final  int  preyrl =  prey . getRunningLength  ( ) ;   final  int  tobediscarded =   (  predatorrl >= preyrl ) ? preyrl : predatorrl ;   container . addStreamOfEmptyWords  (  predator . getRunningBit  ( ) , tobediscarded ) ;   final  int  dw_predator =   predator . dirtywordoffset +  (  i_is_prey ?  j . dirtyWords  ( ) :  i . dirtyWords  ( ) ) ;  if  ( i_is_prey )   container . addStreamOfDirtyWords  (  j . buffer  ( ) , dw_predator ,  preyrl - tobediscarded ) ; else   container . addStreamOfNegatedDirtyWords  (  i . buffer  ( ) , dw_predator ,  preyrl - tobediscarded ) ;   predator . discardFirstWords  ( preyrl ) ;    prey . RunningLength = 0 ; }   final  int  predatorrl =  predator . getRunningLength  ( ) ;  if  (  predatorrl > 0 )  {  if  (   predator . getRunningBit  ( ) == false )  {   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;   final  int  tobediscarded =   (  predatorrl >= nbre_dirty_prey ) ? nbre_dirty_prey : predatorrl ;   predator . discardFirstWords  ( tobediscarded ) ;   prey . discardFirstWords  ( tobediscarded ) ;   container . addStreamOfEmptyWords  ( false , tobediscarded ) ; } else  {   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;   final  int  dw_prey =   prey . dirtywordoffset +  (  i_is_prey ?  i . dirtyWords  ( ) :  j . dirtyWords  ( ) ) ;   final  int  tobediscarded =   (  predatorrl >= nbre_dirty_prey ) ? nbre_dirty_prey : predatorrl ;  if  ( i_is_prey )   container . addStreamOfNegatedDirtyWords  (  i . buffer  ( ) , dw_prey , tobediscarded ) ; else   container . addStreamOfDirtyWords  (  j . buffer  ( ) , dw_prey , tobediscarded ) ;   predator . discardFirstWords  ( tobediscarded ) ;   prey . discardFirstWords  ( tobediscarded ) ; } }   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;  if  (  nbre_dirty_prey > 0 )  {  for (   int  k = 0 ;  k < nbre_dirty_prey ;  ++ k )  {  if  ( i_is_prey )   container . add  (   (  ~   i . buffer  ( ) [    prey . dirtywordoffset +  i . dirtyWords  ( ) + k ] ) &   j . buffer  ( ) [    predator . dirtywordoffset +  j . dirtyWords  ( ) + k ] ) ; else   container . add  (   (  ~   i . buffer  ( ) [    predator . dirtywordoffset +  i . dirtyWords  ( ) + k ] ) &   j . buffer  ( ) [    prey . dirtywordoffset +  j . dirtyWords  ( ) + k ] ) ; }   predator . discardFirstWords  ( nbre_dirty_prey ) ; }  if  ( i_is_prey )  {  if  (  !  i . hasNext  ( ) )  {   rlwi = null ;  break ; }   rlwi . reset  (  i . next  ( ) ) ;   rlwi . setRunningBit  (  !  rlwi . getRunningBit  ( ) ) ; } else  {  if  (  !  j . hasNext  ( ) )  {   rlwj = null ;  break ; }   rlwj . reset  (  j . next  ( ) ) ; } }  if  (  rlwi != null )   dischargeAsEmpty  ( rlwi , i , container ) ;  if  (  rlwj != null )   discharge  ( rlwj , j , container ) ;   container . setSizeInBits  (  Math . max  (  sizeInBits  ( ) ,  a . sizeInBits  ( ) ) ) ; }   public void not  ( )  {   final EWAHIterator32  i =  new EWAHIterator32  (  this . buffer ,  this . actualsizeinwords ) ;  if  (  !  i . hasNext  ( ) )  return ;  while  ( true )  {   final RunningLengthWord32  rlw1 =  i . next  ( ) ;   rlw1 . setRunningBit  (  !  rlw1 . getRunningBit  ( ) ) ;  for (   int  j = 0 ;  j <  rlw1 . getNumberOfLiteralWords  ( ) ;  ++ j )  {     i . buffer  ( ) [   i . dirtyWords  ( ) + j ] =  ~   i . buffer  ( ) [   i . dirtyWords  ( ) + j ] ; }  if  (  !  i . hasNext  ( ) )  {  if  (   rlw1 . getNumberOfLiteralWords  ( ) == 0 )  return ;   final  int  usedbitsinlast =   this . sizeinbits % wordinbits ;  if  (  usedbitsinlast == 0 )  return ;     i . buffer  ( ) [    i . dirtyWords  ( ) +  rlw1 . getNumberOfLiteralWords  ( ) - 1 ] &=  (   (  ~ 0 ) >>>  (  wordinbits - usedbitsinlast ) ) ;  return ; } } }   public EWAHCompressedBitmap32 or  (   final EWAHCompressedBitmap32 a )  {   final EWAHCompressedBitmap32  container =  new EWAHCompressedBitmap32  ( ) ;   container . reserve  (   this . actualsizeinwords +  a . actualsizeinwords ) ;   or  ( a , container ) ;  return container ; }   public  int orCardinality  (   final EWAHCompressedBitmap32 a )  {   final BitCounter32  counter =  new BitCounter32  ( ) ;   or  ( a , counter ) ;  return  counter . getCount  ( ) ; }   public  int andCardinality  (   final EWAHCompressedBitmap32 a )  {   final BitCounter32  counter =  new BitCounter32  ( ) ;   and  ( a , counter ) ;  return  counter . getCount  ( ) ; }   public  int andNotCardinality  (   final EWAHCompressedBitmap32 a )  {   final BitCounter32  counter =  new BitCounter32  ( ) ;   andNot  ( a , counter ) ;  return  counter . getCount  ( ) ; }   public  int xorCardinality  (   final EWAHCompressedBitmap32 a )  {   final BitCounter32  counter =  new BitCounter32  ( ) ;   xor  ( a , counter ) ;  return  counter . getCount  ( ) ; }   private void or  (   final EWAHCompressedBitmap32 a ,   final BitmapStorage32 container )  {   final EWAHIterator32  i =  a . getEWAHIterator  ( ) ;   final EWAHIterator32  j =  getEWAHIterator  ( ) ;  if  (  !  (   i . hasNext  ( ) &&  j . hasNext  ( ) ) )  {   container . setSizeInBits  (  sizeInBits  ( ) ) ;  return ; }  BufferedRunningLengthWord32  rlwi =  new BufferedRunningLengthWord32  (  i . next  ( ) ) ;  BufferedRunningLengthWord32  rlwj =  new BufferedRunningLengthWord32  (  j . next  ( ) ) ;  while  ( true )  {   final boolean  i_is_prey =   rlwi . size  ( ) <  rlwj . size  ( ) ;   final BufferedRunningLengthWord32  prey =  i_is_prey ? rlwi : rlwj ;   final BufferedRunningLengthWord32  predator =  i_is_prey ? rlwj : rlwi ;  if  (   prey . getRunningBit  ( ) == false )  {   final  int  predatorrl =  predator . getRunningLength  ( ) ;   final  int  preyrl =  prey . getRunningLength  ( ) ;   final  int  tobediscarded =   (  predatorrl >= preyrl ) ? preyrl : predatorrl ;   container . addStreamOfEmptyWords  (  predator . getRunningBit  ( ) , tobediscarded ) ;   final  int  dw_predator =   predator . dirtywordoffset +  (  i_is_prey ?  j . dirtyWords  ( ) :  i . dirtyWords  ( ) ) ;   container . addStreamOfDirtyWords  (  i_is_prey ?  j . buffer  ( ) :  i . buffer  ( ) , dw_predator ,  preyrl - tobediscarded ) ;   predator . discardFirstWords  ( preyrl ) ;   prey . discardFirstWords  ( preyrl ) ;    prey . RunningLength = 0 ; } else  {   container . addStreamOfEmptyWords  ( true ,  prey . RunningLength ) ;   predator . discardFirstWords  (  prey . RunningLength ) ;    prey . RunningLength = 0 ; }   int  predatorrl =  predator . getRunningLength  ( ) ;  if  (  predatorrl > 0 )  {  if  (   predator . getRunningBit  ( ) == false )  {   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;   final  int  tobediscarded =   (  predatorrl >= nbre_dirty_prey ) ? nbre_dirty_prey : predatorrl ;   final  int  dw_prey =   prey . dirtywordoffset +  (  i_is_prey ?  i . dirtyWords  ( ) :  j . dirtyWords  ( ) ) ;   predator . discardFirstWords  ( tobediscarded ) ;   prey . discardFirstWords  ( tobediscarded ) ;   container . addStreamOfDirtyWords  (  i_is_prey ?  i . buffer  ( ) :  j . buffer  ( ) , dw_prey , tobediscarded ) ; } else  {   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;   final  int  tobediscarded =   (  predatorrl >= nbre_dirty_prey ) ? nbre_dirty_prey : predatorrl ;   container . addStreamOfEmptyWords  ( true , tobediscarded ) ;   predator . discardFirstWords  ( tobediscarded ) ;   prey . discardFirstWords  ( tobediscarded ) ; } }   final  int  nbre_dirty_prey =  prey . getNumberOfLiteralWords  ( ) ;  if  (  nbre_dirty_prey > 0 )  {  for (   int  k = 0 ;  k < nbre_dirty_prey ;  ++ k )  {  if  ( i_is_prey )   container . add  (    i . buffer  ( ) [    prey . dirtywordoffset +  i . dirtyWords  ( ) + k ] |   j . buffer  ( ) [    predator . dirtywordoffset +  j . dirtyWords  ( ) + k ] ) ; else   container . add  (    i . buffer  ( ) [    predator . dirtywordoffset +  i . dirtyWords  ( ) + k ] |   j . buffer  ( ) [    prey . dirtywordoffset +  j . dirtyWords  ( ) + k ] ) ; }   predator . discardFirstWords  ( nbre_dirty_prey ) ; }  if  ( i_is_prey )  {  if  (  !  i . hasNext  ( ) )  {   rlwi = null ;  break ; }   rlwi . reset  (  i . next  ( ) ) ; } else  {  if  (  !  j . hasNext  ( ) )  {   rlwj = null ;  break ; }   rlwj . reset  (  j . next  ( ) ) ; } }  if  (  rlwi != null )   discharge  ( rlwi , i , container ) ;  if  (  rlwj != null )   discharge  ( rlwj , j , container ) ;   container . setSizeInBits  (  Math . max  (  sizeInBits  ( ) ,  a . sizeInBits  ( ) ) ) ; }   public static EWAHCompressedBitmap32 or  (   final EWAHCompressedBitmap32 ...  bitmaps )  {   final EWAHCompressedBitmap32  container =  new EWAHCompressedBitmap32  ( ) ;   int  largestSize = 0 ;  for ( EWAHCompressedBitmap32 bitmap : bitmaps )  {   largestSize =  Math . max  (  bitmap . actualsizeinwords , largestSize ) ; }   container . reserve  (  (  int )  (  largestSize * 1.5 ) ) ;   or  ( container , bitmaps ) ;  return container ; }   public static  int orCardinality  (   final EWAHCompressedBitmap32 ...  bitmaps )  {   final BitCounter32  counter =  new BitCounter32  ( ) ;   or  ( counter , bitmaps ) ;  return  counter . getCount  ( ) ; }   private static void or  (   final BitmapStorage32 container ,   final EWAHCompressedBitmap32 ...  bitmaps )  {  if  (   bitmaps . length == 2 )  {    bitmaps [ 0 ] . or  (  bitmaps [ 1 ] , container ) ;  return ; }   final  EWAHCompressedBitmap32  [ ]  sortedBitmaps =  bitmaps . clone  ( ) ;   Arrays . sort  ( sortedBitmaps ,  new  Comparator  < EWAHCompressedBitmap32 >  ( )  {   public  int compare  (  EWAHCompressedBitmap32 a ,  EWAHCompressedBitmap32 b )  {  return    a . sizeinbits <  b . sizeinbits ? 1 :    a . sizeinbits ==  b . sizeinbits ? 0 :  - 1 ; } } ) ;   final  IteratingBufferedRunningLengthWord32  [ ]  rlws =  new IteratingBufferedRunningLengthWord32  [  bitmaps . length ] ;   int  maxAvailablePos = 0 ;  for ( EWAHCompressedBitmap32 bitmap : sortedBitmaps )  {  EWAHIterator32  iterator =  bitmap . getEWAHIterator  ( ) ;  if  (  iterator . hasNext  ( ) )  {    rlws [  maxAvailablePos ++ ] =  new IteratingBufferedRunningLengthWord32  ( iterator ) ; } }  if  (  maxAvailablePos == 0 )  {   container . setSizeInBits  ( 0 ) ;  return ; }   int  maxSize =   sortedBitmaps [ 0 ] . sizeinbits ;  while  ( true )  {   int  maxOneRl = 0 ;   int  minZeroRl =  Integer . MAX_VALUE ;   int  minSize =  Integer . MAX_VALUE ;   int  numEmptyRl = 0 ;  for (   int  i = 0 ;  i < maxAvailablePos ;  i ++ )  {  IteratingBufferedRunningLengthWord32  rlw =  rlws [ i ] ;   int  size =  rlw . size  ( ) ;  if  (  size == 0 )  {   maxAvailablePos = i ;  break ; }   minSize =  Math . min  ( minSize , size ) ;  if  (  rlw . getRunningBit  ( ) )  {   int  rl =  rlw . getRunningLength  ( ) ;   maxOneRl =  Math . max  ( maxOneRl , rl ) ;   minZeroRl = 0 ;  if  (   rl == 0 &&  size > 0 )  {   numEmptyRl ++ ; } } else  {   int  rl =  rlw . getRunningLength  ( ) ;   minZeroRl =  Math . min  ( minZeroRl , rl ) ;  if  (   rl == 0 &&  size > 0 )  {   numEmptyRl ++ ; } } }  if  (  maxAvailablePos == 0 )  {  break ; } else  if  (  maxAvailablePos == 1 )  {    rlws [ 0 ] . discharge  ( container ) ;  break ; }  if  (  maxOneRl > 0 )  {   container . addStreamOfEmptyWords  ( true , maxOneRl ) ;  for (   int  i = 0 ;  i < maxAvailablePos ;  i ++ )  {  IteratingBufferedRunningLengthWord32  rlw =  rlws [ i ] ;   rlw . discardFirstWords  ( maxOneRl ) ; } } else  if  (  minZeroRl > 0 )  {   container . addStreamOfEmptyWords  ( false , minZeroRl ) ;  for (   int  i = 0 ;  i < maxAvailablePos ;  i ++ )  {  IteratingBufferedRunningLengthWord32  rlw =  rlws [ i ] ;   rlw . discardFirstWords  ( minZeroRl ) ; } } else  {   int  index = 0 ;  if  (  numEmptyRl == 1 )  {  IteratingBufferedRunningLengthWord32  emptyRl = null ;   int  minNonEmptyRl =  Integer . MAX_VALUE ;  for (   int  i = 0 ;  i < maxAvailablePos ;  i ++ )  {  IteratingBufferedRunningLengthWord32  rlw =  rlws [ i ] ;   int  rl =  rlw . getRunningLength  ( ) ;  if  (  rl == 0 )  {  assert  emptyRl == null ;   emptyRl = rlw ; } else  {   minNonEmptyRl =  Math . min  ( minNonEmptyRl , rl ) ; } }   int  wordsToWrite =   minNonEmptyRl > minSize ? minSize : minNonEmptyRl ;  if  (  emptyRl != null )   emptyRl . writeDirtyWords  ( wordsToWrite , container ) ;   index += wordsToWrite ; }  while  (  index < minSize )  {   int  word = 0 ;  for (   int  i = 0 ;  i < maxAvailablePos ;  i ++ )  {  IteratingBufferedRunningLengthWord32  rlw =  rlws [ i ] ;  if  (   rlw . getRunningLength  ( ) <= index )  {   word |=  rlw . getDirtyWordAt  (  index -  rlw . getRunningLength  ( ) ) ; } }   container . add  ( word ) ;   index ++ ; }  for (   int  i = 0 ;  i < maxAvailablePos ;  i ++ )  {  IteratingBufferedRunningLengthWord32  rlw =  rlws [ i ] ;   rlw . discardFirstWords  ( minSize ) ; } } }   container . setSizeInBits  ( maxSize ) ; }   protected static void discharge  (   final BufferedRunningLengthWord32 initialWord ,   final EWAHIterator32 iterator ,   final BitmapStorage32 container )  {  BufferedRunningLengthWord32  runningLengthWord = initialWord ;  for ( ; ; )  {   final  int  runningLength =  runningLengthWord . getRunningLength  ( ) ;   container . addStreamOfEmptyWords  (  runningLengthWord . getRunningBit  ( ) , runningLength ) ;   container . addStreamOfDirtyWords  (  iterator . buffer  ( ) ,   iterator . dirtyWords  ( ) +  runningLengthWord . dirtywordoffset ,  runningLengthWord . getNumberOfLiteralWords  ( ) ) ;  if  (  !  iterator . hasNext  ( ) )  break ;   runningLengthWord =  new BufferedRunningLengthWord32  (  iterator . next  ( ) ) ; } }   private static void dischargeAsEmpty  (   final BufferedRunningLengthWord32 initialWord ,   final EWAHIterator32 iterator ,   final BitmapStorage32 container )  {  BufferedRunningLengthWord32  runningLengthWord = initialWord ;  for ( ; ; )  {   final  int  runningLength =  runningLengthWord . getRunningLength  ( ) ;   container . addStreamOfEmptyWords  ( false ,  runningLength +  runningLengthWord . getNumberOfLiteralWords  ( ) ) ;  if  (  !  iterator . hasNext  ( ) )  break ;   runningLengthWord =  new BufferedRunningLengthWord32  (  iterator . next  ( ) ) ; } }   public boolean set  (   final  int i )  {  if  (  i <  this . sizeinbits )  return false ;   final  int  dist =    (  i + wordinbits ) / wordinbits -   (    this . sizeinbits + wordinbits - 1 ) / wordinbits ;  if  (   (  dist > 0 ) ||  (   this . sizeinbits == 0 ) != 0 )  {   addStreamOfEmptyWords  ( false ,  dist - 1 ) ;   addLiteralWord  (  1 <<  (  i % wordinbits ) ) ;    this . sizeinbits =  i + 1 ;  return true ; }  if  (    this . rlw . getNumberOfLiteralWords  ( ) == 0 )  {    this . rlw . setRunningLength  (    this . rlw . getRunningLength  ( ) - 1 ) ;   addLiteralWord  (  1 <<  (  i % wordinbits ) ) ;    this . sizeinbits =  i + 1 ;  return true ; }     this . buffer [   this . actualsizeinwords - 1 ] |=  1 <<  (  i % wordinbits ) ;  if  (    this . buffer [   this . actualsizeinwords - 1 ] ==  ~ 0 )  {     this . buffer [   this . actualsizeinwords - 1 ] = 0 ;   --  this . actualsizeinwords ;    this . rlw . setNumberOfLiteralWords  (    this . rlw . getNumberOfLiteralWords  ( ) - 1 ) ;   addEmptyWord  ( true ) ; }    this . sizeinbits =  i + 1 ;  return true ; }   public  int add  (   final  int newdata )  {  return  add  ( newdata , wordinbits ) ; }   public  int addStreamOfEmptyWords  (   final boolean v ,   final  int number )  {  if  (  number == 0 )  return 0 ;   final boolean  noliteralword =  (    this . rlw . getNumberOfLiteralWords  ( ) == 0 ) ;   final  int  runlen =   this . rlw . getRunningLength  ( ) ;  if  (   ( noliteralword ) &&  (  runlen == 0 ) )  {    this . rlw . setRunningBit  ( v ) ; }   int  wordsadded = 0 ;  if  (    ( noliteralword ) &&  (    this . rlw . getRunningBit  ( ) == v ) &&  (  runlen <  RunningLengthWord32 . largestrunninglengthcount ) )  {   int  whatwecanadd =   number <   RunningLengthWord32 . largestrunninglengthcount - runlen ? number :   RunningLengthWord32 . largestrunninglengthcount - runlen ;    this . rlw . setRunningLength  (  runlen + whatwecanadd ) ;    this . sizeinbits +=  whatwecanadd * wordinbits ;  if  (   number - whatwecanadd > 0 )   wordsadded +=  addStreamOfEmptyWords  ( v ,  number - whatwecanadd ) ; } else  {   push_back  ( 0 ) ;   ++ wordsadded ;     this . rlw . position =   this . actualsizeinwords - 1 ;   final  int  whatwecanadd =   number <  RunningLengthWord32 . largestrunninglengthcount ? number :  RunningLengthWord32 . largestrunninglengthcount ;    this . rlw . setRunningBit  ( v ) ;    this . rlw . setRunningLength  ( whatwecanadd ) ;    this . sizeinbits +=  whatwecanadd * wordinbits ;  if  (   number - whatwecanadd > 0 )   wordsadded +=  addStreamOfEmptyWords  ( v ,  number - whatwecanadd ) ; }  return wordsadded ; }   public  int addStreamOfNegatedDirtyWords  (   final   int  [ ] data ,   final  int start ,   final  int number )  {  if  (  number == 0 )  return 0 ;   final  int  NumberOfLiteralWords =   this . rlw . getNumberOfLiteralWords  ( ) ;   final  int  whatwecanadd =   number <   RunningLengthWord32 . largestliteralcount - NumberOfLiteralWords ? number :   RunningLengthWord32 . largestliteralcount - NumberOfLiteralWords ;    this . rlw . setNumberOfLiteralWords  (  NumberOfLiteralWords + whatwecanadd ) ;   final  int  leftovernumber =  number - whatwecanadd ;   negative_push_back  ( data , start , whatwecanadd ) ;    this . sizeinbits +=  whatwecanadd * wordinbits ;   int  wordsadded = whatwecanadd ;  if  (  leftovernumber > 0 )  {   push_back  ( 0 ) ;     this . rlw . position =   this . actualsizeinwords - 1 ;   ++ wordsadded ;   wordsadded +=  addStreamOfDirtyWords  ( data ,  start + whatwecanadd , leftovernumber ) ; }  return wordsadded ; }   public  int addStreamOfDirtyWords  (   final   int  [ ] data ,   final  int start ,   final  int number )  {  if  (  number == 0 )  return 0 ;   final  int  NumberOfLiteralWords =   this . rlw . getNumberOfLiteralWords  ( ) ;   final  int  whatwecanadd =   number <   RunningLengthWord32 . largestliteralcount - NumberOfLiteralWords ? number :   RunningLengthWord32 . largestliteralcount - NumberOfLiteralWords ;    this . rlw . setNumberOfLiteralWords  (  NumberOfLiteralWords + whatwecanadd ) ;   final  int  leftovernumber =  number - whatwecanadd ;   push_back  ( data , start , whatwecanadd ) ;    this . sizeinbits +=  whatwecanadd * wordinbits ;   int  wordsadded = whatwecanadd ;  if  (  leftovernumber > 0 )  {   push_back  ( 0 ) ;     this . rlw . position =   this . actualsizeinwords - 1 ;   ++ wordsadded ;   wordsadded +=  addStreamOfDirtyWords  ( data ,  start + whatwecanadd , leftovernumber ) ; }  return wordsadded ; }   public  int add  (   final  int newdata ,   final  int bitsthatmatter )  {    this . sizeinbits += bitsthatmatter ;  if  (  newdata == 0 )  {  return  addEmptyWord  ( false ) ; } else  if  (  newdata ==  ~ 0 )  {  return  addEmptyWord  ( true ) ; } else  {  return  addLiteralWord  ( newdata ) ; } }   public  int sizeInBits  ( )  {  return  this . sizeinbits ; }   public void setSizeInBits  (   final  int size )  {    this . sizeinbits = size ; }   public boolean setSizeInBits  (   final  int size ,   final boolean defaultvalue )  {  if  (  size <  this . sizeinbits )  return false ;  if  ( defaultvalue )  while  (   (   (   this . sizeinbits % wordinbits ) != 0 ) &&  (   this . sizeinbits < size ) )  {   this . set  (  this . sizeinbits ) ; }  if  (  defaultvalue == false )   extendEmptyBits  ( this ,  this . sizeinbits , size ) ; else  {   final  int  leftover =  size % wordinbits ;   this . addStreamOfEmptyWords  ( defaultvalue ,   (  size / wordinbits ) -   this . sizeinbits / wordinbits ) ;   final  int  newdata =   (  1 << leftover ) +  (   (  1 << leftover ) - 1 ) ;   this . addLiteralWord  ( newdata ) ; }    this . sizeinbits = size ;  return true ; }   private static void extendEmptyBits  (   final BitmapStorage32 storage ,   final  int currentSize ,   final  int newSize )  {   final  int  currentLeftover =  currentSize % wordinbits ;   final  int  finalLeftover =  newSize % wordinbits ;   storage . addStreamOfEmptyWords  ( false ,     (  newSize / wordinbits ) -  currentSize / wordinbits +  (   finalLeftover != 0 ? 1 : 0 ) +  (   currentLeftover != 0 ?  - 1 : 0 ) ) ; }   public  int sizeInBytes  ( )  {  return   this . actualsizeinwords *  (  wordinbits / 8 ) ; }   private boolean reserve  (   final  int size )  {  if  (  size >   this . buffer . length )  {   final  int  oldbuffer  [ ] =  this . buffer ;    this . buffer =  new  int  [ size ] ;   System . arraycopy  ( oldbuffer , 0 ,  this . buffer , 0 ,  oldbuffer . length ) ;     this . rlw . array =  this . buffer ;  return true ; }  return false ; }   private void push_back  (   final  int data )  {  if  (   this . actualsizeinwords ==   this . buffer . length )  {   final  int  oldbuffer  [ ] =  this . buffer ;    this . buffer =  new  int  [   oldbuffer . length * 2 ] ;   System . arraycopy  ( oldbuffer , 0 ,  this . buffer , 0 ,  oldbuffer . length ) ;     this . rlw . array =  this . buffer ; }     this . buffer [   this . actualsizeinwords ++ ] = data ; }   private void push_back  (   final   int  [ ] data ,   final  int start ,   final  int number )  {  while  (    this . actualsizeinwords + number >=   this . buffer . length )  {   final  int  oldbuffer  [ ] =  this . buffer ;    this . buffer =  new  int  [   oldbuffer . length * 2 ] ;   System . arraycopy  ( oldbuffer , 0 ,  this . buffer , 0 ,  oldbuffer . length ) ;     this . rlw . array =  this . buffer ; }   System . arraycopy  ( data , start ,  this . buffer ,  this . actualsizeinwords , number ) ;    this . actualsizeinwords += number ; }   private void negative_push_back  (   final   int  [ ] data ,   final  int start ,   final  int number )  {  while  (    this . actualsizeinwords + number >=   this . buffer . length )  {   final  int  oldbuffer  [ ] =  this . buffer ;    this . buffer =  new  int  [   oldbuffer . length * 2 ] ;   System . arraycopy  ( oldbuffer , 0 ,  this . buffer , 0 ,  oldbuffer . length ) ;     this . rlw . array =  this . buffer ; }  for (   int  k = 0 ;  k < number ;  ++ k )     this . buffer [   this . actualsizeinwords + k ] =  ~  data [  start + k ] ;    this . actualsizeinwords += number ; }   private  int addEmptyWord  (   final boolean v )  {   final boolean  noliteralword =  (    this . rlw . getNumberOfLiteralWords  ( ) == 0 ) ;   final  int  runlen =   this . rlw . getRunningLength  ( ) ;  if  (   ( noliteralword ) &&  (  runlen == 0 ) )  {    this . rlw . setRunningBit  ( v ) ; }  if  (    ( noliteralword ) &&  (    this . rlw . getRunningBit  ( ) == v ) &&  (  runlen <  RunningLengthWord32 . largestrunninglengthcount ) )  {    this . rlw . setRunningLength  (  runlen + 1 ) ;  return 0 ; }   push_back  ( 0 ) ;     this . rlw . position =   this . actualsizeinwords - 1 ;    this . rlw . setRunningBit  ( v ) ;    this . rlw . setRunningLength  ( 1 ) ;  return 1 ; }   private  int addLiteralWord  (   final  int newdata )  {   final  int  numbersofar =   this . rlw . getNumberOfLiteralWords  ( ) ;  if  (  numbersofar >=  RunningLengthWord32 . largestliteralcount )  {   push_back  ( 0 ) ;     this . rlw . position =   this . actualsizeinwords - 1 ;    this . rlw . setNumberOfLiteralWords  ( 1 ) ;   push_back  ( newdata ) ;  return 2 ; }    this . rlw . setNumberOfLiteralWords  (  numbersofar + 1 ) ;   push_back  ( newdata ) ;  return 1 ; }   public  int cardinality  ( )  {   int  counter = 0 ;   final EWAHIterator32  i =  new EWAHIterator32  (  this . buffer ,  this . actualsizeinwords ) ;  while  (  i . hasNext  ( ) )  {  RunningLengthWord32  localrlw =  i . next  ( ) ;  if  (  localrlw . getRunningBit  ( ) )  {   counter +=  wordinbits *  localrlw . getRunningLength  ( ) ; }  for (   int  j = 0 ;  j <  localrlw . getNumberOfLiteralWords  ( ) ;  ++ j )  {   counter +=  Integer . bitCount  (   i . buffer  ( ) [   i . dirtyWords  ( ) + j ] ) ; } }  return counter ; }    @ Override public String toString  ( )  {  String  ans =     " EWAHCompressedBitmap, size in bits = " +  this . sizeinbits + " size in words = " +  this . actualsizeinwords + "\n" ;   final EWAHIterator32  i =  new EWAHIterator32  (  this . buffer ,  this . actualsizeinwords ) ;  while  (  i . hasNext  ( ) )  {  RunningLengthWord32  localrlw =  i . next  ( ) ;  if  (  localrlw . getRunningBit  ( ) )  {   ans +=   localrlw . getRunningLength  ( ) + " 1x11\n" ; } else  {   ans +=   localrlw . getRunningLength  ( ) + " 0x00\n" ; }   ans +=   localrlw . getNumberOfLiteralWords  ( ) + " dirties\n" ; }  return ans ; }   public String toDebugString  ( )  {  String  ans =     " EWAHCompressedBitmap, size in bits = " +  this . sizeinbits + " size in words = " +  this . actualsizeinwords + "\n" ;   final EWAHIterator32  i =  new EWAHIterator32  (  this . buffer ,  this . actualsizeinwords ) ;  while  (  i . hasNext  ( ) )  {  RunningLengthWord32  localrlw =  i . next  ( ) ;  if  (  localrlw . getRunningBit  ( ) )  {   ans +=   localrlw . getRunningLength  ( ) + " 1x11\n" ; } else  {   ans +=   localrlw . getRunningLength  ( ) + " 0x00\n" ; }   ans +=   localrlw . getNumberOfLiteralWords  ( ) + " dirties\n" ;  for (   int  j = 0 ;  j <  localrlw . getNumberOfLiteralWords  ( ) ;  ++ j )  {   int  data =   i . buffer  ( ) [   i . dirtyWords  ( ) + j ] ;   ans +=   "\t" + data + "\n" ; } }  return ans ; }   public   int  [ ] toArray  ( )  {    int  [ ]  ans =  new  int  [  this . cardinality  ( ) ] ;   int  inanspos = 0 ;   int  pos = 0 ;   final EWAHIterator32  i =  new EWAHIterator32  (  this . buffer ,  this . actualsizeinwords ) ;  while  (  i . hasNext  ( ) )  {  RunningLengthWord32  localrlw =  i . next  ( ) ;  if  (  localrlw . getRunningBit  ( ) )  {  for (   int  j = 0 ;  j <  localrlw . getRunningLength  ( ) ;  ++ j )  {  for (   int  c = 0 ;  c < wordinbits ;  ++ c )  {    ans [  inanspos ++ ] =  pos ++ ; } } } else  {   pos +=  wordinbits *  localrlw . getRunningLength  ( ) ; }  for (   int  j = 0 ;  j <  localrlw . getNumberOfLiteralWords  ( ) ;  ++ j )  {   int  data =   i . buffer  ( ) [   i . dirtyWords  ( ) + j ] ;  if  (  ! usetrailingzeros )  {  for (   int  c = 0 ;  c < wordinbits ;  ++ c )  {  if  (   (  data &  (  1 << c ) ) != 0 )    ans [  inanspos ++ ] =  c + pos ; }   pos += wordinbits ; } else  {  while  (  data != 0 )  {   final  int  ntz =  Integer . numberOfTrailingZeros  ( data ) ;   data ^=  (  1l << ntz ) ;    ans [  inanspos ++ ] =  ntz + pos ; }   pos += wordinbits ; } } }  return ans ; }   public IntIterator intIterator  ( )  {   final EWAHIterator32  i =  new EWAHIterator32  (  this . buffer ,  this . actualsizeinwords ) ;  return  new IntIterator  ( )  {   int  pos = 0 ;  RunningLengthWord32  localrlw = null ;   final static  int  initcapacity = 512 ;    int  [ ]  localbuffer =  new  int  [ initcapacity ] ;   int  localbuffersize = 0 ;   int  bufferpos = 0 ;  boolean  status =  queryStatus  ( ) ;   public boolean hasNext  ( )  {  return  this . status ; }   public boolean queryStatus  ( )  {  while  (   this . localbuffersize == 0 )  {  if  (  !  loadNextRLE  ( ) )  return false ;   loadBuffer  ( ) ; }  return true ; }   private boolean loadNextRLE  ( )  {  while  (  i . hasNext  ( ) )  {    this . localrlw =  i . next  ( ) ;  return true ; }  return false ; }   private void add  (   final  int val )  {   ++  this . localbuffersize ;  if  (   this . localbuffersize >   this . localbuffer . length )  {    int  [ ]  oldbuffer =  this . localbuffer ;    this . localbuffer =  new  int  [    this . localbuffer . length * 2 ] ;   System . arraycopy  ( oldbuffer , 0 ,  this . localbuffer , 0 ,  oldbuffer . length ) ; }     this . localbuffer [   this . localbuffersize - 1 ] = val ; }   private void loadBuffer  ( )  {    this . bufferpos = 0 ;    this . localbuffersize = 0 ;  if  (   this . localrlw . getRunningBit  ( ) )  {  for (   int  j = 0 ;  j <   this . localrlw . getRunningLength  ( ) ;  ++ j )  {  for (   int  c = 0 ;  c < wordinbits ;  ++ c )  {   add  (   this . pos ++ ) ; } } } else  {    this . pos +=  wordinbits *   this . localrlw . getRunningLength  ( ) ; }  for (   int  j = 0 ;  j <   this . localrlw . getNumberOfLiteralWords  ( ) ;  ++ j )  {   int  data =   i . buffer  ( ) [   i . dirtyWords  ( ) + j ] ;  if  (  ! usetrailingzeros )  {  for (   int  c = 0 ;  c < wordinbits ;  ++ c )  {  if  (   (  data &  (  1 << c ) ) != 0 )   add  (  c +  this . pos ) ; }    this . pos += wordinbits ; } else  {  while  (  data != 0 )  {   final  int  ntz =  Long . numberOfTrailingZeros  ( data ) ;   data ^=  (  1l << ntz ) ;   add  (  ntz +  this . pos ) ; }    this . pos += wordinbits ; } } }   public  int next  ( )  {   final  int  answer =   this . localbuffer [   this . bufferpos ++ ] ;  if  (   this . localbuffersize ==  this . bufferpos )  {    this . localbuffersize = 0 ;    this . status =  queryStatus  ( ) ; }  return answer ; } } ; }   public  Iterator  < Integer > iterator  ( )  {  return  new  Iterator  < Integer >  ( )  {   final private IntIterator  under =  intIterator  ( ) ;   public Integer next  ( )  {  return  new Integer  (   this . under . next  ( ) ) ; }   public boolean hasNext  ( )  {  return   this . under . hasNext  ( ) ; }   public void remove  ( )  {  throw  new UnsupportedOperationException  ( "bitsets do not support remove" ) ; } } ; }   public  List  < Integer > getPositions  ( )  {   final  ArrayList  < Integer >  v =  new  ArrayList  < Integer >  ( ) ;   final EWAHIterator32  i =  new EWAHIterator32  (  this . buffer ,  this . actualsizeinwords ) ;   int  pos = 0 ;  while  (  i . hasNext  ( ) )  {  RunningLengthWord32  localrlw =  i . next  ( ) ;  if  (  localrlw . getRunningBit  ( ) )  {  for (   int  j = 0 ;  j <  localrlw . getRunningLength  ( ) ;  ++ j )  {  for (   int  c = 0 ;  c < wordinbits ;  ++ c )   v . add  (  new Integer  (  pos ++ ) ) ; } } else  {   pos +=  wordinbits *  localrlw . getRunningLength  ( ) ; }  for (   int  j = 0 ;  j <  localrlw . getNumberOfLiteralWords  ( ) ;  ++ j )  {   int  data =   i . buffer  ( ) [   i . dirtyWords  ( ) + j ] ;  while  (  data != 0 )  {   final  int  ntz =  Integer . numberOfTrailingZeros  ( data ) ;   data ^=  (  1 << ntz ) ;   v . add  (  new Integer  (  ntz + pos ) ) ; }   pos += wordinbits ; } }  while  (   (   v . size  ( ) > 0 ) &&  (    v . get  (   v . size  ( ) - 1 ) . intValue  ( ) >=  this . sizeinbits ) )   v . remove  (   v . size  ( ) - 1 ) ;  return v ; }    @ Override public boolean equals  (  Object o )  {  if  (  o instanceof EWAHCompressedBitmap32 )  {  EWAHCompressedBitmap32  other =  ( EWAHCompressedBitmap32 ) o ;  if  (     this . sizeinbits ==  other . sizeinbits &&   this . actualsizeinwords ==  other . actualsizeinwords &&    this . rlw . position ==   other . rlw . position )  {  for (   int  k = 0 ;  k <  this . actualsizeinwords ;  ++ k )  if  (    this . buffer [ k ] !=   other . buffer [ k ] )  return false ;  return true ; } }  return false ; }    @ Override public  int hashCode  ( )  {   int  karprabin = 0 ;   final  int  B = 31 ;  for (   int  k = 0 ;  k <  this . actualsizeinwords ;  ++ k )  {   karprabin +=   B * karprabin +  (    this . buffer [ k ] &  (   (  1 << 32 ) - 1 ) ) ;   karprabin +=   B * karprabin +  (    this . buffer [ k ] >>> 32 ) ; }  return   this . sizeinbits ^ karprabin ; }    @ Override public Object clone  ( )  throws   java . lang . CloneNotSupportedException  {   final EWAHCompressedBitmap32  clone =  ( EWAHCompressedBitmap32 )  super . clone  ( ) ;    clone . buffer =   this . buffer . clone  ( ) ;    clone . actualsizeinwords =  this . actualsizeinwords ;    clone . sizeinbits =  this . sizeinbits ;  return clone ; }   public void readExternal  (  ObjectInput in )  throws IOException  {   deserialize  ( in ) ; }   public void deserialize  (  DataInput in )  throws IOException  {    this . sizeinbits =  in . readInt  ( ) ;    this . actualsizeinwords =  in . readInt  ( ) ;  if  (    this . buffer . length <  this . actualsizeinwords )  {    this . buffer =  new  int  [  this . actualsizeinwords ] ; }  for (   int  k = 0 ;  k <  this . actualsizeinwords ;  ++ k )     this . buffer [ k ] =  in . readInt  ( ) ;    this . rlw =  new RunningLengthWord32  (  this . buffer ,  in . readInt  ( ) ) ; }   public void writeExternal  (  ObjectOutput out )  throws IOException  {   serialize  ( out ) ; }   public void serialize  (  DataOutput out )  throws IOException  {   out . writeInt  (  this . sizeinbits ) ;   out . writeInt  (  this . actualsizeinwords ) ;  for (   int  k = 0 ;  k <  this . actualsizeinwords ;  ++ k )   out . writeInt  (   this . buffer [ k ] ) ;   out . writeInt  (   this . rlw . position ) ; }   public  int serializedSizeInBytes  ( )  {  return   this . sizeInBytes  ( ) +  3 * 4 ; }   public void clear  ( )  {    this . sizeinbits = 0 ;    this . actualsizeinwords = 1 ;     this . rlw . position = 0 ;     this . buffer [ 0 ] = 0 ; }   static final  int  defaultbuffersize = 4 ;   int  buffer  [ ] = null ;   int  actualsizeinwords = 1 ;   int  sizeinbits = 0 ;  RunningLengthWord32  rlw = null ;   public static final  int  wordinbits = 32 ;   public static final boolean  usetrailingzeros = true ; }