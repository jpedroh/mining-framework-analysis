  package    ch . iterate . openstack . swift ;   import     org . apache . commons . codec . EncoderException ;  import      org . apache . commons . codec . net . URLCodec ;  import    org . apache . http . HttpEntity ;  import    org . apache . http . HttpHeaders ;  import    org . apache . http . HttpStatus ;  import    org . apache . http . NameValuePair ;  import     org . apache . http . client . HttpClient ;  import     org . apache . http . client . ResponseHandler ;  import      org . apache . http . client . methods . HttpDelete ;  import      org . apache . http . client . methods . HttpEntityEnclosingRequestBase ;  import      org . apache . http . client . methods . HttpGet ;  import      org . apache . http . client . methods . HttpHead ;  import      org . apache . http . client . methods . HttpPost ;  import      org . apache . http . client . methods . HttpPut ;  import      org . apache . http . client . methods . HttpRequestBase ;  import     org . apache . http . conn . ClientConnectionManager ;  import      org . apache . http . conn . scheme . PlainSocketFactory ;  import      org . apache . http . conn . scheme . Scheme ;  import      org . apache . http . conn . scheme . SchemeRegistry ;  import      org . apache . http . conn . ssl . SSLSocketFactory ;  import     org . apache . http . entity . ByteArrayEntity ;  import     org . apache . http . entity . InputStreamEntity ;  import     org . apache . http . entity . StringEntity ;  import      org . apache . http . impl . client . DefaultHttpClient ;  import      org . apache . http . impl . conn . PoolingClientConnectionManager ;  import     org . apache . http . message . BasicNameValuePair ;  import     org . apache . http . params . BasicHttpParams ;  import     org . apache . http . params . HttpConnectionParams ;  import     org . apache . http . params . HttpParams ;  import     org . apache . http . protocol . HTTP ;  import   java . net . URI ;  import      ch . iterate . openstack . swift . exception . AuthorizationException ;  import      ch . iterate . openstack . swift . exception . ContainerExistsException ;  import      ch . iterate . openstack . swift . exception . ContainerNotEmptyException ;  import      ch . iterate . openstack . swift . exception . ContainerNotFoundException ;  import      ch . iterate . openstack . swift . exception . GenericException ;  import      ch . iterate . openstack . swift . exception . NotFoundException ;  import     ch . iterate . openstack . swift . handler .  * ;  import      ch . iterate . openstack . swift . method . Authentication10UsernameKeyRequest ;  import      ch . iterate . openstack . swift . method . Authentication11UsernameKeyRequest ;  import      ch . iterate . openstack . swift . method . Authentication20UsernamePasswordRequest ;  import      ch . iterate . openstack . swift . method . AuthenticationRequest ;  import      ch . iterate . openstack . swift . model . AccountInfo ;  import      ch . iterate . openstack . swift . model . CDNContainer ;  import      ch . iterate . openstack . swift . model . Container ;  import      ch . iterate . openstack . swift . model . ContainerInfo ;  import      ch . iterate . openstack . swift . model . ContainerMetadata ;  import      ch . iterate . openstack . swift . model . ObjectMetadata ;  import      ch . iterate . openstack . swift . model . Region ;  import      ch . iterate . openstack . swift . model . StorageObject ;  import      org . apache . http . client . utils . URIBuilder ;  import    org . json . simple . JSONArray ;  import    org . json . simple . JSONObject ;  import     org . json . simple . parser . JSONParser ;  import    org . json . simple . JSONValue ;  import     org . json . simple . parser . ParseException ;  import  java . io .  * ;  import   java . net . URISyntaxException ;  import  java . util .  * ;  import   java . util . concurrent .  * ;   public class Client  {   private String  username ;   private String  password ;   private String  tenantId ;   private AuthVersion  authVersion =  AuthVersion . v10 ;   private URI  authenticationURL ;   private AuthenticationResponse  authenticationResponse ;   private HttpClient  client ;   public Client  (   final  int connectionTimeOut )  {  this  (  new DefaultHttpClient  ( )  {    @ Override protected HttpParams createHttpParams  ( )  {  BasicHttpParams  params =  new BasicHttpParams  ( ) ;   HttpConnectionParams . setSoTimeout  ( params , connectionTimeOut ) ;  return params ; }    @ Override protected ClientConnectionManager createClientConnectionManager  ( )  {  SchemeRegistry  schemeRegistry =  new SchemeRegistry  ( ) ;   schemeRegistry . register  (  new Scheme  ( "http" , 80 ,  PlainSocketFactory . getSocketFactory  ( ) ) ) ;   schemeRegistry . register  (  new Scheme  ( "https" , 443 ,  SSLSocketFactory . getSocketFactory  ( ) ) ) ;  return  new PoolingClientConnectionManager  ( schemeRegistry ) ; } } ) ; }   public Client  (  HttpClient client )  {    this . client = client ; }   public void disconnect  ( )  {     this . client . getConnectionManager  ( ) . shutdown  ( ) ; }   public enum AuthVersion  {  v10 ,  v11 ,  v20 }   public AuthenticationResponse authenticate  (  AuthVersion authVersion ,  URI authUrl ,  String username ,  String password ,  String tenantId )  throws IOException  {    this . authenticationURL = authUrl ;    this . authVersion = authVersion ;    this . username = username ;    this . password = password ;    this . tenantId = tenantId ;  return  this . authenticate  ( ) ; }   protected AuthenticationResponse authenticate  ( )  throws IOException  {  switch  ( authVersion )  {   case v10 :   default :  return  this . authenticate  (  new Authentication10UsernameKeyRequest  ( authenticationURL , username , password ) ) ;   case v11 :  return  this . authenticate  (  new Authentication11UsernameKeyRequest  ( authenticationURL , username , password ) ) ;   case v20 :  return  this . authenticate  (  new Authentication20UsernamePasswordRequest  ( authenticationURL , username , password , tenantId ) ) ; } }   public AuthenticationResponse authenticate  (  AuthenticationRequest request )  throws IOException  {  switch  (  request . getVersion  ( ) )  {   case v10 :   default :  return  this . authenticate  ( request ,  new Authentication10ResponseHandler  ( ) ) ;   case v11 :  return  this . authenticate  ( request ,  new AuthenticationJson11ResponseHandler  ( ) ) ;   case v20 :  return  this . authenticate  ( request ,  new AuthenticationJson20ResponseHandler  ( ) ) ; } }   public AuthenticationResponse authenticate  (  AuthenticationRequest request ,   ResponseHandler  < AuthenticationResponse > handler )  throws IOException  {  return  authenticationResponse =  client . execute  ( request , handler ) ; }   public AuthenticationResponse getAuthentication  ( )  {  return authenticationResponse ; }   public  Set  < Region > getRegions  ( )  {  return  authenticationResponse . getRegions  ( ) ; }   public void setUserAgent  (  String userAgent )  {    client . getParams  ( ) . setParameter  (  HTTP . USER_AGENT , userAgent ) ; }   public String getUserAgent  ( )  {  return    client . getParams  ( ) . getParameter  (  HTTP . USER_AGENT ) . toString  ( ) ; }   public  List  < ContainerInfo > listContainersInfo  (  Region region )  throws IOException  {  return  listContainersInfo  ( region ,  - 1 , null ) ; }   public  List  < ContainerInfo > listContainersInfo  (  Region region ,   int limit )  throws IOException  {  return  listContainersInfo  ( region , limit , null ) ; }   public  List  < ContainerInfo > listContainersInfo  (  Region region ,   int limit ,  String marker )  throws IOException  {   LinkedList  < NameValuePair >  parameters =  new  LinkedList  < NameValuePair >  ( ) ;  if  (  limit > 0 )  {   parameters . add  (  new BasicNameValuePair  ( "limit" ,  String . valueOf  ( limit ) ) ) ; }  if  (  marker != null )  {   parameters . add  (  new BasicNameValuePair  ( "marker" , marker ) ) ; }   parameters . add  (  new BasicNameValuePair  ( "format" , "xml" ) ) ;  HttpGet  method =  new HttpGet  (  region . getStorageUrl  ( parameters ) ) ;  return  this . execute  ( method ,  new ContainerInfoResponseHandler  ( region ) ) ; }   public  List  < Container > listContainers  (  Region region )  throws IOException  {  return  listContainers  ( region ,  - 1 , null ) ; }   public  List  < Container > listContainers  (  Region region ,   int limit )  throws IOException  {  return  listContainers  ( region , limit , null ) ; }   public  List  < Container > listContainers  (  Region region ,   int limit ,  String marker )  throws IOException  {   LinkedList  < NameValuePair >  parameters =  new  LinkedList  < NameValuePair >  ( ) ;  if  (  limit > 0 )  {   parameters . add  (  new BasicNameValuePair  ( "limit" ,  String . valueOf  ( limit ) ) ) ; }  if  (  marker != null )  {   parameters . add  (  new BasicNameValuePair  ( "marker" , marker ) ) ; }  HttpGet  method =  new HttpGet  (  region . getStorageUrl  ( parameters ) ) ;  return  this . execute  ( method ,  new ContainerResponseHandler  ( region ) ) ; }   private Response execute  (   final HttpRequestBase method )  throws IOException  {  try  {   method . setHeader  (  Constants . X_AUTH_TOKEN ,  authenticationResponse . getAuthToken  ( ) ) ;  try  {  return   new DefaultResponseHandler  ( ) . handleResponse  (  client . execute  ( method ) ) ; }  catch (   AuthorizationException e )  {   method . abort  ( ) ;   authenticationResponse =  this . authenticate  ( ) ;   method . reset  ( ) ;   method . setHeader  (  Constants . X_AUTH_TOKEN ,  authenticationResponse . getAuthToken  ( ) ) ;  return   new DefaultResponseHandler  ( ) . handleResponse  (  client . execute  ( method ) ) ; } }  catch (   IOException e )  {   method . abort  ( ) ;  throw e ; } }   private  <  T > T execute  (   final HttpRequestBase method ,   ResponseHandler  < T > handler )  throws IOException  {  try  {   method . setHeader  (  Constants . X_AUTH_TOKEN ,  authenticationResponse . getAuthToken  ( ) ) ;  try  {  return  client . execute  ( method , handler ) ; }  catch (   AuthorizationException e )  {   method . abort  ( ) ;   authenticationResponse =  this . authenticate  ( ) ;   method . reset  ( ) ;   method . setHeader  (  Constants . X_AUTH_TOKEN ,  authenticationResponse . getAuthToken  ( ) ) ;  return  client . execute  ( method , handler ) ; } }  catch (   IOException e )  {   method . abort  ( ) ;  throw e ; }  finally  {   method . reset  ( ) ; } }   public  List  < StorageObject > listObjectsStartingWith  (  Region region ,  String container ,  String startsWith ,  String path ,   int limit ,  String marker )  throws IOException  {  return  listObjectsStartingWith  ( region , container , startsWith , path , limit , marker , null ) ; }   public  List  < StorageObject > listObjectsStartingWith  (  Region region ,  String container ,  String startsWith ,  String path ,   int limit ,  String marker ,  Character delimiter )  throws IOException  {   LinkedList  < NameValuePair >  parameters =  new  LinkedList  < NameValuePair >  ( ) ;   parameters . add  (  new BasicNameValuePair  ( "format" , "xml" ) ) ;  if  (  startsWith != null )  {   parameters . add  (  new BasicNameValuePair  ( "prefix" , startsWith ) ) ; }  if  (  path != null )  {   parameters . add  (  new BasicNameValuePair  ( "path" , path ) ) ; }  if  (  limit > 0 )  {   parameters . add  (  new BasicNameValuePair  ( "limit" ,  String . valueOf  ( limit ) ) ) ; }  if  (  marker != null )  {   parameters . add  (  new BasicNameValuePair  ( "marker" , marker ) ) ; }  if  (  delimiter != null )  {   parameters . add  (  new BasicNameValuePair  ( "delimiter" ,  delimiter . toString  ( ) ) ) ; }  HttpGet  method =  new HttpGet  (  region . getStorageUrl  ( container , parameters ) ) ;  return  this . execute  ( method ,  new ObjectResponseHandler  ( ) ) ; }   public  List  < StorageObject > listObjects  (  Region region ,  String container )  throws IOException  {  return  listObjectsStartingWith  ( region , container , null , null ,  - 1 , null , null ) ; }   public  List  < StorageObject > listObjects  (  Region region ,  String container ,  Character delimiter )  throws IOException  {  return  listObjectsStartingWith  ( region , container , null , null ,  - 1 , null , delimiter ) ; }   public  List  < StorageObject > listObjects  (  Region region ,  String container ,   int limit )  throws IOException  {  return  listObjectsStartingWith  ( region , container , null , null , limit , null , null ) ; }   public  List  < StorageObject > listObjects  (  Region region ,  String container ,  String path )  throws IOException  {  return  listObjectsStartingWith  ( region , container , null , path ,  - 1 , null , null ) ; }   public  List  < StorageObject > listObjects  (  Region region ,  String container ,  String path ,  Character delimiter )  throws IOException  {  return  listObjectsStartingWith  ( region , container , null , path ,  - 1 , null , delimiter ) ; }   public  List  < StorageObject > listObjects  (  Region region ,  String container ,  String path ,   int limit )  throws IOException  {  return  listObjectsStartingWith  ( region , container , null , path , limit , null ) ; }   public  List  < StorageObject > listObjects  (  Region region ,  String container ,  String path ,   int limit ,  String marker )  throws IOException  {  return  listObjectsStartingWith  ( region , container , null , path , limit , marker ) ; }   public  List  < StorageObject > listObjects  (  Region region ,  String container ,   int limit ,  String marker )  throws IOException  {  return  listObjectsStartingWith  ( region , container , null , null , limit , marker ) ; }   public boolean containerExists  (  Region region ,  String container )  throws IOException  {  try  {   this . getContainerInfo  ( region , container ) ;  return true ; }  catch (   ContainerNotFoundException notfound )  {  return false ; } }   public AccountInfo getAccountInfo  (  Region region )  throws IOException  {  HttpHead  method =  new HttpHead  (  region . getStorageUrl  ( ) ) ;  return  this . execute  ( method ,  new AccountInfoHandler  ( ) ) ; }   public ContainerInfo getContainerInfo  (  Region region ,  String container )  throws IOException  {  HttpHead  method =  new HttpHead  (  region . getStorageUrl  ( container ) ) ;  return  this . execute  ( method ,  new ContainerInfoHandler  ( region , container ) ) ; }   public void createContainer  (  Region region ,  String name )  throws IOException  {  HttpPut  method =  new HttpPut  (  region . getStorageUrl  ( name ) ) ;  Response  response =  this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_CREATED )  {  return ; } else  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_ACCEPTED )  {  throw  new ContainerExistsException  ( response ) ; } else  {  throw  new GenericException  ( response ) ; } }   public void deleteContainer  (  Region region ,  String name )  throws IOException  {  HttpDelete  method =  new HttpDelete  (  region . getStorageUrl  ( name ) ) ;  Response  response =  this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_CONFLICT )  {  throw  new ContainerNotEmptyException  ( response ) ; } }   public String cdnEnableContainer  (  Region region ,  String name )  throws IOException  {  HttpPut  method =  new HttpPut  (  region . getCDNManagementUrl  ( name ) ) ;  Response  response =  this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ;  if  (    response . getStatusCode  ( ) ==  HttpStatus . SC_CREATED ||   response . getStatusCode  ( ) ==  HttpStatus . SC_ACCEPTED )  {  return   response . getResponseHeader  (  Constants . X_CDN_URI ) . getValue  ( ) ; } else  {  throw  new GenericException  ( response ) ; } }   public String cdnUpdateContainer  (  Region region ,  String name ,   int ttl ,  boolean enabled ,  boolean retainLogs )  throws IOException  {  return  cdnUpdateContainer  ( region , name , ttl , enabled , null , null , retainLogs ) ; }   private String cdnUpdateContainer  (  Region region ,  String name ,   int ttl ,  boolean enabled ,  String referrerAcl ,  String userAgentACL ,  boolean retainLogs )  throws IOException  {  HttpPost  method =  new HttpPost  (  region . getCDNManagementUrl  ( name ) ) ;  if  (  ttl > 0 )  {   method . setHeader  (  Constants . X_CDN_TTL ,  Integer . toString  ( ttl ) ) ; }   method . setHeader  (  Constants . X_CDN_ENABLED ,  Boolean . toString  ( enabled ) ) ;   method . setHeader  (  Constants . X_CDN_RETAIN_LOGS ,  Boolean . toString  ( retainLogs ) ) ;  if  (  referrerAcl != null )  {   method . setHeader  (  Constants . X_CDN_REFERRER_ACL , referrerAcl ) ; }  if  (  userAgentACL != null )  {   method . setHeader  (  Constants . X_CDN_USER_AGENT_ACL , userAgentACL ) ; }  Response  response =  this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_ACCEPTED )  {  return   response . getResponseHeader  (  Constants . X_CDN_URI ) . getValue  ( ) ; } else  {  throw  new GenericException  ( response ) ; } }   public CDNContainer getCDNContainerInfo  (  Region region ,  String container )  throws IOException  {  HttpHead  method =  new HttpHead  (  region . getCDNManagementUrl  ( container ) ) ;  return  this . execute  ( method ,  new CdnContainerInfoHandler  ( region , container ) ) ; }   public boolean isCDNEnabled  (  Region region ,  String container )  throws IOException  {   final CDNContainer  info =  this . getCDNContainerInfo  ( region , container ) ;  return  info . isEnabled  ( ) ; }   public void createPath  (  Region region ,  String container ,  String path )  throws IOException  {   this . storeObject  ( region , container ,  new ByteArrayInputStream  (  new  byte  [ ]  { } ) , "application/directory" , path ,  new  HashMap  < String , String >  ( ) ) ; }   public void purgeCDNContainer  (  Region region ,  String container ,  String emailAddresses )  throws IOException  {  HttpDelete  method =  new HttpDelete  (  region . getCDNManagementUrl  ( container ) ) ;  if  (  emailAddresses != null )  {   method . setHeader  (  Constants . X_PURGE_EMAIL , emailAddresses ) ; }   this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ; }   public void purgeCDNObject  (  Region region ,  String container ,  String object ,  String emailAddresses )  throws IOException  {  HttpDelete  method =  new HttpDelete  (  region . getCDNManagementUrl  ( container , object ) ) ;  if  (  emailAddresses != null )  {   method . setHeader  (  Constants . X_PURGE_EMAIL , emailAddresses ) ; }   this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ; }   public  List  < CDNContainer > listCdnContainerInfo  (  Region region )  throws IOException  {  return  listCdnContainerInfo  ( region ,  - 1 , null ) ; }   public  List  < CDNContainer > listCdnContainerInfo  (  Region region ,   int limit )  throws IOException  {  return  listCdnContainerInfo  ( region , limit , null ) ; }   public  List  < CDNContainer > listCdnContainerInfo  (  Region region ,   int limit ,  String marker )  throws IOException  {   LinkedList  < NameValuePair >  params =  new  LinkedList  < NameValuePair >  ( ) ;   params . add  (  new BasicNameValuePair  ( "format" , "xml" ) ) ;  if  (  limit > 0 )  {   params . add  (  new BasicNameValuePair  ( "limit" ,  String . valueOf  ( limit ) ) ) ; }  if  (  marker != null )  {   params . add  (  new BasicNameValuePair  ( "marker" , marker ) ) ; }  HttpGet  method =  new HttpGet  (  region . getCDNManagementUrl  ( params ) ) ;  return  this . execute  ( method ,  new CdnContainerInfoListHandler  ( region ) ) ; }   public String storeObject  (  Region region ,  String container ,  InputStream data ,  String contentType ,  String name ,   Map  < String , String > metadata )  throws IOException  {  HttpPut  method =  new HttpPut  (  region . getStorageUrl  ( container , name ) ) ;  InputStreamEntity  entity =  new InputStreamEntity  ( data ,  - 1 ) ;   entity . setChunked  ( true ) ;   entity . setContentType  ( contentType ) ;   method . setEntity  ( entity ) ;  for (   Map . Entry  < String , String > key :   this . renameObjectMetadata  ( metadata ) . entrySet  ( ) )  {   method . setHeader  (  key . getKey  ( ) ,  key . getValue  ( ) ) ; }  Response  response =  this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_CREATED )  {  return   response . getResponseHeader  (  HttpHeaders . ETAG ) . getValue  ( ) ; } else  {  throw  new GenericException  ( response ) ; } }   public String storeObject  (  Region region ,  String container ,  String name ,  HttpEntity entity ,   Map  < String , String > metadata ,  String md5sum )  throws IOException  {  HttpPut  method =  new HttpPut  (  region . getStorageUrl  ( container , name ) ) ;   method . setEntity  ( entity ) ;  if  (  md5sum != null )  {   method . setHeader  (  HttpHeaders . ETAG , md5sum ) ; }   method . setHeader  (  entity . getContentType  ( ) ) ;  for (   Map . Entry  < String , String > key :   this . renameObjectMetadata  ( metadata ) . entrySet  ( ) )  {   method . setHeader  (  key . getKey  ( ) ,  key . getValue  ( ) ) ; }  Response  response =  this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_CREATED )  {  return   response . getResponseHeader  (  HttpHeaders . ETAG ) . getValue  ( ) ; } else  {  throw  new GenericException  ( response ) ; } }   private  Map  < String , String > renameContainerMetadata  (   Map  < String , String > metadata )  {  return  this . renameMetadata  ( metadata ,  Constants . X_CONTAINER_META ) ; }   private  Map  < String , String > renameObjectMetadata  (   Map  < String , String > metadata )  {  return  this . renameMetadata  ( metadata ,  Constants . X_OBJECT_META ) ; }   private  Map  < String , String > renameMetadata  (   Map  < String , String > metadata ,  String prefix )  {   final  Map  < String , String >  converted =  new  HashMap  < String , String >  (  metadata . size  ( ) ) ;  for (   Map . Entry  < String , String > entry :  metadata . entrySet  ( ) )  {  if  (   entry . getKey  ( ) . startsWith  ( prefix ) )  {   converted . put  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; } else  {  if  (  !   Constants . HTTP_HEADER_EDITABLE_NAMES . contains  (   entry . getKey  ( ) . toLowerCase  (  Locale . ENGLISH ) ) )  {   converted . put  (  prefix +  entry . getKey  ( ) ,  encode  (  entry . getValue  ( ) ) ) ; } else  {   converted . put  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; } } }  return converted ; }   private static String encode  (  String object )  {  URLCodec  codec =  new URLCodec  ( ) ;  try  {  return   codec . encode  ( object ) . replaceAll  ( "\\+" , "%20" ) ; }  catch (   EncoderException ee )  {  return object ; } }   public String copyObject  (  Region region ,  String sourceContainer ,  String sourceObjName ,  String destContainer ,  String destObjName )  throws IOException  {  HttpPut  method =  new HttpPut  (  region . getStorageUrl  ( destContainer , destObjName ) ) ;   method . setHeader  (  Constants . X_COPY_FROM ,    encode  ( sourceContainer ) + "/" +  encode  ( sourceObjName ) ) ;  Response  response =  this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_CREATED )  {  return   response . getResponseHeader  (  HttpHeaders . ETAG ) . getValue  ( ) ; } else  {  throw  new GenericException  ( response ) ; } }   public void deleteObject  (  Region region ,  String container ,  String object )  throws IOException  {  HttpDelete  method =  new HttpDelete  (  region . getStorageUrl  ( container , object ) ) ;   this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ; }   public void deleteObjects  (  Region region ,  String container ,   List  < String > objects )  throws IOException  {  HttpEntityEnclosingRequestBase  method =  new HttpEntityEnclosingRequestBase  ( )  {    @ Override public String getMethod  ( )  {  return "DELETE" ; } } ;   LinkedList  < NameValuePair >  parameters =  new  LinkedList  < NameValuePair >  ( ) ;   parameters . add  (  new BasicNameValuePair  ( "bulk-delete" , "1" ) ) ;   method . setURI  (  region . getStorageUrl  ( container , parameters ) ) ;   method . setHeader  (  HttpHeaders . CONTENT_TYPE , "text/plain" ) ;  StringBuilder  body =  new StringBuilder  ( ) ;  for ( String object : objects )  {   final String  path =   region . getStorageUrl  ( container , object ) . getRawPath  ( ) ;    body . append  (  path . substring  (    region . getStorageUrl  ( ) . getRawPath  ( ) . length  ( ) ) ) . append  ( 
<<<<<<<
'\n'
=======
  path . substring  (     region . getStorageUrl  ( ) . getRawPath  ( ) . length  ( ) + 1 ) + "\n"
>>>>>>>
 ) ; }   method . setEntity  (  new StringEntity  (  body . toString  ( ) , "UTF-8" ) ) ;   this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ; }   public ObjectMetadata getObjectMetaData  (  Region region ,  String container ,  String object )  throws IOException  {  HttpHead  method =  new HttpHead  (  region . getStorageUrl  ( container , object ) ) ;  return  this . execute  ( method ,  new ObjectMetadataResponseHandler  ( ) ) ; }   public ContainerMetadata getContainerMetaData  (  Region region ,  String container )  throws IOException  {  HttpHead  method =  new HttpHead  (  region . getStorageUrl  ( container ) ) ;  return  this . execute  ( method ,  new ContainerMetadataResponseHandler  ( ) ) ; }   public InputStream getObject  (  Region region ,  String container ,  String object )  throws IOException  {  HttpGet  method =  new HttpGet  (  region . getStorageUrl  ( container , object ) ) ;  Response  response =  this . execute  ( method ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_OK )  {  return  response . getResponseBodyAsStream  ( ) ; } else  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_NOT_FOUND )  {   method . abort  ( ) ;  throw  new NotFoundException  ( response ) ; } else  {   method . abort  ( ) ;  throw  new GenericException  ( response ) ; } }   public InputStream getObject  (  Region region ,  String container ,  String object ,   long offset ,   long length )  throws IOException  {  HttpGet  method =  new HttpGet  (  region . getStorageUrl  ( container , object ) ) ;   method . setHeader  ( "Range" ,    "bytes=" + offset + "-" + length ) ;  Response  response =  this . execute  ( method ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_PARTIAL_CONTENT )  {  return  response . getResponseBodyAsStream  ( ) ; } else  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_NOT_FOUND )  {   method . abort  ( ) ;  throw  new NotFoundException  ( response ) ; } else  {   method . abort  ( ) ;  throw  new GenericException  ( response ) ; } }   public void updateObjectManifest  (  Region region ,  String container ,  String object ,  String manifest )  throws IOException  {   this . updateObjectMetadataAndManifest  ( region , container , object ,  new  HashMap  < String , String >  ( ) , manifest ) ; }   public void updateObjectMetadata  (  Region region ,  String container ,  String object ,   Map  < String , String > metadata )  throws IOException  {   this . updateObjectMetadataAndManifest  ( region , container , object , metadata , null ) ; }   public void updateObjectMetadataAndManifest  (  Region region ,  String container ,  String object ,   Map  < String , String > metadata ,  String manifest )  throws IOException  {  HttpPost  method =  new HttpPost  (  region . getStorageUrl  ( container , object ) ) ;  if  (  manifest != null )  {   method . setHeader  (  Constants . MANIFEST_HEADER , manifest ) ; }  for (   Map . Entry  < String , String > key :   this . renameObjectMetadata  ( metadata ) . entrySet  ( ) )  {   method . setHeader  (  key . getKey  ( ) ,  key . getValue  ( ) ) ; }   this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ; }   public void updateContainerMetadata  (  Region region ,  String container ,   Map  < String , String > metadata )  throws IOException  {  HttpPost  method =  new HttpPost  (  region . getStorageUrl  ( container ) ) ;  for (   Map . Entry  < String , String > key :   this . renameContainerMetadata  ( metadata ) . entrySet  ( ) )  {   method . setHeader  (  key . getKey  ( ) ,  key . getValue  ( ) ) ; }   this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ; }   public void updateAccountMetadata  (  Region region ,   Map  < String , String > metadata )  throws IOException  {  HttpPost  method =  new HttpPost  (  region . getStorageUrl  ( ) ) ;  for (   Map . Entry  < String , String > key :  metadata . entrySet  ( ) )  {   method . setHeader  (  key . getKey  ( ) ,  key . getValue  ( ) ) ; }   this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ; }   public String createDLOManifestObject  (  Region region ,  String container ,  String contentType ,  String name ,  String commonPrefix )  throws IOException  {  return  createDLOManifestObject  ( region , container , contentType , name , commonPrefix ,  new  HashMap  < String , String >  ( ) ) ; }   public String createDLOManifestObject  (  Region region ,  String container ,  String contentType ,  String name ,  String commonPrefix ,   Map  < String , String > metadata )  throws IOException  {    byte  [ ]  arr =  new  byte  [ 0 ] ;  HttpPut  method =  new HttpPut  (  region . getStorageUrl  ( container , name ) ) ;   method . setHeader  (  Constants . MANIFEST_HEADER , commonPrefix ) ;  ByteArrayEntity  entity =  new ByteArrayEntity  ( arr ) ;   entity . setContentType  ( contentType ) ;   method . setEntity  ( entity ) ;  for (   Map . Entry  < String , String > key :   this . renameObjectMetadata  ( metadata ) . entrySet  ( ) )  {   method . setHeader  (  key . getKey  ( ) ,  key . getValue  ( ) ) ; }  Response  response =  this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_CREATED )  {  return   response . getResponseHeader  (  HttpHeaders . ETAG ) . getValue  ( ) ; } else  {  throw  new GenericException  ( response ) ; } }   public String createSLOManifestObject  (  Region region ,  String container ,  String contentType ,  String name ,  String manifest ,   Map  < String , String > metadata )  throws IOException  {  String  manifestEtag ;  URIBuilder  urlBuild =  new URIBuilder  (  region . getStorageUrl  ( container , name ) ) ;   urlBuild . setParameter  ( "multipart-manifest" , "put" ) ;  URI  url ;  try  {   url =  urlBuild . build  ( ) ;  InputStreamEntity  manifestEntity =  new InputStreamEntity  (  new ByteArrayInputStream  (  manifest . getBytes  ( ) ) ,  - 1 ) ;   manifestEntity . setChunked  ( true ) ;   manifestEntity . setContentType  ( contentType ) ;  HttpPut  method =  new HttpPut  ( url ) ;   method . setEntity  ( manifestEntity ) ;  for (   Map . Entry  < String , String > key :   this . renameObjectMetadata  ( metadata ) . entrySet  ( ) )  {   method . setHeader  (  key . getKey  ( ) ,  key . getValue  ( ) ) ; }   method . setHeader  (  Constants . X_STATIC_LARGE_OBJECT , "true" ) ;  Response  response =  this . execute  ( method ,  new DefaultResponseHandler  ( ) ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_CREATED )  {   manifestEtag =   response . getResponseHeader  (  HttpHeaders . ETAG ) . getValue  ( ) ; } else  {  throw  new GenericException  ( response ) ; } }  catch (   URISyntaxException ex )  {  throw  new GenericException  ( "URI Building failed when creating Static Large Object manifest" , ex ) ; }  return manifestEtag ; }   public  Map  < String ,  List  < StorageObject > > listObjectSegments  (  Region region ,  String container ,  String name )  throws IOException  {   Map  < String ,  List  < StorageObject > >  existingSegments =  new  HashMap  < String ,  List  < StorageObject > >  ( ) ;  try  {  ObjectMetadata  existingMetadata =  getObjectMetaData  ( region , container , name ) ;   Map  < String , String >  metadataMap =  existingMetadata . getMetaData  ( ) ;  if  (   existingMetadata . getMetaData  ( ) . containsKey  (  Constants . MANIFEST_HEADER ) )  {  String  manifestDLO =   existingMetadata . getMetaData  ( ) . get  (  Constants . MANIFEST_HEADER ) ;  String  oldContainer =  manifestDLO . substring  ( 0 ,  manifestDLO . indexOf  ( '/' , 1 ) ) ;  String  oldPath =  manifestDLO . substring  (  manifestDLO . indexOf  ( '/' , 1 ) ,  manifestDLO . length  ( ) ) ;   existingSegments . put  ( oldContainer ,  listObjects  ( region , oldContainer , oldPath ) ) ; } else  if  (   existingMetadata . getMetaData  ( ) . containsKey  (  Constants . X_STATIC_LARGE_OBJECT ) )  {  boolean  isSLO =  "true" . equals  (    existingMetadata . getMetaData  ( ) . get  (  Constants . X_STATIC_LARGE_OBJECT ) . toLowerCase  (  Locale . ENGLISH ) ) ;  if  ( isSLO )  {  JSONParser  parser =  new JSONParser  ( ) ;  URIBuilder  urlBuild =  new URIBuilder  (  region . getStorageUrl  ( container , name ) ) ;   urlBuild . setParameter  ( "multipart-manifest" , "get" ) ;  URI  url =  urlBuild . build  ( ) ;  HttpGet  method =  new HttpGet  ( url ) ;  Response  response =  this . execute  ( method ) ;  if  (   response . getStatusCode  ( ) ==  HttpStatus . SC_OK )  {  String  manifest =  response . getResponseBodyAsString  ( ) ;  JSONArray  segments =  ( JSONArray )  parser . parse  ( manifest ) ;  Iterator  segmentIt =  segments . iterator  ( ) ;  while  (  segmentIt . hasNext  ( ) )  {  JSONObject  segment =  ( JSONObject )  segmentIt . next  ( ) ;  String  objectPath =   segment . get  ( "name" ) . toString  ( ) ;  String  oldContainer =  objectPath . substring  ( 0 ,  objectPath . indexOf  ( '/' , 1 ) ) ;  String  oldPath =  objectPath . substring  (   objectPath . indexOf  ( '/' , 1 ) + 1 ,  objectPath . length  ( ) ) ;   List  < StorageObject >  containerSegments =  existingSegments . get  ( oldContainer ) ;  if  (  containerSegments == null )  {   containerSegments =  new  ArrayList  < StorageObject >  ( ) ;   existingSegments . put  ( oldContainer , containerSegments ) ; }   containerSegments . add  (  new StorageObject  ( oldPath ) ) ; } } else  {   method . abort  ( ) ;  throw  new GenericException  ( response ) ; } } } else  {  return null ; } }  catch (   NotFoundException e )  {  return null ; }  catch (   ParseException e )  {  throw  new GenericException  ( "JSON parsing failed dealing with static large object" , e ) ; }  catch (   URISyntaxException e )  {  throw  new GenericException  ( "URI Building failed when downloading Static Large Object manifest" , e ) ; }  return existingSegments ; }   public String storeObject  (  Region region ,  String container ,  String name ,  HttpEntity entity ,   Map  < String , String > metadata ,  String md5sum ,  Long objectSize ,  Long segmentSize ,  Boolean dynamicLargeObject ,  String segmentContainer ,  String segmentFolder ,  Boolean leaveSegments )  throws IOException , InterruptedException  {   long  singleObjectSizeLimit =  (  long )  (  5 *  Math . pow  ( 1024 , 3 ) ) ;   long  minSegmentSize =  1024L * 1024L ;   long  actualSegmentSize =   (  segmentSize == null ) ?  (  long )  (  4 *  Math . pow  ( 1024 , 3 ) ) :  Math . max  ( segmentSize , minSegmentSize ) ;   objectSize =   (  objectSize == null ) ?  - 1 : objectSize ;  boolean  useLargeObject =    (   (  segmentSize != null ) &&  (  objectSize > actualSegmentSize ) ) ||  (  objectSize > singleObjectSizeLimit ) ||  (   (  segmentSize != null ) &&  (  objectSize ==  - 1 ) ) ;  if  (  ! useLargeObject )  {  return  storeObject  ( region , container , name , entity , metadata , md5sum ) ; } else  {   leaveSegments =   (  leaveSegments == null ) ?  Boolean . FALSE : leaveSegments ;   dynamicLargeObject =   (  dynamicLargeObject == null ) ?  Boolean . FALSE : dynamicLargeObject ;   segmentFolder =   (  segmentFolder == null ) ? ".file-segments" : segmentFolder ;   segmentContainer =   (  segmentContainer == null ) ? container : segmentContainer ;   Map  < String ,  List  < StorageObject > >  oldSegmentsToRemove = null ;  if  (  ! leaveSegments )  {   oldSegmentsToRemove =  listObjectSegments  ( region , container , name ) ; }   int  segmentNumber = 1 ;   long  timeStamp =   System . currentTimeMillis  ( ) / 1000L ;  String  segmentBase =  String . format  ( "%s/%d/%d" , segmentFolder , timeStamp , objectSize ) ;   final PipedInputStream  contentInStream =  new PipedInputStream  (  64 * 1024 ) ;   final PipedOutputStream  contentOutStream =  new PipedOutputStream  ( contentInStream ) ;  SubInputStream  segmentStream =  new SubInputStream  ( contentInStream , actualSegmentSize , false ) ;   final HttpEntity  e = entity ;   final  Callable  < Boolean >  writer =  new  Callable  < Boolean >  ( )  {   public Boolean call  ( )  throws Exception  {   e . writeTo  ( contentOutStream ) ;  return  Boolean . TRUE ; } } ;  ExecutorService  writeExecutor =  Executors . newSingleThreadExecutor  ( ) ;   final  Future  < Boolean >  future =  writeExecutor . submit  ( writer ) ;   Map  < String ,  List  < StorageObject > >  newSegmentsAdded =  new  HashMap  < String ,  List  < StorageObject > >  ( ) ;   List  < StorageObject >  newSegments =  new  LinkedList  < StorageObject >  ( ) ;  JSONArray  manifestSLO =  new JSONArray  ( ) ;  boolean  finished = false ;  while  (  ! finished )  {  String  segmentName =  String . format  ( "%s/%08d" , segmentBase , segmentNumber ) ;  String  etag ;  try  {   etag =  storeObject  ( region , segmentContainer , segmentStream , "application/octet-stream" , segmentName ,  new  HashMap  < String , String >  ( ) ) ; }  catch (   IOException ex )  {   ex . printStackTrace  ( ) ;  throw ex ; }  String  segmentPath =   segmentContainer + "/" + segmentName ;   long  bytesUploaded =  segmentStream . getBytesProduced  ( ) ;  if  (  ! dynamicLargeObject )  {  JSONObject  segmentJSON =  new JSONObject  ( ) ;   segmentJSON . put  ( "path" , segmentPath ) ;   segmentJSON . put  ( "etag" , etag ) ;   segmentJSON . put  ( "size_bytes" , bytesUploaded ) ;   manifestSLO . add  ( segmentJSON ) ;   newSegments . add  (  new StorageObject  ( segmentName ) ) ; }   segmentNumber ++ ;  if  (  ! finished )  {   finished =  segmentStream . endSourceReached  ( ) ; }   newSegmentsAdded . put  ( segmentContainer , newSegments ) ;   segmentStream . readMoreBytes  ( actualSegmentSize ) ; }  try  {   future . get  ( ) ; }  catch (   InterruptedException ex )  { }  catch (   ExecutionException ex )  {  Throwable  t =  ex . getCause  ( ) ;  if  (  t instanceof IOException )  {  throw  ( IOException ) t ; } else  {  throw  ( RuntimeException ) t ; } }  String  manifestEtag = null ;  if  ( dynamicLargeObject )  {   long  manifestTimeStamp =   System . currentTimeMillis  ( ) / 1000L ;   metadata . put  (   Constants . X_OBJECT_META + "mtime" ,  String . format  ( "%s" , manifestTimeStamp ) ) ;   manifestEtag =  createDLOManifestObject  ( region , container ,   entity . getContentType  ( ) . getValue  ( ) , name , segmentBase , metadata ) ; } else  {   manifestEtag =  createSLOManifestObject  ( region , container ,   entity . getContentType  ( ) . getValue  ( ) , name ,  manifestSLO . toString  ( ) , metadata ) ; }  if  (  ! leaveSegments )  {  if  (  !  (  oldSegmentsToRemove == null ) )  {  for ( String c :  oldSegmentsToRemove . keySet  ( ) )  {   List  < StorageObject >  rmv =  oldSegmentsToRemove . get  ( c ) ;  if  (  newSegmentsAdded . containsKey  ( c ) )  {   rmv . removeAll  (  newSegmentsAdded . get  ( c ) ) ; }   List  < String >  rmvNames =  new  LinkedList  < String >  ( ) ;  for ( StorageObject s : rmv )  {   rmvNames . add  (  s . getName  ( ) ) ; }   deleteObjects  ( region , c , rmvNames ) ; } } }  return manifestEtag ; } }   public String storeObject  (  Region region ,  String container ,  String name ,  HttpEntity entity ,   Map  < String , String > metadata ,  String md5sum ,  Long objectSize )  throws IOException , InterruptedException  {  return  storeObject  ( region , container , name , entity , metadata , md5sum , objectSize , null , null , null , null , null ) ; } }