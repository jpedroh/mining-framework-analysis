  package    smartrics . rest . fitnesse . fixture ;   import  fit . Fixture ;  import    java . lang . reflect . InvocationTargetException ;  import    java . lang . reflect . Method ;  import   java . util . HashMap ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Vector ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import    smartrics . rest . client . RestClient ;  import     smartrics . rest . client . RestData . Header ;  import    smartrics . rest . client . RestRequest ;  import    smartrics . rest . client . RestResponse ;  import      smartrics . rest . fitnesse . fixture . support . BodyTypeAdapter ;  import      smartrics . rest . fitnesse . fixture . support . CellFormatter ;  import      smartrics . rest . fitnesse . fixture . support . CellWrapper ;  import      smartrics . rest . fitnesse . fixture . support . Config ;  import      smartrics . rest . fitnesse . fixture . support . ContentType ;  import      smartrics . rest . fitnesse . fixture . support . HeadersTypeAdapter ;  import      smartrics . rest . fitnesse . fixture . support . JavascriptException ;  import      smartrics . rest . fitnesse . fixture . support . JavascriptWrapper ;  import      smartrics . rest . fitnesse . fixture . support . LetHandler ;  import      smartrics . rest . fitnesse . fixture . support . LetHandlerFactory ;  import      smartrics . rest . fitnesse . fixture . support . RestDataTypeAdapter ;  import      smartrics . rest . fitnesse . fixture . support . RowWrapper ;  import      smartrics . rest . fitnesse . fixture . support . StatusCodeTypeAdapter ;  import      smartrics . rest . fitnesse . fixture . support . StringTypeAdapter ;  import      smartrics . rest . fitnesse . fixture . support . Tools ;  import      smartrics . rest . fitnesse . fixture . support . Url ;  import      smartrics . rest . fitnesse . fixture . support . Variables ;   public class RestFixture  extends Fixture  {   public enum Runner  {  SLIM ,  FIT ,  OTHER  ; } ;   private static final String  LINE_SEPARATOR = "\n" ;   private static final String  FILE = "file" ;   private static final Logger  LOG =  LoggerFactory . getLogger  (  RestFixture . class ) ;   protected Variables  GLOBALS ;   private RestResponse  lastResponse ;   private RestRequest  lastRequest ;   protected String  fileName = null ;   protected String  multipartFileName = null ;   protected String  multipartFileParameterName = FILE ;   protected String  requestBody ;   private  Map  < String , String >  requestHeaders ;   private RestClient  restClient ;   private Config  config ;   private boolean  displayActualOnRight ;   private boolean  debugMethodCall = false ;   private boolean  ignoreReadTimeout = false ;   private  Map  < String , String >  defaultHeaders =  new  HashMap  < String , String >  ( ) ;   private  Map  < String , String >  namespaceContext =  new  HashMap  < String , String >  ( ) ;   private Url  baseUrl ;    @ SuppressWarnings  ( "rawtypes" ) protected RowWrapper  row ;   private  CellFormatter  <  ? >  formatter ;   private PartsFactory  partsFactory ;   private String  lastEvaluation ;   private  int  minLenForCollapseToggle ;   public RestFixture  ( )  {  super  ( ) ;    this . partsFactory =  new PartsFactory  ( ) ;    this . displayActualOnRight = true ;    this . minLenForCollapseToggle =  - 1 ; }   public RestFixture  (  String hostName )  {  this  ( hostName ,  Config . DEFAULT_CONFIG_NAME ) ; }   public RestFixture  (  String hostName ,  String configName )  {  this  (  new PartsFactory  ( ) , hostName , configName ) ; }   public RestFixture  (  PartsFactory partsFactory ,  String hostName ,  String configName )  {    this . displayActualOnRight = true ;    this . minLenForCollapseToggle =  - 1 ;    this . partsFactory = partsFactory ;    this . config =  Config . getConfig  ( configName ) ;    this . baseUrl =  new Url  (  stripTag  ( hostName ) ) ; }   public Config getConfig  ( )  {  return config ; }   public String getLastEvaluation  ( )  {  return lastEvaluation ; }   public String getBaseUrl  ( )  {  if  (  baseUrl != null )  {  return  baseUrl . toString  ( ) ; }  return null ; }   public void setBaseUrl  (  Url url )  {    this . baseUrl = url ; }   public  Map  < String , String > getDefaultHeaders  ( )  {  return defaultHeaders ; }   public  CellFormatter  <  ? > getFormatter  ( )  {  return formatter ; }   public  List  <  List  < String > > doTable  (   List  <  List  < String > > rows )  {   initialize  (  Runner . SLIM ) ;   List  <  List  < String > >  res =  new  Vector  <  List  < String > >  ( ) ;    getFormatter  ( ) . setDisplayActual  ( displayActualOnRight ) ;    getFormatter  ( ) . setMinLenghtForToggleCollapse  ( minLenForCollapseToggle ) ;  for (  List  < String > r : rows )  {   processSlimRow  ( res , r ) ; }  return res ; }   protected boolean validateState  ( )  {  return  baseUrl != null ; }   protected void setConfig  (  Config c )  {    this . config = c ; }   protected void notifyInvalidState  (  boolean state )  {  if  (  ! state )  {  throw  new RuntimeException  ( "You must specify a base url in the |start|, after the fixture to start" ) ; } }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public void setMultipartFileName  ( )  {  CellWrapper  cell =  row . getCell  ( 1 ) ;  if  (  cell == null )  {    getFormatter  ( ) . exception  (  row . getCell  ( 0 ) , "You must pass a multipart file name to set" ) ; } else  {   multipartFileName =  GLOBALS . substitute  (  cell . text  ( ) ) ;   renderReplacement  ( cell , multipartFileName ) ; } }   public String getMultipartFileName  ( )  {  return multipartFileName ; }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public void setFileName  ( )  {  CellWrapper  cell =  row . getCell  ( 1 ) ;  if  (  cell == null )  {    getFormatter  ( ) . exception  (  row . getCell  ( 0 ) , "You must pass a file name to set" ) ; } else  {   fileName =  GLOBALS . substitute  (  cell . text  ( ) ) ;   renderReplacement  ( cell , fileName ) ; } }   public String getFileName  ( )  {  return fileName ; }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public void setMultipartFileParameterName  ( )  {  CellWrapper  cell =  row . getCell  ( 1 ) ;  if  (  cell == null )  {    getFormatter  ( ) . exception  (  row . getCell  ( 0 ) , "You must pass a parameter name to set" ) ; } else  {   multipartFileParameterName =  GLOBALS . substitute  (  cell . text  ( ) ) ;   renderReplacement  ( cell , multipartFileParameterName ) ; } }   public String getMultipartFileParameterName  ( )  {  return multipartFileParameterName ; }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public void setBody  ( )  {  CellWrapper  cell =  row . getCell  ( 1 ) ;  if  (  cell == null )  {    getFormatter  ( ) . exception  (  row . getCell  ( 0 ) , "You must pass a body to set" ) ; } else  {  String  text =   getFormatter  ( ) . fromRaw  (  cell . text  ( ) ) ;   requestBody =  GLOBALS . substitute  ( text ) ;   renderReplacement  ( cell , requestBody ) ; } }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public void setHeader  ( )  {  CellWrapper  cell =  row . getCell  ( 1 ) ;  if  (  cell == null )  {    getFormatter  ( ) . exception  (  row . getCell  ( 0 ) , "You must pass a header map to set" ) ; } else  {   setHeaders  (  cell . text  ( ) ) ; } }   public void setHeaders  ( )  {   setHeader  ( ) ; }   public void setHeaders  (  String headers )  {  String  substitutedHeaders =  GLOBALS . substitute  ( headers ) ;   requestHeaders =  parseHeaders  ( substitutedHeaders ) ;   CellWrapper  <  ? >  cell =  row . getCell  ( 1 ) ;  if  (  !  substitutedHeaders . equals  ( headers ) )  { 
<<<<<<<
=======
  cell . body  (   getFormatter  ( ) . gray  ( substitutedHeaders ) ) ;
>>>>>>>
 } }   public void PUT  ( )  {   debugMethodCallStart  ( ) ;   doMethod  (  emptifyBody  ( requestBody ) , "Put" ) ;   debugMethodCallEnd  ( ) ; }   public void GET  ( )  {   debugMethodCallStart  ( ) ;   doMethod  ( "Get" ) ;   debugMethodCallEnd  ( ) ; }   public void DELETE  ( )  {   debugMethodCallStart  ( ) ;   doMethod  ( "Delete" ) ;   debugMethodCallEnd  ( ) ; }   public void POST  ( )  {   debugMethodCallStart  ( ) ;   doMethod  (  emptifyBody  ( requestBody ) , "Post" ) ;   debugMethodCallEnd  ( ) ; }    @ SuppressWarnings  (  { "unchecked" , "rawtypes" } ) public void let  ( )  {   debugMethodCallStart  ( ) ;  String  label =    row . getCell  ( 1 ) . text  ( ) . trim  ( ) ;  String  loc =   row . getCell  ( 2 ) . text  ( ) ;  CellWrapper  exprCell =  row . getCell  ( 3 ) ;   exprCell . body  (  GLOBALS . substitute  (  exprCell . body  ( ) ) ) ;  String  expr =  exprCell . text  ( ) ;  CellWrapper  valueCell =  row . getCell  ( 4 ) ;  String  valueCellText =  valueCell . body  ( ) ;  String  valueCellTextReplaced =  GLOBALS . substitute  ( valueCellText ) ;   valueCell . body  ( valueCellTextReplaced ) ;  String  sValue = null ;  try  {  LetHandler  letHandler =  LetHandlerFactory . getHandlerFor  ( loc ) ;  if  (  letHandler != null )  {  StringTypeAdapter  adapter =  new StringTypeAdapter  ( ) ;  try  {   LOG . info  (  "LetHandler of type: " +  letHandler . getClass  ( ) ) ;   sValue =  letHandler . handle  (  getLastResponse  ( ) , namespaceContext , expr ) ;   exprCell . body  (   getFormatter  ( ) . gray  (  exprCell . body  ( ) ) ) ; }  catch (   RuntimeException e )  {    getFormatter  ( ) . exception  ( exprCell ,  e . getMessage  ( ) ) ;   e . printStackTrace  ( ) ; }   GLOBALS . put  ( label , sValue ) ;   adapter . set  ( sValue ) ;    getFormatter  ( ) . check  ( valueCell , adapter ) ; } else  {    getFormatter  ( ) . exception  ( exprCell ,   "I don't know how to process the expression for '" + loc + "'" ) ; } }  catch (   RuntimeException e )  {    getFormatter  ( ) . exception  ( exprCell , e ) ; }  finally  {   debugMethodCallEnd  ( ) ; } }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public void comment  ( )  {   debugMethodCallStart  ( ) ;  CellWrapper  messageCell =  row . getCell  ( 1 ) ;  try  {  String  message =   messageCell . text  ( ) . trim  ( ) ;   message =  GLOBALS . substitute  ( message ) ;   messageCell . body  (   getFormatter  ( ) . gray  ( message ) ) ; }  catch (   RuntimeException e )  {    getFormatter  ( ) . exception  ( messageCell , e ) ; }  finally  {   debugMethodCallEnd  ( ) ; } }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public void evalJs  ( )  {  CellWrapper  jsCell =  row . getCell  ( 1 ) ;  if  (  jsCell == null )  {    getFormatter  ( ) . exception  (  row . getCell  ( 0 ) , "Missing string to evaluate)" ) ;  return ; }  JavascriptWrapper  wrapper =  new JavascriptWrapper  ( ) ;  Object  result = null ;  try  {   result =  wrapper . evaluateExpression  ( lastResponse ,  jsCell . body  ( ) ) ; }  catch (   JavascriptException e )  {    getFormatter  ( ) . exception  (  row . getCell  ( 1 ) , e ) ;  return ; }   lastEvaluation = null ;  if  (  result != null )  {   lastEvaluation =  result . toString  ( ) ; }  StringTypeAdapter  adapter =  new StringTypeAdapter  ( ) ;   adapter . set  ( lastEvaluation ) ;    getFormatter  ( ) . right  (  row . getCell  ( 1 ) , adapter ) ; }    @ SuppressWarnings  ( "rawtypes" ) public void processRow  (   RowWrapper  <  ? > currentRow )  {   row = currentRow ;  CellWrapper  cell0 =  row . getCell  ( 0 ) ;  if  (  cell0 == null )  {  throw  new RuntimeException  ( "Current RestFixture row is not parseable (maybe empty or not existent)" ) ; }  String  methodName =  cell0 . text  ( ) ;  if  (  "" . equals  ( methodName ) )  {  throw  new RuntimeException  ( "RestFixture method not specified" ) ; }  Method  method1 = null ;  try  {   method1 =   getClass  ( ) . getMethod  ( methodName ) ;   method1 . invoke  ( this ) ; }  catch (   SecurityException e )  {  throw  new RuntimeException  (    "Not enough permissions to access method " + methodName + " for this class " +   this . getClass  ( ) . getSimpleName  ( ) , e ) ; }  catch (   NoSuchMethodException e )  {  throw  new RuntimeException  (    "Class " +   this . getClass  ( ) . getName  ( ) + " doesn't have a callable method named " + methodName , e ) ; }  catch (   IllegalArgumentException e )  {  throw  new RuntimeException  (   "Method named " + methodName + " invoked with the wrong argument." , e ) ; }  catch (   IllegalAccessException e )  {  throw  new RuntimeException  (   "Method named " + methodName + " is not public." , e ) ; }  catch (   InvocationTargetException e )  {  throw  new RuntimeException  (   "Method named " + methodName + " threw an exception when executing." , e ) ; } }   protected void initialize  (  Runner runner )  {  boolean  state =  validateState  ( ) ;   notifyInvalidState  ( state ) ;   configFormatter  ( runner ) ;   configFixture  ( ) ;   configRestClient  ( ) ; }   protected String emptifyBody  (  String b )  {  String  body = b ;  if  (  body == null )  {   body = "" ; }  return body ; }   public  Map  < String , String > getHeaders  ( )  {   Map  < String , String >  headers = null ;  if  (  requestHeaders != null )  {   headers = requestHeaders ; } else  {   headers = defaultHeaders ; }  return headers ; }   protected String getRequestBody  ( )  {  return requestBody ; }   protected void setRequestBody  (  String text )  {   requestBody = text ; }   protected  Map  < String , String > getNamespaceContext  ( )  {  return namespaceContext ; }   private void doMethod  (  String m )  {   doMethod  ( null , m ) ; }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) protected void doMethod  (  String body ,  String method )  {  CellWrapper  urlCell =  row . getCell  ( 1 ) ;  String  url =  stripTag  (  urlCell . text  ( ) ) ;  String  resUrl =  GLOBALS . substitute  ( url ) ;  String  rBody =  GLOBALS . substitute  ( body ) ;  try  {   doMethod  ( method , resUrl , rBody ) ;   completeHttpMethodExecution  ( ) ; }  catch (   RuntimeException e )  {  if  (  ignoreReadTimeout &&   e . getMessage  ( ) . contains  ( "Read timed out" ) )  {   completeHttpMethodExecutionWithIgnoredTimeout  ( method ) ; } else  {    getFormatter  ( ) . exception  (  row . getCell  ( 0 ) ,     "Execution of " + method + " caused exception '" +  e . getMessage  ( ) + "'" ) ;   e . printStackTrace  ( ) ; } } }   protected void doMethod  (  String method ,  String resUrl ,  String rBody )  {   setLastRequest  (  partsFactory . buildRestRequest  ( ) ) ;    getLastRequest  ( ) . setMethod  (   RestRequest . Method . valueOf  ( method ) ) ;    getLastRequest  ( ) . addHeaders  (  getHeaders  ( ) ) ;  if  (  fileName != null )  {    getLastRequest  ( ) . setFileName  ( fileName ) ; }  if  (  multipartFileName != null )  {    getLastRequest  ( ) . setMultipartFileName  ( multipartFileName ) ; }    getLastRequest  ( ) . setMultipartFileParameterName  ( multipartFileParameterName ) ;   String  [ ]  uri =  resUrl . split  ( "\\?" ) ;   String  [ ]  thisRequestUrlParts =  buildThisRequestUrl  (  uri [ 0 ] ) ;    getLastRequest  ( ) . setResource  (  thisRequestUrlParts [ 1 ] ) ;  if  (   uri . length == 2 )  {    getLastRequest  ( ) . setQuery  (  uri [ 1 ] ) ; }  if  (   "Post" . equals  ( method ) ||  "Put" . equals  ( method ) )  {    getLastRequest  ( ) . setBody  ( rBody ) ; }   restClient . setBaseUrl  (  thisRequestUrlParts [ 0 ] ) ;  RestResponse  response =  restClient . execute  (  getLastRequest  ( ) ) ;   setLastResponse  ( response ) ; }    @ SuppressWarnings  (  { "unchecked" } ) protected void completeHttpMethodExecutionWithIgnoredTimeout  (  String method )  {  String  uri =   getLastRequest  ( ) . getResource  ( ) ;  String  query =   getLastRequest  ( ) . getQuery  ( ) ;  if  (   query != null &&  !  "" . equals  (  query . trim  ( ) ) )  {   uri =   uri + "?" + query ; }  String  clientBaseUri =  restClient . getBaseUrl  ( ) ;  String  u =  clientBaseUri + uri ;    getFormatter  ( ) . asLink  (  row . getCell  ( 1 ) , u , uri ) ; }   private ContentType getContentTypeOfLastResponse  ( )  {  return  ContentType . parse  (   getLastResponse  ( ) . getHeader  ( "Content-Type" ) ) ; }   private String getCharsetOfLastResponse  ( )  {  return  ContentType . parseCharset  (   getLastResponse  ( ) . getHeader  ( "Content-Type" ) ) ; }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) protected void completeHttpMethodExecution  ( )  {  String  uri =   getLastResponse  ( ) . getResource  ( ) ;  String  query =   getLastRequest  ( ) . getQuery  ( ) ;  if  (   query != null &&  !  "" . equals  (  query . trim  ( ) ) )  {   uri =   uri + "?" + query ; }  String  clientBaseUri =  restClient . getBaseUrl  ( ) ;  String  u =  clientBaseUri + uri ;  CellWrapper  uriCell =  row . getCell  ( 1 ) ;    getFormatter  ( ) . asLink  ( uriCell , u , uri ) ;  CellWrapper  cellStatusCode =  row . getCell  ( 2 ) ;  if  (  cellStatusCode == null )  {  throw  new IllegalStateException  ( "You must specify a status code cell" ) ; }  Integer  lastStatusCode =   getLastResponse  ( ) . getStatusCode  ( ) ;   process  ( cellStatusCode ,  lastStatusCode . toString  ( ) ,  new StatusCodeTypeAdapter  ( ) ) ;   List  < Header >  lastHeaders =   getLastResponse  ( ) . getHeaders  ( ) ;   process  (  row . getCell  ( 3 ) , lastHeaders ,  new HeadersTypeAdapter  ( ) ) ;  CellWrapper  bodyCell =  row . getCell  ( 4 ) ;  if  (  bodyCell == null )  {  throw  new IllegalStateException  ( "You must specify a body cell" ) ; }   bodyCell . body  (  GLOBALS . substitute  (  bodyCell . body  ( ) ) ) ;  BodyTypeAdapter  bodyTypeAdapter =  createBodyTypeAdapter  ( ) ;   process  ( bodyCell ,   getLastResponse  ( ) . getBody  ( ) , bodyTypeAdapter ) ; }   protected BodyTypeAdapter createBodyTypeAdapter  ( )  {  return  createBodyTypeAdapter  (  getContentTypeOfLastResponse  ( ) ) ; }   protected BodyTypeAdapter createBodyTypeAdapter  (  ContentType ct )  {  String  charset =  getCharsetOfLastResponse  ( ) ;  BodyTypeAdapter  bodyTypeAdapter =  partsFactory . buildBodyTypeAdapter  ( ct , charset ) ;   bodyTypeAdapter . setContext  ( namespaceContext ) ;  return bodyTypeAdapter ; }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) private void process  (  CellWrapper expected ,  Object actual ,  RestDataTypeAdapter ta )  {  if  (  expected == null )  {  throw  new IllegalStateException  ( "You must specify a headers cell" ) ; }   ta . set  ( actual ) ;  boolean  ignore =  "" . equals  (   expected . text  ( ) . trim  ( ) ) ;  if  ( ignore )  {  String  actualString =  ta . toString  ( ) ;  if  (  !  "" . equals  ( actualString ) )  {   expected . addToBody  (   getFormatter  ( ) . gray  ( actualString ) ) ; } } else  {  boolean  success = false ;  try  {  String  substitute =  GLOBALS . substitute  (  Tools . fromHtml  (  expected . text  ( ) ) ) ;  Object  parse =  ta . parse  ( substitute ) ;   success =  ta . equals  ( parse , actual ) ; }  catch (   Exception e )  {    getFormatter  ( ) . exception  ( expected , e ) ;  return ; }  if  ( success )  {    getFormatter  ( ) . right  ( expected , ta ) ; } else  {    getFormatter  ( ) . wrong  ( expected , ta ) ; } } }   private void debugMethodCallStart  ( )  {   debugMethodCall  ( "=> " ) ; }   private void debugMethodCallEnd  ( )  {   debugMethodCall  ( "<= " ) ; }   private void debugMethodCall  (  String h )  {  if  ( debugMethodCall )  {  StackTraceElement  el =    Thread . currentThread  ( ) . getStackTrace  ( ) [ 4 ] ;   LOG . debug  (  h +  el . getMethodName  ( ) ) ; } }   protected RestResponse getLastResponse  ( )  {  return lastResponse ; }   protected RestRequest getLastRequest  ( )  {  return lastRequest ; }   private  String  [ ] buildThisRequestUrl  (  String uri )  {   String  [ ]  parts =  new String  [ 2 ] ;  if  (   baseUrl == null ||  uri . startsWith  (  baseUrl . toString  ( ) ) )  {  Url  url =  new Url  ( uri ) ;    parts [ 0 ] =  url . getBaseUrl  ( ) ;    parts [ 1 ] =  url . getResource  ( ) ; } else  {  try  {  Url  attempted =  new Url  ( uri ) ;    parts [ 0 ] =  attempted . getBaseUrl  ( ) ;    parts [ 1 ] =  attempted . getResource  ( ) ; }  catch (   RuntimeException e )  {    parts [ 0 ] =  baseUrl . toString  ( ) ;    parts [ 1 ] = uri ; } }  return parts ; }   private void setLastResponse  (  RestResponse lastResponse )  {    this . lastResponse = lastResponse ; }   private void setLastRequest  (  RestRequest lastRequest )  {    this . lastRequest = lastRequest ; }   private  Map  < String , String > parseHeaders  (  String str )  {  return  Tools . convertStringToMap  ( str , ":" , LINE_SEPARATOR , true ) ; }   private  Map  < String , String > parseNamespaceContext  (  String str )  {  return  Tools . convertStringToMap  ( str , "=" , LINE_SEPARATOR , true ) ; }   private String stripTag  (  String somethingWithinATag )  {  return  Tools . fromSimpleTag  ( somethingWithinATag ) ; }   private void configFormatter  (  Runner runner )  {   formatter =  partsFactory . buildCellFormatter  ( runner ) ; }   private void configFixture  ( )  {   GLOBALS =  new Variables  ( config ) ;   displayActualOnRight =  config . getAsBoolean  ( "restfixture.display.actual.on.right" , displayActualOnRight ) ;   minLenForCollapseToggle =  config . getAsInteger  ( "restfixture.display.toggle.for.cells.larger.than" , minLenForCollapseToggle ) ;  String  str =  config . get  ( "restfixture.default.headers" , "" ) ;   defaultHeaders =  parseHeaders  ( str ) ;   str =  config . get  ( "restfixture.xml.namespace.context" , "" ) ;   namespaceContext =  parseNamespaceContext  ( str ) ;   ignoreReadTimeout =  config . getAsBoolean  ( "restfixture.ignore.read.timeout" , ignoreReadTimeout ) ;   LOG . debug  (  "Using namespaces: " + namespaceContext ) ;   ContentType . resetDefaultMapping  ( ) ;   ContentType . config  ( config ) ; }   private void configRestClient  ( )  {   restClient =  partsFactory . buildRestClient  (  getConfig  ( ) ) ; }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) private void renderReplacement  (  CellWrapper cell ,  String actual )  {  StringTypeAdapter  adapter =  new StringTypeAdapter  ( ) ;   adapter . set  ( actual ) ;  if  (  !  adapter . equals  ( actual ,  cell . body  ( ) ) )  {    getFormatter  ( ) . right  ( cell , adapter ) ; } }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) private void processSlimRow  (   List  <  List  < String > > resultTable ,   List  < String > row )  {  RowWrapper  currentRow =  new SlimRow  ( row ) ;  try  {   processRow  ( currentRow ) ; }  catch (   Exception e )  {   LOG . error  (  "Exception raised when processing row " +  row . get  ( 0 ) , e ) ;    getFormatter  ( ) . exception  (  currentRow . getCell  ( 0 ) , e ) ; }  finally  {   List  < String >  rowAsList =  mapSlimRow  ( row , currentRow ) ;   resultTable . add  ( rowAsList ) ; } }    @ SuppressWarnings  ( "rawtypes" ) private  List  < String > mapSlimRow  (   List  < String > resultRow ,  RowWrapper currentRow )  {   List  < String >  rowAsList =   (  ( SlimRow ) currentRow ) . asList  ( ) ;  for (   int  c = 0 ;  c <  rowAsList . size  ( ) ;  c ++ )  {  String  v =  rowAsList . get  ( c ) ;  if  (  v . equals  (  resultRow . get  ( c ) ) )  {   rowAsList . set  ( c , "" ) ; } }  return rowAsList ; }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public void sleep  ( )  {    System . out . println  ( "sleeping" ) ;   LOG . info  ( "sleeping" ) ;   debugMethodCallStart  ( ) ;  CellWrapper  timeCell =  row . getCell  ( 1 ) ;  try  {   long  ms =  Long . parseLong  (   timeCell . text  ( ) . trim  ( ) ) ;   Thread . sleep  ( ms ) ; }  catch (   InterruptedException e )  { }  finally  {   debugMethodCallEnd  ( ) ; } } }