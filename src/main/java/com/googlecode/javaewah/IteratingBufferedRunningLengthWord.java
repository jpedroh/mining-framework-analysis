  package   com . googlecode . javaewah ;   public final class IteratingBufferedRunningLengthWord  implements  IteratingRLW , Cloneable  {   public IteratingBufferedRunningLengthWord  (   final EWAHIterator iterator )  {    this . iterator = iterator ;    this . brlw =  new BufferedRunningLengthWord  (   this . iterator . next  ( ) ) ;    this . literalWordStartPosition =    this . iterator . literalWords  ( ) +   this . brlw . literalwordoffset ;    this . buffer =   this . iterator . buffer  ( ) ; }   public IteratingBufferedRunningLengthWord  (   final EWAHCompressedBitmap bitmap )  {    this . iterator =  EWAHIterator . getEWAHIterator  ( bitmap ) ;    this . brlw =  new BufferedRunningLengthWord  (   this . iterator . next  ( ) ) ;    this . literalWordStartPosition =    this . iterator . literalWords  ( ) +   this . brlw . literalwordoffset ;    this . buffer =   this . iterator . buffer  ( ) ; }   public void discardFirstWords  (   long x )  {  while  (  x > 0 )  {  if  (    this . brlw . RunningLength > x )  {     this . brlw . RunningLength -= x ;  return ; }   x -=   this . brlw . RunningLength ;     this . brlw . RunningLength = 0 ;   long  toDiscard =   x >   this . brlw . NumberOfLiteralWords ?   this . brlw . NumberOfLiteralWords : x ;    this . literalWordStartPosition += toDiscard ;     this . brlw . NumberOfLiteralWords -= toDiscard ;   x -= toDiscard ;  if  (   (  x > 0 ) ||  (    this . brlw . size  ( ) == 0 ) )  {  if  (  !   this . iterator . hasNext  ( ) )  {  break ; }    this . brlw . reset  (   this . iterator . next  ( ) ) ;    this . literalWordStartPosition =   this . iterator . literalWords  ( ) ; } } }   public boolean next  ( )  {  if  (  !   this . iterator . hasNext  ( ) )  {     this . brlw . NumberOfLiteralWords = 0 ;     this . brlw . RunningLength = 0 ;  return false ; }    this . brlw . reset  (   this . iterator . next  ( ) ) ;    this . literalWordStartPosition =   this . iterator . literalWords  ( ) ;  return true ; }   public  long discharge  (  BitmapStorage container ,   long max )  {   long  index = 0 ;  while  (   (  index < max ) &&  (   size  ( ) > 0 ) )  {   long  pl =  getRunningLength  ( ) ;  if  (   index + pl > max )  {   pl =  max - index ; }   container . addStreamOfEmptyWords  (  getRunningBit  ( ) , pl ) ;   index += pl ;   int  pd =  getNumberOfLiteralWords  ( ) ;  if  (   pd + index > max )  {   pd =  (  int )  (  max - index ) ; }   writeLiteralWords  ( pd , container ) ;   discardFirstWords  (  pl + pd ) ;   index += pd ; }  return index ; }   public  long dischargeNegated  (  BitmapStorage container ,   long max )  {   long  index = 0 ;  while  (   (  index < max ) &&  (   size  ( ) > 0 ) )  {   long  pl =  getRunningLength  ( ) ;  if  (   index + pl > max )  {   pl =  max - index ; }   container . addStreamOfEmptyWords  (  !  getRunningBit  ( ) , pl ) ;   index += pl ;   int  pd =  getNumberOfLiteralWords  ( ) ;  if  (   pd + index > max )  {   pd =  (  int )  (  max - index ) ; }   writeNegatedLiteralWords  ( pd , container ) ;   discardFirstWords  (  pl + pd ) ;   index += pd ; }  return index ; }   public void dischargeAsEmpty  (  BitmapStorage container )  {  while  (   size  ( ) > 0 )  {   container . addStreamOfEmptyWords  ( false ,  size  ( ) ) ;   discardFirstWords  (  size  ( ) ) ; } }   public void discharge  (  BitmapStorage container )  {     this . brlw . literalwordoffset =   this . literalWordStartPosition -   this . iterator . literalWords  ( ) ;   discharge  (  this . brlw ,  this . iterator , container ) ; }   public  long getLiteralWordAt  (   int index )  {  return   this . buffer [   this . literalWordStartPosition + index ] ; }   public  int getNumberOfLiteralWords  ( )  {  return   this . brlw . NumberOfLiteralWords ; }   public boolean getRunningBit  ( )  {  return   this . brlw . RunningBit ; }   public  long getRunningLength  ( )  {  return   this . brlw . RunningLength ; }   public  long size  ( )  {  return   this . brlw . size  ( ) ; }   public void writeLiteralWords  (   int numWords ,  BitmapStorage container )  {   container . addStreamOfLiteralWords  (  this . buffer ,  this . literalWordStartPosition , numWords ) ; }   public void writeNegatedLiteralWords  (   int numWords ,  BitmapStorage container )  {   container . addStreamOfNegatedLiteralWords  (  this . buffer ,  this . literalWordStartPosition , numWords ) ; }   private static void discharge  (   final BufferedRunningLengthWord initialWord ,   final EWAHIterator iterator ,   final BitmapStorage container )  {  BufferedRunningLengthWord  runningLengthWord = initialWord ;  for ( ; ; )  {   final  long  runningLength =  runningLengthWord . getRunningLength  ( ) ;   container . addStreamOfEmptyWords  (  runningLengthWord . getRunningBit  ( ) , runningLength ) ;   container . addStreamOfLiteralWords  (  iterator . buffer  ( ) ,   iterator . literalWords  ( ) +  runningLengthWord . literalwordoffset ,  runningLengthWord . getNumberOfLiteralWords  ( ) ) ;  if  (  !  iterator . hasNext  ( ) )  break ;   runningLengthWord =  new BufferedRunningLengthWord  (  iterator . next  ( ) ) ; } }   public IteratingBufferedRunningLengthWord clone  ( )  throws CloneNotSupportedException  {  IteratingBufferedRunningLengthWord  answer =  ( IteratingBufferedRunningLengthWord )  super . clone  ( ) ;    answer . brlw =   this . brlw . clone  ( ) ;    answer . buffer =  this . buffer ;    answer . iterator =   this . iterator . clone  ( ) ;    answer . literalWordStartPosition =  this . literalWordStartPosition ;  return answer ; }   private BufferedRunningLengthWord  brlw ;   private   long  [ ]  buffer ;   private  int  literalWordStartPosition ;   private EWAHIterator  iterator ; }