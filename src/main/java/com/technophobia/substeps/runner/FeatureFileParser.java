  package    com . technophobia . substeps . runner ;   import   java . io . File ;  import   java . io . IOException ;  import    java . nio . charset . Charset ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Set ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import   junit . framework . Assert ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     com . google . common . base . Strings ;  import     com . google . common . io . Files ;  import     com . technophobia . substeps . model . FeatureFile ;  import     com . technophobia . substeps . model . Scenario ;  import     com . technophobia . substeps . model . Step ;  import     com . technophobia . substeps . model . Background ;   public class FeatureFileParser  {   private final Logger  log =  LoggerFactory . getLogger  (  FeatureFileParser . class ) ;   private static  Map  < String , Directive >  directiveMap =  new  HashMap  < String , Directive >  ( ) ;   private  List  < String >  currentFeatureFileLines = null ;   private String  currentOriginalFileContents = null ;   private   int  [ ]  currentFileOffsets = null ;   public FeatureFile loadFeatureFile  (   final File featureFile )  {    this . currentFeatureFileLines = null ;   final FeatureFile  ff =  new FeatureFile  ( ) ;   ff . setSourceFile  ( featureFile ) ;   Assert . assertTrue  (   "Feature file: " +  featureFile . getAbsolutePath  ( ) + " does not exist!" ,  featureFile . exists  ( ) ) ;   readFeatureFile  ( featureFile ) ;   final String  deCommented =  stripCommentsAndBlankLines  (  this . currentFeatureFileLines ) ;   chunkUpFeatureFile  ( deCommented , ff ) ;  if  (  parseFeatureDescription  ( ff ) )  {  if  (   ff . getScenarios  ( ) != null )  {  for (  final Scenario sc :  ff . getScenarios  ( ) )  {   buildScenario  ( sc , featureFile ) ; }   cascadeTags  ( ff ) ;   cleanup  ( ) ;  return ff ; } else  {    this . log . debug  (   "discarding feature " +  featureFile . getName  ( ) + "as no scenarios" ) ;  return null ; } } else  {    this . log . debug  (   "discarding feature " +  featureFile . getName  ( ) + "as no feature description" ) ;  return null ; } }   private void cleanup  ( )  {    this . currentOriginalFileContents = null ;    this . currentFeatureFileLines = null ;    this . currentFileOffsets = null ; }   private void readFeatureFile  (   final File featureFile )  {    this . currentFeatureFileLines = null ;  try  {   currentFeatureFileLines =  Files . readLines  ( featureFile ,  Charset . forName  ( "UTF-8" ) ) ;    this . currentOriginalFileContents =  Files . toString  ( featureFile ,  Charset . forName  ( "UTF-8" ) ) ;    this . currentFileOffsets =  new  int  [  currentFeatureFileLines . size  ( ) ] ;   int  lastOffset = 0 ;  for (   int  i = 0 ;  i <  currentFeatureFileLines . size  ( ) ;  i ++ )  {   final String  s =  currentFeatureFileLines . get  ( i ) ;     this . currentFileOffsets [ i ] =   this . currentOriginalFileContents . indexOf  ( s , lastOffset ) ;   lastOffset =    this . currentFileOffsets [ i ] +  s . length  ( ) ; } }  catch (   final  IOException e )  {    this . log . error  (  "failed to load feature file: " +  e . getMessage  ( ) , e ) ; } }   private String convertElementToPattern  (   final String element )  {   final StringBuilder  buf =  new StringBuilder  ( ) ;   final  String  [ ]  lines =  element . split  ( "\n" ) ;  boolean  first = true ;   buf . append  ( "(" ) ;  for (  final String s : lines )  {  if  (  ! first )  {   buf . append  ( ".*" ) ; }   first = false ;   buf . append  (  Pattern . quote  ( s ) ) ; }   buf . append  ( ")" ) ;  return  buf . toString  ( ) ; }   private void cascadeTags  (   final FeatureFile ff )  {  if  (    ff != null &&   ff . getTags  ( ) != null &&  !   ff . getTags  ( ) . isEmpty  ( ) )  {  for (  final Scenario sc :  ff . getScenarios  ( ) )  {  if  (   sc . getTags  ( ) == null )  {   sc . setTags  (  ff . getTags  ( ) ) ; } else  {    sc . getTags  ( ) . addAll  (  ff . getTags  ( ) ) ; } } } }   private boolean parseFeatureDescription  (   final FeatureFile ff )  {  boolean  valid = true ;   final String  raw =  ff . getRawText  ( ) ;  if  (  Strings . isNullOrEmpty  ( raw ) )  {   valid = false ; } else  {   final  String  [ ]  lines =  raw . split  ( "\n" ) ;   final StringBuilder  description =  new StringBuilder  ( ) ;  for (   int  i = 0 ;  i <  lines . length ;  i ++ )  {   final String  line =  lines [ i ] ;  if  (  i == 0 )  {   final  int  idx =  line . indexOf  ( ':' ) ;   ff . setName  (   line . substring  (  idx + 1 ) . trim  ( ) ) ; } else  {  if  (   description . length  ( ) > 0 )  {   description . append  ( "\n" ) ; }   description . append  ( line ) ; } } }  return valid ; }   private  int getSourceLineNumber  (   final String line ,   final  int offset )  {   int  lineNumber =  - 1 ;   final  int  idx =   this . currentOriginalFileContents . indexOf  ( line ) ;  if  (  idx !=  - 1 )  {   lineNumber =  getSourceLineNumberForOffset  ( offset ) ; }  return lineNumber ; }   private  int getSourceLineNumberForOffset  (   final  int offset )  {   int  lineNumber =  - 1 ;   lineNumber = 0 ;  for ( ;  lineNumber <   this . currentFileOffsets . length ;  lineNumber ++ )  {  if  (    this . currentFileOffsets [ lineNumber ] > offset )  {  break ; } }  return lineNumber ; }   private void buildScenario  (   final Scenario sc ,   final File file )  {   final String  raw =  sc . getRawText  ( ) ;   final  String  [ ]  lines =  raw . split  ( "\n" ) ;  boolean  collectExamples = false ;   int  lastOffset =  sc . getSourceStartOffset  ( ) ;   sc . setSourceStartLineNumber  (  getSourceLineNumberForOffset  ( lastOffset ) ) ;  for (   int  i = 0 ;  i <  lines . length ;  i ++ )  {   final String  line =  lines [ i ] ;   final  int  lineNumber =  this . getSourceLineNumber  ( line , lastOffset ) ;  if  (   lineNumber + 1 <   this . currentFileOffsets . length )  {   lastOffset =    this . currentFileOffsets [  lineNumber + 1 ] - 1 ; } else  {   lastOffset =   this . currentOriginalFileContents . length  ( ) ; }  if  (  i == 0 )  {   final  int  idx =  line . indexOf  ( ':' ) ;   sc . setDescription  (   line . substring  (  idx + 1 ) . trim  ( ) ) ;   sc . setScenarioLineNumber  ( lineNumber ) ; } else  if  (  line . startsWith  (   Directive . EXAMPLES . val ) )  {   collectExamples = true ; } else  {  if  (  line . startsWith  ( "|" ) )  {  if  ( collectExamples )  {   parseExamples  ( lineNumber , line , sc ) ; } else  {   final Step  last =   sc . getSteps  ( ) . get  (    sc . getSteps  ( ) . size  ( ) - 1 ) ;   final  String  [ ]  data =  line . split  ( "\\|" ) ;   last . addTableData  ( data ) ; } } else  {   sc . addStep  (  new Step  ( line , file , lineNumber ) ) ; } } } }   private static final Pattern  DIRECTIVE_PATTERN =  Pattern . compile  ( "([\\w ]*):" ) ;   private void chunkUpFeatureFile  (   final String fileContents ,   final FeatureFile ff )  {   final String  topLevelFeatureElements  [ ] =  fileContents . split  ( "(?=Tags:)|(?=Feature:)|(?=Background:)|(?=Scenario:)|(?=Scenario Outline:)" ) ;   Set  < String >  currentTags = null ;  if  (  topLevelFeatureElements != null )  {  String  currentBackground = null ;  for (  final String element : topLevelFeatureElements )  {   final String  pattern =  convertElementToPattern  ( element ) ;   final Pattern  finderPattern =  Pattern . compile  ( pattern ,  Pattern . DOTALL ) ;   final Matcher  matcher =  finderPattern . matcher  (  this . currentOriginalFileContents ) ;   int  start =  - 1 ;   int  end =  - 1 ;  if  (  matcher . find  ( ) )  {   start =  matcher . start  ( 0 ) ;   end =  matcher . end  ( 0 ) ; }  if  (  !  Strings . isNullOrEmpty  ( element ) )  {    this . log . trace  (  "topLevelElement:\n" + element ) ;   final Matcher  m =  DIRECTIVE_PATTERN . matcher  ( element ) ;  if  (  m . lookingAt  ( ) )  {   final Directive  directive =  directiveMap . get  (  m . group  ( 1 ) ) ;  switch  ( directive )  {   case TAGS :  {  if  (  currentTags == null )  {   currentTags =  new  HashSet  < String >  ( ) ; }   processTags  ( currentTags , element ) ;  break ; }   case FEATURE :  {   ff . setRawText  ( element ) ;  if  (  currentTags != null )  {   ff . setTags  ( currentTags ) ; }   currentTags = null ;   currentBackground = null ;  break ; }   case BACKGROUND :  {   currentBackground = element ;  break ; }   case SCENARIO :  {   processScenarioDirective  ( ff , currentTags , currentBackground , element , false , start , end ) ;   currentTags = null ;  break ; }   case SCENARIO_OUTLINE :  {   processScenarioDirective  ( ff , currentTags , currentBackground , element , true , start , end ) ;   currentTags = null ;  break ; }   default :  {    this . log . error  ( "unknown directive" ) ;  break ; } } } } } } }   private void processScenarioDirective  (   final FeatureFile ff ,   final  Set  < String > currentTags ,   final String currentBackground ,   final String sc ,   final boolean outline ,   final  int start ,   final  int end )  {   final Scenario  scenario =  new Scenario  ( ) ;   scenario . setRawText  ( sc ) ;   scenario . setTags  ( currentTags ) ;   scenario . setOutline  ( outline ) ;   scenario . setSourceStartOffset  ( start ) ;   scenario . setSourceEndOffset  ( end ) ;   ff . addScenario  ( scenario ) ;  if  (  currentBackground != null )  {   scenario . setBackgroundRawText  ( currentBackground ) ; } }   private void processTags  (   final  Set  < String > currentTags ,   final String raw )  {   final String  postDirective =  raw . substring  (   raw . indexOf  ( ':' ) + 1 ) ;   final  String  [ ]  split =  postDirective . split  ( "\\s" ) ;  for (  final String s : split )  {   final String  trimmed =  s . trim  ( ) ;  if  (   trimmed . length  ( ) > 0 )  {   currentTags . add  (  s . trim  ( ) ) ; } } }   public static String stripComments  (   final String line )  {  String  trimmed = null ;  if  (  line != null )  {   final  int  idx =   line . trim  ( ) . indexOf  ( "#" ) ;  if  (  idx >= 0 )  {  boolean  doTrim = false ;  if  (  idx == 0 )  {   doTrim = true ; }   final  String  [ ]  splitByQuotes =  line . split  ( "\"[^\"]*\"|'[^']*'" ) ;  for (  final String split : splitByQuotes )  {  if  (   split . indexOf  ( "#" ) > 0 )  {   doTrim = true ;  break ; } }  if  ( doTrim )  {   trimmed =    line . trim  ( ) . substring  ( 0 , idx ) . trim  ( ) ; } else  {   trimmed =  line . trim  ( ) ; } } else  {   trimmed =  line . trim  ( ) ; } }  return trimmed ; }   private String stripCommentsAndBlankLines  (   final  List  < String > lines )  {   final StringBuilder  buf =  new StringBuilder  ( ) ;  for (  final String s : lines )  {   final String  trimmed =  stripComments  ( s ) ;  if  (  !  Strings . isNullOrEmpty  ( trimmed ) )  {   buf . append  ( trimmed ) ;   buf . append  ( "\n" ) ; } }  return  buf . toString  ( ) ; }   private void parseExamples  (   final  int lineNumber ,   final String trimmed ,   final Scenario sc )  {   final  String  [ ]  split =  trimmed . split  ( "\\|" ) ;  if  (   sc . getExampleParameters  ( ) == null )  {   sc . addExampleKeys  ( split ) ;   sc . setExampleKeysLineNumber  ( lineNumber ) ; } else  {   sc . addExampleValues  ( lineNumber , split ) ; } }   private static enum Directive  {  TAGS  ( "Tags" ) ,  FEATURE  ( "Feature" ) ,  BACKGROUND  ( "Background" ) ,  SCENARIO  ( "Scenario" ) ,  SCENARIO_OUTLINE  ( "Scenario Outline" ) ,  EXAMPLES  ( "Examples" )  ;  Directive  (   final String val )  {    this . val = val ; }   private final String  val ; }  static  {  for (  final Directive d :  Directive . values  ( ) )  {   directiveMap . put  (  d . val , d ) ; } } 
<<<<<<<
=======
  private void processScenarioDirective  (   final FeatureFile ff ,   final  Set  < String > currentTags ,   final String currentBackground ,   final String sc ,   final boolean outline )  {   final Scenario  scenario =  new Scenario  ( ) ;   scenario . setRawText  ( sc ) ;   scenario . setTags  ( currentTags ) ;   scenario . setOutline  ( outline ) ;   ff . addScenario  ( scenario ) ;  if  (  currentBackground != null )  {   scenario . setBackground  (  new Background  (  backgroundLineNumber  ( ) , currentBackground ,  ff . getSourceFile  ( ) ) ) ; } }
>>>>>>>
   private  int backgroundLineNumber  ( )  {  for (   int  i = 0 ;  i <  currentFeatureFileLines . size  ( ) ;  i ++ )  {  if  (   currentFeatureFileLines . get  ( i ) . startsWith  ( "Background:" ) )  {  return i ; } }  return 0 ; } }