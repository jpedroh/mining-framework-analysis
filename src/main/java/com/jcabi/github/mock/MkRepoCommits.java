  package    com . jcabi . github . mock ;   import    com . jcabi . aspects . Immutable ;  import    com . jcabi . aspects . Loggable ;  import    com . jcabi . github . CommitsComparison ;  import    com . jcabi . github . Coordinates ;  import    com . jcabi . github . RepoCommit ;  import    com . jcabi . github . RepoCommits ;  import   java . io . IOException ;  import   javax . json . JsonObject ;  import  lombok . EqualsAndHashCode ;  import  lombok . ToString ;  import    com . jcabi . xml . XML ;  import    javax . validation . constraints . NotNull ;  import   org . xembly . Directives ;    @ Immutable  @ Loggable  (  Loggable . DEBUG )  @ ToString  @ EqualsAndHashCode  (  of =  { "storage" , "self" , "coords" } ) final class MkRepoCommits  implements  RepoCommits  {   private final transient MkStorage  storage ;   private final transient String  self ;   private final transient Coordinates  coords ;  MkRepoCommits  (   final  @ NotNull  (  message = "stg can't be NULL" ) MkStorage stg ,   final  @ NotNull  (  message = "login can't be NULL" ) String login ,   final  @ NotNull  (  message = "repo can't be NULL" ) Coordinates repo )  throws IOException  {    this . storage = stg ;    this . self = login ;    this . coords = repo ;    this . storage . apply  (    new Directives  ( ) . xpath  (  String . format  ( "/github/repos/repo[@coords='%s']" ,  this . coords ) ) . addIf  ( "commits" ) ) ; }    @ Override public  @ NotNull  (  message = "Iterable of commits can't be NULL" )  Iterable  < RepoCommit > iterate  ( )  {  return  new  MkIterable  < RepoCommit >  (  this . storage ,  String . format  ( "%s/commit" ,  this . xpath  ( ) ) ,  new   MkIterable . Mapping  < RepoCommit >  ( )  {    @ Override public RepoCommit map  (   final XML xml )  {  return   MkRepoCommits . this . get  (   xml . xpath  ( "sha/text()" ) . get  ( 0 ) ) ; } } ) ; }    @ Override public  @ NotNull  (  message = "repocommit can't be NULL" ) RepoCommit get  (   final  @ NotNull  (  message = "sha shouldn't be NULL" ) String sha )  {  return  new MkRepoCommit  (  this . storage ,  new MkRepo  (  this . storage ,  this . self ,  this . coords ) , sha ) ; }    @ Override public  @ NotNull  (  message = "comparison is never NULL" ) CommitsComparison compare  (   final  @ NotNull  (  message = "base can't be NULL" ) String base ,   final  @ NotNull  (  message = "head can't be NULL" ) String head )  {  return  new MkCommitsComparison  (  this . storage ,  this . self ,  this . coords ) ; }    @ Override public  @ NotNull  (  message = "diff is never NULL" ) String diff  (   final  @ NotNull  (  message = "base should not be NULL" ) String base ,   final  @ NotNull  (  message = "head should not be NULL" ) String head )  throws IOException  {  throw  new UnsupportedOperationException  ( "MkRepoCommits#diff()" ) ; }    @ Override public  @ NotNull  (  message = "patch is never NULL" ) String patch  (   final  @ NotNull  (  message = "base shouldn't be NULL" ) String base ,   final  @ NotNull  (  message = "head shouldn't be NULL" ) String head )  throws IOException  {  throw  new UnsupportedOperationException  ( "MkRepoCommits#patch()" ) ; }    @ Override public  @ NotNull  (  message = "JSON is never NULL" ) JsonObject json  ( )  throws IOException  {  return   new JsonNode  (     this . storage . xml  ( ) . nodes  (  this . xpath  ( ) ) . get  ( 0 ) ) . json  ( ) ; }   private  @ NotNull  (  message = "Xpath is never NULL" ) String xpath  ( )  {  return  String . format  ( "/github/repos/repo[@coords='%s']/commits" ,  this . coords ) ; } }