  package   com . jcabi . dynamo ;   import   com . amazonaws . AmazonClientException ;  import     com . amazonaws . services . dynamodbv2 . AmazonDynamoDB ;  import      com . amazonaws . services . dynamodbv2 . model . AttributeValue ;  import      com . amazonaws . services . dynamodbv2 . model . Condition ;  import      com . amazonaws . services . dynamodbv2 . model . ReturnConsumedCapacity ;  import      com . amazonaws . services . dynamodbv2 . model . ScanRequest ;  import      com . amazonaws . services . dynamodbv2 . model . ScanResult ;  import      com . amazonaws . services . dynamodbv2 . model . Select ;  import     com . google . common . collect . Iterables ;  import    com . jcabi . aspects . Immutable ;  import    com . jcabi . aspects . Loggable ;  import    com . jcabi . aspects . Tv ;  import    com . jcabi . log . Logger ;  import   java . io . IOException ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Map ;  import  lombok . EqualsAndHashCode ;  import  lombok . ToString ;    @ Immutable  @ ToString  @ Loggable  (  Loggable . DEBUG )  @ EqualsAndHashCode  (  of =  { "limit" , "attributes" } ) public final class ScanValve  implements  Valve  {   private final transient  int  limit ;    @  Immutable . Array private final transient  String  [ ]  attributes ;   public ScanValve  ( )  {  this  (  Tv . HUNDRED ,  new  ArrayList  < String >  ( 0 ) ) ; }   private ScanValve  (   final  int lmt ,   final  Iterable  < String > attrs )  {    this . limit = lmt ;    this . attributes =  Iterables . toArray  ( attrs ,  String . class ) ; }    @ Override public Dosage fetch  (   final Credentials credentials ,   final String table ,   final  Map  < String , Condition > conditions ,   final  Collection  < String > keys )  throws IOException  {   final AmazonDynamoDB  aws =  credentials . aws  ( ) ;  try  {   final  Collection  < String >  attrs =  new  HashSet  < String >  (  Arrays . asList  (  this . attributes ) ) ;   attrs . addAll  ( keys ) ;   final ScanRequest  request =       new ScanRequest  ( ) . withTableName  ( table ) . withAttributesToGet  ( attrs ) . withReturnConsumedCapacity  (  ReturnConsumedCapacity . TOTAL ) . withScanFilter  ( conditions ) . withLimit  (  this . limit ) ;   final  long  start =  System . currentTimeMillis  ( ) ;   final ScanResult  result =  aws . scan  ( request ) ;   Logger . info  ( this , "#items(): loaded %d item(s) from '%s' using %s, %s, in %[ms]s" ,  result . getCount  ( ) , table , conditions ,   new PrintableConsumedCapacity  (  result . getConsumedCapacity  ( ) ) . print  ( ) ,   System . currentTimeMillis  ( ) - start ) ;  return  new  ScanValve . NextDosage  ( credentials , request , result ) ; }  catch (   final  AmazonClientException ex )  {  throw  new IOException  (  String . format  ( "failed to fetch from \"%s\" by %s and %s" , table , conditions , keys ) , ex ) ; }  finally  {   aws . shutdown  ( ) ; } }    @ Override public  int count  (   final Credentials credentials ,   final String table ,   final  Map  < String , Condition > conditions )  throws IOException  {   final AmazonDynamoDB  aws =  credentials . aws  ( ) ;  try  {   final ScanRequest  request =       new ScanRequest  ( ) . withTableName  ( table ) . withReturnConsumedCapacity  (  ReturnConsumedCapacity . TOTAL ) . withScanFilter  ( conditions ) . withSelect  (  Select . COUNT ) . withLimit  (  Integer . MAX_VALUE ) ;   final  long  start =  System . currentTimeMillis  ( ) ;   final ScanResult  rslt =  aws . scan  ( request ) ;   final  int  count =  rslt . getCount  ( ) ;   Logger . info  ( this , "#total(): COUNT=%d in '%s' using %s, %s, in %[ms]s" , count ,  request . getTableName  ( ) ,  request . getFilterExpression  ( ) ,  AwsTable . print  (  rslt . getConsumedCapacity  ( ) ) ,   System . currentTimeMillis  ( ) - start ) ;  return count ; }  finally  {   aws . shutdown  ( ) ; } }   public ScanValve withLimit  (   final  int lmt )  {  return  new ScanValve  ( lmt ,  Arrays . asList  (  this . attributes ) ) ; }   public ScanValve withAttributeToGet  (   final String name )  {  return  new ScanValve  (  this . limit ,  Iterables . concat  (  Arrays . asList  (  this . attributes ) ,  Collections . singletonList  ( name ) ) ) ; }   public ScanValve withAttributeToGet  (   final String ...  names )  {  return  new ScanValve  (  this . limit ,  Iterables . concat  (  Arrays . asList  (  this . attributes ) ,  Arrays . asList  ( names ) ) ) ; }    @ ToString  @ Loggable  (  Loggable . DEBUG )  @ EqualsAndHashCode  (  of =  { "credentials" , "request" , "result" } ) private final class NextDosage  implements  Dosage  {   private final transient Credentials  credentials ;   private final transient ScanRequest  request ;   private final transient ScanResult  result ;  NextDosage  (   final Credentials creds ,   final ScanRequest rqst ,   final ScanResult rslt )  {    this . credentials = creds ;    this . request = rqst ;    this . result = rslt ; }    @ Override public  List  <  Map  < String , AttributeValue > > items  ( )  {  return   this . result . getItems  ( ) ; }    @ Override public boolean hasNext  ( )  {  return    this . result . getLastEvaluatedKey  ( ) != null ; }    @ Override public Dosage next  ( )  {  if  (  !  this . hasNext  ( ) )  {  throw  new IllegalStateException  ( "nothing left in the iterator" ) ; }   final AmazonDynamoDB  aws =   this . credentials . aws  ( ) ;  try  {   final ScanRequest  rqst =   this . request . withExclusiveStartKey  (   this . result . getLastEvaluatedKey  ( ) ) ;   final  long  start =  System . currentTimeMillis  ( ) ;   final ScanResult  rslt =  aws . scan  ( rqst ) ;   Logger . info  ( this , "#next(): loaded %d item(s) from '%s' using %s, %s, in %[ms]s" ,  rslt . getCount  ( ) ,  rqst . getTableName  ( ) ,  rqst . getScanFilter  ( ) ,   new PrintableConsumedCapacity  (  rslt . getConsumedCapacity  ( ) ) . print  ( ) ,   System . currentTimeMillis  ( ) - start ) ;  return  new  ScanValve . NextDosage  (  this . credentials , rqst , rslt ) ; }  finally  {   aws . shutdown  ( ) ; } } } }