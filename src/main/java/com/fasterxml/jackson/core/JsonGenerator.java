  package    com . fasterxml . jackson . core ;   import  java . io .  * ;  import   java . math . BigDecimal ;  import   java . math . BigInteger ;  import      com . fasterxml . jackson . core . JsonParser . NumberType ;  import      com . fasterxml . jackson . core . io . CharacterEscapes ;  import      com . fasterxml . jackson . core . json . JsonFactory ;  import      com . fasterxml . jackson . core . type . WritableTypeId ;  import       com . fasterxml . jackson . core . type . WritableTypeId . Inclusion ;  import      com . fasterxml . jackson . core . util . VersionUtil ;  import static     com . fasterxml . jackson . core . JsonTokenId .  * ;   public abstract class JsonGenerator  implements  Closeable , Flushable , Versioned  {   protected JsonGenerator  ( )  { }    @ Override public abstract Version version  ( ) ;   public abstract TokenStreamContext getOutputContext  ( ) ;   public abstract ObjectWriteContext getObjectWriteContext  ( ) ;   public Object getOutputTarget  ( )  {  return null ; }   public  int getOutputBuffered  ( )  {  return  - 1 ; }   public abstract Object getCurrentValue  ( ) ;   public abstract void setCurrentValue  (  Object v ) ;   public abstract JsonGenerator enable  (  StreamWriteFeature f ) ;   public abstract JsonGenerator disable  (  StreamWriteFeature f ) ;   public final JsonGenerator configure  (  StreamWriteFeature f ,  boolean state )  {  if  ( state )   enable  ( f ) ; else   disable  ( f ) ;  return this ; }   public abstract boolean isEnabled  (  StreamWriteFeature f ) ;   public abstract  int streamWriteFeatures  ( ) ;   public abstract  int formatWriteFeatures  ( ) ;   public FormatSchema getSchema  ( )  {  return null ; }   public JsonGenerator setHighestNonEscapedChar  (   int charCode )  {  return this ; }   public  int getHighestNonEscapedChar  ( )  {  return 0 ; }   public CharacterEscapes getCharacterEscapes  ( )  {  return null ; }   public JsonGenerator setCharacterEscapes  (  CharacterEscapes esc )  {  return this ; }   public boolean canUseSchema  (  FormatSchema schema )  {  return false ; }   public boolean canWriteObjectId  ( )  {  return false ; }   public boolean canWriteTypeId  ( )  {  return false ; }   public boolean canWriteBinaryNatively  ( )  {  return false ; }   public boolean canOmitFields  ( )  {  return true ; }   public boolean canWriteFormattedNumbers  ( )  {  return false ; }   public abstract void writeStartArray  ( )  throws IOException ;   public abstract void writeStartArray  (  Object currentValue )  throws IOException ;   public abstract void writeStartArray  (  Object currentValue ,   int size )  throws IOException ;   public abstract void writeEndArray  ( )  throws IOException ;   public abstract void writeStartObject  ( )  throws IOException ;   public abstract void writeStartObject  (  Object currentValue )  throws IOException ;   public abstract void writeStartObject  (  Object forValue ,   int size )  throws IOException ;   public abstract void writeEndObject  ( )  throws IOException ;   public abstract void writeFieldName  (  String name )  throws IOException ;   public abstract void writeFieldName  (  SerializableString name )  throws IOException ;   public abstract void writeFieldId  (   long id )  throws IOException ;   public void writeArray  (    int  [ ] array ,   int offset ,   int length )  throws IOException  {  if  (  array == null )  {  throw  new IllegalArgumentException  ( "null array" ) ; }   _verifyOffsets  (  array . length , offset , length ) ;   writeStartArray  ( array , length ) ;  for (   int  i = offset ,  end =  offset + length ;  i < end ;  ++ i )  {   writeNumber  (  array [ i ] ) ; }   writeEndArray  ( ) ; }   public void writeArray  (    long  [ ] array ,   int offset ,   int length )  throws IOException  {  if  (  array == null )  {  throw  new IllegalArgumentException  ( "null array" ) ; }   _verifyOffsets  (  array . length , offset , length ) ;   writeStartArray  ( array , length ) ;  for (   int  i = offset ,  end =  offset + length ;  i < end ;  ++ i )  {   writeNumber  (  array [ i ] ) ; }   writeEndArray  ( ) ; }   public void writeArray  (    double  [ ] array ,   int offset ,   int length )  throws IOException  {  if  (  array == null )  {  throw  new IllegalArgumentException  ( "null array" ) ; }   _verifyOffsets  (  array . length , offset , length ) ;   writeStartArray  ( array , length ) ;  for (   int  i = offset ,  end =  offset + length ;  i < end ;  ++ i )  {   writeNumber  (  array [ i ] ) ; }   writeEndArray  ( ) ; }   public abstract void writeString  (  String text )  throws IOException ;   public void writeString  (  Reader reader ,   int len )  throws IOException  {   _reportUnsupportedOperation  ( ) ; }   public abstract void writeString  (    char  [ ] text ,   int offset ,   int len )  throws IOException ;   public abstract void writeString  (  SerializableString text )  throws IOException ;   public abstract void writeRawUTF8String  (    byte  [ ] text ,   int offset ,   int length )  throws IOException ;   public abstract void writeUTF8String  (    byte  [ ] text ,   int offset ,   int length )  throws IOException ;   public abstract void writeRaw  (  String text )  throws IOException ;   public abstract void writeRaw  (  String text ,   int offset ,   int len )  throws IOException ;   public abstract void writeRaw  (    char  [ ] text ,   int offset ,   int len )  throws IOException ;   public abstract void writeRaw  (   char c )  throws IOException ;   public void writeRaw  (  SerializableString raw )  throws IOException  {   writeRaw  (  raw . getValue  ( ) ) ; }   public abstract void writeRawValue  (  String text )  throws IOException ;   public abstract void writeRawValue  (  String text ,   int offset ,   int len )  throws IOException ;   public abstract void writeRawValue  (    char  [ ] text ,   int offset ,   int len )  throws IOException ;   public void writeRawValue  (  SerializableString raw )  throws IOException  {   writeRawValue  (  raw . getValue  ( ) ) ; }   public abstract void writeBinary  (  Base64Variant bv ,    byte  [ ] data ,   int offset ,   int len )  throws IOException ;   public void writeBinary  (    byte  [ ] data ,   int offset ,   int len )  throws IOException  {   writeBinary  (  Base64Variants . getDefaultVariant  ( ) , data , offset , len ) ; }   public void writeBinary  (    byte  [ ] data )  throws IOException  {   writeBinary  (  Base64Variants . getDefaultVariant  ( ) , data , 0 ,  data . length ) ; }   public  int writeBinary  (  InputStream data ,   int dataLength )  throws IOException  {  return  writeBinary  (  Base64Variants . getDefaultVariant  ( ) , data , dataLength ) ; }   public abstract  int writeBinary  (  Base64Variant bv ,  InputStream data ,   int dataLength )  throws IOException ;   public void writeNumber  (   short v )  throws IOException  {   writeNumber  (  (  int ) v ) ; }   public abstract void writeNumber  (   int v )  throws IOException ;   public abstract void writeNumber  (   long v )  throws IOException ;   public abstract void writeNumber  (  BigInteger v )  throws IOException ;   public abstract void writeNumber  (   double v )  throws IOException ;   public abstract void writeNumber  (   float v )  throws IOException ;   public abstract void writeNumber  (  BigDecimal v )  throws IOException ;   public abstract void writeNumber  (  String encodedValue )  throws IOException ;   public abstract void writeBoolean  (  boolean state )  throws IOException ;   public abstract void writeNull  ( )  throws IOException ;   public void writeEmbeddedObject  (  Object object )  throws IOException  {  if  (  object == null )  {   writeNull  ( ) ;  return ; }  if  (  object instanceof   byte  [ ] )  {   writeBinary  (  (   byte  [ ] ) object ) ;  return ; }  throw  new JsonGenerationException  (  "No native support for writing embedded objects of type " +   object . getClass  ( ) . getName  ( ) , this ) ; }   public void writeObjectId  (  Object id )  throws IOException  {  throw  new JsonGenerationException  ( "No native support for writing Object Ids" , this ) ; }   public void writeObjectRef  (  Object id )  throws IOException  {  throw  new JsonGenerationException  ( "No native support for writing Object Ids" , this ) ; }   public void writeTypeId  (  Object id )  throws IOException  {  throw  new JsonGenerationException  ( "No native support for writing Type Ids" , this ) ; }   public WritableTypeId writeTypePrefix  (  WritableTypeId typeIdDef )  throws IOException  {  Object  id =  typeIdDef . id ;   final JsonToken  valueShape =  typeIdDef . valueShape ;  if  (  canWriteTypeId  ( ) )  {    typeIdDef . wrapperWritten = false ;   writeTypeId  ( id ) ; } else  {  String  idStr =   (  id instanceof String ) ?  ( String ) id :  String . valueOf  ( id ) ;    typeIdDef . wrapperWritten = true ;  Inclusion  incl =  typeIdDef . include ;  if  (   (  valueShape !=  JsonToken . START_OBJECT ) &&  incl . requiresObjectContext  ( ) )  {    typeIdDef . include =  incl =   WritableTypeId . Inclusion . WRAPPER_ARRAY ; }  switch  ( incl )  {   case PARENT_PROPERTY :  break ;   case PAYLOAD_PROPERTY :  break ;   case METADATA_PROPERTY :   writeStartObject  (  typeIdDef . forValue ) ;   writeStringField  (  typeIdDef . asProperty , idStr ) ;  return typeIdDef ;   case WRAPPER_OBJECT :   writeStartObject  ( ) ;   writeFieldName  ( idStr ) ;  break ;   case WRAPPER_ARRAY :   default :   writeStartArray  ( ) ;   writeString  ( idStr ) ; } }  if  (  valueShape ==  JsonToken . START_OBJECT )  {   writeStartObject  (  typeIdDef . forValue ) ; } else  if  (  valueShape ==  JsonToken . START_ARRAY )  {   writeStartArray  ( ) ; }  return typeIdDef ; }   public WritableTypeId writeTypeSuffix  (  WritableTypeId typeIdDef )  throws IOException  {   final JsonToken  valueShape =  typeIdDef . valueShape ;  if  (  valueShape ==  JsonToken . START_OBJECT )  {   writeEndObject  ( ) ; } else  if  (  valueShape ==  JsonToken . START_ARRAY )  {   writeEndArray  ( ) ; }  if  (  typeIdDef . wrapperWritten )  {  switch  (  typeIdDef . include )  {   case WRAPPER_ARRAY :   writeEndArray  ( ) ;  break ;   case PARENT_PROPERTY :  {  Object  id =  typeIdDef . id ;  String  idStr =   (  id instanceof String ) ?  ( String ) id :  String . valueOf  ( id ) ;   writeStringField  (  typeIdDef . asProperty , idStr ) ; }  break ;   case METADATA_PROPERTY :   case PAYLOAD_PROPERTY :  break ;   case WRAPPER_OBJECT :   default :   writeEndObject  ( ) ;  break ; } }  return typeIdDef ; }   public abstract void writeObject  (  Object pojo )  throws IOException ;   public abstract void writeTree  (  TreeNode rootNode )  throws IOException ;   public void writeStringField  (  String fieldName ,  String value )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeString  ( value ) ; }   public void writeBooleanField  (  String fieldName ,  boolean value )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeBoolean  ( value ) ; }   public void writeNullField  (  String fieldName )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeNull  ( ) ; }   public void writeNumberField  (  String fieldName ,   int value )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeNumber  ( value ) ; }   public void writeNumberField  (  String fieldName ,   long value )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeNumber  ( value ) ; }   public void writeNumberField  (  String fieldName ,   double value )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeNumber  ( value ) ; }   public void writeNumberField  (  String fieldName ,   float value )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeNumber  ( value ) ; }   public void writeNumberField  (  String fieldName ,  BigDecimal value )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeNumber  ( value ) ; }   public void writeBinaryField  (  String fieldName ,    byte  [ ] data )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeBinary  ( data ) ; }   public void writeArrayFieldStart  (  String fieldName )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeStartArray  ( ) ; }   public void writeObjectFieldStart  (  String fieldName )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeStartObject  ( ) ; }   public void writeObjectField  (  String fieldName ,  Object pojo )  throws IOException  {   writeFieldName  ( fieldName ) ;   writeObject  ( pojo ) ; }   public void writeOmittedField  (  String fieldName )  throws IOException  { }   public void copyCurrentEvent  (  JsonParser p )  throws IOException  {  JsonToken  t =  p . currentToken  ( ) ;   final  int  token =   (  t == null ) ? ID_NOT_AVAILABLE :  t . id  ( ) ;  switch  ( token )  {   case ID_NOT_AVAILABLE :   _reportError  ( "No current event to copy" ) ;  break ;   case ID_START_OBJECT :   writeStartObject  ( ) ;  break ;   case ID_END_OBJECT :   writeEndObject  ( ) ;  break ;   case ID_START_ARRAY :   writeStartArray  ( ) ;  break ;   case ID_END_ARRAY :   writeEndArray  ( ) ;  break ;   case ID_FIELD_NAME :   writeFieldName  (  p . currentName  ( ) ) ;  break ;   case ID_STRING :  if  (  p . hasTextCharacters  ( ) )  {   writeString  (  p . getTextCharacters  ( ) ,  p . getTextOffset  ( ) ,  p . getTextLength  ( ) ) ; } else  {   writeString  (  p . getText  ( ) ) ; }  break ;   case ID_NUMBER_INT :  {  NumberType  n =  p . getNumberType  ( ) ;  if  (  n ==  NumberType . INT )  {   writeNumber  (  p . getIntValue  ( ) ) ; } else  if  (  n ==  NumberType . BIG_INTEGER )  {   writeNumber  (  p . getBigIntegerValue  ( ) ) ; } else  {   writeNumber  (  p . getLongValue  ( ) ) ; }  break ; }   case ID_NUMBER_FLOAT :  {  NumberType  n =  p . getNumberType  ( ) ;  if  (  n ==  NumberType . BIG_DECIMAL )  {   writeNumber  (  p . getDecimalValue  ( ) ) ; } else  if  (  n ==  NumberType . FLOAT )  {   writeNumber  (  p . getFloatValue  ( ) ) ; } else  {   writeNumber  (  p . getDoubleValue  ( ) ) ; }  break ; }   case ID_TRUE :   writeBoolean  ( true ) ;  break ;   case ID_FALSE :   writeBoolean  ( false ) ;  break ;   case ID_NULL :   writeNull  ( ) ;  break ;   case ID_EMBEDDED_OBJECT :   writeObject  (  p . getEmbeddedObject  ( ) ) ;  break ;   default :  throw  new IllegalStateException  (  "Internal error: unknown current token, " + t ) ; } }   public void copyCurrentStructure  (  JsonParser p )  throws IOException  {  JsonToken  t =  p . currentToken  ( ) ;   int  id =   (  t == null ) ? ID_NOT_AVAILABLE :  t . id  ( ) ;  if  (  id == ID_FIELD_NAME )  {   writeFieldName  (  p . currentName  ( ) ) ;   t =  p . nextToken  ( ) ;   id =   (  t == null ) ? ID_NOT_AVAILABLE :  t . id  ( ) ; }  switch  ( id )  {   case ID_START_OBJECT :   writeStartObject  ( ) ;   _copyCurrentContents  ( p ) ;  return ;   case ID_START_ARRAY :   writeStartArray  ( ) ;   _copyCurrentContents  ( p ) ;  return ;   default :   copyCurrentEvent  ( p ) ; } }   protected void _copyCurrentContents  (  JsonParser p )  throws IOException  {   int  depth = 1 ;  JsonToken  t ;  while  (   (  t =  p . nextToken  ( ) ) != null )  {  switch  (  t . id  ( ) )  {   case ID_FIELD_NAME :   writeFieldName  (  p . currentName  ( ) ) ;  break ;   case ID_START_ARRAY :   writeStartArray  ( ) ;   ++ depth ;  break ;   case ID_START_OBJECT :   writeStartObject  ( ) ;   ++ depth ;  break ;   case ID_END_ARRAY :   writeEndArray  ( ) ;  if  (   -- depth == 0 )  {  return ; }  break ;   case ID_END_OBJECT :   writeEndObject  ( ) ;  if  (   -- depth == 0 )  {  return ; }  break ;   case ID_STRING :  if  (  p . hasTextCharacters  ( ) )  {   writeString  (  p . getTextCharacters  ( ) ,  p . getTextOffset  ( ) ,  p . getTextLength  ( ) ) ; } else  {   writeString  (  p . getText  ( ) ) ; }  break ;   case ID_NUMBER_INT :  {  NumberType  n =  p . getNumberType  ( ) ;  if  (  n ==  NumberType . INT )  {   writeNumber  (  p . getIntValue  ( ) ) ; } else  if  (  n ==  NumberType . BIG_INTEGER )  {   writeNumber  (  p . getBigIntegerValue  ( ) ) ; } else  {   writeNumber  (  p . getLongValue  ( ) ) ; }  break ; }   case ID_NUMBER_FLOAT :  {  NumberType  n =  p . getNumberType  ( ) ;  if  (  n ==  NumberType . BIG_DECIMAL )  {   writeNumber  (  p . getDecimalValue  ( ) ) ; } else  if  (  n ==  NumberType . FLOAT )  {   writeNumber  (  p . getFloatValue  ( ) ) ; } else  {   writeNumber  (  p . getDoubleValue  ( ) ) ; }  break ; }   case ID_TRUE :   writeBoolean  ( true ) ;  break ;   case ID_FALSE :   writeBoolean  ( false ) ;  break ;   case ID_NULL :   writeNull  ( ) ;  break ;   case ID_EMBEDDED_OBJECT :   writeObject  (  p . getEmbeddedObject  ( ) ) ;  break ;   default :  throw  new IllegalStateException  (  "Internal error: unknown current token, " + t ) ; } } }    @ Override public abstract void flush  ( )  throws IOException ;   public abstract boolean isClosed  ( ) ;    @ Override public abstract void close  ( )  throws IOException ;   protected  <  T > T _reportError  (  String msg )  throws JsonGenerationException  {  throw  new JsonGenerationException  ( msg , this ) ; }   protected void _throwInternal  ( )  {   VersionUtil . throwInternal  ( ) ; }   protected  <  T > T _reportUnsupportedOperation  ( )  {  throw  new UnsupportedOperationException  (  "Operation not supported by generator of type " +   getClass  ( ) . getName  ( ) ) ; }   protected final void _verifyOffsets  (   int arrayLength ,   int offset ,   int length )  {  if  (   (  offset < 0 ) ||   (  offset + length ) > arrayLength )  {  throw  new IllegalArgumentException  (  String . format  ( "invalid argument(s) (offset=%d, length=%d) for input array of %d element" , offset , length , arrayLength ) ) ; } } }