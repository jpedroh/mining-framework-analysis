  package     com . fasterxml . jackson . core . json ;   import   java . io . DataInput ;  import   java . io . EOFException ;  import   java . io . IOException ;  import   java . io . OutputStream ;  import   java . io . Writer ;  import   java . util . Arrays ;  import    com . fasterxml . jackson . core .  * ;  import      com . fasterxml . jackson . core . exc . StreamReadException ;  import      com . fasterxml . jackson . core . exc . WrappedIOException ;  import      com . fasterxml . jackson . core . io . CharTypes ;  import      com . fasterxml . jackson . core . io . IOContext ;  import      com . fasterxml . jackson . core . sym . ByteQuadsCanonicalizer ;  import     com . fasterxml . jackson . core . util .  * ;  import static     com . fasterxml . jackson . core . JsonTokenId .  * ;   public class UTF8DataInputJsonParser  extends JsonParserBase  {   final static  byte  BYTE_LF =  (  byte ) '\n' ;   private final static   int  [ ]  _icUTF8 =  CharTypes . getInputCodeUtf8  ( ) ;   protected final static   int  [ ]  _icLatin1 =  CharTypes . getInputCodeLatin1  ( ) ;   protected final ByteQuadsCanonicalizer  _symbols ;   protected   int  [ ]  _quadBuffer =  new  int  [ 16 ] ;   protected boolean  _tokenIncomplete ;   private  int  _quad1 ;   protected DataInput  _inputData ;   protected  int  _nextByte =  - 1 ;   public UTF8DataInputJsonParser  (  ObjectReadContext readCtxt ,  IOContext ctxt ,   int stdFeatures ,   int formatFeatures ,  DataInput inputData ,  ByteQuadsCanonicalizer sym ,   int firstByte )  {  super  ( readCtxt , ctxt , stdFeatures , formatFeatures ) ;   _symbols = sym ;   _inputData = inputData ;   _nextByte = firstByte ; }    @ Override public  int releaseBuffered  (  OutputStream out )  {  return 0 ; }    @ Override public Object streamReadInputSource  ( )  {  return _inputData ; }    @ Override protected void _closeInput  ( )  { }    @ Override protected void _releaseBuffers  ( )  {   super . _releaseBuffers  ( ) ;   _symbols . release  ( ) ; }    @ Override public String getText  ( )  throws JacksonException  {  if  (  _currToken ==  JsonToken . VALUE_STRING )  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;  return  _finishAndReturnString  ( ) ; }  return  _textBuffer . contentsAsString  ( ) ; }  return  _getText2  ( _currToken ) ; }    @ Override public  int getText  (  Writer writer )  throws JacksonException  {  JsonToken  t = _currToken ;  try  {  if  (  t ==  JsonToken . VALUE_STRING )  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }  return  _textBuffer . contentsToWriter  ( writer ) ; }  if  (  t ==  JsonToken . PROPERTY_NAME )  {  String  n =  _streamReadContext . currentName  ( ) ;   writer . write  ( n ) ;  return  n . length  ( ) ; }  if  (  t != null )  {  if  (  t . isNumeric  ( ) )  {  return  _textBuffer . contentsToWriter  ( writer ) ; }    char  [ ]  ch =  t . asCharArray  ( ) ;   writer . write  ( ch ) ;  return  ch . length ; } }  catch (   IOException e )  {  throw  _wrapIOFailure  ( e ) ; }  return 0 ; }    @ Override public String getValueAsString  ( )  throws JacksonException  {  if  (  _currToken ==  JsonToken . VALUE_STRING )  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;  return  _finishAndReturnString  ( ) ; }  return  _textBuffer . contentsAsString  ( ) ; }  if  (  _currToken ==  JsonToken . PROPERTY_NAME )  {  return  currentName  ( ) ; }  return  super . getValueAsString  ( null ) ; }    @ Override public String getValueAsString  (  String defValue )  throws JacksonException  {  if  (  _currToken ==  JsonToken . VALUE_STRING )  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;  return  _finishAndReturnString  ( ) ; }  return  _textBuffer . contentsAsString  ( ) ; }  if  (  _currToken ==  JsonToken . PROPERTY_NAME )  {  return  currentName  ( ) ; }  return  super . getValueAsString  ( defValue ) ; }    @ Override public  int getValueAsInt  ( )  throws JacksonException  {  JsonToken  t = _currToken ;  if  (   (  t ==  JsonToken . VALUE_NUMBER_INT ) ||  (  t ==  JsonToken . VALUE_NUMBER_FLOAT ) )  {  if  (   (  _numTypesValid & NR_INT ) == 0 )  {  if  (  _numTypesValid == NR_UNKNOWN )  {  return  _parseIntValue  ( ) ; }  if  (   (  _numTypesValid & NR_INT ) == 0 )  {   convertNumberToInt  ( ) ; } }  return _numberInt ; }  return  super . getValueAsInt  ( 0 ) ; }    @ Override public  int getValueAsInt  (   int defValue )  throws JacksonException  {  JsonToken  t = _currToken ;  if  (   (  t ==  JsonToken . VALUE_NUMBER_INT ) ||  (  t ==  JsonToken . VALUE_NUMBER_FLOAT ) )  {  if  (   (  _numTypesValid & NR_INT ) == 0 )  {  if  (  _numTypesValid == NR_UNKNOWN )  {  return  _parseIntValue  ( ) ; }  if  (   (  _numTypesValid & NR_INT ) == 0 )  {   convertNumberToInt  ( ) ; } }  return _numberInt ; }  return  super . getValueAsInt  ( defValue ) ; }   protected final String _getText2  (  JsonToken t )  {  if  (  t == null )  {  return null ; }  switch  (  t . id  ( ) )  {   case ID_PROPERTY_NAME :  return  _streamReadContext . currentName  ( ) ;   case ID_STRING :   case ID_NUMBER_INT :   case ID_NUMBER_FLOAT :  return  _textBuffer . contentsAsString  ( ) ;   default :  return  t . asString  ( ) ; } }    @ Override public   char  [ ] getTextCharacters  ( )  throws JacksonException  {  if  (  _currToken != null )  {  switch  (  _currToken . id  ( ) )  {   case ID_PROPERTY_NAME :  return  currentNameInBuffer  ( ) ;   case ID_STRING :  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }   case ID_NUMBER_INT :   case ID_NUMBER_FLOAT :  return  _textBuffer . getTextBuffer  ( ) ;   default :  return  _currToken . asCharArray  ( ) ; } }  return null ; }    @ Override public  int getTextLength  ( )  throws JacksonException  {  if  (  _currToken ==  JsonToken . VALUE_STRING )  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }  return  _textBuffer . size  ( ) ; }  if  (  _currToken ==  JsonToken . PROPERTY_NAME )  {  return   _streamReadContext . currentName  ( ) . length  ( ) ; }  if  (  _currToken != null )  {  if  (  _currToken . isNumeric  ( ) )  {  return  _textBuffer . size  ( ) ; }  return   _currToken . asCharArray  ( ) . length ; }  return 0 ; }    @ Override public  int getTextOffset  ( )  throws JacksonException  {  if  (  _currToken != null )  {  switch  (  _currToken . id  ( ) )  {   case ID_PROPERTY_NAME :  return 0 ;   case ID_STRING :  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }   case ID_NUMBER_INT :   case ID_NUMBER_FLOAT :  return  _textBuffer . getTextOffset  ( ) ;   default : } }  return 0 ; }    @ Override public   byte  [ ] getBinaryValue  (  Base64Variant b64variant )  throws JacksonException  {  if  (   _currToken !=  JsonToken . VALUE_STRING &&  (   _currToken !=  JsonToken . VALUE_EMBEDDED_OBJECT ||  _binaryValue == null ) )  {   _reportError  (   "Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary" ) ; }  if  ( _tokenIncomplete )  {  try  {   _binaryValue =  _decodeBase64  ( b64variant ) ; }  catch (   IOException e )  {  throw  _constructReadException  ( "Failed to decode VALUE_STRING as base64 (%s): %s" , b64variant ,  e . getMessage  ( ) ) ; }   _tokenIncomplete = false ; } else  {  if  (  _binaryValue == null )  {    @ SuppressWarnings  ( "resource" ) ByteArrayBuilder  builder =  _getByteArrayBuilder  ( ) ;   _decodeBase64  (  getText  ( ) , builder , b64variant ) ;   _binaryValue =  builder . toByteArray  ( ) ; } }  return _binaryValue ; }    @ Override public  int readBinaryValue  (  Base64Variant b64variant ,  OutputStream out )  throws JacksonException  {  if  (   ! _tokenIncomplete ||  _currToken !=  JsonToken . VALUE_STRING )  {    byte  [ ]  b =  getBinaryValue  ( b64variant ) ;  try  {   out . write  ( b ) ; }  catch (   IOException e )  {  throw  _wrapIOFailure  ( e ) ; }  return  b . length ; }    byte  [ ]  buf =  _ioContext . allocBase64Buffer  ( ) ;  try  {  return  _readBinary  ( b64variant , out , buf ) ; }  catch (   IOException e )  {  throw  _wrapIOFailure  ( e ) ; }  finally  {   _ioContext . releaseBase64Buffer  ( buf ) ; } }   protected  int _readBinary  (  Base64Variant b64variant ,  OutputStream out ,    byte  [ ] buffer )  throws IOException  {   int  outputPtr = 0 ;   final  int  outputEnd =   buffer . length - 3 ;   int  outputCount = 0 ;  while  ( true )  {   int  ch ;  do  {   ch =  _inputData . readUnsignedByte  ( ) ; } while  (  ch <= INT_SPACE ) ;   int  bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  ch == INT_QUOTE )  {  break ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 0 ) ;  if  (  bits < 0 )  {  continue ; } }  if  (  outputPtr > outputEnd )  {   outputCount += outputPtr ;   out . write  ( buffer , 0 , outputPtr ) ;   outputPtr = 0 ; }   int  decodedData = bits ;   ch =  _inputData . readUnsignedByte  ( ) ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {   bits =  _decodeBase64Escape  ( b64variant , ch , 1 ) ; }   decodedData =   (  decodedData << 6 ) | bits ;   ch =  _inputData . readUnsignedByte  ( ) ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  bits !=  Base64Variant . BASE64_VALUE_PADDING )  {  if  (  ch == INT_QUOTE )  {   decodedData >>= 4 ;    buffer [  outputPtr ++ ] =  (  byte ) decodedData ;  if  (  b64variant . usesPadding  ( ) )  {   _handleBase64MissingPadding  ( b64variant ) ; }  break ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 2 ) ; }  if  (  bits ==  Base64Variant . BASE64_VALUE_PADDING )  {   ch =  _inputData . readUnsignedByte  ( ) ;  if  (  !  b64variant . usesPaddingChar  ( ch ) )  {  if  (   (  ch != INT_BACKSLASH ) ||   _decodeBase64Escape  ( b64variant , ch , 3 ) !=  Base64Variant . BASE64_VALUE_PADDING )  {   _reportInvalidBase64Char  ( b64variant , ch , 3 ,   "expected padding character '" +  b64variant . getPaddingChar  ( ) + "'" ) ; } }   decodedData >>= 4 ;    buffer [  outputPtr ++ ] =  (  byte ) decodedData ;  continue ; } }   decodedData =   (  decodedData << 6 ) | bits ;   ch =  _inputData . readUnsignedByte  ( ) ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  bits !=  Base64Variant . BASE64_VALUE_PADDING )  {  if  (  ch == INT_QUOTE )  {   decodedData >>= 2 ;    buffer [  outputPtr ++ ] =  (  byte )  (  decodedData >> 8 ) ;    buffer [  outputPtr ++ ] =  (  byte ) decodedData ;  if  (  b64variant . usesPadding  ( ) )  {   _handleBase64MissingPadding  ( b64variant ) ; }  break ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 3 ) ; }  if  (  bits ==  Base64Variant . BASE64_VALUE_PADDING )  {   decodedData >>= 2 ;    buffer [  outputPtr ++ ] =  (  byte )  (  decodedData >> 8 ) ;    buffer [  outputPtr ++ ] =  (  byte ) decodedData ;  continue ; } }   decodedData =   (  decodedData << 6 ) | bits ;    buffer [  outputPtr ++ ] =  (  byte )  (  decodedData >> 16 ) ;    buffer [  outputPtr ++ ] =  (  byte )  (  decodedData >> 8 ) ;    buffer [  outputPtr ++ ] =  (  byte ) decodedData ; }   _tokenIncomplete = false ;  if  (  outputPtr > 0 )  {   outputCount += outputPtr ;   out . write  ( buffer , 0 , outputPtr ) ; }  return outputCount ; }    @ Override public JsonToken nextToken  ( )  throws JacksonException  {  if  ( _closed )  {  return null ; }  try  {  if  (  _currToken ==  JsonToken . PROPERTY_NAME )  {  return  _nextAfterName  ( ) ; }  return  _nextToken  ( ) ; }  catch (   IOException e )  {  throw  _wrapIOFailure  ( e ) ; } }   private final JsonToken _nextToken  ( )  throws IOException  {   _numTypesValid = NR_UNKNOWN ;  if  ( _tokenIncomplete )  {   _skipString  ( ) ; }   int  i =  _skipWSOrEnd  ( ) ;  if  (  i < 0 )  {   close  ( ) ;  return  (  _currToken = null ) ; }   _binaryValue = null ;   _tokenInputRow = _currInputRow ;  if  (   i == INT_RBRACKET ||  i == INT_RCURLY )  {   _closeScope  ( i ) ;  return _currToken ; }  if  (  _streamReadContext . expectComma  ( ) )  {  if  (  i != INT_COMMA )  {   _reportUnexpectedChar  ( i ,   "was expecting comma to separate " +  _streamReadContext . typeDesc  ( ) + " entries" ) ; }   i =  _skipWS  ( ) ;  if  (  isEnabled  (  JsonReadFeature . ALLOW_TRAILING_COMMA ) )  {  if  (   i == INT_RBRACKET ||  i == INT_RCURLY )  {   _closeScope  ( i ) ;  return _currToken ; } } }  if  (  !  _streamReadContext . inObject  ( ) )  {  return  _nextTokenNotInObject  ( i ) ; }  String  n =  _parseName  ( i ) ;   _streamReadContext . setCurrentName  ( n ) ;   _currToken =  JsonToken . PROPERTY_NAME ;   i =  _skipColon  ( ) ;  if  (  i == INT_QUOTE )  {   _tokenIncomplete = true ;   _nextToken =  JsonToken . VALUE_STRING ;  return _currToken ; }  JsonToken  t ;  switch  ( i )  {   case '-' :   t =  _parseNegNumber  ( ) ;  break ;   case '+' :  if  (  isEnabled  (  JsonReadFeature . ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS ) )  {   t =  _parsePosNumber  ( ) ; } else  {   t =  _handleUnexpectedValue  ( i ) ; }  break ;   case '.' :   t =  _parseFloatThatStartsWithPeriod  ( false , false ) ;  break ;   case '0' :   case '1' :   case '2' :   case '3' :   case '4' :   case '5' :   case '6' :   case '7' :   case '8' :   case '9' :   t =  _parseUnsignedNumber  ( i ) ;  break ;   case 'f' :   _matchToken  ( "false" , 1 ) ;   t =  JsonToken . VALUE_FALSE ;  break ;   case 'n' :   _matchToken  ( "null" , 1 ) ;   t =  JsonToken . VALUE_NULL ;  break ;   case 't' :   _matchToken  ( "true" , 1 ) ;   t =  JsonToken . VALUE_TRUE ;  break ;   case '[' :   t =  JsonToken . START_ARRAY ;  break ;   case '{' :   t =  JsonToken . START_OBJECT ;  break ;   default :   t =  _handleUnexpectedValue  ( i ) ; }   _nextToken = t ;  return _currToken ; }   private final JsonToken _nextTokenNotInObject  (   int i )  throws IOException  {  if  (  i == INT_QUOTE )  {   _tokenIncomplete = true ;  return  (  _currToken =  JsonToken . VALUE_STRING ) ; }  switch  ( i )  {   case '[' :   _streamReadContext =  _streamReadContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ;  return  (  _currToken =  JsonToken . START_ARRAY ) ;   case '{' :   _streamReadContext =  _streamReadContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ;  return  (  _currToken =  JsonToken . START_OBJECT ) ;   case 't' :   _matchToken  ( "true" , 1 ) ;  return  (  _currToken =  JsonToken . VALUE_TRUE ) ;   case 'f' :   _matchToken  ( "false" , 1 ) ;  return  (  _currToken =  JsonToken . VALUE_FALSE ) ;   case 'n' :   _matchToken  ( "null" , 1 ) ;  return  (  _currToken =  JsonToken . VALUE_NULL ) ;   case '-' :  return  (  _currToken =  _parseNegNumber  ( ) ) ;   case '+' :  if  (  isEnabled  (  JsonReadFeature . ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS ) )  {  return  (  _currToken =  _parsePosNumber  ( ) ) ; }  return  (  _currToken =  _handleUnexpectedValue  ( i ) ) ;   case '.' :  return  (  _currToken =  _parseFloatThatStartsWithPeriod  ( false , false ) ) ;   case '0' :   case '1' :   case '2' :   case '3' :   case '4' :   case '5' :   case '6' :   case '7' :   case '8' :   case '9' :  return  (  _currToken =  _parseUnsignedNumber  ( i ) ) ; }  return  (  _currToken =  _handleUnexpectedValue  ( i ) ) ; }   private final JsonToken _nextAfterName  ( )  {   _nameCopied = false ;  JsonToken  t = _nextToken ;   _nextToken = null ;  if  (  t ==  JsonToken . START_ARRAY )  {   _streamReadContext =  _streamReadContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; } else  if  (  t ==  JsonToken . START_OBJECT )  {   _streamReadContext =  _streamReadContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }  return  (  _currToken = t ) ; }    @ Override public void finishToken  ( )  throws JacksonException  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; } }    @ Override public String nextName  ( )  throws JacksonException  {  try  {  return  _nextName  ( ) ; }  catch (   IOException e )  {  throw  _wrapIOFailure  ( e ) ; } }   private final String _nextName  ( )  throws IOException  {   _numTypesValid = NR_UNKNOWN ;  if  (  _currToken ==  JsonToken . PROPERTY_NAME )  {   _nextAfterName  ( ) ;  return null ; }  if  ( _tokenIncomplete )  {   _skipString  ( ) ; }   int  i =  _skipWS  ( ) ;   _binaryValue = null ;   _tokenInputRow = _currInputRow ;  if  (   i == INT_RBRACKET ||  i == INT_RCURLY )  {   _closeScope  ( i ) ;  return null ; }  if  (  _streamReadContext . expectComma  ( ) )  {  if  (  i != INT_COMMA )  {   _reportUnexpectedChar  ( i ,   "was expecting comma to separate " +  _streamReadContext . typeDesc  ( ) + " entries" ) ; }   i =  _skipWS  ( ) ;  if  (  isEnabled  (  JsonReadFeature . ALLOW_TRAILING_COMMA ) )  {  if  (   i == INT_RBRACKET ||  i == INT_RCURLY )  {   _closeScope  ( i ) ;  return null ; } } }  if  (  !  _streamReadContext . inObject  ( ) )  {   _nextTokenNotInObject  ( i ) ;  return null ; }   final String  nameStr =  _parseName  ( i ) ;   _streamReadContext . setCurrentName  ( nameStr ) ;   _currToken =  JsonToken . PROPERTY_NAME ;   i =  _skipColon  ( ) ;  if  (  i == INT_QUOTE )  {   _tokenIncomplete = true ;   _nextToken =  JsonToken . VALUE_STRING ;  return nameStr ; }  JsonToken  t ;  switch  ( i )  {   case '-' :   t =  _parseNegNumber  ( ) ;  break ;   case '+' :  if  (  isEnabled  (  JsonReadFeature . ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS ) )  {   t =  _parsePosNumber  ( ) ; } else  {   t =  _handleUnexpectedValue  ( i ) ; }  break ;   case '.' :   t =  _parseFloatThatStartsWithPeriod  ( false , false ) ;   case '0' :   case '1' :   case '2' :   case '3' :   case '4' :   case '5' :   case '6' :   case '7' :   case '8' :   case '9' :   t =  _parseUnsignedNumber  ( i ) ;  break ;   case 'f' :   _matchToken  ( "false" , 1 ) ;   t =  JsonToken . VALUE_FALSE ;  break ;   case 'n' :   _matchToken  ( "null" , 1 ) ;   t =  JsonToken . VALUE_NULL ;  break ;   case 't' :   _matchToken  ( "true" , 1 ) ;   t =  JsonToken . VALUE_TRUE ;  break ;   case '[' :   t =  JsonToken . START_ARRAY ;  break ;   case '{' :   t =  JsonToken . START_OBJECT ;  break ;   default :   t =  _handleUnexpectedValue  ( i ) ; }   _nextToken = t ;  return nameStr ; }    @ Override public String nextTextValue  ( )  throws JacksonException  {  if  (  _currToken ==  JsonToken . PROPERTY_NAME )  {   _nameCopied = false ;  JsonToken  t = _nextToken ;   _nextToken = null ;   _currToken = t ;  if  (  t ==  JsonToken . VALUE_STRING )  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;  return  _finishAndReturnString  ( ) ; }  return  _textBuffer . contentsAsString  ( ) ; }  if  (  t ==  JsonToken . START_ARRAY )  {   _streamReadContext =  _streamReadContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; } else  if  (  t ==  JsonToken . START_OBJECT )  {   _streamReadContext =  _streamReadContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }  return null ; }  return   (   nextToken  ( ) ==  JsonToken . VALUE_STRING ) ?  getText  ( ) : null ; }    @ Override public  int nextIntValue  (   int defaultValue )  throws JacksonException  {  if  (  _currToken ==  JsonToken . PROPERTY_NAME )  {   _nameCopied = false ;  JsonToken  t = _nextToken ;   _nextToken = null ;   _currToken = t ;  if  (  t ==  JsonToken . VALUE_NUMBER_INT )  {  return  getIntValue  ( ) ; }  if  (  t ==  JsonToken . START_ARRAY )  {   _streamReadContext =  _streamReadContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; } else  if  (  t ==  JsonToken . START_OBJECT )  {   _streamReadContext =  _streamReadContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }  return defaultValue ; }  return   (   nextToken  ( ) ==  JsonToken . VALUE_NUMBER_INT ) ?  getIntValue  ( ) : defaultValue ; }    @ Override public  long nextLongValue  (   long defaultValue )  throws JacksonException  {  if  (  _currToken ==  JsonToken . PROPERTY_NAME )  {   _nameCopied = false ;  JsonToken  t = _nextToken ;   _nextToken = null ;   _currToken = t ;  if  (  t ==  JsonToken . VALUE_NUMBER_INT )  {  return  getLongValue  ( ) ; }  if  (  t ==  JsonToken . START_ARRAY )  {   _streamReadContext =  _streamReadContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; } else  if  (  t ==  JsonToken . START_OBJECT )  {   _streamReadContext =  _streamReadContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }  return defaultValue ; }  return   (   nextToken  ( ) ==  JsonToken . VALUE_NUMBER_INT ) ?  getLongValue  ( ) : defaultValue ; }    @ Override public Boolean nextBooleanValue  ( )  throws JacksonException  {  if  (  _currToken ==  JsonToken . PROPERTY_NAME )  {   _nameCopied = false ;  JsonToken  t = _nextToken ;   _nextToken = null ;   _currToken = t ;  if  (  t ==  JsonToken . VALUE_TRUE )  {  return  Boolean . TRUE ; }  if  (  t ==  JsonToken . VALUE_FALSE )  {  return  Boolean . FALSE ; }  if  (  t ==  JsonToken . START_ARRAY )  {   _streamReadContext =  _streamReadContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; } else  if  (  t ==  JsonToken . START_OBJECT )  {   _streamReadContext =  _streamReadContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }  return null ; }  JsonToken  t =  nextToken  ( ) ;  if  (  t ==  JsonToken . VALUE_TRUE )  {  return  Boolean . TRUE ; }  if  (  t ==  JsonToken . VALUE_FALSE )  {  return  Boolean . FALSE ; }  return null ; }   protected final JsonToken _parseFloatThatStartsWithPeriod  (   final boolean neg ,   final boolean hasSign )  throws IOException  {  if  (  !  isEnabled  (  JsonReadFeature . ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS ) )  {  return  _handleUnexpectedValue  ( INT_PERIOD ) ; }   final   char  [ ]  outBuf =  _textBuffer . emptyAndGetCurrentSegment  ( ) ;   int  outPtr = 0 ;  if  ( neg )  {    outBuf [  outPtr ++ ] = '-' ; }  return  _parseFloat  ( outBuf , outPtr , INT_PERIOD , neg , 0 ) ; }   protected JsonToken _parseUnsignedNumber  (   int c )  throws IOException  {    char  [ ]  outBuf =  _textBuffer . emptyAndGetCurrentSegment  ( ) ;   int  outPtr ;  if  (  c == INT_0 )  {   c =  _handleLeadingZeroes  ( ) ;  if  (   c <= INT_9 &&  c >= INT_0 )  {   outPtr = 0 ; } else  if  (   c == 'x' ||  c == 'X' )  {  return  _handleInvalidNumberStart  ( c , false ) ; } else  {    outBuf [ 0 ] = '0' ;   outPtr = 1 ; } } else  {    outBuf [ 0 ] =  (  char ) c ;   c =  _inputData . readUnsignedByte  ( ) ;   outPtr = 1 ; }   int  intLen = outPtr ;  while  (   c <= INT_9 &&  c >= INT_0 )  {   ++ intLen ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] =  (  char ) c ;   c =  _inputData . readUnsignedByte  ( ) ; }  if  (    c == '.' ||  c == 'e' ||  c == 'E' )  {  return  _parseFloat  ( outBuf , outPtr , c , false , intLen ) ; }   _textBuffer . setCurrentLength  ( outPtr ) ;  if  (  _streamReadContext . inRoot  ( ) )  {   _verifyRootSpace  ( ) ; } else  {   _nextByte = c ; }  return  resetInt  ( false , intLen ) ; }   protected final JsonToken _parsePosNumber  ( )  throws IOException  {  return  _parseSignedNumber  ( false ) ; }   protected final JsonToken _parseNegNumber  ( )  throws IOException  {  return  _parseSignedNumber  ( true ) ; }   private final JsonToken _parseSignedNumber  (  boolean negative )  throws IOException  {    char  [ ]  outBuf =  _textBuffer . emptyAndGetCurrentSegment  ( ) ;   int  outPtr = 0 ;  if  ( negative )  {    outBuf [  outPtr ++ ] = '-' ; }   int  c =  _inputData . readUnsignedByte  ( ) ;    outBuf [  outPtr ++ ] =  (  char ) c ;  if  (  c <= INT_0 )  {  if  (  c == INT_0 )  {   c =  _handleLeadingZeroes  ( ) ; } else  if  (  c == INT_PERIOD )  {  return  _parseFloatThatStartsWithPeriod  ( negative , true ) ; } else  {  return  _handleInvalidNumberStart  ( c , negative , true ) ; } } else  {  if  (  c > INT_9 )  {  return  _handleInvalidNumberStart  ( c , negative , true ) ; }   c =  _inputData . readUnsignedByte  ( ) ; }   int  intLen = 1 ;  while  (   c <= INT_9 &&  c >= INT_0 )  {   ++ intLen ;    outBuf [  outPtr ++ ] =  (  char ) c ;   c =  _inputData . readUnsignedByte  ( ) ; }  if  (    c == '.' ||  c == 'e' ||  c == 'E' )  {  return  _parseFloat  ( outBuf , outPtr , c , negative , intLen ) ; }   _textBuffer . setCurrentLength  ( outPtr ) ;   _nextByte = c ;  if  (  _streamReadContext . inRoot  ( ) )  {   _verifyRootSpace  ( ) ; }  return  resetInt  ( negative , intLen ) ; }   private final  int _handleLeadingZeroes  ( )  throws IOException  {   int  ch =  _inputData . readUnsignedByte  ( ) ;  if  (   ch < INT_0 ||  ch > INT_9 )  {  return ch ; }  if  (  !  isEnabled  (  JsonReadFeature . ALLOW_LEADING_ZEROS_FOR_NUMBERS ) )  {   _reportInvalidNumber  ( "Leading zeroes not allowed" ) ; }  while  (  ch == INT_0 )  {   ch =  _inputData . readUnsignedByte  ( ) ; }  return ch ; }   private final JsonToken _parseFloat  (    char  [ ] outBuf ,   int outPtr ,   int c ,  boolean negative ,   int integerPartLength )  throws IOException  {   int  fractLen = 0 ;  if  (  c == INT_PERIOD )  {    outBuf [  outPtr ++ ] =  (  char ) c ;  fract_loop :  while  ( true )  {   c =  _inputData . readUnsignedByte  ( ) ;  if  (   c < INT_0 ||  c > INT_9 )  {  break fract_loop ; }   ++ fractLen ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] =  (  char ) c ; }  if  (  fractLen == 0 )  {  if  (  !  isEnabled  (  JsonReadFeature . ALLOW_TRAILING_DECIMAL_POINT_FOR_NUMBERS ) )  {   _reportUnexpectedNumberChar  ( c , "Decimal point not followed by a digit" ) ; } } }   int  expLen = 0 ;  if  (   c == INT_e ||  c == INT_E )  {  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] =  (  char ) c ;   c =  _inputData . readUnsignedByte  ( ) ;  if  (   c == '-' ||  c == '+' )  {  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] =  (  char ) c ;   c =  _inputData . readUnsignedByte  ( ) ; }  while  (   c <= INT_9 &&  c >= INT_0 )  {   ++ expLen ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] =  (  char ) c ;   c =  _inputData . readUnsignedByte  ( ) ; }  if  (  expLen == 0 )  {   _reportUnexpectedNumberChar  ( c , "Exponent indicator not followed by a digit" ) ; } }   _nextByte = c ;  if  (  _streamReadContext . inRoot  ( ) )  {   _verifyRootSpace  ( ) ; }   _textBuffer . setCurrentLength  ( outPtr ) ;  return  resetFloat  ( negative , integerPartLength , fractLen , expLen ) ; }   private final void _verifyRootSpace  ( )  throws JacksonException  {   int  ch = _nextByte ;  if  (  ch <= INT_SPACE )  {   _nextByte =  - 1 ;  if  (   ch == INT_CR ||  ch == INT_LF )  {   ++ _currInputRow ; }  return ; }   _reportMissingRootWS  ( ch ) ; }   protected final String _parseName  (   int i )  throws IOException  {  if  (  i != INT_QUOTE )  {  return  _handleOddName  ( i ) ; }   final   int  [ ]  codes = _icLatin1 ;   int  q =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ q ] == 0 )  {   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] == 0 )  {   q =   (  q << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] == 0 )  {   q =   (  q << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] == 0 )  {   q =   (  q << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] == 0 )  {   _quad1 = q ;  return  _parseMediumName  ( i ) ; }  if  (  i == INT_QUOTE )  {  return  findName  ( q , 4 ) ; }  return  parseName  ( q , i , 4 ) ; }  if  (  i == INT_QUOTE )  {  return  findName  ( q , 3 ) ; }  return  parseName  ( q , i , 3 ) ; }  if  (  i == INT_QUOTE )  {  return  findName  ( q , 2 ) ; }  return  parseName  ( q , i , 2 ) ; }  if  (  i == INT_QUOTE )  {  return  findName  ( q , 1 ) ; }  return  parseName  ( q , i , 1 ) ; }  if  (  q == INT_QUOTE )  {  return "" ; }  return  parseName  ( 0 , q , 0 ) ; }   private final String _parseMediumName  (   int q2 )  throws IOException  {   final   int  [ ]  codes = _icLatin1 ;   int  i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quad1 , q2 , 1 ) ; }  return  parseName  ( _quad1 , q2 , i , 1 ) ; }   q2 =   (  q2 << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quad1 , q2 , 2 ) ; }  return  parseName  ( _quad1 , q2 , i , 2 ) ; }   q2 =   (  q2 << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quad1 , q2 , 3 ) ; }  return  parseName  ( _quad1 , q2 , i , 3 ) ; }   q2 =   (  q2 << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quad1 , q2 , 4 ) ; }  return  parseName  ( _quad1 , q2 , i , 4 ) ; }  return  _parseMediumName2  ( i , q2 ) ; }   private final String _parseMediumName2  (   int q3 ,   final  int q2 )  throws IOException  {   final   int  [ ]  codes = _icLatin1 ;   int  i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quad1 , q2 , q3 , 1 ) ; }  return  parseName  ( _quad1 , q2 , q3 , i , 1 ) ; }   q3 =   (  q3 << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quad1 , q2 , q3 , 2 ) ; }  return  parseName  ( _quad1 , q2 , q3 , i , 2 ) ; }   q3 =   (  q3 << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quad1 , q2 , q3 , 3 ) ; }  return  parseName  ( _quad1 , q2 , q3 , i , 3 ) ; }   q3 =   (  q3 << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quad1 , q2 , q3 , 4 ) ; }  return  parseName  ( _quad1 , q2 , q3 , i , 4 ) ; }  return  _parseLongName  ( i , q2 , q3 ) ; }   private final String _parseLongName  (   int q ,   final  int q2 ,   int q3 )  throws IOException  {    _quadBuffer [ 0 ] = _quad1 ;    _quadBuffer [ 1 ] = q2 ;    _quadBuffer [ 2 ] = q3 ;   final   int  [ ]  codes = _icLatin1 ;   int  qlen = 3 ;  while  ( true )  {   int  i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quadBuffer , qlen , q , 1 ) ; }  return  parseEscapedName  ( _quadBuffer , qlen , q , i , 1 ) ; }   q =   (  q << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quadBuffer , qlen , q , 2 ) ; }  return  parseEscapedName  ( _quadBuffer , qlen , q , i , 2 ) ; }   q =   (  q << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quadBuffer , qlen , q , 3 ) ; }  return  parseEscapedName  ( _quadBuffer , qlen , q , i , 3 ) ; }   q =   (  q << 8 ) | i ;   i =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  return  findName  ( _quadBuffer , qlen , q , 4 ) ; }  return  parseEscapedName  ( _quadBuffer , qlen , q , i , 4 ) ; }  if  (  qlen >=  _quadBuffer . length )  {   _quadBuffer =  _growArrayBy  ( _quadBuffer , qlen ) ; }    _quadBuffer [  qlen ++ ] = q ;   q = i ; } }   private final String parseName  (   int q1 ,   int ch ,   int lastQuadBytes )  throws IOException  {  return  parseEscapedName  ( _quadBuffer , 0 , q1 , ch , lastQuadBytes ) ; }   private final String parseName  (   int q1 ,   int q2 ,   int ch ,   int lastQuadBytes )  throws IOException  {    _quadBuffer [ 0 ] = q1 ;  return  parseEscapedName  ( _quadBuffer , 1 , q2 , ch , lastQuadBytes ) ; }   private final String parseName  (   int q1 ,   int q2 ,   int q3 ,   int ch ,   int lastQuadBytes )  throws IOException  {    _quadBuffer [ 0 ] = q1 ;    _quadBuffer [ 1 ] = q2 ;  return  parseEscapedName  ( _quadBuffer , 2 , q3 , ch , lastQuadBytes ) ; }   protected final String parseEscapedName  (    int  [ ] quads ,   int qlen ,   int currQuad ,   int ch ,   int currQuadBytes )  throws IOException  {   final   int  [ ]  codes = _icLatin1 ;  while  ( true )  {  if  (   codes [ ch ] != 0 )  {  if  (  ch == INT_QUOTE )  {  break ; }  if  (  ch != INT_BACKSLASH )  {   _throwUnquotedSpace  ( ch , "name" ) ; } else  {   ch =  _decodeEscaped  ( ) ; }  if  (  ch > 127 )  {  if  (  currQuadBytes >= 4 )  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] = currQuad ;   currQuad = 0 ;   currQuadBytes = 0 ; }  if  (  ch < 0x800 )  {   currQuad =   (  currQuad << 8 ) |  (  0xc0 |  (  ch >> 6 ) ) ;   ++ currQuadBytes ; } else  {   currQuad =   (  currQuad << 8 ) |  (  0xe0 |  (  ch >> 12 ) ) ;   ++ currQuadBytes ;  if  (  currQuadBytes >= 4 )  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] = currQuad ;   currQuad = 0 ;   currQuadBytes = 0 ; }   currQuad =   (  currQuad << 8 ) |  (  0x80 |  (   (  ch >> 6 ) & 0x3f ) ) ;   ++ currQuadBytes ; }   ch =  0x80 |  (  ch & 0x3f ) ; } }  if  (  currQuadBytes < 4 )  {   ++ currQuadBytes ;   currQuad =   (  currQuad << 8 ) | ch ; } else  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] = currQuad ;   currQuad = ch ;   currQuadBytes = 1 ; }   ch =  _inputData . readUnsignedByte  ( ) ; }  if  (  currQuadBytes > 0 )  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] =  pad  ( currQuad , currQuadBytes ) ; }  String  name =  _symbols . findName  ( quads , qlen ) ;  if  (  name == null )  {   name =  addName  ( quads , qlen , currQuadBytes ) ; }  return name ; }   protected String _handleOddName  (   int ch )  throws IOException  {  if  (   ch == '\'' &&  isEnabled  (  JsonReadFeature . ALLOW_SINGLE_QUOTES ) )  {  return  _parseAposName  ( ) ; }  if  (  !  isEnabled  (  JsonReadFeature . ALLOW_UNQUOTED_PROPERTY_NAMES ) )  {   char  c =  (  char )  _decodeCharForError  ( ch ) ;   _reportUnexpectedChar  ( c , "was expecting double-quote to start property name" ) ; }   final   int  [ ]  codes =  CharTypes . getInputCodeUtf8JsNames  ( ) ;  if  (   codes [ ch ] != 0 )  {   _reportUnexpectedChar  ( ch , "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start property name" ) ; }    int  [ ]  quads = _quadBuffer ;   int  qlen = 0 ;   int  currQuad = 0 ;   int  currQuadBytes = 0 ;  while  ( true )  {  if  (  currQuadBytes < 4 )  {   ++ currQuadBytes ;   currQuad =   (  currQuad << 8 ) | ch ; } else  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] = currQuad ;   currQuad = ch ;   currQuadBytes = 1 ; }   ch =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ ch ] != 0 )  {  break ; } }   _nextByte = ch ;  if  (  currQuadBytes > 0 )  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] = currQuad ; }  String  name =  _symbols . findName  ( quads , qlen ) ;  if  (  name == null )  {   name =  addName  ( quads , qlen , currQuadBytes ) ; }  return name ; }   protected String _parseAposName  ( )  throws IOException  {   int  ch =  _inputData . readUnsignedByte  ( ) ;  if  (  ch == '\'' )  {  return "" ; }    int  [ ]  quads = _quadBuffer ;   int  qlen = 0 ;   int  currQuad = 0 ;   int  currQuadBytes = 0 ;   final   int  [ ]  codes = _icLatin1 ;  while  ( true )  {  if  (  ch == '\'' )  {  break ; }  if  (   ch != '"' &&   codes [ ch ] != 0 )  {  if  (  ch != '\\' )  {   _throwUnquotedSpace  ( ch , "name" ) ; } else  {   ch =  _decodeEscaped  ( ) ; }  if  (  ch > 127 )  {  if  (  currQuadBytes >= 4 )  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] = currQuad ;   currQuad = 0 ;   currQuadBytes = 0 ; }  if  (  ch < 0x800 )  {   currQuad =   (  currQuad << 8 ) |  (  0xc0 |  (  ch >> 6 ) ) ;   ++ currQuadBytes ; } else  {   currQuad =   (  currQuad << 8 ) |  (  0xe0 |  (  ch >> 12 ) ) ;   ++ currQuadBytes ;  if  (  currQuadBytes >= 4 )  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] = currQuad ;   currQuad = 0 ;   currQuadBytes = 0 ; }   currQuad =   (  currQuad << 8 ) |  (  0x80 |  (   (  ch >> 6 ) & 0x3f ) ) ;   ++ currQuadBytes ; }   ch =  0x80 |  (  ch & 0x3f ) ; } }  if  (  currQuadBytes < 4 )  {   ++ currQuadBytes ;   currQuad =   (  currQuad << 8 ) | ch ; } else  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] = currQuad ;   currQuad = ch ;   currQuadBytes = 1 ; }   ch =  _inputData . readUnsignedByte  ( ) ; }  if  (  currQuadBytes > 0 )  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] =  pad  ( currQuad , currQuadBytes ) ; }  String  name =  _symbols . findName  ( quads , qlen ) ;  if  (  name == null )  {   name =  addName  ( quads , qlen , currQuadBytes ) ; }  return name ; }   private final String findName  (   int q1 ,   int lastQuadBytes )  throws StreamReadException  {   q1 =  pad  ( q1 , lastQuadBytes ) ;  String  name =  _symbols . findName  ( q1 ) ;  if  (  name != null )  {  return name ; }    _quadBuffer [ 0 ] = q1 ;  return  addName  ( _quadBuffer , 1 , lastQuadBytes ) ; }   private final String findName  (   int q1 ,   int q2 ,   int lastQuadBytes )  throws StreamReadException  {   q2 =  pad  ( q2 , lastQuadBytes ) ;  String  name =  _symbols . findName  ( q1 , q2 ) ;  if  (  name != null )  {  return name ; }    _quadBuffer [ 0 ] = q1 ;    _quadBuffer [ 1 ] = q2 ;  return  addName  ( _quadBuffer , 2 , lastQuadBytes ) ; }   private final String findName  (   int q1 ,   int q2 ,   int q3 ,   int lastQuadBytes )  throws StreamReadException  {   q3 =  pad  ( q3 , lastQuadBytes ) ;  String  name =  _symbols . findName  ( q1 , q2 , q3 ) ;  if  (  name != null )  {  return name ; }    int  [ ]  quads = _quadBuffer ;    quads [ 0 ] = q1 ;    quads [ 1 ] = q2 ;    quads [ 2 ] =  pad  ( q3 , lastQuadBytes ) ;  return  addName  ( quads , 3 , lastQuadBytes ) ; }   private final String findName  (    int  [ ] quads ,   int qlen ,   int lastQuad ,   int lastQuadBytes )  throws StreamReadException  {  if  (  qlen >=  quads . length )  {   _quadBuffer =  quads =  _growArrayBy  ( quads ,  quads . length ) ; }    quads [  qlen ++ ] =  pad  ( lastQuad , lastQuadBytes ) ;  String  name =  _symbols . findName  ( quads , qlen ) ;  if  (  name == null )  {  return  addName  ( quads , qlen , lastQuadBytes ) ; }  return name ; }   private final String addName  (    int  [ ] quads ,   int qlen ,   int lastQuadBytes )  throws StreamReadException  {   int  byteLen =    (  qlen << 2 ) - 4 + lastQuadBytes ;   int  lastQuad ;  if  (  lastQuadBytes < 4 )  {   lastQuad =  quads [  qlen - 1 ] ;    quads [  qlen - 1 ] =  (  lastQuad <<  (   (  4 - lastQuadBytes ) << 3 ) ) ; } else  {   lastQuad = 0 ; }    char  [ ]  cbuf =  _textBuffer . emptyAndGetCurrentSegment  ( ) ;   int  cix = 0 ;  for (   int  ix = 0 ;  ix < byteLen ; )  {   int  ch =  quads [  ix >> 2 ] ;   int  byteIx =  (  ix & 3 ) ;   ch =   (  ch >>  (   (  3 - byteIx ) << 3 ) ) & 0xFF ;   ++ ix ;  if  (  ch > 127 )  {   int  needed ;  if  (   (  ch & 0xE0 ) == 0xC0 )  {   ch &= 0x1F ;   needed = 1 ; } else  if  (   (  ch & 0xF0 ) == 0xE0 )  {   ch &= 0x0F ;   needed = 2 ; } else  if  (   (  ch & 0xF8 ) == 0xF0 )  {   ch &= 0x07 ;   needed = 3 ; } else  {   _reportInvalidInitial  ( ch ) ;   needed =  ch = 1 ; }  if  (   (  ix + needed ) > byteLen )  {   _reportInvalidEOF  ( " in property name" ,  JsonToken . PROPERTY_NAME ) ; }   int  ch2 =  quads [  ix >> 2 ] ;   byteIx =  (  ix & 3 ) ;   ch2 =  (  ch2 >>  (   (  3 - byteIx ) << 3 ) ) ;   ++ ix ;  if  (   (  ch2 & 0xC0 ) != 0x080 )  {   _reportInvalidOther  ( ch2 ) ; }   ch =   (  ch << 6 ) |  (  ch2 & 0x3F ) ;  if  (  needed > 1 )  {   ch2 =  quads [  ix >> 2 ] ;   byteIx =  (  ix & 3 ) ;   ch2 =  (  ch2 >>  (   (  3 - byteIx ) << 3 ) ) ;   ++ ix ;  if  (   (  ch2 & 0xC0 ) != 0x080 )  {   _reportInvalidOther  ( ch2 ) ; }   ch =   (  ch << 6 ) |  (  ch2 & 0x3F ) ;  if  (  needed > 2 )  {   ch2 =  quads [  ix >> 2 ] ;   byteIx =  (  ix & 3 ) ;   ch2 =  (  ch2 >>  (   (  3 - byteIx ) << 3 ) ) ;   ++ ix ;  if  (   (  ch2 & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  ch2 & 0xFF ) ; }   ch =   (  ch << 6 ) |  (  ch2 & 0x3F ) ; } }  if  (  needed > 2 )  {   ch -= 0x10000 ;  if  (  cix >=  cbuf . length )  {   cbuf =  _textBuffer . expandCurrentSegment  ( ) ; }    cbuf [  cix ++ ] =  (  char )  (  0xD800 +  (  ch >> 10 ) ) ;   ch =  0xDC00 |  (  ch & 0x03FF ) ; } }  if  (  cix >=  cbuf . length )  {   cbuf =  _textBuffer . expandCurrentSegment  ( ) ; }    cbuf [  cix ++ ] =  (  char ) ch ; }  String  baseName =  new String  ( cbuf , 0 , cix ) ;  if  (  lastQuadBytes < 4 )  {    quads [  qlen - 1 ] = lastQuad ; }  return  _symbols . addName  ( baseName , quads , qlen ) ; }   protected void _finishString  ( )  throws JacksonException  {   int  outPtr = 0 ;    char  [ ]  outBuf =  _textBuffer . emptyAndGetCurrentSegment  ( ) ;   final   int  [ ]  codes = _icUTF8 ;   final  int  outEnd =  outBuf . length ;  try  {  do  {   int  c =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ c ] != 0 )  {  if  (  c == INT_QUOTE )  {   _textBuffer . setCurrentLength  ( outPtr ) ;  return ; }   _finishString2  ( outBuf , outPtr , c ) ;  return ; }    outBuf [  outPtr ++ ] =  (  char ) c ; } while  (  outPtr < outEnd ) ;   _finishString2  ( outBuf , outPtr ,  _inputData . readUnsignedByte  ( ) ) ; }  catch (   IOException e )  {  throw  _wrapIOFailure  ( e ) ; } }   private String _finishAndReturnString  ( )  throws JacksonException  {   int  outPtr = 0 ;    char  [ ]  outBuf =  _textBuffer . emptyAndGetCurrentSegment  ( ) ;   final   int  [ ]  codes = _icUTF8 ;   final  int  outEnd =  outBuf . length ;  try  {  do  {   int  c =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ c ] != 0 )  {  if  (  c == INT_QUOTE )  {  return  _textBuffer . setCurrentAndReturn  ( outPtr ) ; }   _finishString2  ( outBuf , outPtr , c ) ;  return  _textBuffer . contentsAsString  ( ) ; }    outBuf [  outPtr ++ ] =  (  char ) c ; } while  (  outPtr < outEnd ) ;   _finishString2  ( outBuf , outPtr ,  _inputData . readUnsignedByte  ( ) ) ; }  catch (   IOException e )  {  throw  _wrapIOFailure  ( e ) ; }  return  _textBuffer . contentsAsString  ( ) ; }   private final void _finishString2  (    char  [ ] outBuf ,   int outPtr ,   int c )  throws IOException  {   final   int  [ ]  codes = _icUTF8 ;   int  outEnd =  outBuf . length ;  main_loop :  for ( ; ;  c =  _inputData . readUnsignedByte  ( ) )  {  while  (   codes [ c ] == 0 )  {  if  (  outPtr >= outEnd )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ;   outEnd =  outBuf . length ; }    outBuf [  outPtr ++ ] =  (  char ) c ;   c =  _inputData . readUnsignedByte  ( ) ; }  if  (  c == INT_QUOTE )  {  break main_loop ; }  switch  (  codes [ c ] )  {   case 1 :   c =  _decodeEscaped  ( ) ;  break ;   case 2 :   c =  _decodeUtf8_2  ( c ) ;  break ;   case 3 :   c =  _decodeUtf8_3  ( c ) ;  break ;   case 4 :   c =  _decodeUtf8_4  ( c ) ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ;   outEnd =  outBuf . length ; }    outBuf [  outPtr ++ ] =  (  char )  (  0xD800 |  (  c >> 10 ) ) ;   c =  0xDC00 |  (  c & 0x3FF ) ;  break ;   default :  if  (  c < INT_SPACE )  {   _throwUnquotedSpace  ( c , "string value" ) ; } else  {   _reportInvalidChar  ( c ) ; } }  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ;   outEnd =  outBuf . length ; }    outBuf [  outPtr ++ ] =  (  char ) c ; }   _textBuffer . setCurrentLength  ( outPtr ) ; }   protected void _skipString  ( )  throws IOException  {   _tokenIncomplete = false ;   final   int  [ ]  codes = _icUTF8 ;  main_loop :  while  ( true )  {   int  c ;  ascii_loop :  while  ( true )  {   c =  _inputData . readUnsignedByte  ( ) ;  if  (   codes [ c ] != 0 )  {  break ascii_loop ; } }  if  (  c == INT_QUOTE )  {  break main_loop ; }  switch  (  codes [ c ] )  {   case 1 :   _decodeEscaped  ( ) ;  break ;   case 2 :   _skipUtf8_2  ( ) ;  break ;   case 3 :   _skipUtf8_3  ( ) ;  break ;   case 4 :   _skipUtf8_4  ( ) ;  break ;   default :  if  (  c < INT_SPACE )  {   _throwUnquotedSpace  ( c , "string value" ) ; } else  {   _reportInvalidChar  ( c ) ; } } } }   protected JsonToken _handleUnexpectedValue  (   int c )  throws IOException  {  switch  ( c )  {   case ']' :  if  (  !  _streamReadContext . inArray  ( ) )  {  break ; }   case ',' :  if  (  !  _streamReadContext . inRoot  ( ) )  {  if  (  isEnabled  (  JsonReadFeature . ALLOW_MISSING_VALUES ) )  {   _nextByte = c ;  return  JsonToken . VALUE_NULL ; } }   case '}' :   _reportUnexpectedChar  ( c , "expected a value" ) ;   case '\'' :  if  (  isEnabled  (  JsonReadFeature . ALLOW_SINGLE_QUOTES ) )  {  return  _handleApos  ( ) ; }  break ;   case 'N' :   _matchToken  ( "NaN" , 1 ) ;  if  (  isEnabled  (  JsonReadFeature . ALLOW_NON_NUMERIC_NUMBERS ) )  {  return  resetAsNaN  ( "NaN" ,  Double . NaN ) ; }   _reportError  ( "Non-standard token 'NaN': enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow" ) ;  break ;   case 'I' :   _matchToken  ( "Infinity" , 1 ) ;  if  (  isEnabled  (  JsonReadFeature . ALLOW_NON_NUMERIC_NUMBERS ) )  {  return  resetAsNaN  ( "Infinity" ,  Double . POSITIVE_INFINITY ) ; }   _reportError  ( "Non-standard token 'Infinity': enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow" ) ;  break ;   case '+' :  return  _handleInvalidNumberStart  (  _inputData . readUnsignedByte  ( ) , false , true ) ; }  if  (  Character . isJavaIdentifierStart  ( c ) )  {   _reportInvalidToken  ( c ,  "" +  (  (  char ) c ) ,  _validJsonTokenList  ( ) ) ; }   _reportUnexpectedChar  ( c ,  "expected a valid value " +  _validJsonValueList  ( ) ) ;  return null ; }   protected JsonToken _handleApos  ( )  throws IOException  {   int  c = 0 ;   int  outPtr = 0 ;    char  [ ]  outBuf =  _textBuffer . emptyAndGetCurrentSegment  ( ) ;   final   int  [ ]  codes = _icUTF8 ;  main_loop :  while  ( true )  {  ascii_loop :  while  ( true )  {   int  outEnd =  outBuf . length ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ;   outEnd =  outBuf . length ; }  do  {   c =  _inputData . readUnsignedByte  ( ) ;  if  (  c == '\'' )  {  break main_loop ; }  if  (   (   codes [ c ] != 0 ) &&  (  c != INT_QUOTE ) )  {  break ascii_loop ; }    outBuf [  outPtr ++ ] =  (  char ) c ; } while  (  outPtr < outEnd ) ; }  switch  (  codes [ c ] )  {   case 1 :   c =  _decodeEscaped  ( ) ;  break ;   case 2 :   c =  _decodeUtf8_2  ( c ) ;  break ;   case 3 :   c =  _decodeUtf8_3  ( c ) ;  break ;   case 4 :   c =  _decodeUtf8_4  ( c ) ;    outBuf [  outPtr ++ ] =  (  char )  (  0xD800 |  (  c >> 10 ) ) ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }   c =  0xDC00 |  (  c & 0x3FF ) ;  break ;   default :  if  (  c < INT_SPACE )  {   _throwUnquotedSpace  ( c , "string value" ) ; }   _reportInvalidChar  ( c ) ; }  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] =  (  char ) c ; }   _textBuffer . setCurrentLength  ( outPtr ) ;  return  JsonToken . VALUE_STRING ; }   protected JsonToken _handleInvalidNumberStart  (   int ch ,   final boolean neg )  throws IOException  {  return  _handleInvalidNumberStart  ( ch , neg , false ) ; }   protected JsonToken _handleInvalidNumberStart  (   int ch ,   final boolean neg ,   final boolean hasSign )  throws IOException  {  while  (  ch == 'I' )  {   ch =  _inputData . readUnsignedByte  ( ) ;  String  match ;  if  (  ch == 'N' )  {   match =  neg ? "-INF" : "+INF" ; } else  if  (  ch == 'n' )  {   match =  neg ? "-Infinity" : "+Infinity" ; } else  {  break ; }   _matchToken  ( match , 3 ) ;  if  (  isEnabled  (  JsonReadFeature . ALLOW_NON_NUMERIC_NUMBERS ) )  {  return  resetAsNaN  ( match ,  neg ?  Double . NEGATIVE_INFINITY :  Double . POSITIVE_INFINITY ) ; }   _reportError  (   "Non-standard token '" + match + "': enable `JsonReadFeature.ALLOW_NON_NUMERIC_NUMBERS` to allow" ) ; }  if  (    !  isEnabled  (  JsonReadFeature . ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS ) && hasSign &&  ! neg )  {   _reportUnexpectedNumberChar  ( '+' , "JSON spec does not allow numbers to have plus signs: enable `JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS` to allow" ) ; }   _reportUnexpectedNumberChar  ( ch , "expected digit (0-9) to follow minus sign, for valid numeric value" ) ;  return null ; }   protected final void _matchToken  (  String matchStr ,   int i )  throws IOException  {   final  int  len =  matchStr . length  ( ) ;  do  {   int  ch =  _inputData . readUnsignedByte  ( ) ;  if  (  ch !=  matchStr . charAt  ( i ) )  {   _reportInvalidToken  ( ch ,  matchStr . substring  ( 0 , i ) ) ; } } while  (   ++ i < len ) ;   int  ch =  _inputData . readUnsignedByte  ( ) ;  if  (    ch >= '0' &&  ch != ']' &&  ch != '}' )  {   _checkMatchEnd  ( matchStr , i , ch ) ; }   _nextByte = ch ; }   private final void _checkMatchEnd  (  String matchStr ,   int i ,   int ch )  throws IOException  {   char  c =  (  char )  _decodeCharForError  ( ch ) ;  if  (  Character . isJavaIdentifierPart  ( c ) )  {   _reportInvalidToken  ( c ,  matchStr . substring  ( 0 , i ) ) ; } }   private final  int _skipWS  ( )  throws IOException  {   int  i = _nextByte ;  if  (  i < 0 )  {   i =  _inputData . readUnsignedByte  ( ) ; } else  {   _nextByte =  - 1 ; }  while  ( true )  {  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {  return  _skipWSComment  ( i ) ; }  return i ; } else  {  if  (   i == INT_CR ||  i == INT_LF )  {   ++ _currInputRow ; } }   i =  _inputData . readUnsignedByte  ( ) ; } }   private final  int _skipWSOrEnd  ( )  throws IOException  {   int  i = _nextByte ;  if  (  i < 0 )  {  try  {   i =  _inputData . readUnsignedByte  ( ) ; }  catch (   EOFException e )  {  return  _eofAsNextChar  ( ) ; } } else  {   _nextByte =  - 1 ; }  while  ( true )  {  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {  return  _skipWSComment  ( i ) ; }  return i ; } else  {  if  (   i == INT_CR ||  i == INT_LF )  {   ++ _currInputRow ; } }  try  {   i =  _inputData . readUnsignedByte  ( ) ; }  catch (   EOFException e )  {  return  _eofAsNextChar  ( ) ; } } }   private final  int _skipWSComment  (   int i )  throws IOException  {  while  ( true )  {  if  (  i > INT_SPACE )  {  if  (  i == INT_SLASH )  {   _skipComment  ( ) ; } else  if  (  i == INT_HASH )  {  if  (  !  _skipYAMLComment  ( ) )  {  return i ; } } else  {  return i ; } } else  {  if  (   i == INT_CR ||  i == INT_LF )  {   ++ _currInputRow ; } }   i =  _inputData . readUnsignedByte  ( ) ; } }   private final  int _skipColon  ( )  throws IOException  {   int  i = _nextByte ;  if  (  i < 0 )  {   i =  _inputData . readUnsignedByte  ( ) ; } else  {   _nextByte =  - 1 ; }  if  (  i == INT_COLON )  {   i =  _inputData . readUnsignedByte  ( ) ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {  return  _skipColon2  ( i , true ) ; }  return i ; }  if  (   i == INT_SPACE ||  i == INT_TAB )  {   i =  _inputData . readUnsignedByte  ( ) ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {  return  _skipColon2  ( i , true ) ; }  return i ; } }  return  _skipColon2  ( i , true ) ; }  if  (   i == INT_SPACE ||  i == INT_TAB )  {   i =  _inputData . readUnsignedByte  ( ) ; }  if  (  i == INT_COLON )  {   i =  _inputData . readUnsignedByte  ( ) ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {  return  _skipColon2  ( i , true ) ; }  return i ; }  if  (   i == INT_SPACE ||  i == INT_TAB )  {   i =  _inputData . readUnsignedByte  ( ) ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {  return  _skipColon2  ( i , true ) ; }  return i ; } }  return  _skipColon2  ( i , true ) ; }  return  _skipColon2  ( i , false ) ; }   private final  int _skipColon2  (   int i ,  boolean gotColon )  throws IOException  {  for ( ; ;  i =  _inputData . readUnsignedByte  ( ) )  {  if  (  i > INT_SPACE )  {  if  (  i == INT_SLASH )  {   _skipComment  ( ) ;  continue ; }  if  (  i == INT_HASH )  {  if  (  _skipYAMLComment  ( ) )  {  continue ; } }  if  ( gotColon )  {  return i ; }  if  (  i != INT_COLON )  {   _reportUnexpectedChar  ( i , "was expecting a colon to separate property name and value" ) ; }   gotColon = true ; } else  {  if  (   i == INT_CR ||  i == INT_LF )  {   ++ _currInputRow ; } } } }   private final void _skipComment  ( )  throws IOException  {  if  (  !  isEnabled  (  JsonReadFeature . ALLOW_JAVA_COMMENTS ) )  {   _reportUnexpectedChar  ( '/' , "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)" ) ; }   int  c =  _inputData . readUnsignedByte  ( ) ;  if  (  c == '/' )  {   _skipLine  ( ) ; } else  if  (  c == '*' )  {   _skipCComment  ( ) ; } else  {   _reportUnexpectedChar  ( c , "was expecting either '*' or '/' for a comment" ) ; } }   private final void _skipCComment  ( )  throws IOException  {   final   int  [ ]  codes =  CharTypes . getInputCodeComment  ( ) ;   int  i =  _inputData . readUnsignedByte  ( ) ;  main_loop :  while  ( true )  {   int  code =  codes [ i ] ;  if  (  code != 0 )  {  switch  ( code )  {   case '*' :   i =  _inputData . readUnsignedByte  ( ) ;  if  (  i == INT_SLASH )  {  return ; }  continue main_loop ;   case INT_LF :   case INT_CR :   ++ _currInputRow ;  break ;   case 2 :   _skipUtf8_2  ( ) ;  break ;   case 3 :   _skipUtf8_3  ( ) ;  break ;   case 4 :   _skipUtf8_4  ( ) ;  break ;   default :   _reportInvalidChar  ( i ) ; } }   i =  _inputData . readUnsignedByte  ( ) ; } }   private final boolean _skipYAMLComment  ( )  throws IOException  {  if  (  !  isEnabled  (  JsonReadFeature . ALLOW_YAML_COMMENTS ) )  {  return false ; }   _skipLine  ( ) ;  return true ; }   private final void _skipLine  ( )  throws IOException  {   final   int  [ ]  codes =  CharTypes . getInputCodeComment  ( ) ;  while  ( true )  {   int  i =  _inputData . readUnsignedByte  ( ) ;   int  code =  codes [ i ] ;  if  (  code != 0 )  {  switch  ( code )  {   case INT_LF :   case INT_CR :   ++ _currInputRow ;  return ;   case '*' :  break ;   case 2 :   _skipUtf8_2  ( ) ;  break ;   case 3 :   _skipUtf8_3  ( ) ;  break ;   case 4 :   _skipUtf8_4  ( ) ;  break ;   default :  if  (  code < 0 )  {   _reportInvalidChar  ( i ) ; } } } } }    @ Override protected  char _decodeEscaped  ( )  throws JacksonException  {  try  {  return  _decodeEscaped2  ( ) ; }  catch (   IOException e )  {  throw  _wrapIOFailure  ( e ) ; } }   private  char _decodeEscaped2  ( )  throws IOException  {   int  c =  _inputData . readUnsignedByte  ( ) ;  switch  ( c )  {   case 'b' :  return '\b' ;   case 't' :  return '\t' ;   case 'n' :  return '\n' ;   case 'f' :  return '\f' ;   case 'r' :  return '\r' ;   case '"' :   case '/' :   case '\\' :  return  (  char ) c ;   case 'u' :  break ;   default :  return  _handleUnrecognizedCharacterEscape  (  (  char )  _decodeCharForError  ( c ) ) ; }   int  value = 0 ;  for (   int  i = 0 ;  i < 4 ;  ++ i )  {   int  ch =  _inputData . readUnsignedByte  ( ) ;   int  digit =  CharTypes . charToHex  ( ch ) ;  if  (  digit < 0 )  {   _reportUnexpectedChar  ( ch , "expected a hex-digit for character escape sequence" ) ; }   value =   (  value << 4 ) | digit ; }  return  (  char ) value ; }   protected  int _decodeCharForError  (   int firstByte )  throws IOException  {   int  c =  firstByte & 0xFF ;  if  (  c > 0x7F )  {   int  needed ;  if  (   (  c & 0xE0 ) == 0xC0 )  {   c &= 0x1F ;   needed = 1 ; } else  if  (   (  c & 0xF0 ) == 0xE0 )  {   c &= 0x0F ;   needed = 2 ; } else  if  (   (  c & 0xF8 ) == 0xF0 )  {   c &= 0x07 ;   needed = 3 ; } else  {   _reportInvalidInitial  (  c & 0xFF ) ;   needed = 1 ; }   int  d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }   c =   (  c << 6 ) |  (  d & 0x3F ) ;  if  (  needed > 1 )  {   d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }   c =   (  c << 6 ) |  (  d & 0x3F ) ;  if  (  needed > 2 )  {   d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }   c =   (  c << 6 ) |  (  d & 0x3F ) ; } } }  return c ; }   private final  int _decodeUtf8_2  (   int c )  throws IOException  {   int  d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }  return   (   (  c & 0x1F ) << 6 ) |  (  d & 0x3F ) ; }   private final  int _decodeUtf8_3  (   int c1 )  throws IOException  {   c1 &= 0x0F ;   int  d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }   int  c =   (  c1 << 6 ) |  (  d & 0x3F ) ;   d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }   c =   (  c << 6 ) |  (  d & 0x3F ) ;  return c ; }   private final  int _decodeUtf8_4  (   int c )  throws IOException  {   int  d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }   c =   (   (  c & 0x07 ) << 6 ) |  (  d & 0x3F ) ;   d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }   c =   (  c << 6 ) |  (  d & 0x3F ) ;   d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }  return   (   (  c << 6 ) |  (  d & 0x3F ) ) - 0x10000 ; }   private final void _skipUtf8_2  ( )  throws IOException  {   int  c =  _inputData . readUnsignedByte  ( ) ;  if  (   (  c & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  c & 0xFF ) ; } }   private final void _skipUtf8_3  ( )  throws IOException  {   int  c =  _inputData . readUnsignedByte  ( ) ;  if  (   (  c & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  c & 0xFF ) ; }   c =  _inputData . readUnsignedByte  ( ) ;  if  (   (  c & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  c & 0xFF ) ; } }   private final void _skipUtf8_4  ( )  throws IOException  {   int  d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }   d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; }   d =  _inputData . readUnsignedByte  ( ) ;  if  (   (  d & 0xC0 ) != 0x080 )  {   _reportInvalidOther  (  d & 0xFF ) ; } }   protected void _reportInvalidToken  (   int ch ,  String matchedPart )  throws JacksonException  {   _reportInvalidToken  ( ch , matchedPart ,  _validJsonTokenList  ( ) ) ; }   protected void _reportInvalidToken  (   int ch ,  String matchedPart ,  String msg )  throws JacksonException  {  StringBuilder  sb =  new StringBuilder  ( matchedPart ) ;  try  {  while  ( true )  {   char  c =  (  char )  _decodeCharForError  ( ch ) ;  if  (  !  Character . isJavaIdentifierPart  ( c ) )  {  break ; }   sb . append  ( c ) ;   ch =  _inputData . readUnsignedByte  ( ) ; } }  catch (   IOException e )  { ; }   _reportError  (    "Unrecognized token '" +  sb . toString  ( ) + "': was expecting " + msg ) ; }   protected void _reportInvalidChar  (   int c )  throws StreamReadException  {  if  (  c < INT_SPACE )  {   _throwInvalidSpace  ( c ) ; }   _reportInvalidInitial  ( c ) ; }   protected void _reportInvalidInitial  (   int mask )  throws StreamReadException  {   _reportError  (  "Invalid UTF-8 start byte 0x" +  Integer . toHexString  ( mask ) ) ; }   private void _reportInvalidOther  (   int mask )  throws StreamReadException  {   _reportError  (  "Invalid UTF-8 middle byte 0x" +  Integer . toHexString  ( mask ) ) ; }   private static   int  [ ] _growArrayBy  (    int  [ ] arr ,   int more )  {  if  (  arr == null )  {  return  new  int  [ more ] ; }  return  Arrays . copyOf  ( arr ,   arr . length + more ) ; }    @ SuppressWarnings  ( "resource" ) protected final   byte  [ ] _decodeBase64  (  Base64Variant b64variant )  throws IOException  {  ByteArrayBuilder  builder =  _getByteArrayBuilder  ( ) ;  while  ( true )  {   int  ch ;  do  {   ch =  _inputData . readUnsignedByte  ( ) ; } while  (  ch <= INT_SPACE ) ;   int  bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  ch == INT_QUOTE )  {  return  builder . toByteArray  ( ) ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 0 ) ;  if  (  bits < 0 )  {  continue ; } }   int  decodedData = bits ;   ch =  _inputData . readUnsignedByte  ( ) ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {   bits =  _decodeBase64Escape  ( b64variant , ch , 1 ) ; }   decodedData =   (  decodedData << 6 ) | bits ;   ch =  _inputData . readUnsignedByte  ( ) ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  bits !=  Base64Variant . BASE64_VALUE_PADDING )  {  if  (  ch == INT_QUOTE )  {   decodedData >>= 4 ;   builder . append  ( decodedData ) ;  if  (  b64variant . usesPadding  ( ) )  {   _handleBase64MissingPadding  ( b64variant ) ; }  return  builder . toByteArray  ( ) ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 2 ) ; }  if  (  bits ==  Base64Variant . BASE64_VALUE_PADDING )  {   ch =  _inputData . readUnsignedByte  ( ) ;  if  (  !  b64variant . usesPaddingChar  ( ch ) )  {  if  (   (  ch != INT_BACKSLASH ) ||   _decodeBase64Escape  ( b64variant , ch , 3 ) !=  Base64Variant . BASE64_VALUE_PADDING )  {   _reportInvalidBase64Char  ( b64variant , ch , 3 ,   "expected padding character '" +  b64variant . getPaddingChar  ( ) + "'" ) ; } }   decodedData >>= 4 ;   builder . append  ( decodedData ) ;  continue ; } }   decodedData =   (  decodedData << 6 ) | bits ;   ch =  _inputData . readUnsignedByte  ( ) ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  bits !=  Base64Variant . BASE64_VALUE_PADDING )  {  if  (  ch == INT_QUOTE )  {   decodedData >>= 2 ;   builder . appendTwoBytes  ( decodedData ) ;  if  (  b64variant . usesPadding  ( ) )  {   _handleBase64MissingPadding  ( b64variant ) ; }  return  builder . toByteArray  ( ) ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 3 ) ; }  if  (  bits ==  Base64Variant . BASE64_VALUE_PADDING )  {   decodedData >>= 2 ;   builder . appendTwoBytes  ( decodedData ) ;  continue ; } }   decodedData =   (  decodedData << 6 ) | bits ;   builder . appendThreeBytes  ( decodedData ) ; } }    @ Override public JsonLocation currentTokenLocation  ( )  {  return  new JsonLocation  (  _contentReference  ( ) ,  - 1L ,  - 1L , _tokenInputRow ,  - 1 ) ; }    @ Override public JsonLocation currentLocation  ( )  {   final  int  col =  - 1 ;  return  new JsonLocation  (  _contentReference  ( ) ,  - 1L ,  - 1L , _currInputRow , col ) ; }   private void _closeScope  (   int i )  throws StreamReadException  {  if  (  i == INT_RBRACKET )  {  if  (  !  _streamReadContext . inArray  ( ) )  {   _reportMismatchedEndMarker  ( i , '}' ) ; }   _streamReadContext =  _streamReadContext . clearAndGetParent  ( ) ;   _currToken =  JsonToken . END_ARRAY ; }  if  (  i == INT_RCURLY )  {  if  (  !  _streamReadContext . inObject  ( ) )  {   _reportMismatchedEndMarker  ( i , ']' ) ; }   _streamReadContext =  _streamReadContext . clearAndGetParent  ( ) ;   _currToken =  JsonToken . END_OBJECT ; } }   private final static  int pad  (   int q ,   int bytes )  {  return   (  bytes == 4 ) ? q :  (  q |  (   - 1 <<  (  bytes << 3 ) ) ) ; } }