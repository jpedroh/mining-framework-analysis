  package     com . fasterxml . jackson . core . json ;   import  java . io .  * ;  import    com . fasterxml . jackson . core .  * ;  import      com . fasterxml . jackson . core . base . ParserBase ;  import      com . fasterxml . jackson . core . io . CharTypes ;  import      com . fasterxml . jackson . core . io . IOContext ;  import      com . fasterxml . jackson . core . sym . CharsToNameCanonicalizer ;  import     com . fasterxml . jackson . core . util .  * ;  import static     com . fasterxml . jackson . core . JsonTokenId .  * ;   public class ReaderBasedJsonParser  extends ParserBase  {   protected final static   int  [ ]  _icLatin1 =  CharTypes . getInputCodeLatin1  ( ) ;   protected Reader  _reader ;   protected   char  [ ]  _inputBuffer ;   protected boolean  _bufferRecyclable ;   protected ObjectCodec  _objectCodec ;   final protected CharsToNameCanonicalizer  _symbols ;   final protected  int  _hashSeed ;   protected boolean  _tokenIncomplete = false ;   public ReaderBasedJsonParser  (  IOContext ctxt ,   int features ,  Reader r ,  ObjectCodec codec ,  CharsToNameCanonicalizer st ,    char  [ ] inputBuffer ,   int start ,   int end ,  boolean bufferRecyclable )  {  super  ( ctxt , features ) ;   _reader = r ;   _inputBuffer = inputBuffer ;   _inputPtr = start ;   _inputEnd = end ;   _objectCodec = codec ;   _symbols = st ;   _hashSeed =  st . hashSeed  ( ) ;   _bufferRecyclable = bufferRecyclable ; }   public ReaderBasedJsonParser  (  IOContext ctxt ,   int features ,  Reader r ,  ObjectCodec codec ,  CharsToNameCanonicalizer st )  {  super  ( ctxt , features ) ;   _reader = r ;   _inputBuffer =  ctxt . allocTokenBuffer  ( ) ;   _inputPtr = 0 ;   _inputEnd = 0 ;   _objectCodec = codec ;   _symbols = st ;   _hashSeed =  st . hashSeed  ( ) ;   _bufferRecyclable = true ; }    @ Override public ObjectCodec getCodec  ( )  {  return _objectCodec ; }    @ Override public void setCodec  (  ObjectCodec c )  {   _objectCodec = c ; }    @ Override public  int releaseBuffered  (  Writer w )  throws IOException  {   int  count =  _inputEnd - _inputPtr ;  if  (  count < 1 )  {  return 0 ; }   int  origPtr = _inputPtr ;   w . write  ( _inputBuffer , origPtr , count ) ;  return count ; }    @ Override public Object getInputSource  ( )  {  return _reader ; }    @ Override protected boolean loadMore  ( )  throws IOException  {   _currInputProcessed += _inputEnd ;   _currInputRowStart -= _inputEnd ;  if  (  _reader != null )  {   int  count =  _reader . read  ( _inputBuffer , 0 ,  _inputBuffer . length ) ;  if  (  count > 0 )  {   _inputPtr = 0 ;   _inputEnd = count ;  return true ; }   _closeInput  ( ) ;  if  (  count == 0 )  {  throw  new IOException  (  "Reader returned 0 characters when trying to read " + _inputEnd ) ; } }  return false ; }   protected  char getNextChar  (  String eofMsg )  throws IOException  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {   _reportInvalidEOF  ( eofMsg ) ; } }  return  _inputBuffer [  _inputPtr ++ ] ; }    @ Override protected void _closeInput  ( )  throws IOException  {  if  (  _reader != null )  {  if  (   _ioContext . isResourceManaged  ( ) ||  isEnabled  (  Feature . AUTO_CLOSE_SOURCE ) )  {   _reader . close  ( ) ; }   _reader = null ; } }    @ Override protected void _releaseBuffers  ( )  throws IOException  {   super . _releaseBuffers  ( ) ;   _symbols . release  ( ) ;  if  ( _bufferRecyclable )  {    char  [ ]  buf = _inputBuffer ;  if  (  buf != null )  {   _inputBuffer = null ;   _ioContext . releaseTokenBuffer  ( buf ) ; } } }    @ Override public final String getText  ( )  throws IOException  {  JsonToken  t = _currToken ;  if  (  t ==  JsonToken . VALUE_STRING )  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }  return  _textBuffer . contentsAsString  ( ) ; }  return  _getText2  ( t ) ; }    @ Override public final String getValueAsString  ( )  throws IOException  {  if  (  _currToken ==  JsonToken . VALUE_STRING )  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }  return  _textBuffer . contentsAsString  ( ) ; }  if  (  _currToken ==  JsonToken . FIELD_NAME )  {  return  getCurrentName  ( ) ; }  return  super . getValueAsString  ( null ) ; }    @ Override public final String getValueAsString  (  String defValue )  throws IOException  {  if  (  _currToken ==  JsonToken . VALUE_STRING )  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }  return  _textBuffer . contentsAsString  ( ) ; }  if  (  _currToken ==  JsonToken . FIELD_NAME )  {  return  getCurrentName  ( ) ; }  return  super . getValueAsString  ( defValue ) ; }   protected final String _getText2  (  JsonToken t )  {  if  (  t == null )  {  return null ; }  switch  (  t . id  ( ) )  {   case ID_FIELD_NAME :  return  _parsingContext . getCurrentName  ( ) ;   case ID_STRING :   case ID_NUMBER_INT :   case ID_NUMBER_FLOAT :  return  _textBuffer . contentsAsString  ( ) ;   default :  return  t . asString  ( ) ; } }    @ Override public final   char  [ ] getTextCharacters  ( )  throws IOException  {  if  (  _currToken != null )  {  switch  (  _currToken . id  ( ) )  {   case ID_FIELD_NAME :  if  (  ! _nameCopied )  {  String  name =  _parsingContext . getCurrentName  ( ) ;   int  nameLen =  name . length  ( ) ;  if  (  _nameCopyBuffer == null )  {   _nameCopyBuffer =  _ioContext . allocNameCopyBuffer  ( nameLen ) ; } else  if  (   _nameCopyBuffer . length < nameLen )  {   _nameCopyBuffer =  new  char  [ nameLen ] ; }   name . getChars  ( 0 , nameLen , _nameCopyBuffer , 0 ) ;   _nameCopied = true ; }  return _nameCopyBuffer ;   case ID_STRING :  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }   case ID_NUMBER_INT :   case ID_NUMBER_FLOAT :  return  _textBuffer . getTextBuffer  ( ) ;   default :  return  _currToken . asCharArray  ( ) ; } }  return null ; }    @ Override public final  int getTextLength  ( )  throws IOException  {  if  (  _currToken != null )  {  switch  (  _currToken . id  ( ) )  {   case ID_FIELD_NAME :  return   _parsingContext . getCurrentName  ( ) . length  ( ) ;   case ID_STRING :  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }   case ID_NUMBER_INT :   case ID_NUMBER_FLOAT :  return  _textBuffer . size  ( ) ;   default :  return   _currToken . asCharArray  ( ) . length ; } }  return 0 ; }    @ Override public final  int getTextOffset  ( )  throws IOException  {  if  (  _currToken != null )  {  switch  (  _currToken . id  ( ) )  {   case ID_FIELD_NAME :  return 0 ;   case ID_STRING :  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }   case ID_NUMBER_INT :   case ID_NUMBER_FLOAT :  return  _textBuffer . getTextOffset  ( ) ;   default : } }  return 0 ; }    @ Override public   byte  [ ] getBinaryValue  (  Base64Variant b64variant )  throws IOException  {  if  (   _currToken !=  JsonToken . VALUE_STRING &&  (   _currToken !=  JsonToken . VALUE_EMBEDDED_OBJECT ||  _binaryValue == null ) )  {   _reportError  (   "Current token (" + _currToken + ") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary" ) ; }  if  ( _tokenIncomplete )  {  try  {   _binaryValue =  _decodeBase64  ( b64variant ) ; }  catch (   IllegalArgumentException iae )  {  throw  _constructError  (    "Failed to decode VALUE_STRING as base64 (" + b64variant + "): " +  iae . getMessage  ( ) ) ; }   _tokenIncomplete = false ; } else  {  if  (  _binaryValue == null )  {    @ SuppressWarnings  ( "resource" ) ByteArrayBuilder  builder =  _getByteArrayBuilder  ( ) ;   _decodeBase64  (  getText  ( ) , builder , b64variant ) ;   _binaryValue =  builder . toByteArray  ( ) ; } }  return _binaryValue ; }    @ Override public  int readBinaryValue  (  Base64Variant b64variant ,  OutputStream out )  throws IOException  {  if  (   ! _tokenIncomplete ||  _currToken !=  JsonToken . VALUE_STRING )  {    byte  [ ]  b =  getBinaryValue  ( b64variant ) ;   out . write  ( b ) ;  return  b . length ; }    byte  [ ]  buf =  _ioContext . allocBase64Buffer  ( ) ;  try  {  return  _readBinary  ( b64variant , out , buf ) ; }  finally  {   _ioContext . releaseBase64Buffer  ( buf ) ; } }   protected  int _readBinary  (  Base64Variant b64variant ,  OutputStream out ,    byte  [ ] buffer )  throws IOException  {   int  outputPtr = 0 ;   final  int  outputEnd =   buffer . length - 3 ;   int  outputCount = 0 ;  while  ( true )  {   char  ch ;  do  {  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   ch =  _inputBuffer [  _inputPtr ++ ] ; } while  (  ch <= INT_SPACE ) ;   int  bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  ch == '"' )  {  break ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 0 ) ;  if  (  bits < 0 )  {  continue ; } }  if  (  outputPtr > outputEnd )  {   outputCount += outputPtr ;   out . write  ( buffer , 0 , outputPtr ) ;   outputPtr = 0 ; }   int  decodedData = bits ;  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   ch =  _inputBuffer [  _inputPtr ++ ] ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {   bits =  _decodeBase64Escape  ( b64variant , ch , 1 ) ; }   decodedData =   (  decodedData << 6 ) | bits ;  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   ch =  _inputBuffer [  _inputPtr ++ ] ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  bits !=  Base64Variant . BASE64_VALUE_PADDING )  {  if  (   ch == '"' &&  !  b64variant . usesPadding  ( ) )  {   decodedData >>= 4 ;    buffer [  outputPtr ++ ] =  (  byte ) decodedData ;  break ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 2 ) ; }  if  (  bits ==  Base64Variant . BASE64_VALUE_PADDING )  {  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   ch =  _inputBuffer [  _inputPtr ++ ] ;  if  (  !  b64variant . usesPaddingChar  ( ch ) )  {  throw  reportInvalidBase64Char  ( b64variant , ch , 3 ,   "expected padding character '" +  b64variant . getPaddingChar  ( ) + "'" ) ; }   decodedData >>= 4 ;    buffer [  outputPtr ++ ] =  (  byte ) decodedData ;  continue ; } }   decodedData =   (  decodedData << 6 ) | bits ;  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   ch =  _inputBuffer [  _inputPtr ++ ] ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  bits !=  Base64Variant . BASE64_VALUE_PADDING )  {  if  (   ch == '"' &&  !  b64variant . usesPadding  ( ) )  {   decodedData >>= 2 ;    buffer [  outputPtr ++ ] =  (  byte )  (  decodedData >> 8 ) ;    buffer [  outputPtr ++ ] =  (  byte ) decodedData ;  break ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 3 ) ; }  if  (  bits ==  Base64Variant . BASE64_VALUE_PADDING )  {   decodedData >>= 2 ;    buffer [  outputPtr ++ ] =  (  byte )  (  decodedData >> 8 ) ;    buffer [  outputPtr ++ ] =  (  byte ) decodedData ;  continue ; } }   decodedData =   (  decodedData << 6 ) | bits ;    buffer [  outputPtr ++ ] =  (  byte )  (  decodedData >> 16 ) ;    buffer [  outputPtr ++ ] =  (  byte )  (  decodedData >> 8 ) ;    buffer [  outputPtr ++ ] =  (  byte ) decodedData ; }   _tokenIncomplete = false ;  if  (  outputPtr > 0 )  {   outputCount += outputPtr ;   out . write  ( buffer , 0 , outputPtr ) ; }  return outputCount ; }    @ Override public final JsonToken nextToken  ( )  throws IOException  {   _numTypesValid = NR_UNKNOWN ;  if  (  _currToken ==  JsonToken . FIELD_NAME )  {  return  _nextAfterName  ( ) ; }  if  ( _tokenIncomplete )  {   _skipString  ( ) ; }   int  i =  _skipWSOrEnd  ( ) ;  if  (  i < 0 )  {   close  ( ) ;  return  (  _currToken = null ) ; }   _tokenInputTotal =   _currInputProcessed + _inputPtr - 1 ;   _tokenInputRow = _currInputRow ;   _tokenInputCol =   _inputPtr - _currInputRowStart - 1 ;   _binaryValue = null ;  if  (  i == INT_RBRACKET )  {  if  (  !  _parsingContext . inArray  ( ) )  {   _reportMismatchedEndMarker  ( i , '}' ) ; }   _parsingContext =  _parsingContext . getParent  ( ) ;  return  (  _currToken =  JsonToken . END_ARRAY ) ; }  if  (  i == INT_RCURLY )  {  if  (  !  _parsingContext . inObject  ( ) )  {   _reportMismatchedEndMarker  ( i , ']' ) ; }   _parsingContext =  _parsingContext . getParent  ( ) ;  return  (  _currToken =  JsonToken . END_OBJECT ) ; }  if  (  _parsingContext . expectComma  ( ) )  {   i =  _skipComma  ( i ) ; }  boolean  inObject =  _parsingContext . inObject  ( ) ;  if  ( inObject )  {  String  name =   (  i == INT_QUOTE ) ?  _parseName  ( ) :  _handleOddName  ( i ) ;   _parsingContext . setCurrentName  ( name ) ;   _currToken =  JsonToken . FIELD_NAME ;   i =  _skipColon  ( ) ; }  JsonToken  t ;  switch  ( i )  {   case '"' :   _tokenIncomplete = true ;   t =  JsonToken . VALUE_STRING ;  break ;   case '[' :  if  (  ! inObject )  {   _parsingContext =  _parsingContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; }   t =  JsonToken . START_ARRAY ;  break ;   case '{' :  if  (  ! inObject )  {   _parsingContext =  _parsingContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }   t =  JsonToken . START_OBJECT ;  break ;   case ']' :   case '}' :   _reportUnexpectedChar  ( i , "expected a value" ) ;   case 't' :   _matchTrue  ( ) ;   t =  JsonToken . VALUE_TRUE ;  break ;   case 'f' :   _matchFalse  ( ) ;   t =  JsonToken . VALUE_FALSE ;  break ;   case 'n' :   _matchNull  ( ) ;   t =  JsonToken . VALUE_NULL ;  break ;   case '-' :   t =  _parseNegNumber  ( ) ;  break ;   case '0' :   case '1' :   case '2' :   case '3' :   case '4' :   case '5' :   case '6' :   case '7' :   case '8' :   case '9' :   t =  _parsePosNumber  ( i ) ;  break ;   default :   t =  _handleOddValue  ( i ) ;  break ; }  if  ( inObject )  {   _nextToken = t ;  return _currToken ; }   _currToken = t ;  return t ; }   private final JsonToken _nextAfterName  ( )  {   _nameCopied = false ;  JsonToken  t = _nextToken ;   _nextToken = null ;  if  (  t ==  JsonToken . START_ARRAY )  {   _parsingContext =  _parsingContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; } else  if  (  t ==  JsonToken . START_OBJECT )  {   _parsingContext =  _parsingContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }  return  (  _currToken = t ) ; }    @ Override public final String nextTextValue  ( )  throws IOException  {  if  (  _currToken ==  JsonToken . FIELD_NAME )  {   _nameCopied = false ;  JsonToken  t = _nextToken ;   _nextToken = null ;   _currToken = t ;  if  (  t ==  JsonToken . VALUE_STRING )  {  if  ( _tokenIncomplete )  {   _tokenIncomplete = false ;   _finishString  ( ) ; }  return  _textBuffer . contentsAsString  ( ) ; }  if  (  t ==  JsonToken . START_ARRAY )  {   _parsingContext =  _parsingContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; } else  if  (  t ==  JsonToken . START_OBJECT )  {   _parsingContext =  _parsingContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }  return null ; }  return   (   nextToken  ( ) ==  JsonToken . VALUE_STRING ) ?  getText  ( ) : null ; }    @ Override public final  int nextIntValue  (   int defaultValue )  throws IOException  {  if  (  _currToken ==  JsonToken . FIELD_NAME )  {   _nameCopied = false ;  JsonToken  t = _nextToken ;   _nextToken = null ;   _currToken = t ;  if  (  t ==  JsonToken . VALUE_NUMBER_INT )  {  return  getIntValue  ( ) ; }  if  (  t ==  JsonToken . START_ARRAY )  {   _parsingContext =  _parsingContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; } else  if  (  t ==  JsonToken . START_OBJECT )  {   _parsingContext =  _parsingContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }  return defaultValue ; }  return   (   nextToken  ( ) ==  JsonToken . VALUE_NUMBER_INT ) ?  getIntValue  ( ) : defaultValue ; }    @ Override public final  long nextLongValue  (   long defaultValue )  throws IOException  {  if  (  _currToken ==  JsonToken . FIELD_NAME )  {   _nameCopied = false ;  JsonToken  t = _nextToken ;   _nextToken = null ;   _currToken = t ;  if  (  t ==  JsonToken . VALUE_NUMBER_INT )  {  return  getLongValue  ( ) ; }  if  (  t ==  JsonToken . START_ARRAY )  {   _parsingContext =  _parsingContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; } else  if  (  t ==  JsonToken . START_OBJECT )  {   _parsingContext =  _parsingContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }  return defaultValue ; }  return   (   nextToken  ( ) ==  JsonToken . VALUE_NUMBER_INT ) ?  getLongValue  ( ) : defaultValue ; }    @ Override public final Boolean nextBooleanValue  ( )  throws IOException  {  if  (  _currToken ==  JsonToken . FIELD_NAME )  {   _nameCopied = false ;  JsonToken  t = _nextToken ;   _nextToken = null ;   _currToken = t ;  if  (  t ==  JsonToken . VALUE_TRUE )  {  return  Boolean . TRUE ; }  if  (  t ==  JsonToken . VALUE_FALSE )  {  return  Boolean . FALSE ; }  if  (  t ==  JsonToken . START_ARRAY )  {   _parsingContext =  _parsingContext . createChildArrayContext  ( _tokenInputRow , _tokenInputCol ) ; } else  if  (  t ==  JsonToken . START_OBJECT )  {   _parsingContext =  _parsingContext . createChildObjectContext  ( _tokenInputRow , _tokenInputCol ) ; }  return null ; }  JsonToken  t =  nextToken  ( ) ;  if  (  t != null )  {   int  id =  t . id  ( ) ;  if  (  id == ID_TRUE )  return  Boolean . TRUE ;  if  (  id == ID_FALSE )  return  Boolean . FALSE ; }  return null ; }   protected final JsonToken _parsePosNumber  (   int ch )  throws IOException  {   int  ptr = _inputPtr ;   int  startPtr =  ptr - 1 ;   final  int  inputLen = _inputEnd ;  if  (  ch == INT_0 )  {  return  _parseNumber2  ( false , startPtr ) ; }   int  intLen = 1 ;  int_loop :  while  ( true )  {  if  (  ptr >= inputLen )  {   _inputPtr = startPtr ;  return  _parseNumber2  ( false , startPtr ) ; }   ch =  (  int )  _inputBuffer [  ptr ++ ] ;  if  (   ch < INT_0 ||  ch > INT_9 )  {  break int_loop ; }   ++ intLen ; }  if  (    ch == INT_PERIOD ||  ch == INT_e ||  ch == INT_E )  {   _inputPtr = ptr ;  return  _parseFloat  ( ch , startPtr , ptr , false , intLen ) ; }   -- ptr ;   _inputPtr = ptr ;  if  (  _parsingContext . inRoot  ( ) )  {   _verifyRootSpace  ( ch ) ; }   int  len =  ptr - startPtr ;   _textBuffer . resetWithShared  ( _inputBuffer , startPtr , len ) ;  return  resetInt  ( false , intLen ) ; }   private final JsonToken _parseFloat  (   int ch ,   int startPtr ,   int ptr ,  boolean neg ,   int intLen )  throws IOException  {   final  int  inputLen = _inputEnd ;   int  fractLen = 0 ;  if  (  ch == '.' )  {  fract_loop :  while  ( true )  {  if  (  ptr >= inputLen )  {  return  _parseNumber2  ( neg , startPtr ) ; }   ch =  (  int )  _inputBuffer [  ptr ++ ] ;  if  (   ch < INT_0 ||  ch > INT_9 )  {  break fract_loop ; }   ++ fractLen ; }  if  (  fractLen == 0 )  {   reportUnexpectedNumberChar  ( ch , "Decimal point not followed by a digit" ) ; } }   int  expLen = 0 ;  if  (   ch == 'e' ||  ch == 'E' )  {  if  (  ptr >= inputLen )  {   _inputPtr = startPtr ;  return  _parseNumber2  ( neg , startPtr ) ; }   ch =  (  int )  _inputBuffer [  ptr ++ ] ;  if  (   ch == INT_MINUS ||  ch == INT_PLUS )  {  if  (  ptr >= inputLen )  {   _inputPtr = startPtr ;  return  _parseNumber2  ( neg , startPtr ) ; }   ch =  (  int )  _inputBuffer [  ptr ++ ] ; }  while  (   ch <= INT_9 &&  ch >= INT_0 )  {   ++ expLen ;  if  (  ptr >= inputLen )  {   _inputPtr = startPtr ;  return  _parseNumber2  ( neg , startPtr ) ; }   ch =  (  int )  _inputBuffer [  ptr ++ ] ; }  if  (  expLen == 0 )  {   reportUnexpectedNumberChar  ( ch , "Exponent indicator not followed by a digit" ) ; } }   -- ptr ;   _inputPtr = ptr ;  if  (  _parsingContext . inRoot  ( ) )  {   _verifyRootSpace  ( ch ) ; }   int  len =  ptr - startPtr ;   _textBuffer . resetWithShared  ( _inputBuffer , startPtr , len ) ;  return  resetFloat  ( neg , intLen , fractLen , expLen ) ; }   protected final JsonToken _parseNegNumber  ( )  throws IOException  {   int  ptr = _inputPtr ;   int  startPtr =  ptr - 1 ;   final  int  inputLen = _inputEnd ;  if  (  ptr >= inputLen )  {  return  _parseNumber2  ( true , startPtr ) ; }   int  ch =  _inputBuffer [  ptr ++ ] ;  if  (   ch > INT_9 ||  ch < INT_0 )  {   _inputPtr = ptr ;  return  _handleInvalidNumberStart  ( ch , true ) ; }  if  (  ch == INT_0 )  {  return  _parseNumber2  ( true , startPtr ) ; }   int  intLen = 1 ;  int_loop :  while  ( true )  {  if  (  ptr >= inputLen )  {  return  _parseNumber2  ( true , startPtr ) ; }   ch =  (  int )  _inputBuffer [  ptr ++ ] ;  if  (   ch < INT_0 ||  ch > INT_9 )  {  break int_loop ; }   ++ intLen ; }  if  (    ch == INT_PERIOD ||  ch == INT_e ||  ch == INT_E )  {   _inputPtr = ptr ;  return  _parseFloat  ( ch , startPtr , ptr , true , intLen ) ; }   -- ptr ;   _inputPtr = ptr ;  if  (  _parsingContext . inRoot  ( ) )  {   _verifyRootSpace  ( ch ) ; }   int  len =  ptr - startPtr ;   _textBuffer . resetWithShared  ( _inputBuffer , startPtr , len ) ;  return  resetInt  ( true , intLen ) ; }   private final JsonToken _parseNumber2  (  boolean neg ,   int startPtr )  throws IOException  {   _inputPtr =  neg ?  (  startPtr + 1 ) : startPtr ;    char  [ ]  outBuf =  _textBuffer . emptyAndGetCurrentSegment  ( ) ;   int  outPtr = 0 ;  if  ( neg )  {    outBuf [  outPtr ++ ] = '-' ; }   int  intLen = 0 ;   char  c =   (  _inputPtr < _inputEnd ) ?  _inputBuffer [  _inputPtr ++ ] :  getNextChar  ( "No digit following minus sign" ) ;  if  (  c == '0' )  {   c =  _verifyNoLeadingZeroes  ( ) ; }  boolean  eof = false ;  int_loop :  while  (   c >= '0' &&  c <= '9' )  {   ++ intLen ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] = c ;  if  (   _inputPtr >= _inputEnd &&  !  loadMore  ( ) )  {   c = CHAR_NULL ;   eof = true ;  break int_loop ; }   c =  _inputBuffer [  _inputPtr ++ ] ; }  if  (  intLen == 0 )  {  return  _handleInvalidNumberStart  ( c , neg ) ; }   int  fractLen = 0 ;  if  (  c == '.' )  {    outBuf [  outPtr ++ ] = c ;  fract_loop :  while  ( true )  {  if  (   _inputPtr >= _inputEnd &&  !  loadMore  ( ) )  {   eof = true ;  break fract_loop ; }   c =  _inputBuffer [  _inputPtr ++ ] ;  if  (   c < INT_0 ||  c > INT_9 )  {  break fract_loop ; }   ++ fractLen ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] = c ; }  if  (  fractLen == 0 )  {   reportUnexpectedNumberChar  ( c , "Decimal point not followed by a digit" ) ; } }   int  expLen = 0 ;  if  (   c == 'e' ||  c == 'E' )  {  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] = c ;   c =   (  _inputPtr < _inputEnd ) ?  _inputBuffer [  _inputPtr ++ ] :  getNextChar  ( "expected a digit for number exponent" ) ;  if  (   c == '-' ||  c == '+' )  {  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] = c ;   c =   (  _inputPtr < _inputEnd ) ?  _inputBuffer [  _inputPtr ++ ] :  getNextChar  ( "expected a digit for number exponent" ) ; }  exp_loop :  while  (   c <= INT_9 &&  c >= INT_0 )  {   ++ expLen ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] = c ;  if  (   _inputPtr >= _inputEnd &&  !  loadMore  ( ) )  {   eof = true ;  break exp_loop ; }   c =  _inputBuffer [  _inputPtr ++ ] ; }  if  (  expLen == 0 )  {   reportUnexpectedNumberChar  ( c , "Exponent indicator not followed by a digit" ) ; } }  if  (  ! eof )  {   -- _inputPtr ;  if  (  _parsingContext . inRoot  ( ) )  {   _verifyRootSpace  ( c ) ; } }   _textBuffer . setCurrentLength  ( outPtr ) ;  return  reset  ( neg , intLen , fractLen , expLen ) ; }   private final  char _verifyNoLeadingZeroes  ( )  throws IOException  {  if  (  _inputPtr < _inputEnd )  {   char  ch =  _inputBuffer [ _inputPtr ] ;  if  (   ch < '0' ||  ch > '9' )  {  return '0' ; } }  return  _verifyNLZ2  ( ) ; }   private  char _verifyNLZ2  ( )  throws IOException  {  if  (   _inputPtr >= _inputEnd &&  !  loadMore  ( ) )  {  return '0' ; }   char  ch =  _inputBuffer [ _inputPtr ] ;  if  (   ch < '0' ||  ch > '9' )  {  return '0' ; }  if  (  !  isEnabled  (  Feature . ALLOW_NUMERIC_LEADING_ZEROS ) )  {   reportInvalidNumber  ( "Leading zeroes not allowed" ) ; }   ++ _inputPtr ;  if  (  ch == INT_0 )  {  while  (   _inputPtr < _inputEnd ||  loadMore  ( ) )  {   ch =  _inputBuffer [ _inputPtr ] ;  if  (   ch < '0' ||  ch > '9' )  {  return '0' ; }   ++ _inputPtr ;  if  (  ch != '0' )  {  break ; } } }  return ch ; }   protected JsonToken _handleInvalidNumberStart  (   int ch ,  boolean negative )  throws IOException  {  if  (  ch == 'I' )  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {   _reportInvalidEOFInValue  ( ) ; } }   ch =  _inputBuffer [  _inputPtr ++ ] ;  if  (  ch == 'N' )  {  String  match =  negative ? "-INF" : "+INF" ;   _matchToken  ( match , 3 ) ;  if  (  isEnabled  (  Feature . ALLOW_NON_NUMERIC_NUMBERS ) )  {  return  resetAsNaN  ( match ,  negative ?  Double . NEGATIVE_INFINITY :  Double . POSITIVE_INFINITY ) ; }   _reportError  (   "Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow" ) ; } else  if  (  ch == 'n' )  {  String  match =  negative ? "-Infinity" : "+Infinity" ;   _matchToken  ( match , 3 ) ;  if  (  isEnabled  (  Feature . ALLOW_NON_NUMERIC_NUMBERS ) )  {  return  resetAsNaN  ( match ,  negative ?  Double . NEGATIVE_INFINITY :  Double . POSITIVE_INFINITY ) ; }   _reportError  (   "Non-standard token '" + match + "': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow" ) ; } }   reportUnexpectedNumberChar  ( ch , "expected digit (0-9) to follow minus sign, for valid numeric value" ) ;  return null ; }   private final void _verifyRootSpace  (   int ch )  throws IOException  {   ++ _inputPtr ;  switch  ( ch )  {   case ' ' :   case '\t' :  return ;   case '\r' :   _skipCR  ( ) ;  return ;   case '\n' :   ++ _currInputRow ;   _currInputRowStart = _inputPtr ;  return ; }   _reportMissingRootWS  ( ch ) ; }   protected final String _parseName  ( )  throws IOException  {   int  ptr = _inputPtr ;   int  hash = _hashSeed ;   final   int  [ ]  codes = _icLatin1 ;  while  (  ptr < _inputEnd )  {   int  ch =  _inputBuffer [ ptr ] ;  if  (   ch <  codes . length &&   codes [ ch ] != 0 )  {  if  (  ch == '"' )  {   int  start = _inputPtr ;   _inputPtr =  ptr + 1 ;  return  _symbols . findSymbol  ( _inputBuffer , start ,  ptr - start , hash ) ; }  break ; }   hash =   (  hash *  CharsToNameCanonicalizer . HASH_MULT ) + ch ;   ++ ptr ; }   int  start = _inputPtr ;   _inputPtr = ptr ;  return  _parseName2  ( start , hash , INT_QUOTE ) ; }   private String _parseName2  (   int startPtr ,   int hash ,   int endChar )  throws IOException  {   _textBuffer . resetWithShared  ( _inputBuffer , startPtr ,  (  _inputPtr - startPtr ) ) ;    char  [ ]  outBuf =  _textBuffer . getCurrentSegment  ( ) ;   int  outPtr =  _textBuffer . getCurrentSegmentSize  ( ) ;  while  ( true )  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {   _reportInvalidEOF  (   ": was expecting closing '" +  (  (  char ) endChar ) + "' for name" ) ; } }   char  c =  _inputBuffer [  _inputPtr ++ ] ;   int  i =  (  int ) c ;  if  (  i <= INT_BACKSLASH )  {  if  (  i == INT_BACKSLASH )  {   c =  _decodeEscaped  ( ) ; } else  if  (  i <= endChar )  {  if  (  i == endChar )  {  break ; }  if  (  i < INT_SPACE )  {   _throwUnquotedSpace  ( i , "name" ) ; } } }   hash =   (  hash *  CharsToNameCanonicalizer . HASH_MULT ) + c ;    outBuf [  outPtr ++ ] = c ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; } }   _textBuffer . setCurrentLength  ( outPtr ) ;  {  TextBuffer  tb = _textBuffer ;    char  [ ]  buf =  tb . getTextBuffer  ( ) ;   int  start =  tb . getTextOffset  ( ) ;   int  len =  tb . size  ( ) ;  return  _symbols . findSymbol  ( buf , start , len , hash ) ; } }   protected String _handleOddName  (   int i )  throws IOException  {  if  (   i == '\'' &&  isEnabled  (  Feature . ALLOW_SINGLE_QUOTES ) )  {  return  _parseAposName  ( ) ; }  if  (  !  isEnabled  (  Feature . ALLOW_UNQUOTED_FIELD_NAMES ) )  {   _reportUnexpectedChar  ( i , "was expecting double-quote to start field name" ) ; }   final   int  [ ]  codes =  CharTypes . getInputCodeLatin1JsNames  ( ) ;   final  int  maxCode =  codes . length ;  boolean  firstOk ;  if  (  i < maxCode )  {   firstOk =  (   codes [ i ] == 0 ) ; } else  {   firstOk =  Character . isJavaIdentifierPart  (  (  char ) i ) ; }  if  (  ! firstOk )  {   _reportUnexpectedChar  ( i , "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name" ) ; }   int  ptr = _inputPtr ;   int  hash = _hashSeed ;   final  int  inputLen = _inputEnd ;  if  (  ptr < inputLen )  {  do  {   int  ch =  _inputBuffer [ ptr ] ;  if  (  ch < maxCode )  {  if  (   codes [ ch ] != 0 )  {   int  start =  _inputPtr - 1 ;   _inputPtr = ptr ;  return  _symbols . findSymbol  ( _inputBuffer , start ,  ptr - start , hash ) ; } } else  if  (  !  Character . isJavaIdentifierPart  (  (  char ) ch ) )  {   int  start =  _inputPtr - 1 ;   _inputPtr = ptr ;  return  _symbols . findSymbol  ( _inputBuffer , start ,  ptr - start , hash ) ; }   hash =   (  hash *  CharsToNameCanonicalizer . HASH_MULT ) + ch ;   ++ ptr ; } while  (  ptr < inputLen ) ; }   int  start =  _inputPtr - 1 ;   _inputPtr = ptr ;  return  _handleOddName2  ( start , hash , codes ) ; }   protected String _parseAposName  ( )  throws IOException  {   int  ptr = _inputPtr ;   int  hash = _hashSeed ;   final  int  inputLen = _inputEnd ;  if  (  ptr < inputLen )  {   final   int  [ ]  codes = _icLatin1 ;   final  int  maxCode =  codes . length ;  do  {   int  ch =  _inputBuffer [ ptr ] ;  if  (  ch == '\'' )  {   int  start = _inputPtr ;   _inputPtr =  ptr + 1 ;  return  _symbols . findSymbol  ( _inputBuffer , start ,  ptr - start , hash ) ; }  if  (   ch < maxCode &&   codes [ ch ] != 0 )  {  break ; }   hash =   (  hash *  CharsToNameCanonicalizer . HASH_MULT ) + ch ;   ++ ptr ; } while  (  ptr < inputLen ) ; }   int  start = _inputPtr ;   _inputPtr = ptr ;  return  _parseName2  ( start , hash , '\'' ) ; }   protected JsonToken _handleOddValue  (   int i )  throws IOException  {  switch  ( i )  {   case '\'' :  if  (  isEnabled  (  Feature . ALLOW_SINGLE_QUOTES ) )  {  return  _handleApos  ( ) ; }  break ;   case 'N' :   _matchToken  ( "NaN" , 1 ) ;  if  (  isEnabled  (  Feature . ALLOW_NON_NUMERIC_NUMBERS ) )  {  return  resetAsNaN  ( "NaN" ,  Double . NaN ) ; }   _reportError  ( "Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow" ) ;  break ;   case 'I' :   _matchToken  ( "Infinity" , 1 ) ;  if  (  isEnabled  (  Feature . ALLOW_NON_NUMERIC_NUMBERS ) )  {  return  resetAsNaN  ( "Infinity" ,  Double . POSITIVE_INFINITY ) ; }   _reportError  ( "Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow" ) ;  break ;   case '+' :  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {   _reportInvalidEOFInValue  ( ) ; } }  return  _handleInvalidNumberStart  (  _inputBuffer [  _inputPtr ++ ] , false ) ; }  if  (  Character . isJavaIdentifierStart  ( i ) )  {   _reportInvalidToken  (  "" +  (  (  char ) i ) , "('true', 'false' or 'null')" ) ; }   _reportUnexpectedChar  ( i , "expected a valid value (number, String, array, object, 'true', 'false' or 'null')" ) ;  return null ; }   protected JsonToken _handleApos  ( )  throws IOException  {    char  [ ]  outBuf =  _textBuffer . emptyAndGetCurrentSegment  ( ) ;   int  outPtr =  _textBuffer . getCurrentSegmentSize  ( ) ;  while  ( true )  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {   _reportInvalidEOF  ( ": was expecting closing quote for a string value" ) ; } }   char  c =  _inputBuffer [  _inputPtr ++ ] ;   int  i =  (  int ) c ;  if  (  i <= '\\' )  {  if  (  i == '\\' )  {   c =  _decodeEscaped  ( ) ; } else  if  (  i <= '\'' )  {  if  (  i == '\'' )  {  break ; }  if  (  i < INT_SPACE )  {   _throwUnquotedSpace  ( i , "string value" ) ; } } }  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] = c ; }   _textBuffer . setCurrentLength  ( outPtr ) ;  return  JsonToken . VALUE_STRING ; }   private String _handleOddName2  (   int startPtr ,   int hash ,    int  [ ] codes )  throws IOException  {   _textBuffer . resetWithShared  ( _inputBuffer , startPtr ,  (  _inputPtr - startPtr ) ) ;    char  [ ]  outBuf =  _textBuffer . getCurrentSegment  ( ) ;   int  outPtr =  _textBuffer . getCurrentSegmentSize  ( ) ;   final  int  maxCode =  codes . length ;  while  ( true )  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {  break ; } }   char  c =  _inputBuffer [ _inputPtr ] ;   int  i =  (  int ) c ;  if  (  i <= maxCode )  {  if  (   codes [ i ] != 0 )  {  break ; } } else  if  (  !  Character . isJavaIdentifierPart  ( c ) )  {  break ; }   ++ _inputPtr ;   hash =   (  hash *  CharsToNameCanonicalizer . HASH_MULT ) + i ;    outBuf [  outPtr ++ ] = c ;  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; } }   _textBuffer . setCurrentLength  ( outPtr ) ;  {  TextBuffer  tb = _textBuffer ;    char  [ ]  buf =  tb . getTextBuffer  ( ) ;   int  start =  tb . getTextOffset  ( ) ;   int  len =  tb . size  ( ) ;  return  _symbols . findSymbol  ( buf , start , len , hash ) ; } }    @ Override protected final void _finishString  ( )  throws IOException  {   int  ptr = _inputPtr ;   final  int  inputLen = _inputEnd ;  if  (  ptr < inputLen )  {   final   int  [ ]  codes = _icLatin1 ;   final  int  maxCode =  codes . length ;  do  {   int  ch =  _inputBuffer [ ptr ] ;  if  (   ch < maxCode &&   codes [ ch ] != 0 )  {  if  (  ch == '"' )  {   _textBuffer . resetWithShared  ( _inputBuffer , _inputPtr ,  (  ptr - _inputPtr ) ) ;   _inputPtr =  ptr + 1 ;  return ; }  break ; }   ++ ptr ; } while  (  ptr < inputLen ) ; }   _textBuffer . resetWithCopy  ( _inputBuffer , _inputPtr ,  (  ptr - _inputPtr ) ) ;   _inputPtr = ptr ;   _finishString2  ( ) ; }   protected void _finishString2  ( )  throws IOException  {    char  [ ]  outBuf =  _textBuffer . getCurrentSegment  ( ) ;   int  outPtr =  _textBuffer . getCurrentSegmentSize  ( ) ;   final   int  [ ]  codes = _icLatin1 ;   final  int  maxCode =  codes . length ;  while  ( true )  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {   _reportInvalidEOF  ( ": was expecting closing quote for a string value" ) ; } }   char  c =  _inputBuffer [  _inputPtr ++ ] ;   int  i =  (  int ) c ;  if  (   i < maxCode &&   codes [ i ] != 0 )  {  if  (  i == INT_QUOTE )  {  break ; } else  if  (  i == INT_BACKSLASH )  {   c =  _decodeEscaped  ( ) ; } else  if  (  i < INT_SPACE )  {   _throwUnquotedSpace  ( i , "string value" ) ; } }  if  (  outPtr >=  outBuf . length )  {   outBuf =  _textBuffer . finishCurrentSegment  ( ) ;   outPtr = 0 ; }    outBuf [  outPtr ++ ] = c ; }   _textBuffer . setCurrentLength  ( outPtr ) ; }   protected final void _skipString  ( )  throws IOException  {   _tokenIncomplete = false ;   int  inPtr = _inputPtr ;   int  inLen = _inputEnd ;    char  [ ]  inBuf = _inputBuffer ;  while  ( true )  {  if  (  inPtr >= inLen )  {   _inputPtr = inPtr ;  if  (  !  loadMore  ( ) )  {   _reportInvalidEOF  ( ": was expecting closing quote for a string value" ) ; }   inPtr = _inputPtr ;   inLen = _inputEnd ; }   char  c =  inBuf [  inPtr ++ ] ;   int  i =  (  int ) c ;  if  (  i <= INT_BACKSLASH )  {  if  (  i == INT_BACKSLASH )  {   _inputPtr = inPtr ;   c =  _decodeEscaped  ( ) ;   inPtr = _inputPtr ;   inLen = _inputEnd ; } else  if  (  i <= INT_QUOTE )  {  if  (  i == INT_QUOTE )  {   _inputPtr = inPtr ;  break ; }  if  (  i < INT_SPACE )  {   _inputPtr = inPtr ;   _throwUnquotedSpace  ( i , "string value" ) ; } } } } }   protected final void _skipCR  ( )  throws IOException  {  if  (   _inputPtr < _inputEnd ||  loadMore  ( ) )  {  if  (   _inputBuffer [ _inputPtr ] == '\n' )  {   ++ _inputPtr ; } }   ++ _currInputRow ;   _currInputRowStart = _inputPtr ; }   private final  int _skipColon  ( )  throws IOException  {  if  (   (  _inputPtr + 4 ) >= _inputEnd )  {  return  _skipColon2  ( false ) ; }   char  c =  _inputBuffer [ _inputPtr ] ;  if  (  c == ':' )  {   int  i =  _inputBuffer [  ++ _inputPtr ] ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {  return  _skipColon2  ( true ) ; }   ++ _inputPtr ;  return i ; }  if  (   i == INT_SPACE ||  i == INT_TAB )  {   i =  (  int )  _inputBuffer [  ++ _inputPtr ] ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {  return  _skipColon2  ( true ) ; }   ++ _inputPtr ;  return i ; } }  return  _skipColon2  ( true ) ; }  if  (   c == ' ' ||  c == '\t' )  {   c =  _inputBuffer [  ++ _inputPtr ] ; }  if  (  c == ':' )  {   int  i =  _inputBuffer [  ++ _inputPtr ] ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {  return  _skipColon2  ( true ) ; }   ++ _inputPtr ;  return i ; }  if  (   i == INT_SPACE ||  i == INT_TAB )  {   i =  (  int )  _inputBuffer [  ++ _inputPtr ] ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {  return  _skipColon2  ( true ) ; }   ++ _inputPtr ;  return i ; } }  return  _skipColon2  ( true ) ; }  return  _skipColon2  ( false ) ; }   private final  int _skipColon2  (  boolean gotColon )  throws IOException  {  while  ( true )  {  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   int  i =  (  int )  _inputBuffer [  _inputPtr ++ ] ;  if  (  i > INT_SPACE )  {  if  (  i == INT_SLASH )  {   _skipComment  ( ) ;  continue ; }  if  (  i == INT_HASH )  {  if  (  _skipYAMLComment  ( ) )  {  continue ; } }  if  ( gotColon )  {  return i ; }  if  (  i != INT_COLON )  {  if  (  i < INT_SPACE )  {   _throwInvalidSpace  ( i ) ; }   _reportUnexpectedChar  ( i , "was expecting a colon to separate field name and value" ) ; }   gotColon = true ;  continue ; }  if  (  i < INT_SPACE )  {  if  (  i == INT_LF )  {   ++ _currInputRow ;   _currInputRowStart = _inputPtr ; } else  if  (  i == INT_CR )  {   _skipCR  ( ) ; } else  if  (  i != INT_TAB )  {   _throwInvalidSpace  ( i ) ; } } } }   private final  int _skipComma  (   int i )  throws IOException  {  if  (  i != INT_COMMA )  {   _reportUnexpectedChar  ( i ,   "was expecting comma to separate " +  _parsingContext . getTypeDesc  ( ) + " entries" ) ; }  while  (  _inputPtr < _inputEnd )  {   i =  (  int )  _inputBuffer [  _inputPtr ++ ] ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {   -- _inputPtr ;  return  _skipAfterComma2  ( ) ; }  return i ; }  if  (  i < INT_SPACE )  {  if  (  i == INT_LF )  {   ++ _currInputRow ;   _currInputRowStart = _inputPtr ; } else  if  (  i == INT_CR )  {   _skipCR  ( ) ; } else  if  (  i != INT_TAB )  {   _throwInvalidSpace  ( i ) ; } } }  return  _skipAfterComma2  ( ) ; }   private final  int _skipAfterComma2  ( )  throws IOException  {  while  (   _inputPtr < _inputEnd ||  loadMore  ( ) )  {   int  i =  (  int )  _inputBuffer [  _inputPtr ++ ] ;  if  (  i > INT_SPACE )  {  if  (  i == INT_SLASH )  {   _skipComment  ( ) ;  continue ; }  if  (  i == INT_HASH )  {  if  (  _skipYAMLComment  ( ) )  {  continue ; } }  return i ; }  if  (  i < INT_SPACE )  {  if  (  i == INT_LF )  {   ++ _currInputRow ;   _currInputRowStart = _inputPtr ; } else  if  (  i == INT_CR )  {   _skipCR  ( ) ; } else  if  (  i != INT_TAB )  {   _throwInvalidSpace  ( i ) ; } } }  throw  _constructError  (   "Unexpected end-of-input within/between " +  _parsingContext . getTypeDesc  ( ) + " entries" ) ; }   private final  int _skipWSOrEnd  ( )  throws IOException  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {  return  _eofAsNextChar  ( ) ; } }   int  i =  _inputBuffer [  _inputPtr ++ ] ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {   -- _inputPtr ;  return  _skipWSOrEnd2  ( ) ; }  return i ; }  if  (  i != INT_SPACE )  {  if  (  i == INT_LF )  {   ++ _currInputRow ;   _currInputRowStart = _inputPtr ; } else  if  (  i == INT_CR )  {   _skipCR  ( ) ; } else  if  (  i != INT_TAB )  {   _throwInvalidSpace  ( i ) ; } }  while  (  _inputPtr < _inputEnd )  {   i =  (  int )  _inputBuffer [  _inputPtr ++ ] ;  if  (  i > INT_SPACE )  {  if  (   i == INT_SLASH ||  i == INT_HASH )  {   -- _inputPtr ;  return  _skipWSOrEnd2  ( ) ; }  return i ; }  if  (  i != INT_SPACE )  {  if  (  i == INT_LF )  {   ++ _currInputRow ;   _currInputRowStart = _inputPtr ; } else  if  (  i == INT_CR )  {   _skipCR  ( ) ; } else  if  (  i != INT_TAB )  {   _throwInvalidSpace  ( i ) ; } } }  return  _skipWSOrEnd2  ( ) ; }   private  int _skipWSOrEnd2  ( )  throws IOException  {  while  ( true )  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {  return  _eofAsNextChar  ( ) ; } }   int  i =  (  int )  _inputBuffer [  _inputPtr ++ ] ;  if  (  i > INT_SPACE )  {  if  (  i == INT_SLASH )  {   _skipComment  ( ) ;  continue ; }  if  (  i == INT_HASH )  {  if  (  _skipYAMLComment  ( ) )  {  continue ; } }  return i ; } else  if  (  i != INT_SPACE )  {  if  (  i == INT_LF )  {   ++ _currInputRow ;   _currInputRowStart = _inputPtr ; } else  if  (  i == INT_CR )  {   _skipCR  ( ) ; } else  if  (  i != INT_TAB )  {   _throwInvalidSpace  ( i ) ; } } } }   private void _skipComment  ( )  throws IOException  {  if  (  !  isEnabled  (  Feature . ALLOW_COMMENTS ) )  {   _reportUnexpectedChar  ( '/' , "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)" ) ; }  if  (   _inputPtr >= _inputEnd &&  !  loadMore  ( ) )  {   _reportInvalidEOF  ( " in a comment" ) ; }   char  c =  _inputBuffer [  _inputPtr ++ ] ;  if  (  c == '/' )  {   _skipLine  ( ) ; } else  if  (  c == '*' )  {   _skipCComment  ( ) ; } else  {   _reportUnexpectedChar  ( c , "was expecting either '*' or '/' for a comment" ) ; } }   private void _skipCComment  ( )  throws IOException  {  while  (   (  _inputPtr < _inputEnd ) ||  loadMore  ( ) )  {   int  i =  (  int )  _inputBuffer [  _inputPtr ++ ] ;  if  (  i <= '*' )  {  if  (  i == '*' )  {  if  (   (  _inputPtr >= _inputEnd ) &&  !  loadMore  ( ) )  {  break ; }  if  (   _inputBuffer [ _inputPtr ] == INT_SLASH )  {   ++ _inputPtr ;  return ; }  continue ; }  if  (  i < INT_SPACE )  {  if  (  i == INT_LF )  {   ++ _currInputRow ;   _currInputRowStart = _inputPtr ; } else  if  (  i == INT_CR )  {   _skipCR  ( ) ; } else  if  (  i != INT_TAB )  {   _throwInvalidSpace  ( i ) ; } } } }   _reportInvalidEOF  ( " in a comment" ) ; }   private boolean _skipYAMLComment  ( )  throws IOException  {  if  (  !  isEnabled  (  Feature . ALLOW_YAML_COMMENTS ) )  {  return false ; }   _skipLine  ( ) ;  return true ; }   private void _skipLine  ( )  throws IOException  {  while  (   (  _inputPtr < _inputEnd ) ||  loadMore  ( ) )  {   int  i =  (  int )  _inputBuffer [  _inputPtr ++ ] ;  if  (  i < INT_SPACE )  {  if  (  i == INT_LF )  {   ++ _currInputRow ;   _currInputRowStart = _inputPtr ;  break ; } else  if  (  i == INT_CR )  {   _skipCR  ( ) ;  break ; } else  if  (  i != INT_TAB )  {   _throwInvalidSpace  ( i ) ; } } } }    @ Override protected  char _decodeEscaped  ( )  throws IOException  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {   _reportInvalidEOF  ( " in character escape sequence" ) ; } }   char  c =  _inputBuffer [  _inputPtr ++ ] ;  switch  (  (  int ) c )  {   case 'b' :  return '\b' ;   case 't' :  return '\t' ;   case 'n' :  return '\n' ;   case 'f' :  return '\f' ;   case 'r' :  return '\r' ;   case '"' :   case '/' :   case '\\' :  return c ;   case 'u' :  break ;   default :  return  _handleUnrecognizedCharacterEscape  ( c ) ; }   int  value = 0 ;  for (   int  i = 0 ;  i < 4 ;  ++ i )  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {   _reportInvalidEOF  ( " in character escape sequence" ) ; } }   int  ch =  (  int )  _inputBuffer [  _inputPtr ++ ] ;   int  digit =  CharTypes . charToHex  ( ch ) ;  if  (  digit < 0 )  {   _reportUnexpectedChar  ( ch , "expected a hex-digit for character escape sequence" ) ; }   value =   (  value << 4 ) | digit ; }  return  (  char ) value ; }   private final void _matchTrue  ( )  throws IOException  {   int  ptr = _inputPtr ;  if  (   (  ptr + 3 ) < _inputEnd )  {   final   char  [ ]  b = _inputBuffer ;  if  (     b [ ptr ] == 'r' &&   b [  ++ ptr ] == 'u' &&   b [  ++ ptr ] == 'e' )  {   char  c =  b [  ++ ptr ] ;  if  (    c < '0' ||  c == ']' ||  c == '}' )  {   _inputPtr = ptr ;  return ; } } }   _matchToken  ( "true" , 1 ) ; }   private final void _matchFalse  ( )  throws IOException  {   int  ptr = _inputPtr ;  if  (   (  ptr + 4 ) < _inputEnd )  {   final   char  [ ]  b = _inputBuffer ;  if  (      b [ ptr ] == 'a' &&   b [  ++ ptr ] == 'l' &&   b [  ++ ptr ] == 's' &&   b [  ++ ptr ] == 'e' )  {   char  c =  b [  ++ ptr ] ;  if  (    c < '0' ||  c == ']' ||  c == '}' )  {   _inputPtr = ptr ;  return ; } } }   _matchToken  ( "false" , 1 ) ; }   private final void _matchNull  ( )  throws IOException  {   int  ptr = _inputPtr ;  if  (   (  ptr + 3 ) < _inputEnd )  {   final   char  [ ]  b = _inputBuffer ;  if  (     b [ ptr ] == 'u' &&   b [  ++ ptr ] == 'l' &&   b [  ++ ptr ] == 'l' )  {   char  c =  b [  ++ ptr ] ;  if  (    c < '0' ||  c == ']' ||  c == '}' )  {   _inputPtr = ptr ;  return ; } } }   _matchToken  ( "null" , 1 ) ; }   protected final void _matchToken  (  String matchStr ,   int i )  throws IOException  {   final  int  len =  matchStr . length  ( ) ;  do  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {   _reportInvalidToken  (  matchStr . substring  ( 0 , i ) ) ; } }  if  (   _inputBuffer [ _inputPtr ] !=  matchStr . charAt  ( i ) )  {   _reportInvalidToken  (  matchStr . substring  ( 0 , i ) ) ; }   ++ _inputPtr ; } while  (   ++ i < len ) ;  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {  return ; } }   char  c =  _inputBuffer [ _inputPtr ] ;  if  (    c < '0' ||  c == ']' ||  c == '}' )  {  return ; }  if  (  Character . isJavaIdentifierPart  ( c ) )  {   _reportInvalidToken  (  matchStr . substring  ( 0 , i ) ) ; }  return ; }    @ SuppressWarnings  ( "resource" ) protected   byte  [ ] _decodeBase64  (  Base64Variant b64variant )  throws IOException  {  ByteArrayBuilder  builder =  _getByteArrayBuilder  ( ) ;  while  ( true )  {   char  ch ;  do  {  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   ch =  _inputBuffer [  _inputPtr ++ ] ; } while  (  ch <= INT_SPACE ) ;   int  bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  ch == '"' )  {  return  builder . toByteArray  ( ) ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 0 ) ;  if  (  bits < 0 )  {  continue ; } }   int  decodedData = bits ;  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   ch =  _inputBuffer [  _inputPtr ++ ] ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {   bits =  _decodeBase64Escape  ( b64variant , ch , 1 ) ; }   decodedData =   (  decodedData << 6 ) | bits ;  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   ch =  _inputBuffer [  _inputPtr ++ ] ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  bits !=  Base64Variant . BASE64_VALUE_PADDING )  {  if  (   ch == '"' &&  !  b64variant . usesPadding  ( ) )  {   decodedData >>= 4 ;   builder . append  ( decodedData ) ;  return  builder . toByteArray  ( ) ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 2 ) ; }  if  (  bits ==  Base64Variant . BASE64_VALUE_PADDING )  {  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   ch =  _inputBuffer [  _inputPtr ++ ] ;  if  (  !  b64variant . usesPaddingChar  ( ch ) )  {  throw  reportInvalidBase64Char  ( b64variant , ch , 3 ,   "expected padding character '" +  b64variant . getPaddingChar  ( ) + "'" ) ; }   decodedData >>= 4 ;   builder . append  ( decodedData ) ;  continue ; } }   decodedData =   (  decodedData << 6 ) | bits ;  if  (  _inputPtr >= _inputEnd )  {   loadMoreGuaranteed  ( ) ; }   ch =  _inputBuffer [  _inputPtr ++ ] ;   bits =  b64variant . decodeBase64Char  ( ch ) ;  if  (  bits < 0 )  {  if  (  bits !=  Base64Variant . BASE64_VALUE_PADDING )  {  if  (   ch == '"' &&  !  b64variant . usesPadding  ( ) )  {   decodedData >>= 2 ;   builder . appendTwoBytes  ( decodedData ) ;  return  builder . toByteArray  ( ) ; }   bits =  _decodeBase64Escape  ( b64variant , ch , 3 ) ; }  if  (  bits ==  Base64Variant . BASE64_VALUE_PADDING )  {   decodedData >>= 2 ;   builder . appendTwoBytes  ( decodedData ) ;  continue ; } }   decodedData =   (  decodedData << 6 ) | bits ;   builder . appendThreeBytes  ( decodedData ) ; } }   protected void _reportInvalidToken  (  String matchedPart )  throws IOException  {   _reportInvalidToken  ( matchedPart , "'null', 'true', 'false' or NaN" ) ; }   protected void _reportInvalidToken  (  String matchedPart ,  String msg )  throws IOException  {  StringBuilder  sb =  new StringBuilder  ( matchedPart ) ;  while  ( true )  {  if  (  _inputPtr >= _inputEnd )  {  if  (  !  loadMore  ( ) )  {  break ; } }   char  c =  _inputBuffer [ _inputPtr ] ;  if  (  !  Character . isJavaIdentifierPart  ( c ) )  {  break ; }   ++ _inputPtr ;   sb . append  ( c ) ; }   _reportError  (    "Unrecognized token '" +  sb . toString  ( ) + "': was expecting " + msg ) ; } }