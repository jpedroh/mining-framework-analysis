  package     com . fasterxml . jackson . core . json ;   import  java . io .  * ;  import    com . fasterxml . jackson . core .  * ;  import      com . fasterxml . jackson . core . format . InputAccessor ;  import      com . fasterxml . jackson . core . format . MatchStrength ;  import     com . fasterxml . jackson . core . io .  * ;  import      com . fasterxml . jackson . core . sym . ByteQuadsCanonicalizer ;  import      com . fasterxml . jackson . core . sym . CharsToNameCanonicalizer ;   public final class ByteSourceJsonBootstrapper  {   final static  byte  UTF8_BOM_1 =  (  byte ) 0xEF ;   final static  byte  UTF8_BOM_2 =  (  byte ) 0xBB ;   final static  byte  UTF8_BOM_3 =  (  byte ) 0xBF ;   protected final IOContext  _context ;   protected final InputStream  _in ;   protected final   byte  [ ]  _inputBuffer ;   private  int  _inputPtr ;   private  int  _inputEnd ;   private final boolean  _bufferRecyclable ;   protected  int  _inputProcessed ;   protected boolean  _bigEndian = true ;   protected  int  _bytesPerChar ;   public ByteSourceJsonBootstrapper  (  IOContext ctxt ,  InputStream in )  {   _context = ctxt ;   _in = in ;   _inputBuffer =  ctxt . allocReadIOBuffer  ( ) ;   _inputEnd =  _inputPtr = 0 ;   _inputProcessed = 0 ;   _bufferRecyclable = true ; }   public ByteSourceJsonBootstrapper  (  IOContext ctxt ,    byte  [ ] inputBuffer ,   int inputStart ,   int inputLen )  {   _context = ctxt ;   _in = null ;   _inputBuffer = inputBuffer ;   _inputPtr = inputStart ;   _inputEnd =  (  inputStart + inputLen ) ;   _inputProcessed =  - inputStart ;   _bufferRecyclable = false ; }   public JsonEncoding detectEncoding  ( )  throws IOException  {  boolean  foundEncoding = false ;  if  (  ensureLoaded  ( 4 ) )  {   int  quad =     (   _inputBuffer [ _inputPtr ] << 24 ) |  (   (   _inputBuffer [  _inputPtr + 1 ] & 0xFF ) << 16 ) |  (   (   _inputBuffer [  _inputPtr + 2 ] & 0xFF ) << 8 ) |  (   _inputBuffer [  _inputPtr + 3 ] & 0xFF ) ;  if  (  handleBOM  ( quad ) )  {   foundEncoding = true ; } else  {  if  (  checkUTF32  ( quad ) )  {   foundEncoding = true ; } else  if  (  checkUTF16  (  quad >>> 16 ) )  {   foundEncoding = true ; } } } else  if  (  ensureLoaded  ( 2 ) )  {   int  i16 =   (   (   _inputBuffer [ _inputPtr ] & 0xFF ) << 8 ) |  (   _inputBuffer [  _inputPtr + 1 ] & 0xFF ) ;  if  (  checkUTF16  ( i16 ) )  {   foundEncoding = true ; } }  JsonEncoding  enc ;  if  (  ! foundEncoding )  {   enc =  JsonEncoding . UTF8 ; } else  {  switch  ( _bytesPerChar )  {   case 1 :   enc =  JsonEncoding . UTF8 ;  break ;   case 2 :   enc =  _bigEndian ?  JsonEncoding . UTF16_BE :  JsonEncoding . UTF16_LE ;  break ;   case 4 :   enc =  _bigEndian ?  JsonEncoding . UTF32_BE :  JsonEncoding . UTF32_LE ;  break ;   default :  throw  new RuntimeException  ( "Internal error" ) ; } }   _context . setEncoding  ( enc ) ;  return enc ; }   public static  int skipUTF8BOM  (  DataInput input )  throws IOException  {   int  b =  input . readUnsignedByte  ( ) ;  if  (  b != 0xEF )  {  return b ; }   b =  input . readUnsignedByte  ( ) ;  if  (  b != 0xBB )  {  throw  new IOException  (   "Unexpected byte 0x" +  Integer . toHexString  ( b ) + " following 0xEF; should get 0xBB as part of UTF-8 BOM" ) ; }   b =  input . readUnsignedByte  ( ) ;  if  (  b != 0xBF )  {  throw  new IOException  (   "Unexpected byte 0x" +  Integer . toHexString  ( b ) + " following 0xEF 0xBB; should get 0xBF as part of UTF-8 BOM" ) ; }  return  input . readUnsignedByte  ( ) ; }    @ SuppressWarnings  ( "resource" ) public Reader constructReader  ( )  throws IOException  {  JsonEncoding  enc =  _context . getEncoding  ( ) ;  switch  (  enc . bits  ( ) )  {   case 8 :   case 16 :  {  InputStream  in = _in ;  if  (  in == null )  {   in =  new ByteArrayInputStream  ( _inputBuffer , _inputPtr , _inputEnd ) ; } else  {  if  (  _inputPtr < _inputEnd )  {   in =  new MergedStream  ( _context , in , _inputBuffer , _inputPtr , _inputEnd ) ; } }  return  new InputStreamReader  ( in ,  enc . getJavaName  ( ) ) ; }   case 32 :  return  new UTF32Reader  ( _context , _in , _inputBuffer , _inputPtr , _inputEnd ,   _context . getEncoding  ( ) . isBigEndian  ( ) ) ; }  throw  new RuntimeException  ( "Internal error" ) ; }   public JsonParser constructParser  (   int parserFeatures ,  ObjectCodec codec ,  ByteQuadsCanonicalizer rootByteSymbols ,  CharsToNameCanonicalizer rootCharSymbols ,   int factoryFeatures )  throws IOException  {  JsonEncoding  enc =  detectEncoding  ( ) ;  if  (  enc ==  JsonEncoding . UTF8 )  {  if  (    JsonFactory . Feature . CANONICALIZE_FIELD_NAMES . enabledIn  ( factoryFeatures ) )  {  ByteQuadsCanonicalizer  can =  rootByteSymbols . makeChild  ( factoryFeatures ) ;  return  new UTF8StreamJsonParser  ( _context , parserFeatures , _in , codec , can , _inputBuffer , _inputPtr , _inputEnd , _bufferRecyclable ) ; } }  return  new ReaderBasedJsonParser  ( _context , parserFeatures ,  constructReader  ( ) , codec ,  rootCharSymbols . makeChild  ( factoryFeatures ) ) ; }   public static MatchStrength hasJSONFormat  (  InputAccessor acc )  throws IOException  {  if  (  !  acc . hasMoreBytes  ( ) )  {  return  MatchStrength . INCONCLUSIVE ; }   byte  b =  acc . nextByte  ( ) ;  if  (  b == UTF8_BOM_1 )  {  if  (  !  acc . hasMoreBytes  ( ) )  {  return  MatchStrength . INCONCLUSIVE ; }  if  (   acc . nextByte  ( ) != UTF8_BOM_2 )  {  return  MatchStrength . NO_MATCH ; }  if  (  !  acc . hasMoreBytes  ( ) )  {  return  MatchStrength . INCONCLUSIVE ; }  if  (   acc . nextByte  ( ) != UTF8_BOM_3 )  {  return  MatchStrength . NO_MATCH ; }  if  (  !  acc . hasMoreBytes  ( ) )  {  return  MatchStrength . INCONCLUSIVE ; }   b =  acc . nextByte  ( ) ; }   int  ch =  skipSpace  ( acc , b ) ;  if  (  ch < 0 )  {  return  MatchStrength . INCONCLUSIVE ; }  if  (  ch == '{' )  {   ch =  skipSpace  ( acc ) ;  if  (  ch < 0 )  {  return  MatchStrength . INCONCLUSIVE ; }  if  (   ch == '"' ||  ch == '}' )  {  return  MatchStrength . SOLID_MATCH ; }  return  MatchStrength . NO_MATCH ; }  MatchStrength  strength ;  if  (  ch == '[' )  {   ch =  skipSpace  ( acc ) ;  if  (  ch < 0 )  {  return  MatchStrength . INCONCLUSIVE ; }  if  (   ch == ']' ||  ch == '[' )  {  return  MatchStrength . SOLID_MATCH ; }  return  MatchStrength . SOLID_MATCH ; } else  {   strength =  MatchStrength . WEAK_MATCH ; }  if  (  ch == '"' )  {  return strength ; }  if  (   ch <= '9' &&  ch >= '0' )  {  return strength ; }  if  (  ch == '-' )  {   ch =  skipSpace  ( acc ) ;  if  (  ch < 0 )  {  return  MatchStrength . INCONCLUSIVE ; }  return   (   ch <= '9' &&  ch >= '0' ) ? strength :  MatchStrength . NO_MATCH ; }  if  (  ch == 'n' )  {  return  tryMatch  ( acc , "ull" , strength ) ; }  if  (  ch == 't' )  {  return  tryMatch  ( acc , "rue" , strength ) ; }  if  (  ch == 'f' )  {  return  tryMatch  ( acc , "alse" , strength ) ; }  return  MatchStrength . NO_MATCH ; }   private static MatchStrength tryMatch  (  InputAccessor acc ,  String matchStr ,  MatchStrength fullMatchStrength )  throws IOException  {  for (   int  i = 0 ,  len =  matchStr . length  ( ) ;  i < len ;  ++ i )  {  if  (  !  acc . hasMoreBytes  ( ) )  {  return  MatchStrength . INCONCLUSIVE ; }  if  (   acc . nextByte  ( ) !=  matchStr . charAt  ( i ) )  {  return  MatchStrength . NO_MATCH ; } }  return fullMatchStrength ; }   private static  int skipSpace  (  InputAccessor acc )  throws IOException  {  if  (  !  acc . hasMoreBytes  ( ) )  {  return  - 1 ; }  return  skipSpace  ( acc ,  acc . nextByte  ( ) ) ; }   private static  int skipSpace  (  InputAccessor acc ,   byte b )  throws IOException  {  while  ( true )  {   int  ch =   (  int ) b & 0xFF ;  if  (  !  (     ch == ' ' ||  ch == '\r' ||  ch == '\n' ||  ch == '\t' ) )  {  return ch ; }  if  (  !  acc . hasMoreBytes  ( ) )  {  return  - 1 ; }   b =  acc . nextByte  ( ) ; } }   private boolean handleBOM  (   int quad )  throws IOException  {  switch  ( quad )  {   case 0x0000FEFF :   _bigEndian = true ;   _inputPtr += 4 ;   _bytesPerChar = 4 ;  return true ;   case 0xFFFE0000 :   _inputPtr += 4 ;   _bytesPerChar = 4 ;   _bigEndian = false ;  return true ;   case 0x0000FFFE :   reportWeirdUCS4  ( "2143" ) ;   case 0xFEFF0000 :   reportWeirdUCS4  ( "3412" ) ; }   int  msw =  quad >>> 16 ;  if  (  msw == 0xFEFF )  {   _inputPtr += 2 ;   _bytesPerChar = 2 ;   _bigEndian = true ;  return true ; }  if  (  msw == 0xFFFE )  {   _inputPtr += 2 ;   _bytesPerChar = 2 ;   _bigEndian = false ;  return true ; }  if  (   (  quad >>> 8 ) == 0xEFBBBF )  {   _inputPtr += 3 ;   _bytesPerChar = 1 ;   _bigEndian = true ;  return true ; }  return false ; }   private boolean checkUTF32  (   int quad )  throws IOException  {  if  (   (  quad >> 8 ) == 0 )  {   _bigEndian = true ; } else  if  (   (  quad & 0x00FFFFFF ) == 0 )  {   _bigEndian = false ; } else  if  (   (  quad &  ~ 0x00FF0000 ) == 0 )  {   reportWeirdUCS4  ( "3412" ) ; } else  if  (   (  quad &  ~ 0x0000FF00 ) == 0 )  {   reportWeirdUCS4  ( "2143" ) ; } else  {  return false ; }   _bytesPerChar = 4 ;  return true ; }   private boolean checkUTF16  (   int i16 )  {  if  (   (  i16 & 0xFF00 ) == 0 )  {   _bigEndian = true ; } else  if  (   (  i16 & 0x00FF ) == 0 )  {   _bigEndian = false ; } else  {  return false ; }   _bytesPerChar = 2 ;  return true ; }   private void reportWeirdUCS4  (  String type )  throws IOException  {  throw  new CharConversionException  (   "Unsupported UCS-4 endianness (" + type + ") detected" ) ; }   protected boolean ensureLoaded  (   int minimum )  throws IOException  {   int  gotten =  (  _inputEnd - _inputPtr ) ;  while  (  gotten < minimum )  {   int  count ;  if  (  _in == null )  {   count =  - 1 ; } else  {   count =  _in . read  ( _inputBuffer , _inputEnd ,   _inputBuffer . length - _inputEnd ) ; }  if  (  count < 1 )  {  return false ; }   _inputEnd += count ;   gotten += count ; }  return true ; } }