  package   com . splunk . logging ;   import   com . google . gson .  * ;  import     com . splunk . logging . hec . MetadataTags ;  import     com . splunk . logging . serialization . EventInfoTypeAdapter ;  import     com . splunk . logging . serialization . HecJsonSerializer ;  import okhttp3 .  * ;  import   javax . net . ssl .  * ;  import   java . io . IOException ;  import   java . io . Serializable ;  import    java . security . cert . CertificateException ;  import  java . util .  * ;  import    java . util . concurrent . TimeUnit ;  import    java . util . stream . Collectors ;   public class HttpEventCollectorSender  extends TimerTask  implements   HttpEventCollectorMiddleware . IHttpSender  {   private static final String  ChannelQueryParam = "channel" ;   private static final String  AuthorizationHeaderTag = "Authorization" ;   private static final String  AuthorizationHeaderScheme = "Splunk %s" ;   private static final String  HttpEventCollectorUriPath = "/services/collector/event/1.0" ;   private static final String  HttpRawCollectorUriPath = "/services/collector/raw" ;   private static final String  JsonHttpContentType = "application/json; profile=urn:splunk:event:1.0; charset=utf-8" ;   private static final String  PlainTextHttpContentType = "plain/text; charset=utf-8" ;   private static final String  SendModeSequential = "sequential" ;   private static final String  SendModeSParallel = "parallel" ;   private TimeoutSettings  timeoutSettings =  new TimeoutSettings  ( ) ;   private static final Gson  gson =    new GsonBuilder  ( ) . registerTypeAdapter  (  HttpEventCollectorEventInfo . class ,  new EventInfoTypeAdapter  ( ) ) . create  ( ) ;   private final HecJsonSerializer  serializer ;   public enum SendMode  {  Sequential ,  Parallel } ;   public static final  int  DefaultBatchInterval =  10 * 1000 ;   public static final  int  DefaultBatchSize =  10 * 1024 ;   public static final  int  DefaultBatchCount = 10 ;   private HttpUrl  url ;   private String  token ;   private String  channel ;   private String  type ;   private  long  maxEventsBatchCount ;   private  long  maxEventsBatchSize ;   private Timer  timer ;   private  List  < HttpEventCollectorEventInfo >  eventsBatch =  new  LinkedList  < HttpEventCollectorEventInfo >  ( ) ;   private  long  eventsBatchSize = 0 ;   private static OkHttpClient  httpClient = null ;   private boolean  disableCertificateValidation = false ;   private SendMode  sendMode =  SendMode . Sequential ;   private HttpEventCollectorMiddleware  middleware =  new HttpEventCollectorMiddleware  ( ) ;   public HttpEventCollectorSender  (   final String Url ,   final String token ,   final String channel ,   final String type ,   long delay ,   long maxEventsBatchCount ,   long maxEventsBatchSize ,  String sendModeStr ,   Map  < String , String > metadata ,  TimeoutSettings timeoutSettings )  {    this . token = token ;    this . channel = channel ;    this . type = type ;  if  (  timeoutSettings != null )  {    this . timeoutSettings = timeoutSettings ; }  if  (  "Raw" . equalsIgnoreCase  ( type ) )  {  if  (   channel == null ||   channel . trim  ( ) . equals  ( "" ) )  {  throw  new IllegalArgumentException  ( "Channel cannot be null or empty" ) ; }   HttpUrl . Builder  urlBuilder =    HttpUrl . parse  (  Url + HttpRawCollectorUriPath ) . newBuilder  ( ) . addQueryParameter  ( ChannelQueryParam , channel ) ;   metadata . forEach  (  urlBuilder :: addQueryParameter ) ;    this . url =  urlBuilder . build  ( ) ; } else  {    this . url =  HttpUrl . parse  (  Url + HttpEventCollectorUriPath ) ; }  if  (   maxEventsBatchCount == 0 &&  maxEventsBatchSize > 0 )  {   maxEventsBatchCount =  Long . MAX_VALUE ; } else  if  (   maxEventsBatchSize == 0 &&  maxEventsBatchCount > 0 )  {   maxEventsBatchSize =  Long . MAX_VALUE ; }    this . maxEventsBatchCount = maxEventsBatchCount ;    this . maxEventsBatchSize = maxEventsBatchSize ;   serializer =  new HecJsonSerializer  ( metadata ) ;   final String  format =  metadata . get  (  MetadataTags . MESSAGEFORMAT ) ;  if  (  sendModeStr != null )  {  if  (  sendModeStr . equals  ( SendModeSequential ) )    this . sendMode =  SendMode . Sequential ; else  if  (  sendModeStr . equals  ( SendModeSParallel ) )    this . sendMode =  SendMode . Parallel ; else  throw  new IllegalArgumentException  (  "Unknown send mode: " + sendModeStr ) ; }  if  (  delay > 0 )  {   timer =  new Timer  ( ) ;   timer . scheduleAtFixedRate  ( this , delay , delay ) ; } }   public void addMiddleware  (   HttpEventCollectorMiddleware . HttpSenderMiddleware middleware )  {    this . middleware . add  ( middleware ) ; }   public synchronized void send  (   final String severity ,   final String message ,   final String logger_name ,   final String thread_name ,   Map  < String , String > properties ,   final String exception_message ,  Serializable marker )  {  HttpEventCollectorEventInfo  eventInfo =  new HttpEventCollectorEventInfo  ( severity , message , logger_name , thread_name , properties , exception_message , marker ) ;   eventsBatch . add  ( eventInfo ) ;   eventsBatchSize +=   severity . length  ( ) +  message . length  ( ) ;  if  (    eventsBatch . size  ( ) >= maxEventsBatchCount ||  eventsBatchSize > maxEventsBatchSize )  {   flush  ( ) ; } }   public synchronized void send  (   final String message )  {   send  ( "" , message , "" , "" , null , null , "" ) ; }   public synchronized void flush  ( )  {  if  (   eventsBatch . size  ( ) > 0 )  {   postEventsAsync  ( eventsBatch ) ; }   eventsBatch =  new  LinkedList  < >  ( ) ;   eventsBatchSize = 0 ; }   public synchronized void flush  (  boolean close )  {   flush  ( ) ;  if  ( close )  {   stopHttpClient  ( ) ; } }  void close  ( )  {  if  (  timer != null )   timer . cancel  ( ) ;   flush  ( ) ;   stopHttpClient  ( ) ;   super . cancel  ( ) ; }    @ Override public void run  ( )  {   flush  ( ) ; }   public void disableCertificateValidation  ( )  {   disableCertificateValidation = true ; }   public void setEventBodySerializer  (  EventBodySerializer eventBodySerializer )  {   serializer . setEventBodySerializer  ( eventBodySerializer ) ; }   public static void putIfPresent  (  JsonObject collection ,  String tag ,  Object value )  {  if  (  value != null )  {  if  (   value instanceof String &&    (  ( String ) value ) . length  ( ) == 0 )  {  return ; }   collection . add  ( tag ,  gson . toJsonTree  ( value ) ) ; } }   private void stopHttpClient  ( )  {  if  (  httpClient != null )  {     httpClient . dispatcher  ( ) . executorService  ( ) . shutdown  ( ) ;   httpClient = null ; } }   private void startHttpClient  ( )  {  if  (  httpClient != null )  {  return ; }   OkHttpClient . Builder  builder =  new  OkHttpClient . Builder  ( ) ;  if  (  sendMode ==  SendMode . Sequential )  {  Dispatcher  dispatcher =  new Dispatcher  ( ) ;   dispatcher . setMaxRequests  ( 1 ) ;   builder . dispatcher  ( dispatcher ) ; }  if  ( disableCertificateValidation )  {   final  TrustManager  [ ]  trustAllCerts =  new TrustManager  [ ]  {  new X509TrustManager  ( )  {    @ Override public void checkClientTrusted  (      java . security . cert . X509Certificate  [ ] chain ,  String authType )  throws CertificateException  { }    @ Override public void checkServerTrusted  (      java . security . cert . X509Certificate  [ ] chain ,  String authType )  throws CertificateException  { }    @ Override public     java . security . cert . X509Certificate  [ ] getAcceptedIssuers  ( )  {  return  new    java . security . cert . X509Certificate  [ ]  { } ; } } } ;  try  {   final SSLContext  sslContext =  SSLContext . getInstance  ( "TLSv1.2" ) ;   sslContext . init  ( null , trustAllCerts ,  new   java . security . SecureRandom  ( ) ) ;   final SSLSocketFactory  sslSocketFactory =  sslContext . getSocketFactory  ( ) ;   builder . sslSocketFactory  ( sslSocketFactory ,  ( X509TrustManager )  trustAllCerts [ 0 ] ) ; }  catch (   Exception ignored )  { }   builder . hostnameVerifier  (  new HostnameVerifier  ( )  {    @ Override public boolean verify  (  String hostname ,  SSLSession session )  {  return true ; } } ) ; }   httpClient =  builder . build  ( ) ; }   private void postEventsAsync  (   final  List  < HttpEventCollectorEventInfo > events )  {    this . middleware . postEvents  ( events , this ,  new  HttpEventCollectorMiddleware . IHttpSenderCallback  ( )  {    @ Override public void completed  (   int statusCode ,  String reply )  {  if  (  statusCode != 200 )  {   HttpEventCollectorErrorHandler . error  ( events ,  new  HttpEventCollectorErrorHandler . ServerErrorException  ( reply ) ) ; } }    @ Override public void failed  (  Exception ex )  {   HttpEventCollectorErrorHandler . error  ( events ,  new  HttpEventCollectorErrorHandler . ServerErrorException  (  ex . getMessage  ( ) ) ) ; } } ) ; }   public void postEvents  (   final  List  < HttpEventCollectorEventInfo > events ,   final  HttpEventCollectorMiddleware . IHttpSenderCallback callback )  {   startHttpClient  ( ) ;   Request . Builder  requestBldr =    new  Request . Builder  ( ) . url  ( url ) . addHeader  ( AuthorizationHeaderTag ,  String . format  ( AuthorizationHeaderScheme , token ) ) ;  if  (  "Raw" . equalsIgnoreCase  ( type ) )  {  String  lineSeparatedEvents =    events . stream  ( ) . map  (  HttpEventCollectorEventInfo :: getMessage ) . collect  (  Collectors . joining  (  System . lineSeparator  ( ) ) ) ;   requestBldr . post  (  RequestBody . create  (  MediaType . parse  ( PlainTextHttpContentType ) , lineSeparatedEvents ) ) ; } else  {  StringBuilder  eventsBatchString =  new StringBuilder  ( ) ;  for ( HttpEventCollectorEventInfo eventInfo : events )  {   eventsBatchString . append  (  serializer . serialize  ( eventInfo ) ) ; }   requestBldr . post  (  RequestBody . create  (  MediaType . parse  ( JsonHttpContentType ) ,  eventsBatchString . toString  ( ) ) ) ; }    httpClient . newCall  (  requestBldr . build  ( ) ) . enqueue  (  new Callback  ( )  {    @ Override public void onResponse  (  Call call ,   final Response response )  {  String  reply = "" ;   int  httpStatusCode =  response . code  ( ) ;  try  (  ResponseBody body =  response . body  ( ) )  {  if  (   httpStatusCode != 200 &&  body != null )  {  try  {   reply =  body . string  ( ) ; }  catch (   IOException e )  {   reply =  e . getMessage  ( ) ; } } }   callback . completed  ( httpStatusCode , reply ) ; }    @ Override public void onFailure  (  Call call ,  IOException ex )  {   callback . failed  ( ex ) ; } } ) ; }   public static class TimeoutSettings  {   public static final  long  DEFAULT_CONNECT_TIMEOUT = 30000 ;   public static final  long  DEFAULT_WRITE_TIMEOUT = 0 ;   public static final  long  DEFAULT_CALL_TIMEOUT = 0 ;   public static final  long  DEFAULT_READ_TIMEOUT = 0 ;   public  long  connectTimeout = DEFAULT_CONNECT_TIMEOUT ;   public  long  callTimeout = DEFAULT_CALL_TIMEOUT ;   public  long  readTimeout = DEFAULT_READ_TIMEOUT ;   public  long  writeTimeout = DEFAULT_WRITE_TIMEOUT ;   public TimeoutSettings  ( )  { }   public TimeoutSettings  (   long connectTimeout ,   long callTimeout ,   long readTimeout ,   long writeTimeout )  {    this . connectTimeout = connectTimeout ;    this . callTimeout = callTimeout ;    this . readTimeout = readTimeout ;    this . writeTimeout = writeTimeout ; } } 
<<<<<<<
=======
  public HttpEventCollectorSender  (   final String Url ,   final String token ,   final String channel ,   final String type ,   long delay ,   long maxEventsBatchCount ,   long maxEventsBatchSize ,  String sendModeStr ,   Map  < String , String > metadata )  {    this . url =  Url + HttpEventCollectorUriPath ;    this . token = token ;    this . channel = channel ;    this . type = type ;  if  (  "Raw" . equalsIgnoreCase  ( type ) )  {    this . url =  Url + HttpRawCollectorUriPath ; }  if  (   maxEventsBatchCount == 0 &&  maxEventsBatchSize > 0 )  {   maxEventsBatchCount =  Long . MAX_VALUE ; } else  if  (   maxEventsBatchSize == 0 &&  maxEventsBatchCount > 0 )  {   maxEventsBatchSize =  Long . MAX_VALUE ; }    this . maxEventsBatchCount = maxEventsBatchCount ;    this . maxEventsBatchSize = maxEventsBatchSize ;   serializer =  new HecJsonSerializer  ( metadata ) ;   final String  format =  metadata . get  (  MetadataTags . MESSAGEFORMAT ) ;    this . messageFormat =  MessageFormat . fromFormat  ( format ) ;  if  (  sendModeStr != null )  {  if  (  sendModeStr . equals  ( SendModeSequential ) )    this . sendMode =  SendMode . Sequential ; else  if  (  sendModeStr . equals  ( SendModeSParallel ) )    this . sendMode =  SendMode . Parallel ; else  throw  new IllegalArgumentException  (  "Unknown send mode: " + sendModeStr ) ; }  if  (  delay > 0 )  {   timer =  new Timer  ( true ) ;   timer . scheduleAtFixedRate  ( this , delay , delay ) ; } }
>>>>>>>
 }