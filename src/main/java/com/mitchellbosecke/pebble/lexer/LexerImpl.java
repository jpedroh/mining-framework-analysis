  package    com . mitchellbosecke . pebble . lexer ;   import   java . io . IOException ;  import   java . io . Reader ;  import   java . util . ArrayList ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . HashMap ;  import   java . util . LinkedList ;  import   java . util . List ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import     com . mitchellbosecke . pebble . error . ParserException ;  import      com . mitchellbosecke . pebble . lexer . Token . Type ;  import     com . mitchellbosecke . pebble . operator . BinaryOperator ;  import     com . mitchellbosecke . pebble . operator . UnaryOperator ;  import     com . mitchellbosecke . pebble . utils . Pair ;  import     com . mitchellbosecke . pebble . utils . StringLengthComparator ;  import     com . mitchellbosecke . pebble . utils . StringUtils ;   public final class LexerImpl  implements  Lexer  {   private final Syntax  syntax ;   private final  Collection  < UnaryOperator >  unaryOperators ;   private final  Collection  < BinaryOperator >  binaryOperators ;   private TemplateSource  source ;   private  ArrayList  < Token >  tokens ;   private  LinkedList  <  Pair  < String , Integer > >  brackets ;   private State  state ;   private  LinkedList  < State >  states ;   private enum State  {  DATA ,  EXECUTE ,  PRINT ,  COMMENT ,  STRING ,  STRING_INTERPOLATION }   private boolean  trimLeadingWhitespaceFromNextData = false ;   private static final Pattern  REGEX_NAME =  Pattern . compile  ( "^[a-zA-Z_][a-zA-Z0-9_]*" ) ;   private static final Pattern  REGEX_NUMBER =  Pattern . compile  ( "^[0-9]+(\\.[0-9]+)?" ) ;   private static final Pattern  REGEX_DOUBLEQUOTE =  Pattern . compile  ( "^\"" ) ;   private static final Pattern  REGEX_STRING_NON_INTERPOLATED_PART =  Pattern . compile  ( "^[^#\"\\\\]*(?:(?:\\\\.|#(?!\\{))[^#\"\\\\]*)*" ,  Pattern . DOTALL ) ;   private static final Pattern  REGEX_STRING_PLAIN =  Pattern . compile  ( "^\"([^#\"\\\\]*(?:\\\\.[^#\"\\\\]*)*)\"|'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'" ,  Pattern . DOTALL ) ;   private static final String  PUNCTUATION = "()[]{}?:.,|=" ;   private Pattern  regexOperators ;   public LexerImpl  (  Syntax syntax ,   Collection  < UnaryOperator > unaryOperators ,   Collection  < BinaryOperator > binaryOperators )  {    this . syntax = syntax ;    this . unaryOperators = unaryOperators ;    this . binaryOperators = binaryOperators ; }    @ Override public TokenStream tokenize  (  Reader reader ,  String name )  {   buildOperatorRegex  ( ) ;  try  {    this . source =  new TemplateSource  ( reader , name ) ; }  catch (   IOException e )  {  throw  new ParserException  ( e , "Can not convert template Reader into a String" , 0 , name ) ; }    this . state =  State . DATA ;    this . tokens =  new  ArrayList  < >  ( ) ;    this . states =  new  LinkedList  < >  ( ) ;    this . brackets =  new  LinkedList  < >  ( ) ;  while  (    this . source . length  ( ) > 0 )  {  switch  (  this . state )  {   case DATA :   lexData  ( ) ;  break ;   case EXECUTE :   lexExecute  ( ) ;  break ;   case PRINT :   lexPrint  ( ) ;  break ;   case COMMENT :   lexComment  ( ) ;  break ;   case STRING :   lexString  ( ) ;  break ;   case STRING_INTERPOLATION :   lexStringInterpolation  ( ) ;  break ;   default :  break ; } }   pushToken  (   Token . Type . EOF ) ;  if  (  !   this . brackets . isEmpty  ( ) )  {  String  expected =   brackets . pop  ( ) . getLeft  ( ) ;  throw  new ParserException  ( null ,  String . format  ( "Unclosed \"%s\"" , expected ) ,  source . getLineNumber  ( ) ,  source . getFilename  ( ) ) ; }  return  new TokenStream  ( tokens ,  source . getFilename  ( ) ) ; }   private void lexStringInterpolation  ( )  throws ParserException  {  String  lastBracket =   brackets . peek  ( ) . getLeft  ( ) ;  Matcher  matcher =   syntax . getRegexInterpolationClose  ( ) . matcher  ( source ) ;  if  (    syntax . getInterpolationOpenDelimiter  ( ) . equals  ( lastBracket ) &&  matcher . lookingAt  ( ) )  {   brackets . pop  ( ) ;   pushToken  (   Token . Type . STRING_INTERPOLATION_END ) ;   source . advance  (  matcher . end  ( ) ) ;   popState  ( ) ; } else  {   lexExpression  ( ) ; } }   private void lexString  ( )  throws ParserException  {  Matcher  matcher =    this . syntax . getRegexInterpolationOpen  ( ) . matcher  ( source ) ;  if  (  matcher . lookingAt  ( ) )  {   brackets . push  (  new  Pair  < >  (  syntax . getInterpolationOpenDelimiter  ( ) ,  source . getLineNumber  ( ) ) ) ;   pushToken  (   Token . Type . STRING_INTERPOLATION_START ) ;   source . advance  (  matcher . end  ( ) ) ;   pushState  (  State . STRING_INTERPOLATION ) ;  return ; }   matcher =  REGEX_STRING_NON_INTERPOLATED_PART . matcher  ( source ) ;  if  (   matcher . lookingAt  ( ) &&   matcher . end  ( ) > 0 )  {  String  token =  source . substring  (  matcher . end  ( ) ) ;   source . advance  (  matcher . end  ( ) ) ;   pushToken  (   Token . Type . STRING , token ) ;  return ; }   matcher =  REGEX_DOUBLEQUOTE . matcher  ( source ) ;  if  (  matcher . lookingAt  ( ) )  {  String  expected =   brackets . pop  ( ) . getLeft  ( ) ;  if  (   source . charAt  ( 0 ) != '"' )  {  throw  new ParserException  ( null ,  String . format  ( "Unclosed \"%s\"" , expected ) ,  source . getLineNumber  ( ) ,  source . getFilename  ( ) ) ; }   popState  ( ) ;   source . advance  (  matcher . end  ( ) ) ; } }   private void lexData  ( )  {  Matcher  matcher =    this . syntax . getRegexStartDelimiters  ( ) . matcher  ( source ) ;  boolean  match =  matcher . find  ( ) ;  String  text ;  String  startDelimiterToken = null ;  if  (  ! match )  {   text =  source . toString  ( ) ;   source . advance  (  source . length  ( ) ) ; } else  {   text =  source . substring  (  matcher . start  ( ) ) ;   startDelimiterToken =  source . substring  (  matcher . start  ( ) ,  matcher . end  ( ) ) ;   source . advance  (  matcher . end  ( ) ) ; }  if  ( trimLeadingWhitespaceFromNextData )  {   text =  StringUtils . ltrim  ( text ) ;   trimLeadingWhitespaceFromNextData = false ; }  Token  textToken =  pushToken  (  Type . TEXT , text ) ;  if  ( match )  {   checkForLeadingWhitespaceTrim  ( textToken ) ;  if  (    this . syntax . getCommentOpenDelimiter  ( ) . equals  ( startDelimiterToken ) )  {   pushState  (  State . COMMENT ) ; } else  if  (    this . syntax . getPrintOpenDelimiter  ( ) . equals  ( startDelimiterToken ) )  {   pushToken  (   Token . Type . PRINT_START ) ;   pushState  (  State . PRINT ) ; } else  if  (  (    this . syntax . getExecuteOpenDelimiter  ( ) . equals  ( startDelimiterToken ) ) )  {  Matcher  verbatimStartMatcher =    this . syntax . getRegexVerbatimStart  ( ) . matcher  ( source ) ;  if  (  verbatimStartMatcher . lookingAt  ( ) )  {   lexVerbatimData  ( verbatimStartMatcher ) ;   pushState  (  State . DATA ) ; } else  {   pushToken  (   Token . Type . EXECUTE_START ) ;   pushState  (  State . EXECUTE ) ; } } } }   private void lexExecute  ( )  {   checkForTrailingWhitespaceTrim  ( ) ;  Matcher  matcher =    this . syntax . getRegexExecuteClose  ( ) . matcher  ( source ) ;  if  (   brackets . isEmpty  ( ) &&  matcher . lookingAt  ( ) )  {   pushToken  (   Token . Type . EXECUTE_END ,   this . syntax . getExecuteCloseDelimiter  ( ) ) ;   source . advance  (  matcher . end  ( ) ) ;   popState  ( ) ; } else  {   lexExpression  ( ) ; } }   private void lexPrint  ( )  {   checkForTrailingWhitespaceTrim  ( ) ;  Matcher  matcher =    this . syntax . getRegexPrintClose  ( ) . matcher  ( source ) ;  if  (   brackets . isEmpty  ( ) &&  matcher . lookingAt  ( ) )  {   pushToken  (   Token . Type . PRINT_END ,   this . syntax . getPrintCloseDelimiter  ( ) ) ;   source . advance  (  matcher . end  ( ) ) ;   popState  ( ) ; } else  {   lexExpression  ( ) ; } }   private void lexComment  ( )  {  Matcher  matcher =    this . syntax . getRegexCommentClose  ( ) . matcher  ( source ) ;  boolean  match =  matcher . find  ( 0 ) ;  if  (  ! match )  {  throw  new ParserException  ( null , "Unclosed comment." ,  source . getLineNumber  ( ) ,  source . getFilename  ( ) ) ; }  String  comment =  source . substring  (  matcher . start  ( ) ) ;  String  reversedComment =    new StringBuilder  ( comment ) . reverse  ( ) . toString  ( ) ;  Matcher  whitespaceTrimMatcher =    this . syntax . getRegexLeadingWhitespaceTrim  ( ) . matcher  ( reversedComment ) ;  if  (  whitespaceTrimMatcher . lookingAt  ( ) )  {    this . trimLeadingWhitespaceFromNextData = true ; }   source . advance  (  matcher . end  ( ) ) ;   popState  ( ) ; }   private void lexExpression  ( )  {  String  token ;   source . advanceThroughWhitespace  ( ) ;  Matcher  matcher =  regexOperators . matcher  ( source ) ;  if  (  matcher . lookingAt  ( ) )  {   token =  source . substring  (  matcher . end  ( ) ) ;   pushToken  (   Token . Type . OPERATOR , token ) ;   source . advance  (  matcher . end  ( ) ) ;  return ; }   matcher =  REGEX_NAME . matcher  ( source ) ;  if  (  matcher . lookingAt  ( ) )  {   token =  source . substring  (  matcher . end  ( ) ) ;   pushToken  (   Token . Type . NAME , token ) ;   source . advance  (  matcher . end  ( ) ) ;  return ; }   matcher =  REGEX_NUMBER . matcher  ( source ) ;  if  (  matcher . lookingAt  ( ) )  {   token =  source . substring  (  matcher . end  ( ) ) ;   pushToken  (   Token . Type . NUMBER , token ) ;   source . advance  (  matcher . end  ( ) ) ;  return ; }  if  (   PUNCTUATION . indexOf  (  source . charAt  ( 0 ) ) >= 0 )  {  String  character =  String . valueOf  (  source . charAt  ( 0 ) ) ;  if  (   "([{" . indexOf  ( character ) >= 0 )  {   brackets . push  (  new  Pair  < >  ( character ,  source . getLineNumber  ( ) ) ) ; } else  if  (   ")]}" . indexOf  ( character ) >= 0 )  {  if  (  brackets . isEmpty  ( ) )  throw  new ParserException  ( null ,   "Unexpected \"" + character + "\"" ,  source . getLineNumber  ( ) ,  source . getFilename  ( ) ) ; else  {   HashMap  < String , String >  validPairs =  new  HashMap  < >  ( ) ;   validPairs . put  ( "(" , ")" ) ;   validPairs . put  ( "[" , "]" ) ;   validPairs . put  ( "{" , "}" ) ;  String  lastBracket =   brackets . pop  ( ) . getLeft  ( ) ;  String  expected =  validPairs . get  ( lastBracket ) ;  if  (  !  expected . equals  ( character ) )  {  throw  new ParserException  ( null ,   "Unclosed \"" + expected + "\"" ,  source . getLineNumber  ( ) ,  source . getFilename  ( ) ) ; } } }   pushToken  (   Token . Type . PUNCTUATION , character ) ;   source . advance  ( 1 ) ;  return ; }   matcher =  REGEX_STRING_PLAIN . matcher  ( source ) ;  if  (  matcher . lookingAt  ( ) )  {   token =  source . substring  (  matcher . end  ( ) ) ;   source . advance  (  matcher . end  ( ) ) ;   token =  unquoteAndUnescape  ( token ) ;   pushToken  (   Token . Type . STRING , token ) ;  return ; }   matcher =  REGEX_DOUBLEQUOTE . matcher  ( source ) ;  if  (  matcher . lookingAt  ( ) )  {   brackets . push  (  new  Pair  < >  ( "\"" ,  source . getLineNumber  ( ) ) ) ;   pushState  (  State . STRING ) ;   source . advance  (  matcher . end  ( ) ) ;  return ; }  throw  new ParserException  ( null ,  String . format  ( "Unexpected character [%s]" ,  source . charAt  ( 0 ) ) ,  source . getLineNumber  ( ) ,  source . getFilename  ( ) ) ; }   private String unquoteAndUnescape  (  String str )  {   char  quotationType =  str . charAt  ( 0 ) ;   str =  str . substring  ( 1 ,   str . length  ( ) - 1 ) ;  if  (  quotationType == '\'' )  {   str =  str . replaceAll  ( "\\\\(')" , "$1" ) ; } else  if  (  quotationType == '"' )  {   str =  str . replaceAll  ( "\\\\(\")" , "$1" ) ; }  return str ; }   private void checkForLeadingWhitespaceTrim  (  Token leadingToken )  {  Matcher  whitespaceTrimMatcher =    this . syntax . getRegexLeadingWhitespaceTrim  ( ) . matcher  ( source ) ;  if  (  whitespaceTrimMatcher . lookingAt  ( ) )  {  if  (  leadingToken != null )  {   leadingToken . setValue  (  StringUtils . rtrim  (  leadingToken . getValue  ( ) ) ) ; }   source . advance  (  whitespaceTrimMatcher . end  ( ) ) ; } }   private void checkForTrailingWhitespaceTrim  ( )  {  Matcher  whitespaceTrimMatcher =    this . syntax . getRegexTrailingWhitespaceTrim  ( ) . matcher  ( source ) ;  if  (  whitespaceTrimMatcher . lookingAt  ( ) )  {    this . trimLeadingWhitespaceFromNextData = true ; } }   private void lexVerbatimData  (  Matcher verbatimStartMatcher )  {   source . advance  (  verbatimStartMatcher . end  ( ) ) ;  Matcher  verbatimEndMatcher =    this . syntax . getRegexVerbatimEnd  ( ) . matcher  ( source ) ;  if  (  !  verbatimEndMatcher . find  ( ) )  {  throw  new ParserException  ( null , "Unclosed verbatim tag." ,  source . getLineNumber  ( ) ,  source . getFilename  ( ) ) ; }  String  verbatimText =  source . substring  (  verbatimEndMatcher . start  ( ) ) ;  if  (   verbatimStartMatcher . group  ( 0 ) != null )  {   verbatimText =  StringUtils . ltrim  ( verbatimText ) ; }  if  (   verbatimEndMatcher . group  ( 1 ) != null )  {   verbatimText =  StringUtils . rtrim  ( verbatimText ) ; }  if  (   verbatimEndMatcher . group  ( 2 ) != null )  {   trimLeadingWhitespaceFromNextData = true ; }   source . advance  (  verbatimEndMatcher . end  ( ) ) ;   pushToken  (  Type . TEXT , verbatimText ) ; }   private Token pushToken  (   Token . Type type )  {  return  pushToken  ( type , null ) ; }   private Token pushToken  (   Token . Type type ,  String value )  {  if  (   type . equals  (   Token . Type . TEXT ) &&  (   value == null ||  "" . equals  ( value ) ) )  {  return null ; }  Token  result =  new Token  ( type , value ,  source . getLineNumber  ( ) ) ;    this . tokens . add  ( result ) ;  return result ; }   private void pushState  (  State state )  {    this . states . push  (  this . state ) ;    this . state = state ; }   private void popState  ( )  {    this . state =   this . states . pop  ( ) ; }   private void buildOperatorRegex  ( )  {   List  < String >  operators =  new  ArrayList  < >  ( ) ;  for ( UnaryOperator operator : unaryOperators )  {   operators . add  (  operator . getSymbol  ( ) ) ; }  for ( BinaryOperator operator : binaryOperators )  {   operators . add  (  operator . getSymbol  ( ) ) ; }   Collections . sort  ( operators ,  new StringLengthComparator  ( ) ) ;  StringBuilder  regex =  new StringBuilder  ( "^" ) ;  boolean  isFirst = true ;  for ( String operator : operators )  {  if  ( isFirst )  {   isFirst = false ; } else  {   regex . append  ( "|" ) ; }   regex . append  (  Pattern . quote  ( operator ) ) ;   char  nextChar =  operator . charAt  (   operator . length  ( ) - 1 ) ;  if  (   Character . isLetter  ( nextChar ) ||   Character . getType  ( nextChar ) ==  Character . LETTER_NUMBER )  {   regex . append  ( "(?![a-zA-Z])" ) ; } }    this . regexOperators =  Pattern . compile  (  regex . toString  ( ) ) ; } }