  package   com . mitchellbosecke . pebble ;   import     com . mitchellbosecke . pebble . cache . BaseTagCacheKey ;  import     com . mitchellbosecke . pebble . error . LoaderException ;  import     com . mitchellbosecke . pebble . error . PebbleException ;  import     com . mitchellbosecke . pebble . extension . Extension ;  import     com . mitchellbosecke . pebble . extension . ExtensionRegistry ;  import     com . mitchellbosecke . pebble . extension . NodeVisitorFactory ;  import      com . mitchellbosecke . pebble . extension . core . CoreExtension ;  import      com . mitchellbosecke . pebble . extension . escaper . EscaperExtension ;  import      com . mitchellbosecke . pebble . extension . escaper . EscapingStrategy ;  import      com . mitchellbosecke . pebble . extension . i18n . I18nExtension ;  import     com . mitchellbosecke . pebble . lexer . LexerImpl ;  import     com . mitchellbosecke . pebble . lexer . Syntax ;  import     com . mitchellbosecke . pebble . lexer . TokenStream ;  import     com . mitchellbosecke . pebble . loader . ClasspathLoader ;  import     com . mitchellbosecke . pebble . loader . DelegatingLoader ;  import     com . mitchellbosecke . pebble . loader . FileLoader ;  import     com . mitchellbosecke . pebble . loader . Loader ;  import     com . mitchellbosecke . pebble . node . RootNode ;  import     com . mitchellbosecke . pebble . parser . Parser ;  import     com . mitchellbosecke . pebble . parser . ParserImpl ;  import     com . mitchellbosecke . pebble . template . PebbleTemplate ;  import     com . mitchellbosecke . pebble . template . PebbleTemplateImpl ;  import   java . io . Reader ;  import   java . util . ArrayList ;  import   java . util . Collection ;  import   java . util . List ;  import   java . util . Locale ;  import    java . util . concurrent . ExecutorService ;  import      com . github . benmanes . caffeine . cache . Cache ;  import      com . github . benmanes . caffeine . cache . Caffeine ;  import     com . mitchellbosecke . pebble . error . ParserException ;  import     com . mitchellbosecke . pebble . error . RuntimePebbleException ;  import    java . util . concurrent . CompletionException ;  import static    java . util . Objects . isNull ;   public class PebbleEngine  {   private final  Loader  <  ? >  loader ;   private final Syntax  syntax ;   private final boolean  strictVariables ;   private final Locale  defaultLocale ;   private final  Cache  < BaseTagCacheKey , Object >  tagCache ;   private final ExecutorService  executorService ;   private final  Cache  < Object , PebbleTemplate >  templateCache ;   private final ExtensionRegistry  extensionRegistry ;   private PebbleEngine  (   Loader  <  ? > loader ,  Syntax syntax ,  boolean strictVariables ,  Locale defaultLocale ,   Cache  < BaseTagCacheKey , Object > tagCache ,   Cache  < Object , PebbleTemplate > templateCache ,  ExecutorService executorService ,   Collection  <  ? extends Extension > extensions )  {    this . loader = loader ;    this . syntax = syntax ;    this . strictVariables = strictVariables ;    this . defaultLocale = defaultLocale ;    this . tagCache = tagCache ;    this . executorService = executorService ;    this . templateCache = templateCache ;    this . extensionRegistry =  new ExtensionRegistry  ( extensions ) ; }   public PebbleTemplate getTemplate  (   final String templateName )  throws PebbleException  {  if  (  templateName == null )  {  return null ; }  if  (   this . loader == null )  {  throw  new LoaderException  ( null , "Loader has not yet been specified." ) ; }   final PebbleEngine  self = this ;  PebbleTemplate  result ;  try  {   final Object  cacheKey =   this . loader . createCacheKey  ( templateName ) ;  if  (  isNull  ( templateCache ) )  {   result =  getPebbleTemplate  ( self , templateName , cacheKey ) ; } else  {   result =  templateCache . get  ( cacheKey ,  k ->  {  try  {  return  getPebbleTemplate  ( self , templateName , cacheKey ) ; }  catch (   PebbleException e )  {  throw  new RuntimePebbleException  ( e ) ; } } ) ; } }  catch (   CompletionException e )  {  if  (    e . getCause  ( ) != null &&   e . getCause  ( ) instanceof RuntimePebbleException )  {  RuntimePebbleException  runtimePebbleException =  ( RuntimePebbleException )  e . getCause  ( ) ;  throw  ( PebbleException )  runtimePebbleException . getCause  ( ) ; } else  {  throw  new PebbleException  ( e ,  String . format  ( "An error occurred while compiling %s" , templateName ) ) ; } }  return result ; }   private  <  T > Reader retrieveReaderFromLoader  (   Loader  < T > loader ,  Object cacheKey )  throws LoaderException  {    @ SuppressWarnings  ( "unchecked" ) T  casted =  ( T ) cacheKey ;  return  loader . getReader  ( casted ) ; }   public  Loader  <  ? > getLoader  ( )  {  return loader ; }   public  Cache  < Object , PebbleTemplate > getTemplateCache  ( )  {  return templateCache ; }   public boolean isStrictVariables  ( )  {  return strictVariables ; }   public Locale getDefaultLocale  ( )  {  return defaultLocale ; }   public ExecutorService getExecutorService  ( )  {  return executorService ; }   public Syntax getSyntax  ( )  {  return  this . syntax ; }   public ExtensionRegistry getExtensionRegistry  ( )  {  return extensionRegistry ; }   public  Cache  < BaseTagCacheKey , Object > getTagCache  ( )  {  return  this . tagCache ; }   public static class Builder  {   private  Loader  <  ? >  loader ;   private  List  < Extension >  userProvidedExtensions =  new  ArrayList  < >  ( ) ;   private Syntax  syntax =   new  Syntax . Builder  ( ) . build  ( ) ;   private boolean  strictVariables = false ;   private boolean  enableNewLineTrimming = true ;   private Locale  defaultLocale ;   private ExecutorService  executorService ;   private  Cache  < Object , PebbleTemplate >  templateCache ;   private boolean  cacheActive = true ;   private  Cache  < BaseTagCacheKey , Object >  tagCache ;   private EscaperExtension  escaperExtension =  new EscaperExtension  ( ) ;   public Builder  ( )  { }   public Builder loader  (   Loader  <  ? > loader )  {    this . loader = loader ;  return this ; }   public Builder extension  (  Extension ...  extensions )  {  for ( Extension extension : extensions )  {    this . userProvidedExtensions . add  ( extension ) ; }  return this ; }   public Builder syntax  (  Syntax syntax )  {    this . syntax = syntax ;  return this ; }   public Builder strictVariables  (  boolean strictVariables )  {    this . strictVariables = strictVariables ;  return this ; }   public Builder newLineTrimming  (  boolean enableNewLineTrimming )  {    this . enableNewLineTrimming = enableNewLineTrimming ;  return this ; }   public Builder defaultLocale  (  Locale defaultLocale )  {    this . defaultLocale = defaultLocale ;  return this ; }   public Builder executorService  (  ExecutorService executorService )  {    this . executorService = executorService ;  return this ; }   public Builder templateCache  (   Cache  < Object , PebbleTemplate > templateCache )  {    this . templateCache = templateCache ;  return this ; }   public Builder tagCache  (   Cache  < BaseTagCacheKey , Object > tagCache )  {    this . tagCache = tagCache ;  return this ; }   public Builder autoEscaping  (  boolean autoEscaping )  {   escaperExtension . setAutoEscaping  ( autoEscaping ) ;  return this ; }   public Builder defaultEscapingStrategy  (  String strategy )  {   escaperExtension . setDefaultStrategy  ( strategy ) ;  return this ; }   public Builder addEscapingStrategy  (  String name ,  EscapingStrategy strategy )  {   escaperExtension . addEscapingStrategy  ( name , strategy ) ;  return this ; }   public Builder cacheActive  (  boolean cacheActive )  {    this . cacheActive = cacheActive ;  return this ; }   public PebbleEngine build  ( )  {   List  < Extension >  extensions =  new  ArrayList  < >  ( ) ;   extensions . add  (  new CoreExtension  ( ) ) ;   extensions . add  ( escaperExtension ) ;   extensions . add  (  new I18nExtension  ( ) ) ;   extensions . addAll  (  this . userProvidedExtensions ) ;  if  (  loader == null )  {   List  <  Loader  <  ? > >  defaultLoadingStrategies =  new  ArrayList  < >  ( ) ;   defaultLoadingStrategies . add  (  new ClasspathLoader  ( ) ) ;   defaultLoadingStrategies . add  (  new FileLoader  ( ) ) ;   loader =  new DelegatingLoader  ( defaultLoadingStrategies ) ; }  if  (  defaultLocale == null )  {   defaultLocale =  Locale . getDefault  ( ) ; }  if  ( cacheActive )  {  if  (  templateCache == null )  {   templateCache =    Caffeine . newBuilder  ( ) . maximumSize  ( 200 ) . build  ( ) ; }  if  (  tagCache == null )  {   tagCache =    Caffeine . newBuilder  ( ) . maximumSize  ( 200 ) . build  ( ) ; } } else  {   templateCache = null ;   tagCache = null ; }  if  (  syntax == null )  {   syntax =    new  Syntax . Builder  ( ) . setEnableNewLineTrimming  ( enableNewLineTrimming ) . build  ( ) ; }  return  new PebbleEngine  ( loader , syntax , strictVariables , defaultLocale , tagCache , templateCache , executorService , extensions ) ; } }   private PebbleTemplate getPebbleTemplate  (   final PebbleEngine self ,   final String templateName ,   final Object cacheKey )  throws LoaderException , ParserException  {  LexerImpl  lexer =  new LexerImpl  ( syntax ,   extensionRegistry . getUnaryOperators  ( ) . values  ( ) ,   extensionRegistry . getBinaryOperators  ( ) . values  ( ) ) ;  Reader  templateReader =  self . retrieveReaderFromLoader  (  self . loader , cacheKey ) ;  TokenStream  tokenStream =  lexer . tokenize  ( templateReader , templateName ) ;  Parser  parser =  new ParserImpl  (  extensionRegistry . getUnaryOperators  ( ) ,  extensionRegistry . getBinaryOperators  ( ) ,  extensionRegistry . getTokenParsers  ( ) ) ;  RootNode  root =  parser . parse  ( tokenStream ) ;  PebbleTemplateImpl  instance =  new PebbleTemplateImpl  ( self , root , templateName ) ;  for ( NodeVisitorFactory visitorFactory :  extensionRegistry . getNodeVisitors  ( ) )  {    visitorFactory . createVisitor  ( instance ) . visit  ( root ) ; }  return instance ; } }