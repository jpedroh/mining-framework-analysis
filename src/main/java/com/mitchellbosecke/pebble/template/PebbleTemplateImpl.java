  package    com . mitchellbosecke . pebble . template ;   import    com . mitchellbosecke . pebble . PebbleEngine ;  import     com . mitchellbosecke . pebble . error . PebbleException ;  import      com . mitchellbosecke . pebble . extension . escaper . SafeString ;  import     com . mitchellbosecke . pebble . node . ArgumentsNode ;  import     com . mitchellbosecke . pebble . node . RootNode ;  import     com . mitchellbosecke . pebble . utils . FutureWriter ;  import   java . io . IOException ;  import   java . io . Writer ;  import   java . util . ArrayList ;  import   java . util . HashMap ;  import   java . util . Locale ;  import   java . util . Map ;  import    java . util . Map . Entry ;   public class PebbleTemplateImpl  implements  PebbleTemplate  {   private final PebbleEngine  engine ;   private final  Map  < String , Block >  blocks =  new  HashMap  < >  ( ) ;   private final  Map  < String , Macro >  macros =  new  HashMap  < >  ( ) ;   private final RootNode  rootNode ;   private final String  name ;   public PebbleTemplateImpl  (  PebbleEngine engine ,  RootNode root ,  String name )  {    this . engine = engine ;    this . rootNode = root ;    this . name = name ; }   public void evaluate  (  Writer writer )  throws PebbleException , IOException  {  EvaluationContextImpl  context =  this . initContext  ( null ) ;   this . evaluate  ( writer , context ) ; }   public void evaluate  (  Writer writer ,  Locale locale )  throws PebbleException , IOException  {  EvaluationContextImpl  context =  this . initContext  ( locale ) ;   this . evaluate  ( writer , context ) ; }   public void evaluate  (  Writer writer ,   Map  < String , Object > map )  throws PebbleException , IOException  {  EvaluationContextImpl  context =  this . initContext  ( null ) ;    context . getScopeChain  ( ) . pushScope  ( map ) ;   this . evaluate  ( writer , context ) ; }   public void evaluate  (  Writer writer ,   Map  < String , Object > map ,  Locale locale )  throws PebbleException , IOException  {  EvaluationContextImpl  context =  this . initContext  ( locale ) ;    context . getScopeChain  ( ) . pushScope  ( map ) ;   this . evaluate  ( writer , context ) ; }   private void evaluate  (  Writer writer ,  EvaluationContextImpl context )  throws PebbleException , IOException  {  if  (   context . getExecutorService  ( ) != null )  {   writer =  new FutureWriter  ( writer ) ; }   rootNode . render  ( this , writer , context ) ;  if  (    context . getHierarchy  ( ) . getParent  ( ) != null )  {  PebbleTemplateImpl  parent =   context . getHierarchy  ( ) . getParent  ( ) ;    context . getHierarchy  ( ) . ascend  ( ) ;   parent . evaluate  ( writer , context ) ; }   writer . flush  ( ) ; }   private EvaluationContextImpl initContext  (  Locale locale )  {   locale =   locale == null ?   this . engine . getDefaultLocale  ( ) : locale ;   Map  < String , Object >  globals =  new  HashMap  < >  ( ) ;   globals . put  ( "locale" , locale ) ;   globals . put  ( "template" , this ) ;  ScopeChain  scopeChain =  new ScopeChain  ( globals ) ;   scopeChain . pushScope  (    this . engine . getExtensionRegistry  ( ) . getGlobalVariables  ( ) ) ;  EvaluationContextImpl  context = 
<<<<<<<
 new EvaluationContextImpl  ( this ,  engine . isStrictVariables  ( ) , locale ,  engine . getExtensionRegistry  ( ) ,  engine . getTagCache  ( ) ,  engine . getExecutorService  ( ) ,  new  ArrayList  < PebbleTemplateImpl >  ( ) , scopeChain , null )
=======
 new EvaluationContext  ( this ,   this . engine . isStrictVariables  ( ) , locale ,   this . engine . getExtensionRegistry  ( ) ,   this . engine . getTagCache  ( ) ,   this . engine . getExecutorService  ( ) ,  new  ArrayList  < PebbleTemplateImpl >  ( ) , scopeChain , null )
>>>>>>>
 ;  return context ; }   public void importTemplate  (  EvaluationContextImpl context ,  String name )  throws PebbleException  {    context . getImportedTemplates  ( ) . add  (  ( PebbleTemplateImpl )  engine . getTemplate  (  this . resolveRelativePath  ( name ) ) ) ; }   public void includeTemplate  (  Writer writer ,  EvaluationContextImpl context ,  String name ,   Map  <  ? ,  ? > additionalVariables )  throws PebbleException , IOException  {  PebbleTemplateImpl  template =  ( PebbleTemplateImpl )  engine . getTemplate  (  this . resolveRelativePath  ( name ) ) ;  EvaluationContextImpl  newContext =  context . shallowCopyWithoutInheritanceChain  ( template ) ;  ScopeChain  scopeChain =  newContext . getScopeChain  ( ) ;   scopeChain . pushScope  ( ) ;  for (  Entry  <  ? ,  ? > entry :  additionalVariables . entrySet  ( ) )  {   scopeChain . put  (  ( String )  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; }   template . evaluate  ( writer , newContext ) ;   scopeChain . popScope  ( ) ; }   public boolean hasMacro  (  String macroName )  {  return   this . macros . containsKey  ( macroName ) ; }   public boolean hasBlock  (  String blockName )  {  return   this . blocks . containsKey  ( blockName ) ; }   public String resolveRelativePath  (  String relativePath )  {  String  resolved =    this . engine . getLoader  ( ) . resolveRelativePath  ( relativePath ,  this . name ) ;  if  (  resolved == null )  {  return relativePath ; } else  {  return resolved ; } }   public void registerBlock  (  Block block )  {    this . blocks . put  (  block . getName  ( ) , block ) ; }   public void registerMacro  (  Macro macro )  throws PebbleException  {  if  (   this . macros . containsKey  (  macro . getName  ( ) ) )  {  throw  new PebbleException  ( null ,  "More than one macro can not share the same name: " +  macro . getName  ( ) ) ; }    this . macros . put  (  macro . getName  ( ) , macro ) ; }   public void block  (  Writer writer ,  EvaluationContextImpl context ,  String blockName ,  boolean ignoreOverriden )  throws PebbleException , IOException  {  Hierarchy  hierarchy =  context . getHierarchy  ( ) ;  PebbleTemplateImpl  childTemplate =  hierarchy . getChild  ( ) ;  if  (   ! ignoreOverriden &&  childTemplate != null )  {   hierarchy . descend  ( ) ;   childTemplate . block  ( writer , context , blockName , false ) ;   hierarchy . ascend  ( ) ; } else  if  (  blocks . containsKey  ( blockName ) )  {  Block  block =  blocks . get  ( blockName ) ;   block . evaluate  ( this , writer , context ) ; } else  {  if  (   hierarchy . getParent  ( ) != null )  {  PebbleTemplateImpl  parent =  hierarchy . getParent  ( ) ;   hierarchy . ascend  ( ) ;   parent . block  ( writer , context , blockName , true ) ;   hierarchy . descend  ( ) ; } } }   public SafeString macro  (  EvaluationContextImpl context ,  String macroName ,  ArgumentsNode args ,  boolean ignoreOverriden )  throws PebbleException  {  SafeString  result = null ;  boolean  found = false ;  PebbleTemplateImpl  childTemplate =   context . getHierarchy  ( ) . getChild  ( ) ;  if  (   ! ignoreOverriden &&  childTemplate != null )  {   found = true ;    context . getHierarchy  ( ) . descend  ( ) ;   result =  childTemplate . macro  ( context , macroName , args , false ) ;    context . getHierarchy  ( ) . ascend  ( ) ; } else  if  (  hasMacro  ( macroName ) )  {   found = true ;  Macro  macro =  macros . get  ( macroName ) ;   Map  < String , Object >  namedArguments =  args . getArgumentMap  ( this , context , macro ) ;   result =  new SafeString  (  macro . call  ( this , context , namedArguments ) ) ; }  if  (  ! found )  {  for ( PebbleTemplateImpl template :  context . getImportedTemplates  ( ) )  {  if  (  template . hasMacro  ( macroName ) )  {   found = true ;   result =  template . macro  ( context , macroName , args , false ) ;  break ; } } }  if  (  ! found )  {  if  (    context . getHierarchy  ( ) . getParent  ( ) != null )  {  PebbleTemplateImpl  parent =   context . getHierarchy  ( ) . getParent  ( ) ;    context . getHierarchy  ( ) . ascend  ( ) ;   result =  parent . macro  ( context , macroName , args , true ) ;    context . getHierarchy  ( ) . descend  ( ) ; } else  {  throw  new PebbleException  ( null ,  String . format  ( "Function or Macro [%s] does not exist." , macroName ) ) ; } }  return result ; }   public void setParent  (  EvaluationContextImpl context ,  String parentName )  throws PebbleException  {    context . getHierarchy  ( ) . pushAncestor  (  ( PebbleTemplateImpl )  engine . getTemplate  (  this . resolveRelativePath  ( parentName ) ) ) ; }   public String getName  ( )  {  return  this . name ; } 
<<<<<<<
=======
  private void evaluate  (  Writer writer ,  EvaluationContext context )  throws PebbleException , IOException  {  if  (   context . getExecutorService  ( ) != null )  {   writer =  new FutureWriter  ( writer ) ; }    this . rootNode . render  ( this , writer , context ) ;  if  (    context . getHierarchy  ( ) . getParent  ( ) != null )  {  PebbleTemplateImpl  parent =   context . getHierarchy  ( ) . getParent  ( ) ;    context . getHierarchy  ( ) . ascend  ( ) ;   parent . evaluate  ( writer , context ) ; }   writer . flush  ( ) ; }
>>>>>>>
 
<<<<<<<
=======
  public void importTemplate  (  EvaluationContext context ,  String name )  throws PebbleException  {    context . getImportedTemplates  ( ) . add  (  ( PebbleTemplateImpl )   this . engine . getTemplate  (  this . resolveRelativePath  ( name ) ) ) ; }
>>>>>>>
 
<<<<<<<
=======
  public void includeTemplate  (  Writer writer ,  EvaluationContext context ,  String name ,   Map  <  ? ,  ? > additionalVariables )  throws PebbleException , IOException  {  PebbleTemplateImpl  template =  ( PebbleTemplateImpl )   this . engine . getTemplate  (  this . resolveRelativePath  ( name ) ) ;  EvaluationContext  newContext =  context . shallowCopyWithoutInheritanceChain  ( template ) ;  ScopeChain  scopeChain =  newContext . getScopeChain  ( ) ;   scopeChain . pushScope  ( ) ;  for (  Entry  <  ? ,  ? > entry :  additionalVariables . entrySet  ( ) )  {   scopeChain . put  (  ( String )  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; }   template . evaluate  ( writer , newContext ) ;   scopeChain . popScope  ( ) ; }
>>>>>>>
 
<<<<<<<
=======
  public void block  (  Writer writer ,  EvaluationContext context ,  String blockName ,  boolean ignoreOverriden )  throws PebbleException , IOException  {  Hierarchy  hierarchy =  context . getHierarchy  ( ) ;  PebbleTemplateImpl  childTemplate =  hierarchy . getChild  ( ) ;  if  (   ! ignoreOverriden &&  childTemplate != null )  {   hierarchy . descend  ( ) ;   childTemplate . block  ( writer , context , blockName , false ) ;   hierarchy . ascend  ( ) ; } else  if  (   this . blocks . containsKey  ( blockName ) )  {  Block  block =   this . blocks . get  ( blockName ) ;   block . evaluate  ( this , writer , context ) ; } else  {  if  (   hierarchy . getParent  ( ) != null )  {  PebbleTemplateImpl  parent =  hierarchy . getParent  ( ) ;   hierarchy . ascend  ( ) ;   parent . block  ( writer , context , blockName , true ) ;   hierarchy . descend  ( ) ; } } }
>>>>>>>
   public SafeString macro  (  EvaluationContext context ,  String macroName ,  ArgumentsNode args ,  boolean ignoreOverriden ,   int lineNumber )  throws PebbleException  {  SafeString  result = null ;  boolean  found = false ;  PebbleTemplateImpl  childTemplate =   context . getHierarchy  ( ) . getChild  ( ) ;  if  (   ! ignoreOverriden &&  childTemplate != null )  {   found = true ;    context . getHierarchy  ( ) . descend  ( ) ;   result =  childTemplate . macro  ( context , macroName , args , false , lineNumber ) ;    context . getHierarchy  ( ) . ascend  ( ) ; } else  if  (  this . hasMacro  ( macroName ) )  {   found = true ;  Macro  macro =   this . macros . get  ( macroName ) ;   Map  < String , Object >  namedArguments =  args . getArgumentMap  ( this , context , macro ) ;   result =  new SafeString  (  macro . call  ( this , context , namedArguments ) ) ; }  if  (  ! found )  {  for ( PebbleTemplateImpl template :  context . getImportedTemplates  ( ) )  {  if  (  template . hasMacro  ( macroName ) )  {   found = true ;   result =  template . macro  ( context , macroName , args , false , lineNumber ) ;  break ; } } }  if  (  ! found )  {  if  (    context . getHierarchy  ( ) . getParent  ( ) != null )  {  PebbleTemplateImpl  parent =   context . getHierarchy  ( ) . getParent  ( ) ;    context . getHierarchy  ( ) . ascend  ( ) ;   result =  parent . macro  ( context , macroName , args , true , lineNumber ) ;    context . getHierarchy  ( ) . descend  ( ) ; } else  {  throw  new PebbleException  ( null ,  String . format  ( "Function or Macro [%s] does not exist." , macroName ) , lineNumber ,  this . name ) ; } }  return result ; } 
<<<<<<<
=======
  public void setParent  (  EvaluationContext context ,  String parentName )  throws PebbleException  {    context . getHierarchy  ( ) . pushAncestor  (  ( PebbleTemplateImpl )   this . engine . getTemplate  (  this . resolveRelativePath  ( parentName ) ) ) ; }
>>>>>>>
 }