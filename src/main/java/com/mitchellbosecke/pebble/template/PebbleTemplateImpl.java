  package    com . mitchellbosecke . pebble . template ;   import    com . mitchellbosecke . pebble . PebbleEngine ;  import     com . mitchellbosecke . pebble . error . PebbleException ;  import      com . mitchellbosecke . pebble . extension . escaper . SafeString ;  import     com . mitchellbosecke . pebble . node . ArgumentsNode ;  import     com . mitchellbosecke . pebble . node . RootNode ;  import     com . mitchellbosecke . pebble . utils . FutureWriter ;  import     com . mitchellbosecke . pebble . utils . Pair ;  import   java . io . IOException ;  import   java . io . Writer ;  import   java . util . ArrayList ;  import   java . util . HashMap ;  import   java . util . List ;  import   java . util . Locale ;  import   java . util . Map ;  import    java . util . Map . Entry ;   public class PebbleTemplateImpl  implements  PebbleTemplate  {   private final PebbleEngine  engine ;   private final  Map  < String , Block >  blocks =  new  HashMap  < >  ( ) ;   private final  Map  < String , Macro >  macros =  new  HashMap  < >  ( ) ;   private final RootNode  rootNode ;   private final String  name ;   public PebbleTemplateImpl  (  PebbleEngine engine ,  RootNode root ,  String name )  {    this . engine = engine ;    this . rootNode = root ;    this . name = name ; }   public void evaluate  (  Writer writer )  throws IOException  {  EvaluationContext  context =  this . initContext  ( null ) ;   this . evaluate  ( writer , context ) ; }   public void evaluate  (  Writer writer ,  Locale locale )  throws IOException  {  EvaluationContext  context =  this . initContext  ( locale ) ;   this . evaluate  ( writer , context ) ; }   public void evaluate  (  Writer writer ,   Map  < String , Object > map )  throws IOException  {  EvaluationContext  context =  this . initContext  ( null ) ;    context . getScopeChain  ( ) . pushScope  ( map ) ;   this . evaluate  ( writer , context ) ; }   public void evaluate  (  Writer writer ,   Map  < String , Object > map ,  Locale locale )  throws IOException  {  EvaluationContext  context =  this . initContext  ( locale ) ;    context . getScopeChain  ( ) . pushScope  ( map ) ;   this . evaluate  ( writer , context ) ; }   public void evaluateBlock  (  String blockName ,  Writer writer )  throws IOException  {  EvaluationContext  context =  this . initContext  ( null ) ;   this . evaluate  (  new NoopWriter  ( ) , context ) ;   this . block  ( writer , context , blockName , false ) ;   writer . flush  ( ) ; }   public void evaluateBlock  (  String blockName ,  Writer writer ,  Locale locale )  throws IOException  {  EvaluationContext  context =  this . initContext  ( locale ) ;   this . evaluate  (  new NoopWriter  ( ) , context ) ;   this . block  ( writer , context , blockName , false ) ;   writer . flush  ( ) ; }   public void evaluateBlock  (  String blockName ,  Writer writer ,   Map  < String , Object > map )  throws IOException  {  EvaluationContext  context =  this . initContext  ( null ) ;    context . getScopeChain  ( ) . pushScope  ( map ) ;   this . evaluate  (  new NoopWriter  ( ) , context ) ;   this . block  ( writer , context , blockName , false ) ;   writer . flush  ( ) ; }   public void evaluateBlock  (  String blockName ,  Writer writer ,   Map  < String , Object > map ,  Locale locale )  throws IOException  {  EvaluationContext  context =  this . initContext  ( locale ) ;    context . getScopeChain  ( ) . pushScope  ( map ) ;   this . evaluate  (  new NoopWriter  ( ) , context ) ;   this . block  ( writer , context , blockName , false ) ;   writer . flush  ( ) ; }   private void evaluate  (  Writer writer ,  EvaluationContext context )  throws IOException  {  if  (   context . getExecutorService  ( ) != null )  {   writer =  new FutureWriter  ( writer ) ; }    this . rootNode . render  ( this , writer , context ) ;  if  (    context . getHierarchy  ( ) . getParent  ( ) != null )  {  PebbleTemplateImpl  parent =   context . getHierarchy  ( ) . getParent  ( ) ;    context . getHierarchy  ( ) . ascend  ( ) ;   parent . evaluate  ( writer , context ) ; }   writer . flush  ( ) ; }   private EvaluationContext initContext  (  Locale locale )  {   locale =   locale == null ?   this . engine . getDefaultLocale  ( ) : locale ;   Map  < String , Object >  globals =  new  HashMap  < >  ( ) ;   globals . put  ( "locale" , locale ) ;   globals . put  ( "template" , this ) ;  ScopeChain  scopeChain =  new ScopeChain  ( globals ) ;   scopeChain . pushScope  (    this . engine . getExtensionRegistry  ( ) . getGlobalVariables  ( ) ) ;  return  new EvaluationContext  ( this ,   this . engine . isStrictVariables  ( ) , locale ,   this . engine . getExtensionRegistry  ( ) ,   this . engine . getTagCache  ( ) ,   this . engine . getExecutorService  ( ) ,  new  ArrayList  < PebbleTemplateImpl >  ( ) ,  new  HashMap  < String , PebbleTemplateImpl >  ( ) , scopeChain , null ,   this . engine . isAllowGetClass  ( ) ) ; }   public void importTemplate  (  EvaluationContext context ,  String name )  {    context . getImportedTemplates  ( ) . add  (  ( PebbleTemplateImpl )   this . engine . getTemplate  (  this . resolveRelativePath  ( name ) ) ) ; }   public void importNamedTemplate  (  EvaluationContext context ,  String name ,  String alias )  throws PebbleException  {   context . addNamedImportedTemplates  ( alias ,  ( PebbleTemplateImpl )   this . engine . getTemplate  (  this . resolveRelativePath  ( name ) ) ) ; }   public void importNamedMacrosFromTemplate  (  EvaluationContext context ,  String name ,   List  <  Pair  < String , String > > namedMacros )  throws PebbleException  {  PebbleTemplateImpl  templateImpl =  ( PebbleTemplateImpl )   this . engine . getTemplate  (  this . resolveRelativePath  ( name ) ) ;  for (  Pair  < String , String > pair : namedMacros )  {  Macro  m =   templateImpl . macros . get  (  pair . getRight  ( ) ) ;   registerMacro  (  pair . getLeft  ( ) , m ) ; } }   public PebbleTemplateImpl getNamedImportedTemplate  (  EvaluationContext context ,  String alias )  {  return  context . getNamedImportedTemplate  ( alias ) ; }   public void includeTemplate  (  Writer writer ,  EvaluationContext context ,  String name ,   Map  <  ? ,  ? > additionalVariables )  throws IOException  {  PebbleTemplateImpl  template =  ( PebbleTemplateImpl )   this . engine . getTemplate  (  this . resolveRelativePath  ( name ) ) ;  EvaluationContext  newContext =  context . shallowCopyWithoutInheritanceChain  ( template ) ;  ScopeChain  scopeChain =  newContext . getScopeChain  ( ) ;   scopeChain . pushScope  ( ) ;  for (  Entry  <  ? ,  ? > entry :  additionalVariables . entrySet  ( ) )  {   scopeChain . put  (  ( String )  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; }   template . evaluate  ( writer , newContext ) ;   scopeChain . popScope  ( ) ; }   public boolean hasMacro  (  String macroName )  {  return   this . macros . containsKey  ( macroName ) ; }   public boolean hasBlock  (  String blockName )  {  return   this . blocks . containsKey  ( blockName ) ; }   public String resolveRelativePath  (  String relativePath )  {  String  resolved =    this . engine . getLoader  ( ) . resolveRelativePath  ( relativePath ,  this . name ) ;  if  (  resolved == null )  {  return relativePath ; } else  {  return resolved ; } }   public void registerBlock  (  Block block )  {    this . blocks . put  (  block . getName  ( ) , block ) ; }   public void registerMacro  (  Macro macro )  {  if  (   this . macros . containsKey  (  macro . getName  ( ) ) )  {  throw  new PebbleException  ( null ,  "More than one macro can not share the same name: " +  macro . getName  ( ) ) ; }    this . macros . put  (  macro . getName  ( ) , macro ) ; }   public void registerMacro  (  String alias ,  Macro macro )  throws PebbleException  {  if  (   this . macros . containsKey  ( alias ) )  {  throw  new PebbleException  ( null ,  "More than one macro can not share the same name: " + alias ) ; }    this . macros . put  ( alias , macro ) ; }   public void block  (  Writer writer ,  EvaluationContext context ,  String blockName ,  boolean ignoreOverriden )  throws IOException  {  Hierarchy  hierarchy =  context . getHierarchy  ( ) ;  PebbleTemplateImpl  childTemplate =  hierarchy . getChild  ( ) ;  if  (   ! ignoreOverriden &&  childTemplate != null )  {   hierarchy . descend  ( ) ;   childTemplate . block  ( writer , context , blockName , false ) ;   hierarchy . ascend  ( ) ; } else  if  (   this . blocks . containsKey  ( blockName ) )  {  Block  block =   this . blocks . get  ( blockName ) ;   block . evaluate  ( this , writer , context ) ; } else  {  if  (   hierarchy . getParent  ( ) != null )  {  PebbleTemplateImpl  parent =  hierarchy . getParent  ( ) ;   hierarchy . ascend  ( ) ;   parent . block  ( writer , context , blockName , true ) ;   hierarchy . descend  ( ) ; } } }   public SafeString macro  (  EvaluationContext context ,  String macroName ,  ArgumentsNode args ,  boolean ignoreOverriden ,   int lineNumber )  {  SafeString  result = null ;  boolean  found = false ;  PebbleTemplateImpl  childTemplate =   context . getHierarchy  ( ) . getChild  ( ) ;  if  (   ! ignoreOverriden &&  childTemplate != null )  {   found = true ;    context . getHierarchy  ( ) . descend  ( ) ;   result =  childTemplate . macro  ( context , macroName , args , false , lineNumber ) ;    context . getHierarchy  ( ) . ascend  ( ) ; } else  if  (  this . hasMacro  ( macroName ) )  {   found = true ;  Macro  macro =   this . macros . get  ( macroName ) ;   Map  < String , Object >  namedArguments =  args . getArgumentMap  ( this , context , macro ) ;   result =  new SafeString  (  macro . call  ( this , context , namedArguments ) ) ; }  if  (  ! found )  {  for ( PebbleTemplateImpl template :  context . getImportedTemplates  ( ) )  {  if  (  template . hasMacro  ( macroName ) )  {   found = true ;   result =  template . macro  ( context , macroName , args , false , lineNumber ) ;  break ; } } }  if  (  ! found )  {  if  (    context . getHierarchy  ( ) . getParent  ( ) != null )  {  PebbleTemplateImpl  parent =   context . getHierarchy  ( ) . getParent  ( ) ;    context . getHierarchy  ( ) . ascend  ( ) ;   result =  parent . macro  ( context , macroName , args , true , lineNumber ) ;    context . getHierarchy  ( ) . descend  ( ) ; } else  {  throw  new PebbleException  ( null ,  String . format  ( "Function or Macro [%s] does not exist." , macroName ) , lineNumber ,  this . name ) ; } }  return result ; }   public void setParent  (  EvaluationContext context ,  String parentName )  {    context . getHierarchy  ( ) . pushAncestor  (  ( PebbleTemplateImpl )   this . engine . getTemplate  (  this . resolveRelativePath  ( parentName ) ) ) ; }   public String getName  ( )  {  return  this . name ; }   private static class NoopWriter  extends Writer  {   public void write  (    char  [ ] cbuf ,   int off ,   int len )  throws IOException  { }   public void flush  ( )  throws IOException  { }   public void close  ( )  throws IOException  { } } }