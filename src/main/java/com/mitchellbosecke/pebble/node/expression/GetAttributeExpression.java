  package     com . mitchellbosecke . pebble . node . expression ;   import     com . mitchellbosecke . pebble . attributes . AttributeResolver ;  import     com . mitchellbosecke . pebble . attributes . ResolvedAttribute ;  import     com . mitchellbosecke . pebble . error . AttributeNotFoundException ;  import     com . mitchellbosecke . pebble . error . PebbleException ;  import     com . mitchellbosecke . pebble . error . RootAttributeNotFoundException ;  import     com . mitchellbosecke . pebble . extension . NodeVisitor ;  import     com . mitchellbosecke . pebble . node . ArgumentsNode ;  import     com . mitchellbosecke . pebble . node . PositionalArgumentNode ;  import     com . mitchellbosecke . pebble . template . EvaluationContextImpl ;  import     com . mitchellbosecke . pebble . template . PebbleTemplateImpl ;  import   java . util . List ;   public class GetAttributeExpression  implements   Expression  < Object >  {   private final  Expression  <  ? >  node ;   private final  Expression  <  ? >  attributeNameExpression ;   private final ArgumentsNode  args ;   private final String  filename ;   private final  int  lineNumber ;   public GetAttributeExpression  (   Expression  <  ? > node ,   Expression  <  ? > attributeNameExpression ,  String filename ,   int lineNumber )  {  this  ( node , attributeNameExpression , null , filename , lineNumber ) ; }   public GetAttributeExpression  (   Expression  <  ? > node ,   Expression  <  ? > attributeNameExpression ,  ArgumentsNode args ,  String filename ,   int lineNumber )  {    this . node = node ;    this . attributeNameExpression = attributeNameExpression ;    this . args = args ;    this . filename = filename ;    this . lineNumber = lineNumber ; }    @ Override public Object evaluate  (  PebbleTemplateImpl self ,  EvaluationContextImpl context )  throws PebbleException  {   final Object  object =   this . node . evaluate  ( self , context ) ;   final Object  attributeNameValue =   this . attributeNameExpression . evaluate  ( self , context ) ;   final String  attributeName =  String . valueOf  ( attributeNameValue ) ;   final  Object  [ ]  argumentValues =  this . getArgumentValues  ( self , context ) ;  if  (   object == null &&  context . isStrictVariables  ( ) )  {  if  (   this . node instanceof ContextVariableExpression )  {   final String  rootPropertyName =   (  ( ContextVariableExpression )  this . node ) . getName  ( ) ;  throw  new RootAttributeNotFoundException  ( null ,  String . format  ( "Root attribute [%s] does not exist or can not be accessed and strict variables is set to true." , rootPropertyName ) , rootPropertyName ,  this . lineNumber ,  this . filename ) ; } else  {  throw  new RootAttributeNotFoundException  ( null , "Attempt to get attribute of null object and strict variables is set to true." , attributeName ,  this . lineNumber ,  this . filename ) ; } }  for ( AttributeResolver attributeResolver :   context . getExtensionRegistry  ( ) . getAttributeResolver  ( ) )  {  ResolvedAttribute  resolvedAttribute =  attributeResolver . resolve  ( object , attributeNameValue , argumentValues , context ,  this . filename ,  this . lineNumber ) ;  if  (  resolvedAttribute != null )  {  return  resolvedAttribute . evaluate  ( ) ; } }  if  (  context . isStrictVariables  ( ) )  {  throw  new AttributeNotFoundException  ( null ,  String . format  ( "Attribute [%s] of [%s] does not exist or can not be accessed and strict variables is set to true." , attributeName ,   object != null ?   object . getClass  ( ) . getName  ( ) : null ) , attributeName ,  this . lineNumber ,  this . filename ) ; }  return null ; }   private  Object  [ ] getArgumentValues  (  PebbleTemplateImpl self ,  EvaluationContextImpl context )  {   Object  [ ]  argumentValues ;  if  (   this . args == null )  {   argumentValues = null ; } else  {   List  < PositionalArgumentNode >  args =   this . args . getPositionalArgs  ( ) ;   argumentValues =  new Object  [  args . size  ( ) ] ;   int  index = 0 ;  for ( PositionalArgumentNode arg : args )  {  Object  argumentValue =   arg . getValueExpression  ( ) . evaluate  ( self , context ) ;    argumentValues [ index ] = argumentValue ;   index ++ ; } }  return argumentValues ; }    @ Override public void accept  (  NodeVisitor visitor )  {   visitor . visit  ( this ) ; }   public  Expression  <  ? > getNode  ( )  {  return  this . node ; }   public  Expression  <  ? > getAttributeNameExpression  ( )  {  return  this . attributeNameExpression ; }   public ArgumentsNode getArgumentsNode  ( )  {  return  this . args ; }    @ Override public  int getLineNumber  ( )  {  return  this . lineNumber ; } 
<<<<<<<
=======
   @ Override public Object evaluate  (  PebbleTemplateImpl self ,  EvaluationContext context )  {  Object  object =   this . node . evaluate  ( self , context ) ;  Object  attributeNameValue =   this . attributeNameExpression . evaluate  ( self , context ) ;  String  attributeName =  String . valueOf  ( attributeNameValue ) ;  Object  result = null ;   Object  [ ]  argumentValues =  this . getArgumentValues  ( self , context ) ;  Member  member =   object == null ? null :   this . memberCache . get  (  new MemberCacheKey  (  object . getClass  ( ) , attributeName ) ) ;  if  (   object != null &&  member == null )  {  if  (   this . args == null )  {  if  (  object instanceof Map )  {  return  this . getObjectFromMap  (  (  Map  <  ? ,  ? > ) object , attributeNameValue ) ; }  try  {  if  (   object . getClass  ( ) . isArray  ( ) )  {   int  index =  Integer . parseInt  ( attributeName ) ;   int  length =  Array . getLength  ( object ) ;  if  (   index < 0 ||  index >= length )  {  if  (  context . isStrictVariables  ( ) )  {  throw  new AttributeNotFoundException  ( null , "Index out of bounds while accessing array with strict variables on." , attributeName ,  this . lineNumber ,  this . filename ) ; } else  {  return null ; } }  return  Array . get  ( object , index ) ; }  if  (  object instanceof List )  {    @ SuppressWarnings  ( "unchecked" )  List  < Object >  list =  (  List  < Object > ) object ;   int  index =  Integer . parseInt  ( attributeName ) ;   int  length =  list . size  ( ) ;  if  (   index < 0 ||  index >= length )  {  if  (  context . isStrictVariables  ( ) )  {  throw  new AttributeNotFoundException  ( null , "Index out of bounds while accessing array with strict variables on." , attributeName ,  this . lineNumber ,  this . filename ) ; } else  {  return null ; } }  return  list . get  ( index ) ; } }  catch (   NumberFormatException ex )  { } }  if  (  object instanceof DynamicAttributeProvider )  {  DynamicAttributeProvider  dynamicAttributeProvider =  ( DynamicAttributeProvider ) object ;  if  (  dynamicAttributeProvider . canProvideDynamicAttribute  ( attributeName ) )  {  return  dynamicAttributeProvider . getDynamicAttribute  ( attributeNameValue , argumentValues ) ; } }    Class  <  ? >  [ ]  argumentTypes =  new  Class  <  ? >  [  argumentValues . length ] ;  for (   int  i = 0 ;  i <  argumentValues . length ;  i ++ )  {  Object  o =  argumentValues [ i ] ;  if  (  o == null )  {    argumentTypes [ i ] = null ; } else  {    argumentTypes [ i ] =  o . getClass  ( ) ; } }   member =  this . reflect  ( object , attributeName , argumentTypes ,  context . isAllowGetClass  ( ) ) ;  if  (  member != null )  {    this . memberCache . put  (  new MemberCacheKey  (  object . getClass  ( ) , attributeName ) , member ) ; } }  if  (   object != null &&  member != null )  {   result =  this . invokeMember  ( object , member , argumentValues ) ; } else  if  (  context . isStrictVariables  ( ) )  {  if  (  object == null )  {  if  (   this . node instanceof ContextVariableExpression )  {   final String  rootPropertyName =   (  ( ContextVariableExpression )  this . node ) . getName  ( ) ;  throw  new RootAttributeNotFoundException  ( null ,  String . format  ( "Root attribute [%s] does not exist or can not be accessed and strict variables is set to true." , rootPropertyName ) , rootPropertyName ,  this . lineNumber ,  this . filename ) ; } else  {  throw  new RootAttributeNotFoundException  ( null , "Attempt to get attribute of null object and strict variables is set to true." , attributeName ,  this . lineNumber ,  this . filename ) ; } } else  {  if  (   attributeName . equals  ( "class" ) ||  attributeName . equals  ( "getClass" ) )  {  throw  new ClassAccessException  (  this . lineNumber ,  this . filename ) ; } else  {  throw  new AttributeNotFoundException  ( null ,  String . format  ( "Attribute [%s] of [%s] does not exist or can not be accessed and strict variables is set to true." , attributeName ,   object . getClass  ( ) . getName  ( ) ) , attributeName ,  this . lineNumber ,  this . filename ) ; } } }  return result ; }
>>>>>>>
   private Member reflect  (  Object object ,  String attributeName ,    Class  <  ? >  [ ] parameterTypes ,  boolean allowGetClass )  {   Class  <  ? >  clazz =  object . getClass  ( ) ;  Member  result = null ;  String  attributeCapitalized =   Character . toUpperCase  (  attributeName . charAt  ( 0 ) ) +  attributeName . substring  ( 1 ) ;   result =  this . findMethod  ( clazz ,  "get" + attributeCapitalized , parameterTypes , allowGetClass ) ;  if  (  result == null )  {   result =  this . findMethod  ( clazz ,  "is" + attributeCapitalized , parameterTypes , allowGetClass ) ; }  if  (  result == null )  {   result =  this . findMethod  ( clazz ,  "has" + attributeCapitalized , parameterTypes , allowGetClass ) ; }  if  (  result == null )  {   result =  this . findMethod  ( clazz , attributeName , parameterTypes , allowGetClass ) ; }  if  (  result == null )  {  try  {   result =  clazz . getField  ( attributeName ) ; }  catch (   NoSuchFieldException | SecurityException e )  { } }  if  (  result != null )  {    (  ( AccessibleObject ) result ) . setAccessible  ( true ) ; }  return result ; }   private Method findMethod  (   Class  <  ? > clazz ,  String name ,    Class  <  ? >  [ ] requiredTypes ,  boolean allowGetClass )  {  if  (  name . equals  ( "getClass" ) )  {  if  (  ! allowGetClass )  {  throw  new ClassAccessException  (  this . lineNumber ,  this . filename ) ; }  return null ; }  Method  result = null ;   Method  [ ]  candidates =  clazz . getMethods  ( ) ;  for ( Method candidate : candidates )  {  if  (  !   candidate . getName  ( ) . equalsIgnoreCase  ( name ) )  {  continue ; }    Class  <  ? >  [ ]  types =  candidate . getParameterTypes  ( ) ;  if  (   types . length !=  requiredTypes . length )  {  continue ; }  boolean  compatibleTypes = true ;  for (   int  i = 0 ;  i <  types . length ;  i ++ )  {  if  (    requiredTypes [ i ] != null &&  !   this . widen  (  types [ i ] ) . isAssignableFrom  (  requiredTypes [ i ] ) )  {   compatibleTypes = false ;  break ; } }  if  ( compatibleTypes )  {   result = candidate ;  break ; } }  return result ; } }