  package    com . mitchellbosecke . pebble . parser ;   import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Set ;  import     com . mitchellbosecke . pebble . error . ParserException ;  import     com . mitchellbosecke . pebble . lexer . Token ;  import     com . mitchellbosecke . pebble . lexer . TokenStream ;  import     com . mitchellbosecke . pebble . node . ArgumentsNode ;  import     com . mitchellbosecke . pebble . node . FunctionOrMacroNameNode ;  import     com . mitchellbosecke . pebble . node . NamedArgumentNode ;  import     com . mitchellbosecke . pebble . node . PositionalArgumentNode ;  import     com . mitchellbosecke . pebble . node . TestInvocationExpression ;  import      com . mitchellbosecke . pebble . node . expression . ArrayExpression ;  import      com . mitchellbosecke . pebble . node . expression . BinaryExpression ;  import      com . mitchellbosecke . pebble . node . expression . BlockFunctionExpression ;  import      com . mitchellbosecke . pebble . node . expression . ConcatenateExpression ;  import      com . mitchellbosecke . pebble . node . expression . ContextVariableExpression ;  import      com . mitchellbosecke . pebble . node . expression . Expression ;  import      com . mitchellbosecke . pebble . node . expression . FilterExpression ;  import      com . mitchellbosecke . pebble . node . expression . FilterInvocationExpression ;  import      com . mitchellbosecke . pebble . node . expression . FunctionOrMacroInvocationExpression ;  import      com . mitchellbosecke . pebble . node . expression . GetAttributeExpression ;  import      com . mitchellbosecke . pebble . node . expression . LiteralBooleanExpression ;  import      com . mitchellbosecke . pebble . node . expression . LiteralDoubleExpression ;  import      com . mitchellbosecke . pebble . node . expression . LiteralLongExpression ;  import      com . mitchellbosecke . pebble . node . expression . LiteralNullExpression ;  import      com . mitchellbosecke . pebble . node . expression . LiteralStringExpression ;  import      com . mitchellbosecke . pebble . node . expression . MapExpression ;  import      com . mitchellbosecke . pebble . node . expression . NegativeTestExpression ;  import      com . mitchellbosecke . pebble . node . expression . ParentFunctionExpression ;  import      com . mitchellbosecke . pebble . node . expression . PositiveTestExpression ;  import      com . mitchellbosecke . pebble . node . expression . TernaryExpression ;  import      com . mitchellbosecke . pebble . node . expression . UnaryExpression ;  import     com . mitchellbosecke . pebble . operator . Associativity ;  import     com . mitchellbosecke . pebble . operator . BinaryOperator ;  import     com . mitchellbosecke . pebble . operator . UnaryOperator ;   public class ExpressionParser  {   private static final  Set  < String >  RESERVED_KEYWORDS =  new  HashSet  < >  (  Arrays . asList  ( "true" , "false" , "null" , "none" ) ) ;   private final Parser  parser ;   private TokenStream  stream ;   private  Map  < String , BinaryOperator >  binaryOperators ;   private  Map  < String , UnaryOperator >  unaryOperators ;   public ExpressionParser  (  Parser parser ,   Map  < String , BinaryOperator > binaryOperators ,   Map  < String , UnaryOperator > unaryOperators )  {    this . parser = parser ;    this . binaryOperators = binaryOperators ;    this . unaryOperators = unaryOperators ; }   public  Expression  <  ? > parseExpression  ( )  {  return  parseExpression  ( 0 ) ; }   private  Expression  <  ? > parseExpression  (   int minPrecedence )  {    this . stream =  parser . getStream  ( ) ;  Token  token =  stream . current  ( ) ;   Expression  <  ? >  expression = null ;  if  (  isUnary  ( token ) )  {  UnaryOperator  operator =   this . unaryOperators . get  (  token . getValue  ( ) ) ;   stream . next  ( ) ;   expression =  parseExpression  (  operator . getPrecedence  ( ) ) ;  UnaryExpression  unaryExpression = null ;   Class  <  ? extends UnaryExpression >  operatorNodeClass =  operator . getNodeClass  ( ) ;  try  {   unaryExpression =  operatorNodeClass . newInstance  ( ) ;   unaryExpression . setLineNumber  (   stream . current  ( ) . getLineNumber  ( ) ) ; }  catch (   InstantiationException | IllegalAccessException e )  {  throw  new RuntimeException  ( e ) ; }   unaryExpression . setChildExpression  ( expression ) ;   expression = unaryExpression ; } else  if  (  token . test  (   Token . Type . PUNCTUATION , "(" ) )  {   stream . next  ( ) ;   expression =  parseExpression  ( ) ;   stream . expect  (   Token . Type . PUNCTUATION , ")" ) ;   expression =  parsePostfixExpression  ( expression ) ; } else  if  (  token . test  (   Token . Type . PUNCTUATION , "[" ) )  {   expression =  parseArrayDefinitionExpression  ( ) ; } else  if  (  token . test  (   Token . Type . PUNCTUATION , "{" ) )  {   expression =  parseMapDefinitionExpression  ( ) ; } else  {   expression =  subparseExpression  ( ) ; }   token =  stream . current  ( ) ;  while  (   isBinary  ( token ) &&    binaryOperators . get  (  token . getValue  ( ) ) . getPrecedence  ( ) >= minPrecedence )  {  BinaryOperator  operator =  binaryOperators . get  (  token . getValue  ( ) ) ;   stream . next  ( ) ;   Expression  <  ? >  expressionRight = null ;  if  (   FilterExpression . class . equals  (  operator . getNodeClass  ( ) ) )  {   expressionRight =  parseFilterInvocationExpression  ( ) ; } else  if  (    PositiveTestExpression . class . equals  (  operator . getNodeClass  ( ) ) ||   NegativeTestExpression . class . equals  (  operator . getNodeClass  ( ) ) )  {   expressionRight =  parseTestInvocationExpression  ( ) ; } else  {   expressionRight =  parseExpression  (    Associativity . LEFT . equals  (  operator . getAssociativity  ( ) ) ?   operator . getPrecedence  ( ) + 1 :  operator . getPrecedence  ( ) ) ; }   BinaryExpression  <  ? >  finalExpression = null ;   Class  <  ? extends  BinaryExpression  <  ? > >  operatorNodeClass =  operator . getNodeClass  ( ) ;  try  {   finalExpression =  operatorNodeClass . newInstance  ( ) ;   finalExpression . setLineNumber  (   stream . current  ( ) . getLineNumber  ( ) ) ; }  catch (   InstantiationException | IllegalAccessException e )  {  throw  new ParserException  ( e ,   "Error instantiating operator node [" +  operatorNodeClass . getName  ( ) + "]" ,  token . getLineNumber  ( ) ,  stream . getFilename  ( ) ) ; }   finalExpression . setLeft  ( expression ) ;   finalExpression . setRight  ( expressionRight ) ;   expression = finalExpression ;   token =  stream . current  ( ) ; }  if  (  minPrecedence == 0 )  {  return  parseTernaryExpression  ( expression ) ; }  return expression ; }   private boolean isUnary  (  Token token )  {  return   token . test  (   Token . Type . OPERATOR ) &&   this . unaryOperators . containsKey  (  token . getValue  ( ) ) ; }   private boolean isBinary  (  Token token )  {  return   token . test  (   Token . Type . OPERATOR ) &&   this . binaryOperators . containsKey  (  token . getValue  ( ) ) ; }   private  Expression  <  ? > subparseExpression  ( )  {   final Token  token =  stream . current  ( ) ;   Expression  <  ? >  node = null ;  switch  (  token . getType  ( ) )  {   case NAME :  switch  (  token . getValue  ( ) )  {   case "true" :   case "TRUE" :   node =  new LiteralBooleanExpression  ( true ,  token . getLineNumber  ( ) ) ;   stream . next  ( ) ;  break ;   case "false" :   case "FALSE" :   node =  new LiteralBooleanExpression  ( false ,  token . getLineNumber  ( ) ) ;   stream . next  ( ) ;  break ;   case "none" :   case "NONE" :   case "null" :   case "NULL" :   node =  new LiteralNullExpression  (  token . getLineNumber  ( ) ) ;   stream . next  ( ) ;  break ;   default :  if  (   stream . peek  ( ) . test  (   Token . Type . PUNCTUATION , "(" ) )  {   node =  new FunctionOrMacroNameNode  (  token . getValue  ( ) ,   stream . peek  ( ) . getLineNumber  ( ) ) ; } else  {   node =  new ContextVariableExpression  (  token . getValue  ( ) ,  token . getLineNumber  ( ) ) ; }   stream . next  ( ) ;  break ; }  break ;   case NUMBER :   final String  numberValue =  token . getValue  ( ) ;  if  (  numberValue . contains  ( "." ) )  {   node =  new LiteralDoubleExpression  (  Double . valueOf  ( numberValue ) ,  token . getLineNumber  ( ) ) ; } else  {   node =  new LiteralLongExpression  (  Long . valueOf  ( numberValue ) ,  token . getLineNumber  ( ) ) ; }   stream . next  ( ) ;  break ;   case STRING :   case STRING_INTERPOLATION_START :   node =  parseStringExpression  ( ) ;  break ;   default :  throw  new ParserException  ( null ,  String . format  ( "Unexpected token \"%s\" of value \"%s\"" ,   token . getType  ( ) . toString  ( ) ,  token . getValue  ( ) ) ,  token . getLineNumber  ( ) ,  stream . getFilename  ( ) ) ; }  return  parsePostfixExpression  ( node ) ; }   private  Expression  <  ? > parseStringExpression  ( )  throws ParserException  {   List  <  Expression  <  ? > >  nodes =  new  ArrayList  < >  ( ) ;  boolean  nextCanBeString = true ;  while  ( true )  {  if  (  nextCanBeString &&   stream . current  ( ) . test  (   Token . Type . STRING ) )  {  Token  token =  stream . expect  (   Token . Type . STRING ) ;   nodes . add  (  new LiteralStringExpression  (  token . getValue  ( ) ,  token . getLineNumber  ( ) ) ) ; } else  if  (   stream . current  ( ) . test  (   Token . Type . STRING_INTERPOLATION_START ) )  {   stream . expect  (   Token . Type . STRING_INTERPOLATION_START ) ;   nodes . add  (  parseExpression  ( ) ) ;   stream . expect  (   Token . Type . STRING_INTERPOLATION_END ) ;   nextCanBeString = true ; } else  {  break ; } }   Expression  <  ? >  first =  nodes . remove  ( 0 ) ;  if  (  nodes . isEmpty  ( ) )  {  return first ; }  ConcatenateExpression  expr ,  firstExpr ;   expr =  firstExpr =  new ConcatenateExpression  ( first , null ) ;  for (   int  i = 0 ;  i <  nodes . size  ( ) ;  i ++ )  {   Expression  <  ? >  node =  nodes . get  ( i ) ;  if  (  i ==   nodes . size  ( ) - 1 )  {   expr . setRight  ( node ) ; } else  {  ConcatenateExpression  newExpr =  new ConcatenateExpression  ( node , null ) ;   expr . setRight  ( newExpr ) ;   expr = newExpr ; } }  return firstExpr ; }    @ SuppressWarnings  ( "unchecked" ) private  Expression  <  ? > parseTernaryExpression  (   Expression  <  ? > expression )  {  if  (  !   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "?" ) )  return expression ;   stream . next  ( ) ;   Expression  <  ? >  expression2 =  parseExpression  ( ) ;   stream . expect  (   Token . Type . PUNCTUATION , ":" ) ;   Expression  <  ? >  expression3 =  parseExpression  ( ) ;   expression =  new TernaryExpression  (  (  Expression  < Boolean > ) expression , expression2 , expression3 ,    this . stream . current  ( ) . getLineNumber  ( ) ,  stream . getFilename  ( ) ) ;  return expression ; }   private  Expression  <  ? > parsePostfixExpression  (   Expression  <  ? > node )  {  Token  current ;  while  ( true )  {   current =  stream . current  ( ) ;  if  (   current . test  (   Token . Type . PUNCTUATION , "." ) ||  current . test  (   Token . Type . PUNCTUATION , "[" ) )  {   node =  parseBeanAttributeExpression  ( node ) ; } else  if  (  current . test  (   Token . Type . PUNCTUATION , "(" ) )  {   node =  parseFunctionOrMacroInvocation  ( node ) ; } else  {  break ; } }  return node ; }   private  Expression  <  ? > parseFunctionOrMacroInvocation  (   Expression  <  ? > node )  {  String  functionName =   (  ( FunctionOrMacroNameNode ) node ) . getName  ( ) ;  ArgumentsNode  args =  parseArguments  ( ) ;  switch  ( functionName )  {   case "parent" :  return  new ParentFunctionExpression  (  parser . peekBlockStack  ( ) ,   stream . current  ( ) . getLineNumber  ( ) ) ;   case "block" :  return  new BlockFunctionExpression  ( args ,  node . getLineNumber  ( ) ) ; }  return  new FunctionOrMacroInvocationExpression  ( functionName , args ,  node . getLineNumber  ( ) ) ; }   public FilterInvocationExpression parseFilterInvocationExpression  ( )  {  TokenStream  stream =  parser . getStream  ( ) ;  Token  filterToken =  stream . expect  (   Token . Type . NAME ) ;  ArgumentsNode  args = null ;  if  (   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "(" ) )  {   args =  this . parseArguments  ( ) ; } else  {   args =  new ArgumentsNode  ( null , null ,  filterToken . getLineNumber  ( ) ) ; }  return  new FilterInvocationExpression  (  filterToken . getValue  ( ) , args ,  filterToken . getLineNumber  ( ) ) ; }   private  Expression  <  ? > parseTestInvocationExpression  ( )  {  TokenStream  stream =  parser . getStream  ( ) ;   int  lineNumber =   stream . current  ( ) . getLineNumber  ( ) ;  Token  testToken =  stream . expect  (   Token . Type . NAME ) ;  ArgumentsNode  args = null ;  if  (   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "(" ) )  {   args =  this . parseArguments  ( ) ; } else  {   args =  new ArgumentsNode  ( null , null ,  testToken . getLineNumber  ( ) ) ; }  return  new TestInvocationExpression  ( lineNumber ,  testToken . getValue  ( ) , args ) ; }   private  Expression  <  ? > parseBeanAttributeExpression  (   Expression  <  ? > node )  {  TokenStream  stream =  parser . getStream  ( ) ;  if  (   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "." ) )  {   stream . next  ( ) ;  Token  token =  stream . expect  (   Token . Type . NAME ) ;  ArgumentsNode  args = null ;  if  (   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "(" ) )  {   args =  this . parseArguments  ( ) ;  if  (  !   args . getNamedArgs  ( ) . isEmpty  ( ) )  {  throw  new ParserException  ( null , "Can not use named arguments when calling a bean method" ,   stream . current  ( ) . getLineNumber  ( ) ,  stream . getFilename  ( ) ) ; } }   node =  new GetAttributeExpression  ( node ,  new LiteralStringExpression  (  token . getValue  ( ) ,  token . getLineNumber  ( ) ) , args ,  stream . getFilename  ( ) ,  token . getLineNumber  ( ) ) ; } else  if  (   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "[" ) )  {   stream . next  ( ) ;   node =  new GetAttributeExpression  ( node ,  parseExpression  ( ) ,  stream . getFilename  ( ) ,   stream . current  ( ) . getLineNumber  ( ) ) ;   stream . expect  (   Token . Type . PUNCTUATION , "]" ) ; }  return node ; }   public ArgumentsNode parseArguments  ( )  {  return  parseArguments  ( false ) ; }   public ArgumentsNode parseArguments  (  boolean isMacroDefinition )  {   List  < PositionalArgumentNode >  positionalArgs =  new  ArrayList  < >  ( ) ;   List  < NamedArgumentNode >  namedArgs =  new  ArrayList  < >  ( ) ;    this . stream =   this . parser . getStream  ( ) ;   stream . expect  (   Token . Type . PUNCTUATION , "(" ) ;  while  (  !   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , ")" ) )  {  String  argumentName = null ;   Expression  <  ? >  argumentValue = null ;  if  (   !  namedArgs . isEmpty  ( ) ||  !  positionalArgs . isEmpty  ( ) )  {   stream . expect  (   Token . Type . PUNCTUATION , "," ) ; }  if  ( isMacroDefinition )  {   argumentName =  parseNewVariableName  ( ) ;  if  (   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "=" ) )  {   stream . expect  (   Token . Type . PUNCTUATION , "=" ) ;   argumentValue =  parseExpression  ( ) ; } } else  {  if  (   stream . peek  ( ) . test  (   Token . Type . PUNCTUATION , "=" ) )  {   argumentName =  parseNewVariableName  ( ) ;   stream . expect  (   Token . Type . PUNCTUATION , "=" ) ; }   argumentValue =  parseExpression  ( ) ; }  if  (  argumentName == null )  {  if  (  !  namedArgs . isEmpty  ( ) )  {  throw  new ParserException  ( null , "Positional arguments must be declared before any named arguments." ,   stream . current  ( ) . getLineNumber  ( ) ,  stream . getFilename  ( ) ) ; }   positionalArgs . add  (  new PositionalArgumentNode  ( argumentValue ) ) ; } else  {   namedArgs . add  (  new NamedArgumentNode  ( argumentName , argumentValue ) ) ; } }   stream . expect  (   Token . Type . PUNCTUATION , ")" ) ;  return  new ArgumentsNode  ( positionalArgs , namedArgs ,   stream . current  ( ) . getLineNumber  ( ) ) ; }   public String parseNewVariableName  ( )  {    this . stream =   this . parser . getStream  ( ) ;  Token  token =  stream . current  ( ) ;   token . test  (   Token . Type . NAME ) ;  if  (  RESERVED_KEYWORDS . contains  (  token . getValue  ( ) ) )  {  throw  new ParserException  ( null ,  String . format  ( "Can not assign a value to %s" ,  token . getValue  ( ) ) ,  token . getLineNumber  ( ) ,  stream . getFilename  ( ) ) ; }   stream . next  ( ) ;  return  token . getValue  ( ) ; }   private  Expression  <  ? > parseArrayDefinitionExpression  ( )  {  TokenStream  stream =  parser . getStream  ( ) ;   stream . expect  (   Token . Type . PUNCTUATION , "[" ) ;  if  (   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "]" ) )  {   stream . next  ( ) ;  return  new ArrayExpression  (   stream . current  ( ) . getLineNumber  ( ) ) ; }   List  <  Expression  <  ? > >  elements =  new  ArrayList  < >  ( ) ;  while  ( true )  {   Expression  <  ? >  expr =  parseExpression  ( ) ;   elements . add  ( expr ) ;  if  (   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "]" ) )  {  break ; }   stream . expect  (   Token . Type . PUNCTUATION , "," ) ; }   stream . expect  (   Token . Type . PUNCTUATION , "]" ) ;  return  new ArrayExpression  ( elements ,   stream . current  ( ) . getLineNumber  ( ) ) ; }   private  Expression  <  ? > parseMapDefinitionExpression  ( )  {  TokenStream  stream =  parser . getStream  ( ) ;   stream . expect  (   Token . Type . PUNCTUATION , "{" ) ;  if  (   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "}" ) )  {   stream . next  ( ) ;  return  new MapExpression  (   stream . current  ( ) . getLineNumber  ( ) ) ; }   Map  <  Expression  <  ? > ,  Expression  <  ? > >  elements =  new  HashMap  < >  ( ) ;  while  ( true )  {   Expression  <  ? >  keyExpr =  parseExpression  ( ) ;   stream . expect  (   Token . Type . PUNCTUATION , ":" ) ;   Expression  <  ? >  valueExpr =  parseExpression  ( ) ;   elements . put  ( keyExpr , valueExpr ) ;  if  (   stream . current  ( ) . test  (   Token . Type . PUNCTUATION , "}" ) )  {  break ; }   stream . expect  (   Token . Type . PUNCTUATION , "," ) ; }   stream . expect  (   Token . Type . PUNCTUATION , "}" ) ;  return  new MapExpression  ( elements ,   stream . current  ( ) . getLineNumber  ( ) ) ; } }