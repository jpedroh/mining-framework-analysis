  package    com . ebay . xcelite . reader ;   import     com . ebay . xcelite . annotate . NoConverterClass ;  import     com . ebay . xcelite . annotations . AnyColumn ;  import     com . ebay . xcelite . column . Col ;  import     com . ebay . xcelite . column . ColumnsExtractor ;  import     com . ebay . xcelite . converters . ColumnValueConverter ;  import     com . ebay . xcelite . exceptions . ColumnNotFoundException ;  import     com . ebay . xcelite . exceptions . EmptyCellException ;  import     com . ebay . xcelite . exceptions . XceliteException ;  import     com . ebay . xcelite . options . XceliteOptions ;  import     com . ebay . xcelite . policies . MissingCellPolicy ;  import     com . ebay . xcelite . sheet . XceliteSheet ;  import  lombok . SneakyThrows ;  import      org . apache . poi . ss . usermodel . Cell ;  import      org . apache . poi . ss . usermodel . DateUtil ;  import      org . apache . poi . ss . usermodel . Row ;  import   org . reflections . ReflectionUtils ;  import    java . lang . reflect . Field ;  import  java . util .  * ;  import    java . util . stream . Collectors ;  import static    org . reflections . ReflectionUtils . withName ;   public class BeanSheetReader  <  T >  extends  AbstractSheetReader  < T >  {   private final Col  anyColumn ;   private final ColumnsMapper  mapper ;   private final  Class  < T >  type ;   private  Map  < Integer , String >  headerColumns ;   public  @ Override boolean expectsHeaderRow  ( )  {  return true ; }   public BeanSheetReader  (  XceliteSheet sheet ,  XceliteOptions options ,   Class  < T > type )  {  super  ( sheet , options ) ;    this . type = type ;  ColumnsExtractor  extractor =  new ColumnsExtractor  ( type ) ;   extractor . extract  ( ) ;   anyColumn =  extractor . getAnyColumn  ( ) ;   LinkedHashSet  < Col >  declaredColumns =  extractor . getColumns  ( ) ;   mapper =  new ColumnsMapper  ( declaredColumns ) ; }   public BeanSheetReader  (  XceliteSheet sheet ,   Class  < T > type )  {  this  ( sheet ,  sheet . getOptions  ( ) , type ) ; } 
<<<<<<<
   @ Override  @ SneakyThrows public  Collection  < T > read  ( )  {   List  < T >  data =  new  ArrayList  < >  ( ) ;   int  lastNonEmptyRowId = 0 ;  boolean  firstIteration = true ;   rowIterator =  sheet . moveToHeaderRow  (  options . getHeaderRowIndex  ( ) , false ) ;  if  (  !  rowIterator . hasNext  ( ) )  return data ;   buildHeader  ( ) ;   validateColumns  ( ) ;   rowIterator =  sheet . moveToFirstDataRow  ( this , false ) ;  while  (  rowIterator . hasNext  ( ) )  {  T  object ;  Row  excelRow =  rowIterator . next  ( ) ;  if  ( firstIteration )  {   int  rowNum =  excelRow . getRowNum  ( ) ;  if  (   data . size  ( ) < rowNum )  {   int  firstDataRowIndex =  XceliteSheetImpl . getFirstDataRowIndex  ( this ) ;  for (   int  i = firstDataRowIndex ;  i < rowNum ;  i ++ )  {   data . add  (  handleEmptyRow  (   sheet . getNativeSheet  ( ) . getRow  ( i ) ) ) ; } }   firstIteration = false ; }  if  (  isBlankRow  ( excelRow ) )  {   object =  handleEmptyRow  ( excelRow ) ;  if  (  !   options . getMissingRowPolicy  ( ) . equals  ( SKIP ) )  {  if  (  shouldKeepObject  ( object , rowPostProcessors ) )  {   data . add  ( object ) ; } } } else  {   object =  fillObject  ( excelRow ) ;  if  (  shouldKeepObject  ( object , rowPostProcessors ) )  {   data . add  ( object ) ; }   lastNonEmptyRowId =  data . size  ( ) ; } }  return  applyTrailingEmptyRowPolicy  ( data , lastNonEmptyRowId ) ; }
=======
>>>>>>>
    @ SneakyThrows  @ Override public T fillObject  (  Row row )  {  T  object =  getNewObject  ( ) ;  for (   int  i = 0 ;  i <   headerColumns . keySet  ( ) . size  ( ) ;  i ++ )  {  String  columnName =  headerColumns . get  ( i ) ;   checkHasThrowPolicyMustThrow  ( row , i ) ;  Cell  cell =  row . getCell  ( i ,  MissingCellPolicy . toPoiMissingCellPolicy  (  options . getMissingCellPolicy  ( ) ) ) ;  Col  col =  mapper . getColumn  ( columnName ) ;  if  (  col != null )  {  Field  field =  getField  (  object . getClass  ( ) ,  col . getFieldName  ( ) ) ;   writeToField  ( field , object , cell , col ) ; } else  {  if  (  anyColumn != null )  {  Field  field =  getField  (  object . getClass  ( ) ,  anyColumn . getFieldName  ( ) ) ;  if  (  !  isColumnInIgnoreList  ( field , columnName ) )  {   writeToAnyColumnField  ( field , object , cell , columnName ) ; } } } }  return object ; }    @ SuppressWarnings  ( "unchecked" ) private Field getField  (   Class  <  ? > aClass ,  String name )  {  return    ReflectionUtils . getAllFields  ( aClass ,  withName  ( name ) ) . iterator  ( ) . next  ( ) ; }    @ SneakyThrows  @ Override T getNewObject  ( )  {  return  type . newInstance  ( ) ; }    @ Override protected void validateColumns  ( )  {  if  (  anyColumn != null )  {  return ; }   Collection  < String >  declaredHeaders =  mapper . getDeclaredHeaderNames  ( ) ;   Collection  < String >  headers =  headerColumns . values  ( ) ;  if  (  !  options . isHeaderParsingIsCaseSensitive  ( ) )  {   headers =    headers . stream  ( ) . map  (  n ->  {   n =   (  n == null ) ? null :  n . toLowerCase  ( ) ;  return n ; } ) . collect  (  Collectors . toList  ( ) ) ;   declaredHeaders =    declaredHeaders . stream  ( ) . map  (  n ->  {   n =   (  n == null ) ? null :  n . toLowerCase  ( ) ;  return n ; } ) . collect  (  Collectors . toList  ( ) ) ; }  if  (  !  headers . containsAll  ( declaredHeaders ) )  {   declaredHeaders . removeAll  ( headers ) ;   declaredHeaders =    declaredHeaders . stream  ( ) . filter  (   ( h ) ->  {  Col  col =  mapper . getColumn  ( h ) ;  Field  field =  getField  (  this . type ,  col . getFieldName  ( ) ) ;  return  (  !   field . getAnnotation  (      com . ebay . xcelite . annotations . Column . class ) . optional  ( ) ) ; } ) . collect  (  Collectors . toSet  ( ) ) ;  if  (   declaredHeaders . size  ( ) > 0 )  {  throw  new ColumnNotFoundException  (    declaredHeaders . stream  ( ) . limit  ( 10 ) . collect  (  Collectors . joining  ( ", " ) ) ) ; } } }   private static boolean isColumnInIgnoreList  (  Field anyColumnField ,  String columnName )  {  AnyColumn  annotation =  anyColumnField . getAnnotation  (  AnyColumn . class ) ;   Set  < String >  ignoreCols =   Arrays . stream  (  annotation . ignoreCols  ( ) ) . collect  (  Collectors . toSet  ( ) ) ;  return  ignoreCols . contains  ( columnName ) ; }    @ SuppressWarnings  ( "unchecked" )  @ SneakyThrows private void writeToAnyColumnField  (  Field field ,  T object ,  Cell cell ,  String columnName )  {   field . setAccessible  ( true ) ;  Object  cellValue =  readValueFromCell  ( cell ) ;  if  (   cellValue == null &&  (    field . getType  ( ) . equals  (  Boolean . class ) ||   field . getType  ( ) . equals  (  boolean . class ) ) )  {   cellValue =  Boolean . FALSE ; }  AnyColumn  annotation =  field . getAnnotation  (  AnyColumn . class ) ;  if  (   field . get  ( object ) == null )  {   Map  < String , Object >  map =  (  Map  < String , Object > )   annotation . as  ( ) . newInstance  ( ) ;   field . set  ( object , map ) ; }   Map  < String , Object >  map =  (  Map  < String , Object > )  field . get  ( object ) ;  if  (  cellValue != null )  {  if  (  !   annotation . converter  ( ) . equals  (  NoConverterClass . class ) )  {   ColumnValueConverter  < Object ,  ? >  converter =  (  ColumnValueConverter  < Object ,  ? > )   annotation . converter  ( ) . newInstance  ( ) ;   cellValue =  converter . deserialize  ( cellValue ) ; } }  if  (  options . isAnyColumnCreatesCollection  ( ) )  {  List  holder =  ( List )  map . get  ( columnName ) ;  if  (  null == holder )  {   holder =  new ArrayList  ( ) ; }   holder . add  ( cellValue ) ;   cellValue = holder ; }   map . put  ( columnName , cellValue ) ; }    @ SuppressWarnings  ( "unchecked" )  @ SneakyThrows private void writeToField  (  Field field ,  T object ,  Cell cell ,  Col column )  {  Object  cellValue =  readValueFromCell  ( cell ) ;  if  (   cellValue == null &&  (    field . getType  ( ) . equals  (  Boolean . class ) ||   field . getType  ( ) . equals  (  boolean . class ) ) )  {   cellValue =  Boolean . FALSE ; }  if  (  cellValue != null )  {  if  (   column . getConverter  ( ) != null )  {   ColumnValueConverter  < Object ,  ? >  converter =  (  ColumnValueConverter  < Object ,  ? > )   column . getConverter  ( ) . newInstance  ( ) ;   cellValue =  converter . deserialize  ( cellValue ) ; } else  {   cellValue =  convertToFieldType  ( cellValue ,  field . getType  ( ) ) ; }   field . setAccessible  ( true ) ;   field . set  ( object , cellValue ) ; } }   private static Object convertToFieldType  (  Object cellValue ,   Class  <  ? > fieldType )  {  String  value =  String . valueOf  ( cellValue ) ;  if  (   (  fieldType . equals  (  Double . class ) ) ||  (  fieldType . equals  (   double . class ) ) )  {  return  Double . valueOf  ( value ) ; } else  if  (   (  fieldType . equals  (  Integer . class ) ) ||  (  fieldType . equals  (   int . class ) ) )  {  return   Double . valueOf  ( value ) . intValue  ( ) ; } else  if  (   (  fieldType . equals  (  Short . class ) ) ||  (  fieldType . equals  (   short . class ) ) )  {  return   Double . valueOf  ( value ) . shortValue  ( ) ; } else  if  (   (  fieldType . equals  (  Long . class ) ) ||  (  fieldType . equals  (   long . class ) ) )  {  return   Double . valueOf  ( value ) . longValue  ( ) ; } else  if  (   (  fieldType . equals  (  Float . class ) ) ||  (  fieldType . equals  (   float . class ) ) )  {  return   Double . valueOf  ( value ) . floatValue  ( ) ; } else  if  (   (  fieldType . equals  (  Character . class ) ) ||  (  fieldType . equals  (   char . class ) ) )  {  return  value . charAt  ( 0 ) ; } else  if  (  fieldType . equals  (  Date . class ) )  {  return  DateUtil . getJavaDate  (  Double . valueOf  ( value ) ) ; } else  if  (   (  fieldType . equals  (  Boolean . class ) ) ||  (  fieldType . equals  (  boolean . class ) ) )  {  return  Boolean . valueOf  ( value ) ; }  return value ; }   private boolean checkHasThrowPolicyMustThrow  (  Row row ,   int colIdx )  {  MissingCellPolicy  policy =  options . getMissingCellPolicy  ( ) ;  if  (  policy . equals  (  MissingCellPolicy . THROW ) )  {  Cell  cell =  row . getCell  ( colIdx ,   Row . MissingCellPolicy . RETURN_BLANK_AS_NULL ) ;  if  (  null == cell )  {  String  colName =  headerColumns . get  ( colIdx ) ;  if  (  null != colName )  throw  new EmptyCellException  ( colName ) ; else  throw  new EmptyCellException  ( ) ; }  return true ; }  return false ; }   private class ColumnsMapper  {   private final  Map  < String , Col >  columnsMap ;   private final  Map  < String , Col >  lowerCaseColumnsMap ;  ColumnsMapper  (   Set  < Col > columns )  {   columnsMap =  new  LinkedHashMap  < >  ( ) ;   lowerCaseColumnsMap =  new  LinkedHashMap  < >  ( ) ;  for ( Col col : columns )  {   columnsMap . put  (  col . getName  ( ) , col ) ;   lowerCaseColumnsMap . put  (   col . getName  ( ) . toLowerCase  ( ) , col ) ; } }  Col getColumn  (  String name )  {  if  (   options . isHeaderParsingIsCaseSensitive  ( ) ||  (  null == name ) )  {  return  columnsMap . get  ( name ) ; } else  {  return  lowerCaseColumnsMap . get  (  name . toLowerCase  ( ) ) ; } }   Set  < String > getDeclaredHeaderNames  ( )  {  return     columnsMap . values  ( ) . stream  ( ) . map  ( 
<<<<<<<
 Col :: getName
=======
 c ->  c . getName  ( )
>>>>>>>
 ) . collect  (  Collectors . toSet  ( ) ) ; } }    @ Override protected void buildHeader  (  Row row )  {   headerColumns =  new  LinkedHashMap  < >  ( ) ;  if  (  row == null )  {  throw  new XceliteException  ( "First row in sheet is empty. First row must contain header" ) ; }  for (   int  i = 0 ;  i <  row . getLastCellNum  ( ) ;  i ++ )  {  if  (  !  checkHasThrowPolicyMustThrow  ( row , i ) )  {  Cell  cell =  row . getCell  ( i ,  MissingCellPolicy . toPoiMissingCellPolicy  (  options . getMissingCellPolicy  ( ) ) ) ;  String  cellValue = null ;  if  (  null != cell )  {   cellValue =  cell . getStringCellValue  ( ) ;  if  (   (  null == cellValue ) ||  (  cellValue . isEmpty  ( ) ) )   cellValue = null ; }   headerColumns . put  ( i , cellValue ) ; } } } }