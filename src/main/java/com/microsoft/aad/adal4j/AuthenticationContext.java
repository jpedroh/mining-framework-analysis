  package    com . microsoft . aad . adal4j ;   import    javax . net . ssl . SSLSocketFactory ;  import   java . net . MalformedURLException ;  import   java . net . Proxy ;  import   java . net . URI ;  import   java . net . URL ;  import   java . util . HashMap ;  import   java . util . Map ;  import    java . util . concurrent . ExecutorService ;  import    java . util . concurrent . Future ;  import    com . nimbusds . jwt . SignedJWT ;  import     com . nimbusds . oauth2 . sdk . AuthorizationCode ;  import     com . nimbusds . oauth2 . sdk . AuthorizationCodeGrant ;  import     com . nimbusds . oauth2 . sdk . ClientCredentialsGrant ;  import     com . nimbusds . oauth2 . sdk . JWTBearerGrant ;  import     com . nimbusds . oauth2 . sdk . ParseException ;  import     com . nimbusds . oauth2 . sdk . RefreshTokenGrant ;  import     com . nimbusds . oauth2 . sdk . ResourceOwnerPasswordCredentialsGrant ;  import      com . nimbusds . oauth2 . sdk . auth . ClientAuthentication ;  import      com . nimbusds . oauth2 . sdk . auth . ClientAuthenticationMethod ;  import      com . nimbusds . oauth2 . sdk . auth . ClientSecretPost ;  import      com . nimbusds . oauth2 . sdk . auth . PrivateKeyJWT ;  import      com . nimbusds . oauth2 . sdk . auth . Secret ;  import      com . nimbusds . oauth2 . sdk . id . ClientID ;  import      com . nimbusds . oauth2 . sdk . token . RefreshToken ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import   java . net . URLEncoder ;   public class AuthenticationContext  {   final Logger  log =  LoggerFactory . getLogger  (  AuthenticationContext . class ) ;   final AuthenticationAuthority  authenticationAuthority ;  String  correlationId ;   private String  authority ;   private final ExecutorService  service ;   private final boolean  validateAuthority ;  Proxy  proxy ;  SSLSocketFactory  sslSocketFactory ;   public AuthenticationContext  (   final String authority ,   final boolean validateAuthority ,   final ExecutorService service )  throws MalformedURLException  {  if  (  StringHelper . isBlank  ( authority ) )  {  throw  new IllegalArgumentException  ( "authority is null or empty" ) ; }  if  (  service == null )  {  throw  new IllegalArgumentException  ( "service is null" ) ; }    this . service = service ;    this . validateAuthority = validateAuthority ;    this . authority =  this . canonicalizeUri  ( authority ) ;   authenticationAuthority =  new AuthenticationAuthority  (  new URL  (  this . getAuthority  ( ) ) ,  this . shouldValidateAuthority  ( ) ) ; }   public Proxy getProxy  ( )  {  return proxy ; }   public void setProxy  (  Proxy proxy )  {    this . proxy = proxy ; }   public SSLSocketFactory getSslSocketFactory  ( )  {  return sslSocketFactory ; }   public void setSslSocketFactory  (  SSLSocketFactory sslSocketFactory )  {    this . sslSocketFactory = sslSocketFactory ; }   private String canonicalizeUri  (  String authority )  {  if  (  !  authority . endsWith  ( "/" ) )  {   authority += "/" ; }  return authority ; }   public  Future  < AuthenticationResult > acquireToken  (   final String resource ,   final String clientId ,   final String username ,   final String password ,   final AuthenticationCallback callback )  {  if  (  StringHelper . isBlank  ( resource ) )  {  throw  new IllegalArgumentException  ( "resource is null or empty" ) ; }  if  (  StringHelper . isBlank  ( clientId ) )  {  throw  new IllegalArgumentException  ( "clientId is null or empty" ) ; }  if  (  StringHelper . isBlank  ( username ) )  {  throw  new IllegalArgumentException  ( "username is null or empty" ) ; }  ClientAuthenticationPost  clientAuth =  new ClientAuthenticationPost  (  ClientAuthenticationMethod . NONE ,  new ClientID  ( clientId ) ) ;  if  (  password != null )  {  return  this . acquireToken  (  new AdalAuthorizatonGrant  (  new ResourceOwnerPasswordCredentialsGrant  ( username ,  new Secret  ( password ) ) , resource ) , clientAuth , callback ) ; } else  {  return  this . acquireTokenIntegrated  ( username , resource , clientAuth , callback ) ; } 
<<<<<<<
 return  this . acquireToken  (  new AdalOauthAuthorizationGrant  (  new ResourceOwnerPasswordCredentialsGrant  ( username ,  new Secret  ( password ) ) , resource ) ,  new ClientAuthenticationPost  (  ClientAuthenticationMethod . NONE ,  new ClientID  ( clientId ) ) , callback ) ;
=======
>>>>>>>
 }   public  Future  < AuthenticationResult > acquireToken  (   final String resource ,   final ClientAssertion clientAssertion ,   final AuthenticationCallback callback )  {   this . validateInput  ( resource , clientAssertion , true ) ;   final ClientAuthentication  clientAuth =  createClientAuthFromClientAssertion  ( clientAssertion ) ;   final AdalOauthAuthorizationGrant  authGrant =  new AdalOauthAuthorizationGrant  (  new ClientCredentialsGrant  ( ) , resource ) ;  return  this . acquireToken  ( authGrant , clientAuth , callback ) ; }   private void validateInput  (   final String resource ,   final Object credential ,   final boolean validateResource )  {  if  (  validateResource &&  StringHelper . isBlank  ( resource ) )  {  throw  new IllegalArgumentException  ( "resource is null or empty" ) ; }  if  (  credential == null )  {  throw  new IllegalArgumentException  ( "credential is null" ) ; } }   public  Future  < AuthenticationResult > acquireToken  (   final String resource ,   final UserAssertion userAssertion ,   final ClientCredential credential ,   final AuthenticationCallback callback )  {   this . validateInput  ( resource , credential , true ) ;   Map  < String , String >  params =  new  HashMap  < String , String >  ( ) ;   params . put  ( "resource" , resource ) ;   params . put  ( "requested_token_use" , "on_behalf_of" ) ;  try  {  AdalOauthAuthorizationGrant  grant =  new AdalOauthAuthorizationGrant  (  new JWTBearerGrant  (  SignedJWT . parse  (  userAssertion . getAssertion  ( ) ) ) , params ) ;   final ClientAuthentication  clientAuth =  new ClientSecretPost  (  new ClientID  (  credential . getClientId  ( ) ) ,  new Secret  (  credential . getClientSecret  ( ) ) ) ;  return  this . acquireToken  ( grant , clientAuth , callback ) ; }  catch (   final  Exception e )  {  throw  new AuthenticationException  ( e ) ; } }   public  Future  < AuthenticationResult > acquireToken  (   final String resource ,   final ClientCredential credential ,   final AuthenticationCallback callback )  {   this . validateInput  ( resource , credential , true ) ;   final ClientAuthentication  clientAuth =  new ClientSecretPost  (  new ClientID  (  credential . getClientId  ( ) ) ,  new Secret  (  credential . getClientSecret  ( ) ) ) ;   final AdalOauthAuthorizationGrant  authGrant =  new AdalOauthAuthorizationGrant  (  new ClientCredentialsGrant  ( ) , resource ) ;  return  this . acquireToken  ( authGrant , clientAuth , callback ) ; }   public  Future  < AuthenticationResult > acquireToken  (   final String resource ,   final AsymmetricKeyCredential credential ,   final AuthenticationCallback callback )  throws AuthenticationException  {  return  this . acquireToken  ( resource ,  JwtHelper . buildJwt  ( credential ,   this . authenticationAuthority . getSelfSignedJwtAudience  ( ) ) , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByAuthorizationCode  (   final String authorizationCode ,   final String resource ,   final String clientId ,   final URI redirectUri ,   final AuthenticationCallback callback )  {   final ClientAuthentication  clientAuth =  new ClientAuthenticationPost  (  ClientAuthenticationMethod . NONE ,  new ClientID  ( clientId ) ) ;   this . validateAuthCodeRequestInput  ( authorizationCode , redirectUri , clientAuth , resource ) ;   final AdalOauthAuthorizationGrant  authGrant =  new AdalOauthAuthorizationGrant  (  new AuthorizationCodeGrant  (  new AuthorizationCode  ( authorizationCode ) , redirectUri ) , resource ) ;  return  this . acquireToken  ( authGrant , clientAuth , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByAuthorizationCode  (   final String authorizationCode ,   final URI redirectUri ,   final ClientAssertion clientAssertion ,   final AuthenticationCallback callback )  {  return  acquireTokenByAuthorizationCode  ( authorizationCode , redirectUri , clientAssertion ,  ( String ) null , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByAuthorizationCode  (   final String authorizationCode ,   final URI redirectUri ,   final ClientAssertion clientAssertion ,   final String resource ,   final AuthenticationCallback callback )  {   this . validateAuthCodeRequestInput  ( authorizationCode , redirectUri , clientAssertion , resource ) ;   final ClientAuthentication  clientAuth =  createClientAuthFromClientAssertion  ( clientAssertion ) ;   final AdalOauthAuthorizationGrant  authGrant =  new AdalOauthAuthorizationGrant  (  new AuthorizationCodeGrant  (  new AuthorizationCode  ( authorizationCode ) , redirectUri ) , resource ) ;  return  this . acquireToken  ( authGrant , clientAuth , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByAuthorizationCode  (   final String authorizationCode ,   final URI redirectUri ,   final ClientCredential credential ,   final AuthenticationCallback callback )  {   this . validateAuthCodeRequestInput  ( authorizationCode , redirectUri , credential , null ) ;  return  this . acquireTokenByAuthorizationCode  ( authorizationCode , redirectUri , credential , null , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByAuthorizationCode  (   final String authorizationCode ,   final URI redirectUri ,   final ClientCredential credential ,   final String resource ,   final AuthenticationCallback callback )  {   this . validateAuthCodeRequestInput  ( authorizationCode , redirectUri , credential , resource ) ;   final ClientAuthentication  clientAuth =  new ClientSecretPost  (  new ClientID  (  credential . getClientId  ( ) ) ,  new Secret  (  credential . getClientSecret  ( ) ) ) ;   final AdalOauthAuthorizationGrant  authGrant =  new AdalOauthAuthorizationGrant  (  new AuthorizationCodeGrant  (  new AuthorizationCode  ( authorizationCode ) , redirectUri ) , resource ) ;  return  this . acquireToken  ( authGrant , clientAuth , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByAuthorizationCode  (   final String authorizationCode ,   final URI redirectUri ,   final AsymmetricKeyCredential credential ,   final AuthenticationCallback callback )  throws AuthenticationException  {  return  this . acquireTokenByAuthorizationCode  ( authorizationCode , redirectUri , credential , null , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByAuthorizationCode  (   final String authorizationCode ,   final URI redirectUri ,   final AsymmetricKeyCredential credential ,   final String resource ,   final AuthenticationCallback callback )  throws AuthenticationException  {   this . validateAuthCodeRequestInput  ( authorizationCode , redirectUri , credential , resource ) ;  return  this . acquireTokenByAuthorizationCode  ( authorizationCode , redirectUri ,  JwtHelper . buildJwt  ( credential ,   this . authenticationAuthority . getSelfSignedJwtAudience  ( ) ) , resource , callback ) ; }   public  Future  < DeviceCode > acquireDeviceCode  (   final String clientId ,   final String resource ,   final  AuthenticationCallback  < DeviceCode > callback )  {   validateDeviceCodeRequestInput  ( clientId , resource ) ;  return  service . submit  (  new AcquireDeviceCodeCallable  ( this , clientId , resource , callback ) ) ; }   public  Future  < AuthenticationResult > acquireTokenByDeviceCode  (   final DeviceCode deviceCode ,   final AuthenticationCallback callback )  throws AuthenticationException  {   final ClientAuthentication  clientAuth =  new ClientAuthenticationPost  (  ClientAuthenticationMethod . NONE ,  new ClientID  (  deviceCode . getClientId  ( ) ) ) ;   this . validateDeviceCodeRequestInput  ( deviceCode , clientAuth ,  deviceCode . getResource  ( ) ) ;   final AdalDeviceCodeAuthorizationGrant  deviceCodeGrant =  new AdalDeviceCodeAuthorizationGrant  ( deviceCode ,  deviceCode . getResource  ( ) ) ;  return  this . acquireToken  ( deviceCodeGrant , clientAuth , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByRefreshToken  (   final String refreshToken ,   final String clientId ,   final ClientAssertion clientAssertion ,   final AuthenticationCallback callback )  {  return  acquireTokenByRefreshToken  ( refreshToken , clientId , clientAssertion , null , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByRefreshToken  (   final String refreshToken ,   final String clientId ,   final ClientAssertion clientAssertion ,   final String resource ,   final AuthenticationCallback callback )  {   this . validateRefreshTokenRequestInput  ( refreshToken , clientId , clientAssertion ) ;   final ClientAuthentication  clientAuth =  createClientAuthFromClientAssertion  ( clientAssertion ) ;   final AdalOauthAuthorizationGrant  authGrant =  new AdalOauthAuthorizationGrant  (  new RefreshTokenGrant  (  new RefreshToken  ( refreshToken ) ) , resource ) ;  return  this . acquireToken  ( authGrant , clientAuth , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByRefreshToken  (   final String refreshToken ,   final ClientCredential credential ,   final AuthenticationCallback callback )  {  return  acquireTokenByRefreshToken  ( refreshToken , credential ,  ( String ) null , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByRefreshToken  (   final String refreshToken ,   final ClientCredential credential ,   final String resource ,   final AuthenticationCallback callback )  {   final ClientAuthentication  clientAuth =  new ClientSecretPost  (  new ClientID  (  credential . getClientId  ( ) ) ,  new Secret  (  credential . getClientSecret  ( ) ) ) ;   final AdalOauthAuthorizationGrant  authGrant =  new AdalOauthAuthorizationGrant  (  new RefreshTokenGrant  (  new RefreshToken  ( refreshToken ) ) , resource ) ;  return  this . acquireToken  ( authGrant , clientAuth , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByRefreshToken  (   final String refreshToken ,   final AsymmetricKeyCredential credential ,   final AuthenticationCallback callback )  throws AuthenticationException  {  return  acquireTokenByRefreshToken  ( refreshToken , credential ,  ( String ) null , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByRefreshToken  (   final String refreshToken ,   final AsymmetricKeyCredential credential ,   final String resource ,   final AuthenticationCallback callback )  throws AuthenticationException  {  return  acquireTokenByRefreshToken  ( refreshToken ,  credential . getClientId  ( ) ,  JwtHelper . buildJwt  ( credential ,   this . authenticationAuthority . getSelfSignedJwtAudience  ( ) ) , resource , callback ) ; }   public  Future  < AuthenticationResult > acquireTokenByRefreshToken  (   final String refreshToken ,   final String clientId ,   final AuthenticationCallback callback )  {  return  acquireTokenByRefreshToken  ( refreshToken , clientId ,  ( String ) null , callback ) ; }   private  Future  < AuthenticationResult > acquireToken  (   final AdalAuthorizationGrant authGrant ,   final ClientAuthentication clientAuth ,   final  AuthenticationCallback  < AuthenticationResult > callback )  {  return  service . submit  (  new AcquireTokenCallable  ( this , authGrant , clientAuth , callback ) ) ; }   private void validateDeviceCodeRequestInput  (  String clientId ,  String resource )  {  if  (  StringHelper . isBlank  ( clientId ) )  {  throw  new IllegalArgumentException  ( "clientId is null or empty" ) ; }  if  (  StringHelper . isBlank  ( resource ) )  {  throw  new IllegalArgumentException  ( "resource is null or empty" ) ; }  if  (   AuthorityType . ADFS . equals  (  authenticationAuthority . getAuthorityType  ( ) ) )  {  throw  new IllegalArgumentException  ( "Invalid authority type. Device Flow is not supported by ADFS authority" ) ; } }   public  Future  < AuthenticationResult > acquireTokenByRefreshToken  (   final String refreshToken ,   final String clientId ,   final String resource ,   final AuthenticationCallback callback )  {   final ClientAuthentication  clientAuth =  new ClientAuthenticationPost  (  ClientAuthenticationMethod . NONE ,  new ClientID  ( clientId ) ) ;   final AdalOauthAuthorizationGrant  authGrant =  new AdalOauthAuthorizationGrant  (  new RefreshTokenGrant  (  new RefreshToken  ( refreshToken ) ) , resource ) ;  return  this . acquireToken  ( authGrant , clientAuth , callback ) ; }   private void validateRefreshTokenRequestInput  (   final String refreshToken ,   final String clientId ,   final Object credential )  {  if  (  StringHelper . isBlank  ( refreshToken ) )  {  throw  new IllegalArgumentException  ( "refreshToken is null or empty" ) ; }  if  (  StringHelper . isBlank  ( clientId ) )  {  throw  new IllegalArgumentException  ( "clientId is null or empty" ) ; }   this . validateInput  ( null , credential , false ) ; }  AuthenticationResult acquireTokenCommon  (   final AdalAuthorizationGrant authGrant ,   final ClientAuthentication clientAuth ,   final ClientDataHttpHeaders headers )  throws Exception  {   log . debug  (  LogHelper . createMessage  (  String . format  ( "Using Client Http Headers: %s" , headers ) ,  headers . getHeaderCorrelationIdValue  ( ) ) ) ;    this . authenticationAuthority . doInstanceDiscovery  (  headers . getReadonlyHeaderMap  ( ) ,  this . proxy ,  this . sslSocketFactory ) ;   final URL  url =  new URL  (   this . authenticationAuthority . getTokenUri  ( ) ) ;   final AdalTokenRequest  request =  new AdalTokenRequest  ( url , clientAuth , authGrant ,  headers . getReadonlyHeaderMap  ( ) ,  this . proxy ,  this . sslSocketFactory ) ;  AuthenticationResult  result =  request . executeOAuthRequestAndProcessResponse  ( ) ;  return result ; }   private ClientAuthentication createClientAuthFromClientAssertion  (   final ClientAssertion clientAssertion )  {  try  {   final  Map  < String , String >  map =  new  HashMap  < String , String >  ( ) ;   map . put  ( "client_assertion_type" ,  clientAssertion . getAssertionType  ( ) ) ;   map . put  ( "client_assertion" ,  clientAssertion . getAssertion  ( ) ) ;  return  PrivateKeyJWT . parse  ( map ) ; }  catch (   final  ParseException e )  {  throw  new AuthenticationException  ( e ) ; } }   public String getCorrelationId  ( )  {  return correlationId ; }   public void setCorrelationId  (   final String correlationId )  {    this . correlationId = correlationId ; }   public boolean shouldValidateAuthority  ( )  {  return  this . validateAuthority ; }   public String getAuthority  ( )  {  return  this . authority ; }   private void validateAuthCodeRequestInput  (   final String authorizationCode ,   final URI redirectUri ,   final Object clientCredential ,   final String resource )  {  if  (  StringHelper . isBlank  ( authorizationCode ) )  {  throw  new IllegalArgumentException  ( "authorization code is null or empty" ) ; }  if  (  redirectUri == null )  {  throw  new IllegalArgumentException  ( "redirect uri is null" ) ; }   this . validateInput  ( resource , clientCredential , false ) ; }   private void validateDeviceCodeRequestInput  (   final DeviceCode deviceCode ,   final Object credential ,   final String resource )  {  if  (  StringHelper . isBlank  (  deviceCode . getDeviceCode  ( ) ) )  {  throw  new IllegalArgumentException  ( "device code is null or empty" ) ; }  if  (  StringHelper . isBlank  (  deviceCode . getCorrelationId  ( ) ) )  {  throw  new IllegalArgumentException  ( "correlation id in device code is null or empty" ) ; }   this . validateInput  ( resource , credential , true ) ; }   private final Logger  piiLog =  LoggerFactory . getLogger  (   LogHelper . PII_LOGGER_PREFIX +  AuthenticationContext . class ) ; 
<<<<<<<
=======
  private  Future  < AuthenticationResult > acquireToken  (   final AdalAuthorizatonGrant authGrant ,   final ClientAuthentication clientAuth ,   final AuthenticationCallback callback )  {  return  service . submit  (   new  Callable  < AuthenticationResult >  ( )  {   private AdalAuthorizatonGrant  authGrant ;   private ClientAuthentication  clientAuth ;   private ClientDataHttpHeaders  headers ;    @ Override public AuthenticationResult call  ( )  throws Exception  {  AuthenticationResult  result = null ;  try  {    this . authGrant =  processPasswordGrant  (  this . authGrant ) ;   result =  acquireTokenCommon  (  this . authGrant ,  this . clientAuth ,  this . headers ) ;   logResult  ( result , headers ) ;  if  (  callback != null )  {   callback . onSuccess  ( result ) ; } }  catch (   final  Exception ex )  {  String  msg =  LogHelper . createMessage  ( "Request to acquire token failed." ,   this . headers . getHeaderCorrelationIdValue  ( ) ) ;   log . error  (   msg +  System . getProperty  ( "line.separator" ) +  LogHelper . getPiiScrubbedDetails  ( ex ) ) ;   piiLog . error  ( msg , ex ) ;  if  (  callback != null )  {   callback . onFailure  ( ex ) ; } else  {  throw ex ; } }  return result ; }   private  Callable  < AuthenticationResult > init  (   final AdalAuthorizatonGrant authGrant ,   final ClientAuthentication clientAuth ,   final ClientDataHttpHeaders headers )  {    this . authGrant = authGrant ;    this . clientAuth = clientAuth ;    this . headers = headers ;  return this ; } } . init  ( authGrant , clientAuth ,  new ClientDataHttpHeaders  (  this . getCorrelationId  ( ) ) ) ) ; }
>>>>>>>
   private  Future  < AuthenticationResult > acquireTokenIntegrated  (  String userName ,   final String resource ,   final ClientAuthentication clientAuth ,   final AuthenticationCallback callback )  {  return  service . submit  (   new  Callable  < AuthenticationResult >  ( )  {   private String  userName ;   private String  resource ;   private ClientAuthentication  clientAuth ;   private ClientDataHttpHeaders  headers ;    @ Override public AuthenticationResult call  ( )  throws Exception  {  AuthenticationResult  result = null ;  try  {  AdalAuthorizatonGrant  authGrant =  new AdalAuthorizatonGrant  (  getAuthorizationGrantIntegrated  (  this . userName ) ,  this . resource ) ;   result =  acquireTokenCommon  ( authGrant ,  this . clientAuth ,  this . headers ) ;   logResult  ( result , headers ) ;  if  (  callback != null )  {   callback . onSuccess  ( result ) ; } }  catch (   final  Exception ex )  {   log . error  (  LogHelper . createMessage  ( "Request to acquire token failed." ,   this . headers . getHeaderCorrelationIdValue  ( ) ) , ex ) ;  if  (  callback != null )  {   callback . onFailure  ( ex ) ; } else  {  throw ex ; } }  return result ; }   private  Callable  < AuthenticationResult > init  (  String userName ,   final String resource ,   final ClientAuthentication clientAuth ,   final ClientDataHttpHeaders headers )  {    this . userName = userName ;    this . resource = resource ;    this . clientAuth = clientAuth ;    this . headers = headers ;  return this ; } } . init  ( userName , resource , clientAuth ,  new ClientDataHttpHeaders  (  this . getCorrelationId  ( ) ) ) ) ; }  AuthorizationGrant getAuthorizationGrantIntegrated  (  String userName )  throws Exception  {  AuthorizationGrant  updatedGrant ;  String  userRealmEndpoint =  authenticationAuthority . getUserRealmEndpoint  (  URLEncoder . encode  ( userName , "UTF-8" ) ) ;  UserDiscoveryResponse  userRealmResponse =  UserDiscoveryRequest . execute  ( userRealmEndpoint , proxy , sslSocketFactory ) ;  if  (   userRealmResponse . isAccountFederated  ( ) &&  "WSTrust" . equalsIgnoreCase  (  userRealmResponse . getFederationProtocol  ( ) ) )  {  String  mexURL =  userRealmResponse . getFederationMetadataUrl  ( ) ;  String  cloudAudienceUrn =  userRealmResponse . getCloudAudienceUrn  ( ) ;  WSTrustResponse  wsTrustResponse =  WSTrustRequest . execute  ( mexURL , cloudAudienceUrn , proxy , sslSocketFactory ) ;  if  (  wsTrustResponse . isTokenSaml2  ( ) )  {   updatedGrant =  new SAML2BearerGrant  (  new Base64URL  (  Base64 . encodeBase64String  (   wsTrustResponse . getToken  ( ) . getBytes  ( "UTF-8" ) ) ) ) ; } else  {   updatedGrant =  new SAML11BearerGrant  (  new Base64URL  (  Base64 . encodeBase64String  (   wsTrustResponse . getToken  ( ) . getBytes  ( ) ) ) ) ; } } else  if  (  userRealmResponse . isAccountManaged  ( ) )  {  throw  new AuthenticationException  ( "Password is required for managed user" ) ; } else  {  throw  new AuthenticationException  ( "Unknown User Type" ) ; }  return updatedGrant ; } 
<<<<<<<
=======
  private AuthenticationResult acquireTokenCommon  (   final AdalAuthorizatonGrant authGrant ,   final ClientAuthentication clientAuth ,   final ClientDataHttpHeaders headers )  throws Exception  {  String  msg =  LogHelper . createMessage  (  String . format  ( "Using Client Http Headers: %s" , headers ) ,  headers . getHeaderCorrelationIdValue  ( ) ) ;   piiLog . debug  ( msg ) ;    this . authenticationAuthority . doInstanceDiscovery  (  headers . getReadonlyHeaderMap  ( ) ,  this . proxy ,  this . sslSocketFactory ) ;   final URL  url =  new URL  (   this . authenticationAuthority . getTokenUri  ( ) ) ;   final AdalTokenRequest  request =  new AdalTokenRequest  ( url , clientAuth , authGrant ,  headers . getReadonlyHeaderMap  ( ) ,  this . proxy ,  this . sslSocketFactory ) ;  AuthenticationResult  result =  request . executeOAuthRequestAndProcessResponse  ( ) ;  return result ; }
>>>>>>>
 
<<<<<<<
=======
  private void logResult  (  AuthenticationResult result ,  ClientDataHttpHeaders headers )  throws NoSuchAlgorithmException , UnsupportedEncodingException  {  if  (  !  StringHelper . isBlank  (  result . getAccessToken  ( ) ) )  {  String  logMessage = "" ;  String  piiLogMessage = "" ;  String  accessTokenHash =  this . computeSha256Hash  (  result . getAccessToken  ( ) ) ;  if  (  !  StringHelper . isBlank  (  result . getRefreshToken  ( ) ) )  {  String  refreshTokenHash =  this . computeSha256Hash  (  result . getRefreshToken  ( ) ) ;   logMessage = "Access Token and Refresh Token were returned" ;   piiLogMessage =  String . format  ( "Access Token with hash '%s' and Refresh Token with hash '%s' returned" , accessTokenHash , refreshTokenHash ) ; } else  {   logMessage = "Access Token was returned" ;   piiLogMessage =  String . format  ( "Access Token with hash '%s' returned" , accessTokenHash ) ; }   log . debug  (  LogHelper . createMessage  ( logMessage ,  headers . getHeaderCorrelationIdValue  ( ) ) ) ;   piiLog . debug  (  LogHelper . createMessage  ( piiLogMessage ,  headers . getHeaderCorrelationIdValue  ( ) ) ) ; } }
>>>>>>>
 }