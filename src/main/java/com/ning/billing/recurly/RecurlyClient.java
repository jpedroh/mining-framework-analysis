  package    com . ning . billing . recurly ;   import   java . io . IOException ;  import   java . io . InputStream ;  import   java . io . Reader ;  import   java . math . BigDecimal ;  import   java . net . URL ;  import    java . nio . charset . Charset ;  import   java . util . NoSuchElementException ;  import   java . util . Properties ;  import   java . util . Scanner ;  import    java . util . concurrent . ExecutionException ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import   javax . annotation . Nullable ;  import    javax . xml . bind . DatatypeConverter ;  import    org . joda . time . DateTime ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import      com . ning . billing . recurly . model . Account ;  import      com . ning . billing . recurly . model . Accounts ;  import      com . ning . billing . recurly . model . AddOn ;  import      com . ning . billing . recurly . model . AddOns ;  import      com . ning . billing . recurly . model . Adjustment ;  import      com . ning . billing . recurly . model . Adjustments ;  import      com . ning . billing . recurly . model . BillingInfo ;  import      com . ning . billing . recurly . model . Coupon ;  import      com . ning . billing . recurly . model . Coupons ;  import      com . ning . billing . recurly . model . Errors ;  import      com . ning . billing . recurly . model . Invoice ;  import      com . ning . billing . recurly . model . Invoices ;  import      com . ning . billing . recurly . model . Plan ;  import      com . ning . billing . recurly . model . Plans ;  import      com . ning . billing . recurly . model . RecurlyAPIError ;  import      com . ning . billing . recurly . model . RecurlyObject ;  import      com . ning . billing . recurly . model . RecurlyObjects ;  import      com . ning . billing . recurly . model . Redemption ;  import      com . ning . billing . recurly . model . RefundOption ;  import      com . ning . billing . recurly . model . Subscription ;  import      com . ning . billing . recurly . model . SubscriptionUpdate ;  import      com . ning . billing . recurly . model . SubscriptionNotes ;  import      com . ning . billing . recurly . model . Subscriptions ;  import      com . ning . billing . recurly . model . Transaction ;  import      com . ning . billing . recurly . model . Transactions ;  import     com . ning . http . client . AsyncHttpClient ;  import     com . ning . http . client . AsyncHttpClientConfig ;  import     com . ning . http . client . Response ;  import      com . fasterxml . jackson . dataformat . xml . XmlMapper ;  import     com . google . common . annotations . VisibleForTesting ;  import     com . google . common . base . Objects ;  import     com . google . common . base . StandardSystemProperty ;  import     com . google . common . io . CharSource ;  import     com . google . common . io . Resources ;  import     com . google . common . net . HttpHeaders ;  import   java . security . GeneralSecurityException ;  import   java . security . KeyManagementException ;  import   java . security . NoSuchAlgorithmException ;  import      com . ning . billing . recurly . model . Redemptions ;  import       com . ning . billing . recurly . util . http . SslUtils ;   public class RecurlyClient  {   private static final Logger  log =  LoggerFactory . getLogger  (  RecurlyClient . class ) ;   public static final String  RECURLY_DEBUG_KEY = "recurly.debug" ;   public static final String  RECURLY_PAGE_SIZE_KEY = "recurly.page.size" ;   private static final Integer  DEFAULT_PAGE_SIZE = 20 ;   private static final String  PER_PAGE = "per_page=" ;   private static final String  X_RECORDS_HEADER_NAME = "X-Records" ;   private static final String  LINK_HEADER_NAME = "Link" ;   private static final String  GIT_PROPERTIES_FILE = "com/ning/billing/recurly/git.properties" ;    @ VisibleForTesting static final String  GIT_COMMIT_ID_DESCRIBE_SHORT = "git.commit.id.describe-short" ;   private static final Pattern  TAG_FROM_GIT_DESCRIBE_PATTERN =  Pattern . compile  ( "recurly-java-library-([0-9]*\\.[0-9]*\\.[0-9]*)(-[0-9]*)?" ) ;   public static final String  FETCH_RESOURCE = "/recurly_js/result" ;   private static boolean debug  ( )  {  return  Boolean . getBoolean  ( RECURLY_DEBUG_KEY ) ; }   public static Integer getPageSize  ( )  {  Integer  pageSize ;  try  {   pageSize =  new Integer  (  System . getProperty  ( RECURLY_PAGE_SIZE_KEY ) ) ; }  catch (   NumberFormatException nfex )  {   pageSize = DEFAULT_PAGE_SIZE ; }  return pageSize ; }   public static String getPageSizeGetParam  ( )  {  return  PER_PAGE +   getPageSize  ( ) . toString  ( ) ; }   private final XmlMapper  xmlMapper ;   private final String  userAgent ;   private final String  key ;   private final String  baseUrl ;   private AsyncHttpClient  client ;   public RecurlyClient  (   final String apiKey )  {  this  ( apiKey , "api" ) ; }   public RecurlyClient  (   final String apiKey ,   final String subDomain )  {  this  ( apiKey ,  subDomain + ".recurly.com" , 443 , "v2" ) ; }   public RecurlyClient  (   final String apiKey ,   final String host ,   final  int port ,   final String version )  {    this . key =  DatatypeConverter . printBase64Binary  (  apiKey . getBytes  ( ) ) ;    this . baseUrl =  String . format  ( "https://%s:%d/%s" , host , port , version ) ;    this . xmlMapper =  RecurlyObject . newXmlMapper  ( ) ;    this . userAgent =  buildUserAgent  ( ) ; }   public synchronized void open  ( )  throws NoSuchAlgorithmException , KeyManagementException  {   client =  createHttpClient  ( ) ; }   public synchronized void close  ( )  {  if  (  client != null )  {   client . close  ( ) ; } }   public Account createAccount  (   final Account account )  {  return  doPOST  (  Account . ACCOUNT_RESOURCE , account ,  Account . class ) ; }   public Accounts getAccounts  ( )  {  return  doGET  (  Accounts . ACCOUNTS_RESOURCE ,  Accounts . class ) ; }   public Coupons getCoupons  ( )  {  return  doGET  (  Coupons . COUPONS_RESOURCE ,  Coupons . class ) ; }   public Account getAccount  (   final String accountCode )  {  return  doGET  (    Account . ACCOUNT_RESOURCE + "/" + accountCode ,  Account . class ) ; }   public Account updateAccount  (   final String accountCode ,   final Account account )  {  return  doPUT  (    Account . ACCOUNT_RESOURCE + "/" + accountCode , account ,  Account . class ) ; }   public void closeAccount  (   final String accountCode )  {   doDELETE  (    Account . ACCOUNT_RESOURCE + "/" + accountCode ) ; }   public Adjustments getAccountAdjustments  (   final String accountCode ,   final  Adjustments . AdjustmentType type )  {  return  getAccountAdjustments  ( accountCode , type , null ) ; }   public Adjustments getAccountAdjustments  (   final String accountCode ,   final  Adjustments . AdjustmentType type ,   final  Adjustments . AdjustmentState state )  {  String  url =     Account . ACCOUNT_RESOURCE + "/" + accountCode +  Adjustments . ADJUSTMENTS_RESOURCE ;  if  (   type != null ||  state != null )  {   url += "?" ; }  if  (  type != null )  {   url +=  "type=" +  type . getType  ( ) ;  if  (  state != null )  {   url += "&" ; } }  if  (  state != null )  {   url +=  "state=" +  state . getState  ( ) ; }  return  doGET  ( url ,  Adjustments . class ) ; }   public Adjustment createAccountAdjustment  (   final String accountCode ,   final Adjustment adjustment )  {  return  doPOST  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  Adjustments . ADJUSTMENTS_RESOURCE , adjustment ,  Adjustment . class ) ; }   public void deleteAccountAdjustment  (   final String accountCode )  {   doDELETE  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  Adjustments . ADJUSTMENTS_RESOURCE ) ; }   public Subscription createSubscription  (   final Subscription subscription )  {  return  doPOST  (  Subscription . SUBSCRIPTION_RESOURCE , subscription ,  Subscription . class ) ; }   public Subscription previewSubscription  (   final Subscription subscription )  {  return  doPOST  (   Subscription . SUBSCRIPTION_RESOURCE + "/preview" , subscription ,  Subscription . class ) ; }   public Subscription getSubscription  (   final String uuid )  {  return  doGET  (    Subscriptions . SUBSCRIPTIONS_RESOURCE + "/" + uuid ,  Subscription . class ) ; }   public Subscription cancelSubscription  (   final Subscription subscription )  {  return  doPUT  (     Subscription . SUBSCRIPTION_RESOURCE + "/" +  subscription . getUuid  ( ) + "/cancel" , subscription ,  Subscription . class ) ; }   public Subscription postponeSubscription  (   final Subscription subscription ,   final DateTime renewaldate )  {  return  doPUT  (      Subscription . SUBSCRIPTION_RESOURCE + "/" +  subscription . getUuid  ( ) + "/postpone?next_renewal_date=" + renewaldate , subscription ,  Subscription . class ) ; }   public void terminateSubscription  (   final Subscription subscription ,   final RefundOption refund )  {   doPUT  (      Subscription . SUBSCRIPTION_RESOURCE + "/" +  subscription . getUuid  ( ) + "/terminate?refund=" + refund , subscription ,  Subscription . class ) ; }   public Subscription reactivateSubscription  (   final Subscription subscription )  {  return  doPUT  (     Subscription . SUBSCRIPTION_RESOURCE + "/" +  subscription . getUuid  ( ) + "/reactivate" , subscription ,  Subscription . class ) ; }   public Subscription updateSubscription  (   final String uuid ,   final SubscriptionUpdate subscriptionUpdate )  {  return  doPUT  (    Subscriptions . SUBSCRIPTIONS_RESOURCE + "/" + uuid , subscriptionUpdate ,  Subscription . class ) ; }   public Subscription updateSubscriptionPreview  (   final String uuid ,   final SubscriptionUpdate subscriptionUpdate )  {  return  doPOST  (     Subscriptions . SUBSCRIPTIONS_RESOURCE + "/" + uuid + "/preview" , subscriptionUpdate ,  Subscription . class ) ; }   public Subscription updateSubscriptionNotes  (   final String uuid ,   final SubscriptionNotes subscriptionNotes )  {  return  doPUT  (     SubscriptionNotes . SUBSCRIPTION_RESOURCE + "/" + uuid + "/notes" , subscriptionNotes ,  Subscription . class ) ; }   public Subscriptions getAccountSubscriptions  (   final String accountCode )  {  return  doGET  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  Subscriptions . SUBSCRIPTIONS_RESOURCE ,  Subscriptions . class ) ; }   public Subscriptions getAccountSubscriptions  (   final String accountCode ,   final String status )  {  return  doGET  (       Account . ACCOUNT_RESOURCE + "/" + accountCode +  Subscriptions . SUBSCRIPTIONS_RESOURCE + "?state=" + status ,  Subscriptions . class ) ; }   public BillingInfo createOrUpdateBillingInfo  (   final BillingInfo billingInfo )  {   final String  accountCode =   billingInfo . getAccount  ( ) . getAccountCode  ( ) ;   billingInfo . setAccount  ( null ) ;  return  doPUT  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  BillingInfo . BILLING_INFO_RESOURCE , billingInfo ,  BillingInfo . class ) ; }   public BillingInfo getBillingInfo  (   final String accountCode )  {  return  doGET  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  BillingInfo . BILLING_INFO_RESOURCE ,  BillingInfo . class ) ; }   public void clearBillingInfo  (   final String accountCode )  {   doDELETE  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  BillingInfo . BILLING_INFO_RESOURCE ) ; }   public Transactions getAccountTransactions  (   final String accountCode )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Transactions . TRANSACTIONS_RESOURCE ,  Transactions . class ) ; }   public Transaction getTransaction  (   final String transactionId )  {  return  doGET  (    Transactions . TRANSACTIONS_RESOURCE + "/" + transactionId ,  Transaction . class ) ; }   public Transaction createTransaction  (   final Transaction trans )  {  return  doPOST  (  Transactions . TRANSACTIONS_RESOURCE , trans ,  Transaction . class ) ; }   public void refundTransaction  (   final String transactionId ,    @ Nullable final BigDecimal amount )  {  String  url =    Transactions . TRANSACTIONS_RESOURCE + "/" + transactionId ;  if  (  amount != null )  {   url =   url + "?amount_in_cents=" +  (   amount . intValue  ( ) * 100 ) ; }   doDELETE  ( url ) ; }   public Invoice getInvoice  (   final Integer invoiceId )  {  return  doGET  (    Invoices . INVOICES_RESOURCE + "/" + invoiceId ,  Invoice . class ) ; }   public Invoices getAccountInvoices  (   final String accountCode )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Invoices . INVOICES_RESOURCE ,  Invoices . class ) ; }   public Invoice postAccountInvoice  (   final String accountCode ,   final Invoice invoice )  {  return  doPOST  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Invoices . INVOICES_RESOURCE , invoice ,  Invoice . class ) ; }   public Invoice markInvoiceSuccessful  (   final Integer invoiceId )  {  return  doPUT  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId + "/mark_successful" , null ,  Invoice . class ) ; }   public Invoice markInvoiceFailed  (   final Integer invoiceId )  {  return  doPUT  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId + "/mark_failed" , null ,  Invoice . class ) ; }   public Transaction enterOfflinePayment  (   final Integer invoiceId ,   final Transaction payment )  {  return  doPOST  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId + "/transactions" , payment ,  Transaction . class ) ; }   public Plan createPlan  (   final Plan plan )  {  return  doPOST  (  Plan . PLANS_RESOURCE , plan ,  Plan . class ) ; }   public Plan updatePlan  (   final Plan plan )  {  return  doPUT  (    Plan . PLANS_RESOURCE + "/" +  plan . getPlanCode  ( ) , plan ,  Plan . class ) ; }   public Plan getPlan  (   final String planCode )  {  return  doGET  (    Plan . PLANS_RESOURCE + "/" + planCode ,  Plan . class ) ; }   public Plans getPlans  ( )  {  return  doGET  (  Plans . PLANS_RESOURCE ,  Plans . class ) ; }   public void deletePlan  (   final String planCode )  {   doDELETE  (    Plan . PLANS_RESOURCE + "/" + planCode ) ; }   public AddOn createPlanAddOn  (   final String planCode ,   final AddOn addOn )  {  return  doPOST  (     Plan . PLANS_RESOURCE + "/" + planCode +  AddOn . ADDONS_RESOURCE , addOn ,  AddOn . class ) ; }   public AddOn getAddOn  (   final String planCode ,   final String addOnCode )  {  return  doGET  (       Plan . PLANS_RESOURCE + "/" + planCode +  AddOn . ADDONS_RESOURCE + "/" + addOnCode ,  AddOn . class ) ; }   public AddOns getAddOns  (   final String planCode )  {  return  doGET  (     Plan . PLANS_RESOURCE + "/" + planCode +  AddOn . ADDONS_RESOURCE ,  AddOns . class ) ; }   public void deleteAddOn  (   final String planCode ,   final String addOnCode )  {   doDELETE  (       Plan . PLANS_RESOURCE + "/" + planCode +  AddOn . ADDONS_RESOURCE + "/" + addOnCode ) ; }   public Coupon createCoupon  (   final Coupon coupon )  {  return  doPOST  (  Coupon . COUPON_RESOURCE , coupon ,  Coupon . class ) ; }   public Coupon getCoupon  (   final String couponCode )  {  return  doGET  (    Coupon . COUPON_RESOURCE + "/" + couponCode ,  Coupon . class ) ; }   public void deleteCoupon  (   final String couponCode )  {   doDELETE  (    Coupon . COUPON_RESOURCE + "/" + couponCode ) ; }   public Redemption redeemCoupon  (   final String couponCode ,   final Redemption redemption )  {  return  doPOST  (     Coupon . COUPON_RESOURCE + "/" + couponCode +  Redemption . REDEEM_RESOURCE , redemption ,  Redemption . class ) ; }   public Redemption getCouponRedemptionByAccount  (   final String accountCode )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Redemption . REDEMPTION_RESOURCE ,  Redemption . class ) ; }   public Redemption getCouponRedemptionByInvoice  (   final Integer invoiceNumber )  {  return  doGET  (     Invoices . INVOICES_RESOURCE + "/" + invoiceNumber +  Redemption . REDEMPTION_RESOURCE ,  Redemption . class ) ; }   public void deleteCouponRedemption  (   final String accountCode )  {   doDELETE  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Redemption . REDEMPTION_RESOURCE ) ; }   public Subscription fetchSubscription  (   final String recurlyToken )  {  return  fetch  ( recurlyToken ,  Subscription . class ) ; }   public BillingInfo fetchBillingInfo  (   final String recurlyToken )  {  return  fetch  ( recurlyToken ,  BillingInfo . class ) ; }   public Invoice fetchInvoice  (   final String recurlyToken )  {  return  fetch  ( recurlyToken ,  Invoice . class ) ; }   private  <  T > T fetch  (   final String recurlyToken ,   final  Class  < T > clazz )  {  return  doGET  (   FETCH_RESOURCE + "/" + recurlyToken , clazz ) ; }   private  <  T > T doGET  (   final String resource ,   final  Class  < T > clazz )  {   final StringBuffer  url =  new StringBuffer  ( baseUrl ) ;   url . append  ( resource ) ;  if  (   resource != null &&  !  resource . contains  ( "?" ) )  {   url . append  ( "?" ) ; } else  {   url . append  ( "&" ) ;   url . append  ( "&" ) ; }   url . append  (  getPageSizeGetParam  ( ) ) ;  return  doGETWithFullURL  ( clazz ,  url . toString  ( ) ) ; }   public  <  T > T doGETWithFullURL  (   final  Class  < T > clazz ,   final String url )  {  if  (  debug  ( ) )  {   log . info  ( "Msg to Recurly API [GET] :: URL : {}" , url ) ; }  return  callRecurlySafe  (  client . prepareGet  ( url ) , clazz ) ; }   private  <  T > T doPOST  (   final String resource ,   final RecurlyObject payload ,   final  Class  < T > clazz )  {   final String  xmlPayload ;  try  {   xmlPayload =  xmlMapper . writeValueAsString  ( payload ) ;  if  (  debug  ( ) )  {   log . info  ( "Msg to Recurly API [POST]:: URL : {}" ,  baseUrl + resource ) ;   log . info  ( "Payload for [POST]:: {}" , xmlPayload ) ; } }  catch (   IOException e )  {   log . warn  ( "Unable to serialize {} object as XML: {}" ,  clazz . getName  ( ) ,  payload . toString  ( ) ) ;  return null ; }  return  callRecurlySafe  (   client . preparePost  (  baseUrl + resource ) . setBody  ( xmlPayload ) , clazz ) ; }   private  <  T > T doPUT  (   final String resource ,   final RecurlyObject payload ,   final  Class  < T > clazz )  {   final String  xmlPayload ;  try  {  if  (  payload != null )  {   xmlPayload =  xmlMapper . writeValueAsString  ( payload ) ; } else  {   xmlPayload = null ; }  if  (  debug  ( ) )  {   log . info  ( "Msg to Recurly API [PUT]:: URL : {}" ,  baseUrl + resource ) ;   log . info  ( "Payload for [PUT]:: {}" , xmlPayload ) ; } }  catch (   IOException e )  {   log . warn  ( "Unable to serialize {} object as XML: {}" ,  clazz . getName  ( ) ,  payload . toString  ( ) ) ;  return null ; }  return  callRecurlySafe  (   client . preparePut  (  baseUrl + resource ) . setBody  ( xmlPayload ) , clazz ) ; }   private void doDELETE  (   final String resource )  {   callRecurlySafe  (  client . prepareDelete  (  baseUrl + resource ) , null ) ; }   private  <  T > T callRecurlySafe  (   final  AsyncHttpClient . BoundRequestBuilder builder ,    @ Nullable final  Class  < T > clazz )  {  try  {  return  callRecurly  ( builder , clazz ) ; }  catch (   IOException e )  {   log . warn  ( "Error while calling Recurly" , e ) ;  return null ; }  catch (   ExecutionException e )  {  if  (     e . getCause  ( ) != null &&    e . getCause  ( ) . getCause  ( ) != null &&    e . getCause  ( ) . getCause  ( ) instanceof TransactionErrorException )  {  throw  ( TransactionErrorException )   e . getCause  ( ) . getCause  ( ) ; } else  if  (    e . getCause  ( ) != null &&   e . getCause  ( ) instanceof TransactionErrorException )  {  throw  ( TransactionErrorException )  e . getCause  ( ) ; }   log . error  ( "Execution error" , e ) ;  return null ; }  catch (   InterruptedException e )  {   log . error  ( "Interrupted while calling Recurly" , e ) ;  return null ; } }   private  <  T > T callRecurly  (   final  AsyncHttpClient . BoundRequestBuilder builder ,    @ Nullable final  Class  < T > clazz )  throws IOException , ExecutionException , InterruptedException  {   final Response  response =         builder . addHeader  ( "Authorization" ,  "Basic " + key ) . addHeader  ( "Accept" , "application/xml" ) . addHeader  ( "Content-Type" , "application/xml; charset=utf-8" ) . addHeader  ( "X-Api-Version" , RECURLY_API_VERSION ) . addHeader  (  HttpHeaders . USER_AGENT , userAgent ) . setBodyEncoding  ( "UTF-8" ) . execute  ( ) . get  ( ) ;   final InputStream  in =  response . getResponseBodyAsStream  ( ) ;  try  {   final String  payload =  convertStreamToString  ( in ) ;  if  (  debug  ( ) )  {   log . info  ( "Msg from Recurly API :: {}" , payload ) ; }  if  (   response . getStatusCode  ( ) >= 300 )  {   log . warn  ( "Recurly error whilst calling: {}\n{}" ,  response . getUri  ( ) , payload ) ;  if  (   response . getStatusCode  ( ) == 422 )  {   final Errors  errors ;  try  {   errors =  xmlMapper . readValue  ( payload ,  Errors . class ) ; }  catch (   Exception e )  {   log . debug  ( "Unable to extract error" , e ) ;  return null ; }  throw  new TransactionErrorException  ( errors ) ; } else  {  RecurlyAPIError  recurlyError = null ;  try  {   recurlyError =  xmlMapper . readValue  ( payload ,  RecurlyAPIError . class ) ; }  catch (   Exception e )  {   log . debug  ( "Unable to extract error" , e ) ; }  throw  new RecurlyAPIException  ( recurlyError ) ; } }  if  (  clazz == null )  {  return null ; }   final T  obj =  xmlMapper . readValue  ( payload , clazz ) ;  if  (  obj instanceof RecurlyObject )  {    (  ( RecurlyObject ) obj ) . setRecurlyClient  ( this ) ; } else  if  (  obj instanceof RecurlyObjects )  {   final RecurlyObjects  recurlyObjects =  ( RecurlyObjects ) obj ;   recurlyObjects . setRecurlyClient  ( this ) ;  for (  final Object object : recurlyObjects )  {    (  ( RecurlyObject ) object ) . setRecurlyClient  ( this ) ; }   final String  xRecords =  response . getHeader  ( X_RECORDS_HEADER_NAME ) ;  if  (  xRecords != null )  {   recurlyObjects . setNbRecords  (  Integer . valueOf  ( xRecords ) ) ; }   final String  linkHeader =  response . getHeader  ( LINK_HEADER_NAME ) ;  if  (  linkHeader != null )  {   final  String  [ ]  links =  PaginationUtils . getLinks  ( linkHeader ) ;   recurlyObjects . setStartUrl  (  links [ 0 ] ) ;   recurlyObjects . setPrevUrl  (  links [ 1 ] ) ;   recurlyObjects . setNextUrl  (  links [ 2 ] ) ; } }  return obj ; }  finally  {   closeStream  ( in ) ; } }   private String convertStreamToString  (   final   java . io . InputStream is )  {  try  {  return    new Scanner  ( is ) . useDelimiter  ( "\\A" ) . next  ( ) ; }  catch (   final  NoSuchElementException e )  {  return "" ; } }   private void closeStream  (   final InputStream in )  {  if  (  in != null )  {  try  {   in . close  ( ) ; }  catch (   IOException e )  {   log . warn  ( "Failed to close http-client - provided InputStream: {}" ,  e . getLocalizedMessage  ( ) ) ; } } }   private AsyncHttpClient createHttpClient  ( )  throws KeyManagementException , NoSuchAlgorithmException  {   final  AsyncHttpClientConfig . Builder  builder =  new  AsyncHttpClientConfig . Builder  ( ) ;   builder . setMaxConnectionsPerHost  (  - 1 ) ;   builder . setSSLContext  (   SslUtils . getInstance  ( ) . getSSLContext  ( ) ) ;  return  new AsyncHttpClient  (  builder . build  ( ) ) ; }    @ VisibleForTesting String getUserAgent  ( )  {  return userAgent ; }   private String buildUserAgent  ( )  {   final String  defaultVersion = "0.0.0" ;   final String  defaultJavaVersion = "0.0.0" ;  try  {   final Properties  gitRepositoryState =  new Properties  ( ) ;   final URL  resourceURL =  Resources . getResource  ( GIT_PROPERTIES_FILE ) ;   final CharSource  charSource =  Resources . asCharSource  ( resourceURL ,  Charset . forName  ( "UTF-8" ) ) ;  Reader  reader = null ;  try  {   reader =  charSource . openStream  ( ) ;   gitRepositoryState . load  ( reader ) ; }  finally  {  if  (  reader != null )  {   reader . close  ( ) ; } }   final String  version =  Objects . firstNonNull  (  getVersionFromGitRepositoryState  ( gitRepositoryState ) , defaultVersion ) ;   final String  javaVersion =  Objects . firstNonNull  (   StandardSystemProperty . JAVA_VERSION . value  ( ) , defaultJavaVersion ) ;  return  String . format  ( "KillBill/%s; %s" , version , javaVersion ) ; }  catch (   final  Exception e )  {  return  String . format  ( "KillBill/%s; %s" , defaultVersion , defaultJavaVersion ) ; } }    @ VisibleForTesting String getVersionFromGitRepositoryState  (   final Properties gitRepositoryState )  {   final String  gitDescribe =  gitRepositoryState . getProperty  ( GIT_COMMIT_ID_DESCRIBE_SHORT ) ;  if  (  gitDescribe == null )  {  return null ; }   final Matcher  matcher =  TAG_FROM_GIT_DESCRIBE_PATTERN . matcher  ( gitDescribe ) ;  return   matcher . find  ( ) ?  matcher . group  ( 1 ) : null ; }   public static final String  RECURLY_API_VERSION = "2.1" ;   public Redemptions getCouponRedemptionsByAccount  (   final String accountCode )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Redemption . REDEMPTIONS_RESOURCE ,  Redemptions . class ) ; }   public Redemptions getCouponRedemptionsByInvoice  (   final Integer invoiceNumber )  {  return  doGET  (     Invoices . INVOICES_RESOURCE + "/" + invoiceNumber +  Redemption . REDEMPTION_RESOURCE ,  Redemptions . class ) ; }   public void deleteCouponRedemption  (   final String accountCode ,   final String redemptionUuid )  {   doDELETE  (       Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Redemption . REDEMPTIONS_RESOURCE + "/" + redemptionUuid ) ; } }