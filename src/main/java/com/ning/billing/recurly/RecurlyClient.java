  package    com . ning . billing . recurly ;   import   java . io . IOException ;  import   java . io . InputStream ;  import   java . io . Reader ;  import   java . math . BigDecimal ;  import   java . net . URL ;  import    java . nio . charset . Charset ;  import   java . security . KeyManagementException ;  import   java . security . NoSuchAlgorithmException ;  import   java . util . List ;  import   java . util . NoSuchElementException ;  import   java . util . Properties ;  import   java . util . Scanner ;  import    java . util . concurrent . ExecutionException ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import   javax . annotation . Nullable ;  import    javax . xml . bind . DatatypeConverter ;  import      com . ning . billing . recurly . model . Account ;  import      com . ning . billing . recurly . model . AccountBalance ;  import      com . ning . billing . recurly . model . Accounts ;  import      com . ning . billing . recurly . model . AddOn ;  import      com . ning . billing . recurly . model . AddOns ;  import      com . ning . billing . recurly . model . Adjustment ;  import      com . ning . billing . recurly . model . AdjustmentRefund ;  import      com . ning . billing . recurly . model . Adjustments ;  import      com . ning . billing . recurly . model . BillingInfo ;  import      com . ning . billing . recurly . model . Coupon ;  import      com . ning . billing . recurly . model . Coupons ;  import      com . ning . billing . recurly . model . Errors ;  import      com . ning . billing . recurly . model . GiftCard ;  import      com . ning . billing . recurly . model . GiftCards ;  import      com . ning . billing . recurly . model . Invoice ;  import      com . ning . billing . recurly . model . InvoiceRefund ;  import      com . ning . billing . recurly . model . InvoiceState ;  import      com . ning . billing . recurly . model . Invoices ;  import      com . ning . billing . recurly . model . Plan ;  import      com . ning . billing . recurly . model . Plans ;  import      com . ning . billing . recurly . model . Purchase ;  import      com . ning . billing . recurly . model . RecurlyAPIError ;  import      com . ning . billing . recurly . model . RecurlyObject ;  import      com . ning . billing . recurly . model . RecurlyObjects ;  import      com . ning . billing . recurly . model . Redemption ;  import      com . ning . billing . recurly . model . Redemptions ;  import      com . ning . billing . recurly . model . RefundOption ;  import      com . ning . billing . recurly . model . ShippingAddresses ;  import      com . ning . billing . recurly . model . Subscription ;  import      com . ning . billing . recurly . model . SubscriptionState ;  import      com . ning . billing . recurly . model . SubscriptionUpdate ;  import      com . ning . billing . recurly . model . SubscriptionNotes ;  import      com . ning . billing . recurly . model . Subscriptions ;  import      com . ning . billing . recurly . model . Transaction ;  import      com . ning . billing . recurly . model . TransactionState ;  import      com . ning . billing . recurly . model . TransactionType ;  import      com . ning . billing . recurly . model . Transactions ;  import      com . ning . billing . recurly . model . Usage ;  import      com . ning . billing . recurly . model . MeasuredUnit ;  import      com . ning . billing . recurly . model . MeasuredUnits ;  import      com . ning . billing . recurly . model . AccountAcquisition ;  import       com . ning . billing . recurly . util . http . SslUtils ;  import     com . ning . http . client . FluentCaseInsensitiveStringsMap ;  import    org . joda . time . DateTime ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     com . ning . http . client . AsyncHttpClient ;  import     com . ning . http . client . AsyncHttpClientConfig ;  import     com . ning . http . client . Response ;  import      com . fasterxml . jackson . dataformat . xml . XmlMapper ;  import     com . google . common . annotations . VisibleForTesting ;  import     com . google . common . base . MoreObjects ;  import     com . google . common . base . StandardSystemProperty ;  import     com . google . common . io . CharSource ;  import     com . google . common . io . Resources ;  import     com . google . common . net . HttpHeaders ;  import      com . ning . billing . recurly . model . AccountNotes ;  import      com . ning . billing . recurly . model . CreditPayments ;  import      com . ning . billing . recurly . model . InvoiceCollection ;  import      com . ning . billing . recurly . model . RefundMethod ;  import      com . ning . billing . recurly . model . ResponseMetadata ;  import      com . ning . billing . recurly . model . ShippingAddress ;  import      com . ning . billing . recurly . model . Usages ;  import      com . ning . billing . recurly . model . ShippingMethod ;  import      com . ning . billing . recurly . model . ShippingMethods ;  import   java . net . ConnectException ;  import   java . net . URI ;  import   java . util . Arrays ;   public class RecurlyClient  {   private static final Logger  log =  LoggerFactory . getLogger  (  RecurlyClient . class ) ;   public static final String  RECURLY_DEBUG_KEY = "recurly.debug" ;   public static final String  RECURLY_API_VERSION = "2.21" ;   private static final String  X_RECORDS_HEADER_NAME = "X-Records" ;   private static final String  LINK_HEADER_NAME = "Link" ;   private static final String  GIT_PROPERTIES_FILE = "com/ning/billing/recurly/git.properties" ;    @ VisibleForTesting static final String  GIT_COMMIT_ID_DESCRIBE_SHORT = "git.commit.id.describe-short" ;   private static final Pattern  TAG_FROM_GIT_DESCRIBE_PATTERN =  Pattern . compile  ( "recurly-java-library-([0-9]*\\.[0-9]*\\.[0-9]*)(-[0-9]*)?" ) ;   public static final String  FETCH_RESOURCE = "/recurly_js/result" ;   private static boolean debug  ( )  {  return  Boolean . getBoolean  ( RECURLY_DEBUG_KEY ) ; }   private final XmlMapper  xmlMapper ;   private final String  userAgent ;   private final String  key ;   private final String  baseUrl ;   private AsyncHttpClient  client ;   public RecurlyClient  (   final String apiKey )  {  this  ( apiKey , "api" ) ;   loggerWarning  ( ) ; }   public RecurlyClient  (   final String apiKey ,   final String subDomain )  {  this  ( apiKey ,  subDomain + ".recurly.com" , 443 , "v2" ) ;   loggerWarning  ( ) ; }   public RecurlyClient  (   final String apiKey ,   final String host ,   final  int port ,   final String version )  {  this  ( apiKey , "https" , host , port , version ) ;   loggerWarning  ( ) ; }   public RecurlyClient  (   final String apiKey ,   final String scheme ,   final String host ,   final  int port ,   final String version )  {    this . key =  DatatypeConverter . printBase64Binary  (  apiKey . getBytes  ( ) ) ;    this . baseUrl =  String . format  ( "%s://%s:%d/%s" , scheme , host , port , version ) ;    this . xmlMapper =  RecurlyObject . newXmlMapper  ( ) ;    this . userAgent =  buildUserAgent  ( ) ;    this . rateLimitRemaining =  - 1 ;   loggerWarning  ( ) ; }   public synchronized void open  ( )  throws NoSuchAlgorithmException , KeyManagementException  {   client =  createHttpClient  ( ) ; }   public synchronized void close  ( )  {  if  (  client != null )  {   client . close  ( ) ; } }   public Account createAccount  (   final Account account )  {  return  doPOST  (  Account . ACCOUNT_RESOURCE , account ,  Account . class ) ; }   public Accounts getAccounts  ( )  {  return  doGET  (  Accounts . ACCOUNTS_RESOURCE ,  Accounts . class ,  new QueryParams  ( ) ) ; }   public Accounts getAccounts  (   final QueryParams params )  {  return  doGET  (  Accounts . ACCOUNTS_RESOURCE ,  Accounts . class , params ) ; }   public Integer getAccountsCount  (   final QueryParams params )  {  FluentCaseInsensitiveStringsMap  map =  doHEAD  (  Accounts . ACCOUNTS_RESOURCE , params ) ;  return  Integer . parseInt  (  map . getFirstValue  ( X_RECORDS_HEADER_NAME ) ) ; }   public Coupons getCoupons  ( )  {  return  doGET  (  Coupons . COUPONS_RESOURCE ,  Coupons . class ,  new QueryParams  ( ) ) ; }   public Coupons getCoupons  (   final QueryParams params )  {  return  doGET  (  Coupons . COUPONS_RESOURCE ,  Coupons . class , params ) ; }   public Integer getCouponsCount  (   final QueryParams params )  {  FluentCaseInsensitiveStringsMap  map =  doHEAD  (  Coupons . COUPONS_RESOURCE , params ) ;  return  Integer . parseInt  (  map . getFirstValue  ( X_RECORDS_HEADER_NAME ) ) ; }   public Account getAccount  (   final String accountCode )  {  if  (   accountCode == null ||  accountCode . isEmpty  ( ) )  throw  new RuntimeException  ( "accountCode cannot be empty!" ) ;  return  doGET  (    Account . ACCOUNT_RESOURCE + "/" + accountCode ,  Account . class ) ; }   public Account updateAccount  (   final String accountCode ,   final Account account )  {  return  doPUT  (    Account . ACCOUNT_RESOURCE + "/" + accountCode , account ,  Account . class ) ; }   public AccountBalance getAccountBalance  (   final String accountCode )  {  return  doGET  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  AccountBalance . ACCOUNT_BALANCE_RESOURCE ,  AccountBalance . class ) ; }   public void closeAccount  (   final String accountCode )  {   doDELETE  (    Account . ACCOUNT_RESOURCE + "/" + accountCode ) ; }   public Adjustments getAccountAdjustments  (   final String accountCode )  {  return  getAccountAdjustments  ( accountCode , null , null ,  new QueryParams  ( ) ) ; }   public Adjustments getAccountAdjustments  (   final String accountCode ,   final  Adjustments . AdjustmentType type )  {  return  getAccountAdjustments  ( accountCode , type , null ,  new QueryParams  ( ) ) ; }   public Adjustments getAccountAdjustments  (   final String accountCode ,   final  Adjustments . AdjustmentType type ,   final  Adjustments . AdjustmentState state )  {  return  getAccountAdjustments  ( accountCode , type , state ,  new QueryParams  ( ) ) ; }   public Adjustments getAccountAdjustments  (   final String accountCode ,   final  Adjustments . AdjustmentType type ,   final  Adjustments . AdjustmentState state ,   final QueryParams params )  {   final String  url =     Account . ACCOUNT_RESOURCE + "/" + accountCode +  Adjustments . ADJUSTMENTS_RESOURCE ;  if  (  type != null )   params . put  ( "type" ,  type . getType  ( ) ) ;  if  (  state != null )   params . put  ( "state" ,  state . getState  ( ) ) ;  return  doGET  ( url ,  Adjustments . class , params ) ; }   public Adjustment getAdjustment  (   final String adjustmentUuid )  {  if  (   adjustmentUuid == null ||  adjustmentUuid . isEmpty  ( ) )  throw  new RuntimeException  ( "adjustmentUuid cannot be empty!" ) ;  return  doGET  (    Adjustments . ADJUSTMENTS_RESOURCE + "/" + adjustmentUuid ,  Adjustment . class ) ; }   public Adjustment createAccountAdjustment  (   final String accountCode ,   final Adjustment adjustment )  {  return  doPOST  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  Adjustments . ADJUSTMENTS_RESOURCE , adjustment ,  Adjustment . class ) ; }   public void deleteAccountAdjustment  (   final String accountCode )  {   doDELETE  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  Adjustments . ADJUSTMENTS_RESOURCE ) ; }   public void deleteAdjustment  (   final String adjustmentUuid )  {   doDELETE  (    Adjustments . ADJUSTMENTS_RESOURCE + "/" + adjustmentUuid ) ; }   public Subscription createSubscription  (   final Subscription subscription )  {  return  doPOST  (  Subscription . SUBSCRIPTION_RESOURCE , subscription ,  Subscription . class ) ; }   public Subscription previewSubscription  (   final Subscription subscription )  {  return  doPOST  (   Subscription . SUBSCRIPTION_RESOURCE + "/preview" , subscription ,  Subscription . class ) ; }   public Subscription getSubscription  (   final String uuid )  {  if  (   uuid == null ||  uuid . isEmpty  ( ) )  throw  new RuntimeException  ( "uuid cannot be empty!" ) ;  return  doGET  (    Subscriptions . SUBSCRIPTIONS_RESOURCE + "/" + uuid ,  Subscription . class ) ; }   public Subscription cancelSubscription  (   final Subscription subscription )  {  return  doPUT  (     Subscription . SUBSCRIPTION_RESOURCE + "/" +  subscription . getUuid  ( ) + "/cancel" , subscription ,  Subscription . class ) ; }   public Subscription postponeSubscription  (   final Subscription subscription ,   final DateTime renewaldate )  {  return  doPUT  (      Subscription . SUBSCRIPTION_RESOURCE + "/" +  subscription . getUuid  ( ) + "/postpone?next_renewal_date=" + renewaldate , subscription ,  Subscription . class ) ; }   public void terminateSubscription  (   final Subscription subscription ,   final RefundOption refund )  {   doPUT  (      Subscription . SUBSCRIPTION_RESOURCE + "/" +  subscription . getUuid  ( ) + "/terminate?refund=" + refund , subscription ,  Subscription . class ) ; }   public Subscription reactivateSubscription  (   final Subscription subscription )  {  return  doPUT  (     Subscription . SUBSCRIPTION_RESOURCE + "/" +  subscription . getUuid  ( ) + "/reactivate" , subscription ,  Subscription . class ) ; }   public Subscription updateSubscription  (   final String uuid ,   final SubscriptionUpdate subscriptionUpdate )  {  return  doPUT  (    Subscriptions . SUBSCRIPTIONS_RESOURCE + "/" + uuid , subscriptionUpdate ,  Subscription . class ) ; }   public Subscription updateSubscriptionPreview  (   final String uuid ,   final SubscriptionUpdate subscriptionUpdate )  {  return  doPOST  (     Subscriptions . SUBSCRIPTIONS_RESOURCE + "/" + uuid + "/preview" , subscriptionUpdate ,  Subscription . class ) ; }   public Subscription updateSubscriptionNotes  (   final String uuid ,   final SubscriptionNotes subscriptionNotes )  {  return  doPUT  (     SubscriptionNotes . SUBSCRIPTION_RESOURCE + "/" + uuid + "/notes" , subscriptionNotes ,  Subscription . class ) ; }   public Subscriptions getAccountSubscriptions  (   final String accountCode )  {  return  doGET  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  Subscriptions . SUBSCRIPTIONS_RESOURCE ,  Subscriptions . class ,  new QueryParams  ( ) ) ; }   public Subscriptions getSubscriptions  ( )  {  return  doGET  (  Subscriptions . SUBSCRIPTIONS_RESOURCE ,  Subscriptions . class ,  new QueryParams  ( ) ) ; }   public Subscriptions getSubscriptions  (   final SubscriptionState state ,   final QueryParams params )  {  if  (  state != null )  {   params . put  ( "state" ,  state . getType  ( ) ) ; }  return  doGET  (  Subscriptions . SUBSCRIPTIONS_RESOURCE ,  Subscriptions . class , params ) ; }   public Integer getSubscriptionsCount  (   final QueryParams params )  {  FluentCaseInsensitiveStringsMap  map =  doHEAD  (  Subscription . SUBSCRIPTION_RESOURCE , params ) ;  return  Integer . parseInt  (  map . getFirstValue  ( X_RECORDS_HEADER_NAME ) ) ; }   public Subscriptions getAccountSubscriptions  (   final String accountCode ,   final SubscriptionState state ,   final QueryParams params )  {  if  (  state != null )   params . put  ( "state" ,  state . getType  ( ) ) ;  return  doGET  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  Subscriptions . SUBSCRIPTIONS_RESOURCE ,  Subscriptions . class , params ) ; }   public Usage postSubscriptionUsage  (   final String subscriptionCode ,   final String addOnCode ,   final Usage usage )  {  return  doPOST  (        Subscription . SUBSCRIPTION_RESOURCE + "/" + subscriptionCode +  AddOn . ADDONS_RESOURCE + "/" + addOnCode +  Usage . USAGE_RESOURCE , usage ,  Usage . class ) ; }    @ Deprecated public Subscriptions getAccountSubscriptions  (   final String accountCode ,   final String status )  {   final QueryParams  params =  new QueryParams  ( ) ;  if  (  status != null )   params . put  ( "state" , status ) ;  return  doGET  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  Subscriptions . SUBSCRIPTIONS_RESOURCE ,  Subscriptions . class , params ) ; }   public  @ Deprecated BillingInfo createOrUpdateBillingInfo  (   final BillingInfo billingInfo )  {   final String  accountCode =   billingInfo . getAccount  ( ) . getAccountCode  ( ) ;   billingInfo . setAccount  ( null ) ;  return  doPUT  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  BillingInfo . BILLING_INFO_RESOURCE , billingInfo ,  BillingInfo . class ) ; }   public BillingInfo getBillingInfo  (   final String accountCode )  {  return  doGET  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  BillingInfo . BILLING_INFO_RESOURCE ,  BillingInfo . class ) ; }   public void clearBillingInfo  (   final String accountCode )  {   doDELETE  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  BillingInfo . BILLING_INFO_RESOURCE ) ; }   public Transactions getAccountTransactions  (   final String accountCode )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Transactions . TRANSACTIONS_RESOURCE ,  Transactions . class ,  new QueryParams  ( ) ) ; }   public Transactions getAccountTransactions  (   final String accountCode ,   final TransactionState state ,   final TransactionType type ,   final QueryParams params )  {  if  (  state != null )   params . put  ( "state" ,  state . getType  ( ) ) ;  if  (  type != null )   params . put  ( "type" ,  type . getType  ( ) ) ;  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Transactions . TRANSACTIONS_RESOURCE ,  Transactions . class , params ) ; }   public Transactions getTransactions  ( )  {  return  doGET  (  Transactions . TRANSACTIONS_RESOURCE ,  Transactions . class ,  new QueryParams  ( ) ) ; }   public Transactions getTransactions  (   final TransactionState state ,   final TransactionType type ,   final QueryParams params )  {  if  (  state != null )   params . put  ( "state" ,  state . getType  ( ) ) ;  if  (  type != null )   params . put  ( "type" ,  type . getType  ( ) ) ;  return  doGET  (  Transactions . TRANSACTIONS_RESOURCE ,  Transactions . class , params ) ; }   public Integer getTransactionsCount  (   final QueryParams params )  {  FluentCaseInsensitiveStringsMap  map =  doHEAD  (  Transactions . TRANSACTIONS_RESOURCE , params ) ;  return  Integer . parseInt  (  map . getFirstValue  ( X_RECORDS_HEADER_NAME ) ) ; }   public Transaction getTransaction  (   final String transactionId )  {  if  (   transactionId == null ||  transactionId . isEmpty  ( ) )  throw  new RuntimeException  ( "transactionId cannot be empty!" ) ;  return  doGET  (    Transactions . TRANSACTIONS_RESOURCE + "/" + transactionId ,  Transaction . class ) ; }   public Transaction createTransaction  (   final Transaction trans )  {  return  doPOST  (  Transactions . TRANSACTIONS_RESOURCE , trans ,  Transaction . class ) ; }   public void refundTransaction  (   final String transactionId ,    @ Nullable final BigDecimal amount )  {  String  url =    Transactions . TRANSACTIONS_RESOURCE + "/" + transactionId ;  if  (  amount != null )  {   url =   url + "?amount_in_cents=" +  (   amount . intValue  ( ) * 100 ) ; }   doDELETE  ( url ) ; }    @ Deprecated public Invoice getInvoice  (   final Integer invoiceId )  {  return  getInvoice  (  invoiceId . toString  ( ) ) ; }   public Invoice getInvoice  (   final String invoiceId )  {  if  (   invoiceId == null ||  invoiceId . isEmpty  ( ) )  throw  new RuntimeException  ( "invoiceId cannot be empty!" ) ;  return  doGET  (    Invoices . INVOICES_RESOURCE + "/" + invoiceId ,  Invoice . class ) ; }    @ Deprecated public InputStream getInvoicePdf  (   final Integer invoiceId )  {  return  getInvoicePdf  (  invoiceId . toString  ( ) ) ; }   public InputStream getInvoicePdf  (   final String invoiceId )  {  if  (   invoiceId == null ||  invoiceId . isEmpty  ( ) )  throw  new RuntimeException  ( "invoiceId cannot be empty!" ) ;  return  doGETPdf  (    Invoices . INVOICES_RESOURCE + "/" + invoiceId ) ; }   public Invoices getAccountInvoices  (   final String accountCode )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Invoices . INVOICES_RESOURCE ,  Invoices . class ,  new QueryParams  ( ) ) ; }   public ShippingAddresses getAccountShippingAddresses  (   final String accountCode )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  ShippingAddresses . SHIPPING_ADDRESSES_RESOURCE ,  ShippingAddresses . class ,  new QueryParams  ( ) ) ; }   public Invoices getAccountInvoices  (   final String accountCode ,   final InvoiceState state ,   final QueryParams params )  {  if  (  state != null )   params . put  ( "state" ,  state . getType  ( ) ) ;  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Invoices . INVOICES_RESOURCE ,  Invoices . class , params ) ; }   public InvoiceCollection postAccountInvoice  (   final String accountCode ,   final Invoice invoice )  {  return  doPOST  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Invoices . INVOICES_RESOURCE , invoice ,  InvoiceCollection . class ) ; }    @ Deprecated public Invoice markInvoiceSuccessful  (   final Integer invoiceId )  {  return  markInvoiceSuccessful  (  invoiceId . toString  ( ) ) ; }   public Invoice markInvoiceSuccessful  (   final String invoiceId )  {  return  doPUT  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId + "/mark_successful" , null ,  Invoice . class ) ; }    @ Deprecated public InvoiceCollection markInvoiceFailed  (   final Integer invoiceId )  {  return  markInvoiceFailed  (  invoiceId . toString  ( ) ) ; }   public InvoiceCollection markInvoiceFailed  (   final String invoiceId )  {  return  doPUT  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId + "/mark_failed" , null ,  InvoiceCollection . class ) ; }   public Invoice forceCollectInvoice  (   final String invoiceId )  {  return  doPUT  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId + "/collect" , null ,  Invoice . class ) ; }    @ Deprecated public Transaction enterOfflinePayment  (   final Integer invoiceId ,   final Transaction payment )  {  return  enterOfflinePayment  (  invoiceId . toString  ( ) , payment ) ; }   public Transaction enterOfflinePayment  (   final String invoiceId ,   final Transaction payment )  {  return  doPOST  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId + "/transactions" , payment ,  Transaction . class ) ; }   public Plan createPlan  (   final Plan plan )  {  return  doPOST  (  Plan . PLANS_RESOURCE , plan ,  Plan . class ) ; }   public Plan updatePlan  (   final Plan plan )  {  return  doPUT  (    Plan . PLANS_RESOURCE + "/" +  plan . getPlanCode  ( ) , plan ,  Plan . class ) ; }   public Plan getPlan  (   final String planCode )  {  if  (   planCode == null ||  planCode . isEmpty  ( ) )  throw  new RuntimeException  ( "planCode cannot be empty!" ) ;  return  doGET  (    Plan . PLANS_RESOURCE + "/" + planCode ,  Plan . class ) ; }   public Plans getPlans  ( )  {  return  doGET  (  Plans . PLANS_RESOURCE ,  Plans . class ,  new QueryParams  ( ) ) ; }   public Plans getPlans  (   final QueryParams params )  {  return  doGET  (  Plans . PLANS_RESOURCE ,  Plans . class , params ) ; }   public Integer getPlansCount  (   final QueryParams params )  {  FluentCaseInsensitiveStringsMap  map =  doHEAD  (  Plans . PLANS_RESOURCE , params ) ;  return  Integer . parseInt  (  map . getFirstValue  ( X_RECORDS_HEADER_NAME ) ) ; }   public void deletePlan  (   final String planCode )  {   doDELETE  (    Plan . PLANS_RESOURCE + "/" + planCode ) ; }   public AddOn createPlanAddOn  (   final String planCode ,   final AddOn addOn )  {  return  doPOST  (     Plan . PLANS_RESOURCE + "/" + planCode +  AddOn . ADDONS_RESOURCE , addOn ,  AddOn . class ) ; }   public AddOn getAddOn  (   final String planCode ,   final String addOnCode )  {  if  (   addOnCode == null ||  addOnCode . isEmpty  ( ) )  throw  new RuntimeException  ( "addOnCode cannot be empty!" ) ;  return  doGET  (       Plan . PLANS_RESOURCE + "/" + planCode +  AddOn . ADDONS_RESOURCE + "/" + addOnCode ,  AddOn . class ) ; }   public AddOns getAddOns  (   final String planCode )  {  return  doGET  (     Plan . PLANS_RESOURCE + "/" + planCode +  AddOn . ADDONS_RESOURCE ,  AddOns . class ,  new QueryParams  ( ) ) ; }   public AddOns getAddOns  (   final String planCode ,   final QueryParams params )  {  return  doGET  (     Plan . PLANS_RESOURCE + "/" + planCode +  AddOn . ADDONS_RESOURCE ,  AddOns . class , params ) ; }   public void deleteAddOn  (   final String planCode ,   final String addOnCode )  {   doDELETE  (       Plan . PLANS_RESOURCE + "/" + planCode +  AddOn . ADDONS_RESOURCE + "/" + addOnCode ) ; }   public Coupon createCoupon  (   final Coupon coupon )  {  return  doPOST  (  Coupon . COUPON_RESOURCE , coupon ,  Coupon . class ) ; }   public Coupon getCoupon  (   final String couponCode )  {  if  (   couponCode == null ||  couponCode . isEmpty  ( ) )  throw  new RuntimeException  ( "couponCode cannot be empty!" ) ;  return  doGET  (    Coupon . COUPON_RESOURCE + "/" + couponCode ,  Coupon . class ) ; }   public void deleteCoupon  (   final String couponCode )  {   doDELETE  (    Coupon . COUPON_RESOURCE + "/" + couponCode ) ; }   public Redemption redeemCoupon  (   final String couponCode ,   final Redemption redemption )  {  return  doPOST  (     Coupon . COUPON_RESOURCE + "/" + couponCode +  Redemption . REDEEM_RESOURCE , redemption ,  Redemption . class ) ; }   public Redemption getCouponRedemptionByAccount  (   final String accountCode )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Redemption . REDEMPTION_RESOURCE ,  Redemption . class ) ; }   public Redemptions getCouponRedemptionsByAccount  (   final String accountCode )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Redemption . REDEMPTIONS_RESOURCE ,  Redemptions . class ,  new QueryParams  ( ) ) ; }   public Redemptions getCouponRedemptionsByAccount  (   final String accountCode ,   final QueryParams params )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Redemption . REDEMPTIONS_RESOURCE ,  Redemptions . class , params ) ; }    @ Deprecated public Redemption getCouponRedemptionByInvoice  (   final Integer invoiceNumber )  {  return  getCouponRedemptionByInvoice  (  invoiceNumber . toString  ( ) ) ; }   public Redemption getCouponRedemptionByInvoice  (   final String invoiceId )  {  return  doGET  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId +  Redemption . REDEMPTION_RESOURCE ,  Redemption . class ) ; }    @ Deprecated public Redemptions getCouponRedemptionsByInvoice  (   final Integer invoiceNumber )  {  return  getCouponRedemptionsByInvoice  (  invoiceNumber . toString  ( ) ,  new QueryParams  ( ) ) ; }   public Redemptions getCouponRedemptionsByInvoice  (   final String invoiceId )  {  return  getCouponRedemptionsByInvoice  ( invoiceId ,  new QueryParams  ( ) ) ; }    @ Deprecated public Redemptions getCouponRedemptionsByInvoice  (   final Integer invoiceNumber ,   final QueryParams params )  {  return  getCouponRedemptionsByInvoice  (  invoiceNumber . toString  ( ) , params ) ; }   public Redemptions getCouponRedemptionsByInvoice  (   final String invoiceId ,   final QueryParams params )  {  return  doGET  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId +  Redemption . REDEMPTION_RESOURCE ,  Redemptions . class , params ) ; }   public void deleteCouponRedemption  (   final String accountCode )  {   doDELETE  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Redemption . REDEMPTION_RESOURCE ) ; }   public void deleteCouponRedemption  (   final String accountCode ,   final String redemptionUuid )  {   doDELETE  (       Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  Redemption . REDEMPTIONS_RESOURCE + "/" + redemptionUuid ) ; }   public Subscription fetchSubscription  (   final String recurlyToken )  {  return  fetch  ( recurlyToken ,  Subscription . class ) ; }   public BillingInfo fetchBillingInfo  (   final String recurlyToken )  {  return  fetch  ( recurlyToken ,  BillingInfo . class ) ; }   public Invoice fetchInvoice  (   final String recurlyToken )  {  return  fetch  ( recurlyToken ,  Invoice . class ) ; }   public GiftCards getGiftCards  (   final QueryParams params )  {  return  doGET  (  GiftCards . GIFT_CARDS_RESOURCE ,  GiftCards . class , params ) ; }   public GiftCards getGiftCards  ( )  {  return  doGET  (  GiftCards . GIFT_CARDS_RESOURCE ,  GiftCards . class ,  new QueryParams  ( ) ) ; }   public Integer getGiftCardsCount  (   final QueryParams params )  {  FluentCaseInsensitiveStringsMap  map =  doHEAD  (  GiftCards . GIFT_CARDS_RESOURCE , params ) ;  return  Integer . parseInt  (  map . getFirstValue  ( X_RECORDS_HEADER_NAME ) ) ; }   public GiftCard getGiftCard  (   final Long giftCardId )  {  return  doGET  (    GiftCards . GIFT_CARDS_RESOURCE + "/" +  Long . toString  ( giftCardId ) ,  GiftCard . class ) ; }   public GiftCard redeemGiftCard  (   final String redemptionCode ,   final String accountCode )  {   final  GiftCard . Redemption  redemptionData =  GiftCard . createRedemption  ( accountCode ) ;   final String  url =     GiftCards . GIFT_CARDS_RESOURCE + "/" + redemptionCode + "/redeem" ;  return  doPOST  ( url , redemptionData ,  GiftCard . class ) ; }   public GiftCard purchaseGiftCard  (   final GiftCard giftCard )  {  return  doPOST  (  GiftCards . GIFT_CARDS_RESOURCE , giftCard ,  GiftCard . class ) ; }   public GiftCard previewGiftCard  (   final GiftCard giftCard )  {  return  doPOST  (   GiftCards . GIFT_CARDS_RESOURCE + "/preview" , giftCard ,  GiftCard . class ) ; }   public MeasuredUnits getMeasuredUnits  ( )  {  return  doGET  (  MeasuredUnits . MEASURED_UNITS_RESOURCE ,  MeasuredUnits . class ,  new QueryParams  ( ) ) ; }   public MeasuredUnit createMeasuredUnit  (   final MeasuredUnit measuredUnit )  {  return  doPOST  (  MeasuredUnit . MEASURED_UNITS_RESOURCE , measuredUnit ,  MeasuredUnit . class ) ; }   public InvoiceCollection purchase  (   final Purchase purchase )  {  return  doPOST  (  Purchase . PURCHASES_ENDPOINT , purchase ,  InvoiceCollection . class ) ; }   public InvoiceCollection previewPurchase  (   final Purchase purchase )  {  return  doPOST  (   Purchase . PURCHASES_ENDPOINT + "/preview" , purchase ,  InvoiceCollection . class ) ; }   public InvoiceCollection authorizePurchase  (   final Purchase purchase )  {  return  doPOST  (   Purchase . PURCHASES_ENDPOINT + "/authorize" , purchase ,  InvoiceCollection . class ) ; }   public AccountAcquisition createAccountAcquisition  (   final String accountCode ,   final AccountAcquisition acquisition )  {   final String  path =     Account . ACCOUNT_RESOURCE + "/" + accountCode +  AccountAcquisition . ACCOUNT_ACQUISITION_RESOURCE ;  return  doPOST  ( path , acquisition ,  AccountAcquisition . class ) ; }   public AccountAcquisition getAccountAcquisition  (   final String accountCode )  {   final String  path =     Account . ACCOUNT_RESOURCE + "/" + accountCode +  AccountAcquisition . ACCOUNT_ACQUISITION_RESOURCE ;  return  doGET  ( path ,  AccountAcquisition . class ) ; }   public AccountAcquisition updateAccountAcquisition  (   final String accountCode ,   final AccountAcquisition acquisition )  {   final String  path =     Account . ACCOUNT_RESOURCE + "/" + accountCode +  AccountAcquisition . ACCOUNT_ACQUISITION_RESOURCE ;  return  doPUT  ( path , acquisition ,  AccountAcquisition . class ) ; }   public void deleteAccountAcquisition  (   final String accountCode )  {   doDELETE  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  AccountAcquisition . ACCOUNT_ACQUISITION_RESOURCE ) ; }   private  <  T > T fetch  (   final String recurlyToken ,   final  Class  < T > clazz )  {  return  doGET  (   FETCH_RESOURCE + "/" + recurlyToken , clazz ) ; }   private InputStream doGETPdf  (   final String resource )  {  return  doGETPdfWithFullURL  (  baseUrl + resource ) ; }   private  <  T > T doGET  (   final String resource ,   final  Class  < T > clazz )  {  return  doGETWithFullURL  ( clazz ,  baseUrl + resource ) ; }   private  <  T > T doGET  (   final String resource ,   final  Class  < T > clazz ,  QueryParams params )  {  return  doGETWithFullURL  ( clazz ,  constructGetUrl  ( resource , params ) ) ; }   private String constructGetUrl  (   final String resource ,  QueryParams params )  {  return   baseUrl + resource +  params . toString  ( ) ; }   public  <  T > T doGETWithFullURL  (   final  Class  < T > clazz ,   final String url )  {  if  (  debug  ( ) )  {   log . info  ( "Msg to Recurly API [GET] :: URL : {}" , url ) ; }   validateHost  ( url ) ;  return  callRecurlySafeXmlContent  (  client . prepareGet  ( url ) , clazz ) ; }   private InputStream doGETPdfWithFullURL  (   final String url )  {  if  (  debug  ( ) )  {   log . info  ( "Msg to Recurly API [GET] :: URL : {}" , url ) ; }  return  callRecurlySafeGetPdf  ( url ) ; }   private InputStream callRecurlySafeGetPdf  (  String url )  {   validateHost  ( url ) ;   final Response  response ;   final InputStream  pdfInputStream ;  try  {   response =      clientRequestBuilderCommon  (  client . prepareGet  ( url ) ) . addHeader  ( "Accept" , "application/pdf" ) . addHeader  ( "Content-Type" , "application/pdf" ) . execute  ( ) . get  ( ) ;   pdfInputStream =  response . getResponseBodyAsStream  ( ) ; }  catch (   InterruptedException e )  {   log . error  ( "Interrupted while calling recurly" , e ) ;  return null ; }  catch (   ExecutionException e )  {   log . error  ( "Execution error" , e ) ;  return null ; }  catch (   IOException e )  {   log . error  ( "Error retrieving response body" , e ) ;  return null ; }  if  (   response . getStatusCode  ( ) != 200 )  {   final RecurlyAPIError  recurlyAPIError =  RecurlyAPIError . buildFromResponse  ( response ) ;  throw  new RecurlyAPIException  ( recurlyAPIError ) ; }  return pdfInputStream ; }   private  <  T > T doPOST  (   final String resource ,   final RecurlyObject payload ,   final  Class  < T > clazz )  {   final String  xmlPayload ;  try  {   xmlPayload =  xmlMapper . writeValueAsString  ( payload ) ;  if  (  debug  ( ) )  {   log . info  ( "Msg to Recurly API [POST]:: URL : {}" ,  baseUrl + resource ) ;   log . info  ( "Payload for [POST]:: {}" , xmlPayload ) ; } }  catch (   IOException e )  {   log . warn  ( "Unable to serialize {} object as XML: {}" ,  clazz . getName  ( ) ,  payload . toString  ( ) ) ;  return null ; }   validateHost  (  baseUrl + resource ) ;  return  callRecurlySafeXmlContent  (   client . preparePost  (  baseUrl + resource ) . setBody  ( xmlPayload ) , clazz ) ; }   private  <  T > T doPUT  (   final String resource ,   final RecurlyObject payload ,   final  Class  < T > clazz )  {   final String  xmlPayload ;  try  {  if  (  payload != null )  {   xmlPayload =  xmlMapper . writeValueAsString  ( payload ) ; } else  {   xmlPayload = null ; }  if  (  debug  ( ) )  {   log . info  ( "Msg to Recurly API [PUT]:: URL : {}" ,  baseUrl + resource ) ;   log . info  ( "Payload for [PUT]:: {}" , xmlPayload ) ; } }  catch (   IOException e )  {   log . warn  ( "Unable to serialize {} object as XML: {}" ,  clazz . getName  ( ) ,  payload . toString  ( ) ) ;  return null ; }   validateHost  (  baseUrl + resource ) ;  return  callRecurlySafeXmlContent  (   client . preparePut  (  baseUrl + resource ) . setBody  ( xmlPayload ) , clazz ) ; }   private FluentCaseInsensitiveStringsMap doHEAD  (   final String resource ,  QueryParams params )  {  if  (  params == null )  {   params =  new QueryParams  ( ) ; }   final String  url =  constructGetUrl  ( resource , params ) ;  if  (  debug  ( ) )  {   log . info  ( "Msg to Recurly API [HEAD]:: URL : {}" , url ) ; }   validateHost  ( url ) ;  return  callRecurlyNoContent  (  client . prepareHead  ( url ) ) ; }   private void doDELETE  (   final String resource )  {   validateHost  (  baseUrl + resource ) ;   callRecurlySafeXmlContent  (  client . prepareDelete  (  baseUrl + resource ) , null ) ; }   private FluentCaseInsensitiveStringsMap callRecurlyNoContent  (   final  AsyncHttpClient . BoundRequestBuilder builder )  {  try  {   final Response  response =      clientRequestBuilderCommon  ( builder ) . addHeader  ( "Accept" , "application/xml" ) . addHeader  ( "Content-Type" , "application/xml; charset=utf-8" ) . execute  ( ) . get  ( ) ;  return  response . getHeaders  ( ) ; }  catch (   ExecutionException e )  {   log . error  ( "Execution error" , e ) ;  return null ; }  catch (   InterruptedException e )  {   log . error  ( "Interrupted while calling Recurly" , e ) ;  return null ; } }   private  <  T > T callRecurlySafeXmlContent  (   final  AsyncHttpClient . BoundRequestBuilder builder ,    @ Nullable final  Class  < T > clazz )  {  try  {  return  callRecurlyXmlContent  ( builder , clazz ) ; }  catch (   IOException e )  {   log . warn  ( "Error while calling Recurly" , e ) ;  return null ; }  catch (   ExecutionException e )  {  if  (   e . getCause  ( ) instanceof ConnectException )  {  throw  new ConnectionErrorException  (  e . getCause  ( ) ) ; } else  if  (     e . getCause  ( ) != null &&    e . getCause  ( ) . getCause  ( ) != null &&    e . getCause  ( ) . getCause  ( ) instanceof TransactionErrorException )  {  throw  ( TransactionErrorException )   e . getCause  ( ) . getCause  ( ) ; } else  if  (    e . getCause  ( ) != null &&   e . getCause  ( ) instanceof TransactionErrorException )  {  throw  ( TransactionErrorException )  e . getCause  ( ) ; }   log . error  ( "Execution error" , e ) ;  return null ; }  catch (   InterruptedException e )  {   log . error  ( "Interrupted while calling Recurly" , e ) ;  return null ; } }   private  <  T > T callRecurlyXmlContent  (   final  AsyncHttpClient . BoundRequestBuilder builder ,    @ Nullable final  Class  < T > clazz )  throws IOException , ExecutionException , InterruptedException  {   final Response  response =      clientRequestBuilderCommon  ( builder ) . addHeader  ( "Accept" , "application/xml" ) . addHeader  ( "Content-Type" , "application/xml; charset=utf-8" ) . execute  ( ) . get  ( ) ;   final InputStream  in =  response . getResponseBodyAsStream  ( ) ;  try  {   final String  payload =  convertStreamToString  ( in ) ;  if  (  debug  ( ) )  {   log . info  ( "Msg from Recurly API :: {}" , payload ) ; }   int  statusCode =  response . getStatusCode  ( ) ;  if  (  statusCode >= 300 )  {   log . warn  ( "Recurly error whilst calling: {}\n{}" ,  response . getUri  ( ) , payload ) ;   log . warn  ( "Error status code: {}\n" ,  response . getStatusCode  ( ) ) ; 
<<<<<<<
=======
 RecurlyAPIError  recurlyError =  RecurlyAPIError . buildFromResponse  ( response ) ;
>>>>>>>
  if  (  statusCode == 422 )  {  Errors  errors = null ;  try  {   errors =  xmlMapper . readValue  ( payload ,  Errors . class ) ; }  catch (   Exception e )  {   log . warn  ( "Unable to extract error" , e ) ; }  if  (   errors == null ||  (    errors . getTransactionError  ( ) == null &&   errors . getRecurlyErrors  ( ) == null ) )  {  throw  new RecurlyAPIException  (  createRecurlyAPIError  ( payload , statusCode ) ) ; } else  {  throw  new TransactionErrorException  ( errors ) ; } } else  if  (  statusCode == 401 )  {  RecurlyAPIError  recurlyError =  new RecurlyAPIError  ( ) ;   recurlyError . setSymbol  ( "unauthorized" ) ;   recurlyError . setDescription  ( "We could not authenticate your request. Either your subdomain and private key are not set or incorrect" ) ;  throw  new RecurlyAPIException  ( recurlyError ) ; } else  { 
<<<<<<<
=======
 try  {   recurlyError =  RecurlyAPIError . buildFromXml  ( xmlMapper , payload , response ) ; }  catch (   Exception e )  {   log . debug  ( "Unable to extract error" , e ) ; }
>>>>>>>
  throw  new RecurlyAPIException  (  createRecurlyAPIError  ( payload , statusCode ) ) ; } }  if  (  clazz == null )  {  return null ; }   final T  obj =  xmlMapper . readValue  ( payload , clazz ) ;   final ResponseMetadata  meta =  new ResponseMetadata  ( response ) ;  if  (  obj instanceof RecurlyObject )  {    (  ( RecurlyObject ) obj ) . setRecurlyClient  ( this ) ; } else  if  (  obj instanceof RecurlyObjects )  {   final RecurlyObjects  recurlyObjects =  ( RecurlyObjects ) obj ;   recurlyObjects . setRecurlyClient  ( this ) ;  for (  final Object object : recurlyObjects )  {    (  ( RecurlyObject ) object ) . setRecurlyClient  ( this ) ; }   final String  linkHeader =  response . getHeader  ( LINK_HEADER_NAME ) ;  if  (  linkHeader != null )  {   final  String  [ ]  links =  PaginationUtils . getLinks  ( linkHeader ) ;   recurlyObjects . setStartUrl  (  links [ 0 ] ) ;   recurlyObjects . setNextUrl  (  links [ 1 ] ) ; } }  String  rateLimitRemainingString =  response . getHeader  ( X_RATELIMIT_REMAINING_HEADER_NAME ) ;  if  (  rateLimitRemainingString != null )   rateLimitRemaining =  Integer . parseInt  ( rateLimitRemainingString ) ;  return obj ; }  finally  {   closeStream  ( in ) ; } }   private RecurlyAPIError createRecurlyAPIError  (  String payload ,   int statusCode )  {  RecurlyAPIError  recurlyError =  new RecurlyAPIError  ( ) ;  try  {   recurlyError =  xmlMapper . readValue  ( payload ,  RecurlyAPIError . class ) ; }  catch (   Exception e )  {   log . debug  ( "Unable to extract error" , e ) ; }   recurlyError . setHttpStatusCode  ( statusCode ) ;  return recurlyError ; }   private  AsyncHttpClient . BoundRequestBuilder clientRequestBuilderCommon  (   AsyncHttpClient . BoundRequestBuilder requestBuilder )  {  return      requestBuilder . addHeader  ( "Authorization" ,  "Basic " + key ) . addHeader  ( "X-Api-Version" , RECURLY_API_VERSION ) . addHeader  (  HttpHeaders . USER_AGENT , userAgent ) . addHeader  ( "Accept-Language" , acceptLanguage ) . setBodyEncoding  ( "UTF-8" ) ; }   private String convertStreamToString  (   final   java . io . InputStream is )  {  try  {  return    new Scanner  ( is ) . useDelimiter  ( "\\A" ) . next  ( ) ; }  catch (   final  NoSuchElementException e )  {  return "" ; } }   private void closeStream  (   final InputStream in )  {  if  (  in != null )  {  try  {   in . close  ( ) ; }  catch (   IOException e )  {   log . warn  ( "Failed to close http-client - provided InputStream: {}" ,  e . getLocalizedMessage  ( ) ) ; } } }   protected AsyncHttpClient createHttpClient  ( )  throws KeyManagementException , NoSuchAlgorithmException  {   final  AsyncHttpClientConfig . Builder  builder =  new  AsyncHttpClientConfig . Builder  ( ) ;   builder . setMaxConnectionsPerHost  (  - 1 ) ;   builder . setSSLContext  (   SslUtils . getInstance  ( ) . getSSLContext  ( ) ) ;  return  new AsyncHttpClient  (  builder . build  ( ) ) ; }    @ VisibleForTesting String getUserAgent  ( )  {  return userAgent ; }   private String buildUserAgent  ( )  {   final String  defaultVersion = "0.0.0" ;   final String  defaultJavaVersion = "0.0.0" ;  try  {   final Properties  gitRepositoryState =  new Properties  ( ) ;   final URL  resourceURL =  Resources . getResource  ( GIT_PROPERTIES_FILE ) ;   final CharSource  charSource =  Resources . asCharSource  ( resourceURL ,  Charset . forName  ( "UTF-8" ) ) ;  Reader  reader = null ;  try  {   reader =  charSource . openStream  ( ) ;   gitRepositoryState . load  ( reader ) ; }  finally  {  if  (  reader != null )  {   reader . close  ( ) ; } }   final String  version =  MoreObjects . firstNonNull  (  getVersionFromGitRepositoryState  ( gitRepositoryState ) , defaultVersion ) ;   final String  javaVersion =  MoreObjects . firstNonNull  (   StandardSystemProperty . JAVA_VERSION . value  ( ) , defaultJavaVersion ) ;  return  String . format  ( "KillBill/%s; %s" , version , javaVersion ) ; }  catch (   final  Exception e )  {  return  String . format  ( "KillBill/%s; %s" , defaultVersion , defaultJavaVersion ) ; } }    @ VisibleForTesting String getVersionFromGitRepositoryState  (   final Properties gitRepositoryState )  {   final String  gitDescribe =  gitRepositoryState . getProperty  ( GIT_COMMIT_ID_DESCRIBE_SHORT ) ;  if  (  gitDescribe == null )  {  return null ; }   final Matcher  matcher =  TAG_FROM_GIT_DESCRIBE_PATTERN . matcher  ( gitDescribe ) ;  return   matcher . find  ( ) ?  matcher . group  ( 1 ) : null ; }   private static final String  X_RATELIMIT_REMAINING_HEADER_NAME = "X-RateLimit-Remaining" ;   private static final  List  < String >  validHosts =  Arrays . asList  ( "recurly.com" ) ;   private static void loggerWarning  ( )  {  if  (  debug  ( ) )  {   log . warn  (  "[WARNING] Logger enabled. The logger has the potential to leak " + "PII and should never be used in production environments." ) ; } }   private String  acceptLanguage = "en-US" ;   private  int  rateLimitRemaining ;   public void setAcceptLanguage  (  String language )  {    this . acceptLanguage = language ; }   public  int getRateLimitRemaining  ( )  {  return rateLimitRemaining ; }   public Accounts getChildAccounts  (   final String accountCode )  {  return  doGET  (     Account . ACCOUNT_RESOURCE + "/" + accountCode + "/child_accounts" ,  Accounts . class ,  new QueryParams  ( ) ) ; }   public Subscription pauseSubscription  (   final String subscriptionUuid ,   final  int remainingPauseCycles )  {  Subscription  request =  new Subscription  ( ) ;   request . setRemainingPauseCycles  ( remainingPauseCycles ) ;  return  doPUT  (     Subscription . SUBSCRIPTION_RESOURCE + "/" + subscriptionUuid + "/pause" , request ,  Subscription . class ) ; }   public Subscription resumeSubscription  (   final String subscriptionUuid )  {  return  doPUT  (     Subscription . SUBSCRIPTION_RESOURCE + "/" + subscriptionUuid + "/resume" , null ,  Subscription . class ) ; }   public Usages getSubscriptionUsages  (   final String subscriptionCode ,   final String addOnCode ,   final QueryParams params )  {  return  doGET  (        Subscription . SUBSCRIPTION_RESOURCE + "/" + subscriptionCode +  AddOn . ADDONS_RESOURCE + "/" + addOnCode +  Usage . USAGE_RESOURCE ,  Usages . class , params ) ; }   public BillingInfo createOrUpdateBillingInfo  (   final String accountCode ,   final BillingInfo billingInfo )  {  return  doPUT  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  BillingInfo . BILLING_INFO_RESOURCE , billingInfo ,  BillingInfo . class ) ; }   public AccountNotes getAccountNotes  (   final String accountCode )  {  return  doGET  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  AccountNotes . ACCOUNT_NOTES_RESOURCE ,  AccountNotes . class ,  new QueryParams  ( ) ) ; }   public Invoice updateInvoice  (   final String invoiceId ,   final Invoice invoice )  {  return  doPUT  (    Invoices . INVOICES_RESOURCE + "/" + invoiceId , invoice ,  Invoice . class ) ; }   public Invoices getInvoices  ( )  {  return  doGET  (  Invoices . INVOICES_RESOURCE ,  Invoices . class ,  new QueryParams  ( ) ) ; }   public Invoices getInvoices  (   final QueryParams params )  {  return  doGET  (  Invoices . INVOICES_RESOURCE ,  Invoices . class , params ) ; }   public  int getInvoicesCount  (   final QueryParams params )  {  FluentCaseInsensitiveStringsMap  map =  doHEAD  (  Invoices . INVOICES_RESOURCE , params ) ;  return  Integer . parseInt  (  map . getFirstValue  ( X_RECORDS_HEADER_NAME ) ) ; }   public Transactions getInvoiceTransactions  (   final String invoiceId )  {  return  doGET  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId +  Transactions . TRANSACTIONS_RESOURCE ,  Transactions . class ,  new QueryParams  ( ) ) ; }   public Invoices getOriginalInvoices  (   final String invoiceId )  {  return  doGET  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId + "/original_invoices" ,  Invoices . class ,  new QueryParams  ( ) ) ; }    @ Deprecated public Invoice refundInvoice  (   final String invoiceId ,   final Integer amountInCents ,   final RefundMethod method )  {   final InvoiceRefund  invoiceRefund =  new InvoiceRefund  ( ) ;   invoiceRefund . setRefundMethod  ( method ) ;   invoiceRefund . setAmountInCents  ( amountInCents ) ;  return  refundInvoice  ( invoiceId , invoiceRefund ) ; }    @ Deprecated public Invoice refundInvoice  (   final String invoiceId ,   List  < AdjustmentRefund > lineItems ,   final RefundMethod method )  {   final InvoiceRefund  invoiceRefund =  new InvoiceRefund  ( ) ;   invoiceRefund . setRefundMethod  ( method ) ;   invoiceRefund . setLineItems  ( lineItems ) ;  return  refundInvoice  ( invoiceId , invoiceRefund ) ; }   public Invoice refundInvoice  (   final String invoiceId ,   final InvoiceRefund refundOptions )  {  return  doPOST  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId + "/refund" , refundOptions ,  Invoice . class ) ; }   public ShippingAddress getShippingAddress  (   final String accountCode ,   final  long shippingAddressId )  {  return  doGET  (       Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  ShippingAddresses . SHIPPING_ADDRESSES_RESOURCE + "/" + shippingAddressId ,  ShippingAddress . class ) ; }   public ShippingAddress createShippingAddress  (   final String accountCode ,   final ShippingAddress shippingAddress )  {  return  doPOST  (     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  ShippingAddresses . SHIPPING_ADDRESSES_RESOURCE , shippingAddress ,  ShippingAddress . class ) ; }   public ShippingAddress updateShippingAddress  (   final String accountCode ,   final  long shippingAddressId ,  ShippingAddress shippingAddress )  {  return  doPUT  (       Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  ShippingAddresses . SHIPPING_ADDRESSES_RESOURCE + "/" + shippingAddressId , shippingAddress ,  ShippingAddress . class ) ; }   public void deleteShippingAddress  (   final String accountCode ,   final  long shippingAddressId )  {   doDELETE  (       Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  ShippingAddresses . SHIPPING_ADDRESSES_RESOURCE + "/" + shippingAddressId ) ; }   public Invoice voidInvoice  (   final String invoiceId )  {  return  doPUT  (     Invoices . INVOICES_RESOURCE + "/" + invoiceId + "/void" , null ,  Invoice . class ) ; }   public AddOn updateAddOn  (   final String planCode ,   final String addOnCode ,   final AddOn addOn )  {  return  doPUT  (       Plan . PLANS_RESOURCE + "/" + planCode +  AddOn . ADDONS_RESOURCE + "/" + addOnCode , addOn ,  AddOn . class ) ; }   public Redemptions getCouponRedemptionsBySubscription  (   final String subscriptionUuid ,   final QueryParams params )  {  return  doGET  (     Subscription . SUBSCRIPTION_RESOURCE + "/" + subscriptionUuid +  Redemptions . REDEMPTIONS_RESOURCE ,  Redemptions . class , params ) ; }   public void generateUniqueCodes  (   final String couponCode ,   final Coupon coupon )  {   doPOST  (     Coupon . COUPON_RESOURCE + "/" + couponCode +  Coupon . GENERATE_RESOURCE , coupon , null ) ; }   public Coupons getUniqueCouponCodes  (   final String couponCode ,   final QueryParams params )  {  return  doGET  (     Coupon . COUPON_RESOURCE + "/" + couponCode +  Coupon . UNIQUE_CODES_RESOURCE ,  Coupons . class , params ) ; }   public InvoiceCollection pendingPurchase  (   final Purchase purchase )  {  return  doPOST  (   Purchase . PURCHASES_ENDPOINT + "/pending" , purchase ,  InvoiceCollection . class ) ; }   public CreditPayments getCreditPayments  ( )  {  return  doGET  (  CreditPayments . CREDIT_PAYMENTS_RESOURCE ,  CreditPayments . class ,  new QueryParams  ( ) ) ; }   public CreditPayments getCreditPayments  (   final QueryParams params )  {  return  doGET  (  CreditPayments . CREDIT_PAYMENTS_RESOURCE ,  CreditPayments . class , params ) ; }   public CreditPayments getCreditPayments  (   final String accountCode ,   final QueryParams params )  {   final String  path =     Accounts . ACCOUNTS_RESOURCE + "/" + accountCode +  CreditPayments . CREDIT_PAYMENTS_RESOURCE ;  return  doGET  ( path ,  CreditPayments . class , params ) ; }   public ShippingMethods getShippingMethods  ( )  {  return  doGET  (  ShippingMethods . SHIPPING_METHODS_RESOURCE ,  ShippingMethods . class ,  new QueryParams  ( ) ) ; }   public ShippingMethods getShippingMethods  (   final QueryParams params )  {  return  doGET  (  ShippingMethods . SHIPPING_METHODS_RESOURCE ,  ShippingMethods . class , params ) ; }   public ShippingMethod getShippingMethod  (   final String shippingMethodCode )  {  if  (   shippingMethodCode == null ||  shippingMethodCode . isEmpty  ( ) )  throw  new RuntimeException  ( "shippingMethodCode cannot be empty!" ) ;  return  doGET  (    ShippingMethod . SHIPPING_METHOD_RESOURCE + "/" + shippingMethodCode ,  ShippingMethod . class ) ; }   private void validateHost  (  String url )  {  String  host =   URI . create  ( url ) . getHost  ( ) ;   host =  host . substring  (   host . indexOf  ( "." ) + 1 ) ;  if  (  !  validHosts . contains  ( host ) )  {  String  exc =  String . format  ( "Attempted to make call to %s instead of Recurly" , host ) ;  throw  new RuntimeException  ( exc ) ; } } }