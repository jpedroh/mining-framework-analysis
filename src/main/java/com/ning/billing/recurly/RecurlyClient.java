  package    com . ning . billing . recurly ;   import   java . io . IOException ;  import   java . io . InputStream ;  import    java . util . concurrent . ExecutionException ;  import   java . util . List ;  import   javax . annotation . Nullable ;  import    javax . xml . bind . DatatypeConverter ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import      com . ning . billing . recurly . model . Plan ;  import      com . ning . billing . recurly . model . Plans ;  import      com . ning . billing . recurly . model . Account ;  import      com . ning . billing . recurly . model . BillingInfo ;  import      com . ning . billing . recurly . model . RecurlyObject ;  import     com . ning . http . client . AsyncCompletionHandler ;  import     com . ning . http . client . AsyncHttpClient ;  import     com . ning . http . client . AsyncHttpClientConfig ;  import     com . ning . http . client . Response ;  import     com . fasterxml . jackson . databind . AnnotationIntrospector ;  import     com . fasterxml . jackson . databind . SerializationFeature ;  import      com . fasterxml . jackson . databind . introspect . JacksonAnnotationIntrospector ;  import      com . fasterxml . jackson . dataformat . xml . XmlMapper ;  import      com . fasterxml . jackson . datatype . joda . JodaModule ;  import      com . fasterxml . jackson . module . jaxb . JaxbAnnotationIntrospector ;  import      com . ning . billing . recurly . model . Accounts ;   public class RecurlyClient  {   private static final Logger  log =  LoggerFactory . getLogger  (  RecurlyClient . class ) ;   private final XmlMapper  xmlMapper =  new XmlMapper  ( ) ;   private final String  key ;   private final String  baseUrl ;   private AsyncHttpClient  client ;   public RecurlyClient  (   final String apiKey )  {  this  ( apiKey , "api.recurly.com" , 443 , "v2" ) ; }   public RecurlyClient  (   final String apiKey ,   final String host ,   final  int port ,   final String version )  {    this . key =  DatatypeConverter . printBase64Binary  (  apiKey . getBytes  ( ) ) ;    this . baseUrl =  String . format  ( "https://%s:%d/%s" , host , port , version ) ;   final AnnotationIntrospector  primary =  new JacksonAnnotationIntrospector  ( ) ;   final AnnotationIntrospector  secondary =  new JaxbAnnotationIntrospector  ( ) ;   final AnnotationIntrospector  pair =  new  AnnotationIntrospector . Pair  ( primary , secondary ) ;   xmlMapper . setAnnotationIntrospector  ( pair ) ;   xmlMapper . registerModule  (  new JodaModule  ( ) ) ;   xmlMapper . disable  (  SerializationFeature . WRITE_DATES_AS_TIMESTAMPS ) ; }   public synchronized void open  ( )  {   client =  createHttpClient  ( ) ; }   public synchronized void close  ( )  {  if  (  client != null )  {   client . close  ( ) ; } }   public Account createAccount  (   final Account account )  {  return  doPOST  (  Account . ACCOUNT_RESOURCE , account ,  Account . class ) ; }   public Account getAccount  (   final String accountCode )  {  return  doGET  (    Account . ACCOUNT_RESOURCE + "/" + accountCode ,  Account . class ) ; }   public Account updateAccount  (   final String accountCode ,   final Account account )  {  return  doPUT  (    Account . ACCOUNT_RESOURCE + "/" + accountCode , account ,  Account . class ) ; }   public void closeAccount  (   final String accountCode )  {   doDELETE  (    Account . ACCOUNT_RESOURCE + "/" + accountCode ) ; }   public BillingInfo createOrUpdateBillingInfo  (   final BillingInfo billingInfo )  {   final String  accountCode =   billingInfo . getAccount  ( ) . getAccountCode  ( ) ;   billingInfo . setAccount  ( null ) ;  return  doPUT  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  BillingInfo . BILLING_INFO_RESOURCE , billingInfo ,  BillingInfo . class ) ; }   public BillingInfo getBillingInfo  (   final String accountCode )  {  return  doGET  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  BillingInfo . BILLING_INFO_RESOURCE ,  BillingInfo . class ) ; }   public void clearBillingInfo  (   final String accountCode )  {   doDELETE  (     Account . ACCOUNT_RESOURCE + "/" + accountCode +  BillingInfo . BILLING_INFO_RESOURCE ) ; }   public Plan createPlan  (   final Plan plan )  {  return  doPOST  (  Plan . PLANS_RESOURCE , plan ,  Plan . class ) ; }   public Plan getPlan  (   final String planCode )  {  return  doGET  (    Plan . PLANS_RESOURCE + "/" + planCode ,  Plan . class ) ; }   public Plans getPlans  ( )  {  return  doGET  (  Plans . PLANS_RESOURCE ,  Plans . class ) ; }   private  <  T > T doGET  (   final String resource ,   final  Class  < T > clazz )  {  return  callRecurlySafe  (  client . prepareGet  (  baseUrl + resource ) , clazz ) ; }   private  <  T > T doPOST  (   final String resource ,   final RecurlyObject payload ,   final  Class  < T > clazz )  {   final String  xmlPayload ;  try  {   xmlPayload =  xmlMapper . writeValueAsString  ( payload ) ; }  catch (   IOException e )  {   log . warn  ( "Unable to serialize {} object as XML: {}" ,  clazz . getName  ( ) ,  payload . toString  ( ) ) ;  return null ; }  return  callRecurlySafe  (   client . preparePost  (  baseUrl + resource ) . setBody  ( xmlPayload ) , clazz ) ; }   private  <  T > T doPUT  (   final String resource ,   final RecurlyObject payload ,   final  Class  < T > clazz )  {   final String  xmlPayload ;  try  {   xmlPayload =  xmlMapper . writeValueAsString  ( payload ) ; }  catch (   IOException e )  {   log . warn  ( "Unable to serialize {} object as XML: {}" ,  clazz . getName  ( ) ,  payload . toString  ( ) ) ;  return null ; }  return  callRecurlySafe  (   client . preparePut  (  baseUrl + resource ) . setBody  ( xmlPayload ) , clazz ) ; }   private void doDELETE  (   final String resource )  {   callRecurlySafe  (  client . prepareDelete  (  baseUrl + resource ) , null ) ; }   private  <  T > T callRecurlySafe  (   final  AsyncHttpClient . BoundRequestBuilder builder ,    @ Nullable final  Class  < T > clazz )  {  try  {  return  callRecurly  ( builder , clazz ) ; }  catch (   IOException e )  {   log . warn  ( "Error while calling Recurly" , e ) ;  return null ; }  catch (   ExecutionException e )  {   log . error  ( "Execution error" , e ) ;  return null ; }  catch (   InterruptedException e )  {   log . error  ( "Interrupted while calling Recurly" , e ) ;  return null ; } }   private  <  T > T callRecurly  (   final  AsyncHttpClient . BoundRequestBuilder builder ,    @ Nullable final  Class  < T > clazz )  throws IOException , ExecutionException , InterruptedException  {  return      builder . addHeader  ( "Authorization" ,  "Basic " + key ) . addHeader  ( "Accept" , "application/xml" ) . addHeader  ( "Content-Type" , "application/xml; charset=utf-8" ) . execute  (  new  AsyncCompletionHandler  < T >  ( )  {    @ Override public T onCompleted  (   final Response response )  throws Exception  {  if  (   response . getStatusCode  ( ) >= 300 )  {   log . warn  ( "Recurly error: {}" ,  response . getResponseBody  ( ) ) ;  return null ; }  if  (  clazz == null )  {  return null ; }   final InputStream  in =  response . getResponseBodyAsStream  ( ) ;  try  {  String  payload =  convertStreamToString  ( in ) ;    System . out . println  ( "**** MESSAGE ****" ) ;    System . out . println  ( payload ) ;  T  obj =  xmlMapper . readValue  ( payload , clazz ) ;  return obj ; }  finally  {   closeStream  ( in ) ; } } } ) . get  ( ) ; }   private String convertStreamToString  (    java . io . InputStream is )  {  try  {  return    new   java . util . Scanner  ( is ) . useDelimiter  ( "\\A" ) . next  ( ) ; }  catch (     java . util . NoSuchElementException e )  {  return "" ; } }   private void closeStream  (   final InputStream in )  {  if  (  in != null )  {  try  {   in . close  ( ) ; }  catch (   IOException e )  {   log . warn  ( "Failed to close http-client - provided InputStream: {}" ,  e . getLocalizedMessage  ( ) ) ; } } }   private AsyncHttpClient createHttpClient  ( )  {   final  AsyncHttpClientConfig . Builder  builder =  new  AsyncHttpClientConfig . Builder  ( ) ;   builder . setMaximumConnectionsPerHost  (  - 1 ) ;  return  new AsyncHttpClient  (  builder . build  ( ) ) ; }   public Accounts getAccounts  ( )  {  return  doGET  (  Accounts . ACCOUNTS_RESOURCE ,  Accounts . class ) ; } }