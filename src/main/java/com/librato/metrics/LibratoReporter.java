  package   com . librato . metrics ;   import    com . ning . http . client .  * ;  import     com . ning . http . util . Base64 ;  import    com . yammer . metrics . Metrics ;  import    com . yammer . metrics . core .  * ;  import     com . yammer . metrics . reporting . AbstractPollingReporter ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import   java . util . Map ;  import   java . util . SortedMap ;  import    java . util . concurrent . TimeUnit ;  import    java . util . concurrent . ScheduledExecutorService ;  import   java . util . EnumSet ;  import   java . util . Set ;   public class LibratoReporter  extends AbstractPollingReporter  implements   MetricProcessor  < MetricsLibratoBatch >  {   private static final Logger  LOG =  LoggerFactory . getLogger  (  LibratoReporter . class ) ;   private final String  source ;   private final String  authHeader ;   private final String  apiUrl ;   private final  long  timeout ;   private final TimeUnit  timeoutUnit ;   private final  APIUtil . Sanitizer  sanitizer ;   private final AsyncHttpClient  httpClient =  new AsyncHttpClient  ( ) ;   private final ScheduledExecutorService  executor ;   protected final MetricsRegistry  registry ;   protected final MetricPredicate  predicate ;   protected final Clock  clock ;   protected final VirtualMachineMetrics  vm ;   protected final boolean  reportVmMetrics ;    @ Override public void run  ( )  {  MetricsLibratoBatch  batch =  new MetricsLibratoBatch  (  LibratoBatch . DEFAULT_BATCH_SIZE , sanitizer , timeout , timeoutUnit , expansionConfig ) ;  if  ( reportVmMetrics )  {   reportVmMetrics  ( batch ) ; }   reportRegularMetrics  ( batch ) ;   AsyncHttpClient . BoundRequestBuilder  builder =  httpClient . preparePost  ( apiUrl ) ;   builder . addHeader  ( "Content-Type" , "application/json" ) ;   builder . addHeader  ( "Authorization" , authHeader ) ;  try  {   batch . post  ( builder , source ,   TimeUnit . MILLISECONDS . toSeconds  (   this . clock . time  ( ) ) ) ; }  catch (   Exception e )  {   LOG . error  ( "Librato post failed: " , e ) ; } }    @ Override public void start  (   long period ,  TimeUnit unit )  {   executor . scheduleAtFixedRate  ( this , period , period , unit ) ; }   protected void reportVmMetrics  (  MetricsLibratoBatch batch )  {   LibratoUtil . addVmMetricsToBatch  ( vm , batch ) ; }   protected void reportRegularMetrics  (  MetricsLibratoBatch batch )  {  for (   Map . Entry  < String ,  SortedMap  < MetricName , Metric > > entry :    getMetricsRegistry  ( ) . groupedMetrics  ( predicate ) . entrySet  ( ) )  {  for (   Map . Entry  < MetricName , Metric > subEntry :   entry . getValue  ( ) . entrySet  ( ) )  {   final Metric  metric =  subEntry . getValue  ( ) ;  if  (  metric != null )  {  try  {   metric . processWith  ( this ,  subEntry . getKey  ( ) , batch ) ; }  catch (   Exception e )  {   LOG . error  ( "Error processing regular metrics:" , e ) ; } } } } }   private String getStringName  (  MetricName fullName )  {  return  sanitizer . apply  (  LibratoUtil . nameToString  ( fullName ) ) ; }   public void processMeter  (  MetricName name ,  Metered meter ,  MetricsLibratoBatch batch )  throws Exception  {   batch . addMetered  (  getStringName  ( name ) , meter ) ; }   public void processCounter  (  MetricName name ,  Counter counter ,  MetricsLibratoBatch batch )  throws Exception  {   batch . addCounterMeasurement  (  getStringName  ( name ) ,  counter . count  ( ) ) ; }   public void processHistogram  (  MetricName name ,  Histogram histogram ,  MetricsLibratoBatch batch )  throws Exception  {  String  sanitizedName =  getStringName  ( name ) ;   batch . addSummarizable  ( sanitizedName , histogram ) ;   batch . addSampling  ( sanitizedName , histogram ) ; }   public void processTimer  (  MetricName name ,  Timer timer ,  MetricsLibratoBatch batch )  throws Exception  {  String  sanitizedName =  getStringName  ( name ) ;   batch . addMetered  ( sanitizedName , timer ) ;   batch . addSummarizable  ( sanitizedName , timer ) ;   batch . addSampling  ( sanitizedName , timer ) ; }   public void processGauge  (  MetricName name ,   Gauge  <  ? > gauge ,  MetricsLibratoBatch batch )  throws Exception  {  if  (   gauge . value  ( ) instanceof Number )  {   batch . addGauge  (  getStringName  ( name ) , gauge ) ; } }   public static class Builder  {   private final String  username ;   private final String  token ;   private final String  source ;   private String  apiUrl = "https://metrics-api.librato.com/v1/metrics" ;   private  APIUtil . Sanitizer  sanitizer =  APIUtil . noopSanitizer ;   private  long  timeout = 5 ;   private TimeUnit  timeoutUnit =  TimeUnit . SECONDS ;   private String  name = "librato-reporter" ;   private MetricsRegistry  registry =  Metrics . defaultRegistry  ( ) ;   private MetricPredicate  predicate =  MetricPredicate . ALL ;   private Clock  clock =  Clock . defaultClock  ( ) ;   private VirtualMachineMetrics  vm =  VirtualMachineMetrics . getInstance  ( ) ;   private boolean  reportVmMetrics = true ;   public Builder  (  String username ,  String token ,  String source )  {  if  (   username == null ||  username . equals  ( "" ) )  {  throw  new IllegalArgumentException  (  String . format  ( "Username must be a non-null, non-empty string. You used '%s'" , username ) ) ; }  if  (   token == null ||  token . equals  ( "" ) )  {  throw  new IllegalArgumentException  (  String . format  ( "Token must be a non-null, non-empty string. You used '%s'" , username ) ) ; }    this . username = username ;    this . token = token ;    this . source = source ; }    @ SuppressWarnings  ( "unused" ) public Builder setApiUrl  (  String apiUrl )  {    this . apiUrl = apiUrl ;  return this ; }    @ SuppressWarnings  ( "unused" ) public Builder setTimeout  (   long timeout ,  TimeUnit timeoutUnit )  {    this . timeout = timeout ;    this . timeoutUnit = timeoutUnit ;  return this ; }    @ SuppressWarnings  ( "unused" ) public Builder setName  (  String name )  {    this . name = name ;  return this ; }    @ SuppressWarnings  ( "unused" ) public Builder setSanitizer  (   APIUtil . Sanitizer sanitizer )  {    this . sanitizer = sanitizer ;  return this ; }    @ SuppressWarnings  ( "unused" ) public Builder setRegistry  (  MetricsRegistry registry )  {    this . registry = registry ;  return this ; }    @ SuppressWarnings  ( "unused" ) public Builder setPredicate  (  MetricPredicate predicate )  {    this . predicate = predicate ;  return this ; }    @ SuppressWarnings  ( "unused" ) public Builder setClock  (  Clock clock )  {    this . clock = clock ;  return this ; }    @ SuppressWarnings  ( "unused" ) public Builder setVm  (  VirtualMachineMetrics vm )  {    this . vm = vm ;  return this ; }   public Builder setReportVmMetrics  (  boolean reportVmMetrics )  {    this . reportVmMetrics = reportVmMetrics ;  return this ; }   public LibratoReporter build  ( )  {  String  auth =  String . format  ( "Basic %s" ,  Base64 . encode  (   (   username + ":" + token ) . getBytes  ( ) ) ) ;  return  new LibratoReporter  ( auth , apiUrl , name , sanitizer , source , timeout , timeoutUnit , registry , predicate , clock , vm , reportVmMetrics , expansionConfig ) ; }   private MetricExpansionConfig  expansionConfig =  MetricExpansionConfig . ALL ;   public Builder setExpansionConfig  (  MetricExpansionConfig expansionConfig )  {    this . expansionConfig = expansionConfig ;  return this ; } }   public static Builder builder  (  String username ,  String token ,  String source )  {  return  new Builder  ( username , token , source ) ; }   public static void enable  (  Builder builder ,   long interval ,  TimeUnit unit )  {    builder . build  ( ) . start  ( interval , unit ) ; }   protected final MetricExpansionConfig  expansionConfig ;   private LibratoReporter  (  String authHeader ,  String apiUrl ,  String name ,   final  APIUtil . Sanitizer customSanitizer ,  String source ,   long timeout ,  TimeUnit timeoutUnit ,  MetricsRegistry registry ,  MetricPredicate predicate ,  Clock clock ,  VirtualMachineMetrics vm ,  boolean reportVmMetrics ,  MetricExpansionConfig expansionConfig )  {  super  ( registry , name ) ;    this . authHeader = authHeader ;    this . sanitizer = customSanitizer ;    this . apiUrl = apiUrl ;    this . source = source ;    this . timeout = timeout ;    this . timeoutUnit = timeoutUnit ;    this . registry = registry ;    this . predicate = predicate ;    this . clock = clock ;    this . vm = vm ;    this . reportVmMetrics = reportVmMetrics ;    this . expansionConfig = expansionConfig ;    this . executor =  registry . newScheduledThreadPool  ( 1 , name ) ; }   public static enum ExpandedMetric  {  MEDIAN  ( "median" ) ,  PCT_75  ( "75th" ) ,  PCT_95  ( "95th" ) ,  PCT_98  ( "98th" ) ,  PCT_99  ( "99th" ) ,  PCT_999  ( "999th" ) ,  COUNT  ( "count" ) ,  RATE_MEAN  ( "meanRate" ) ,  RATE_1_MINUTE  ( "1MinuteRate" ) ,  RATE_5_MINUTE  ( "5MinuteRate" ) ,  RATE_15_MINUTE  ( "15MinuteRate" )  ;   private String  displayName ;   public String buildMetricName  (  String metric )  {  StringBuilder  sb =  new StringBuilder  ( metric ) ;    sb . append  ( '.' ) . append  (  this . displayName ) ;  return  sb . toString  ( ) ; }   private ExpandedMetric  (  String displayName )  {    this . displayName = displayName ; } }   public static class MetricExpansionConfig  {   public static MetricExpansionConfig  ALL =  new MetricExpansionConfig  (  EnumSet . allOf  (  ExpandedMetric . class ) ) ;   private final  Set  < ExpandedMetric >  enabled ;   public MetricExpansionConfig  (   Set  < ExpandedMetric > enabled )  {    this . enabled =  EnumSet . copyOf  ( enabled ) ; }   public boolean isSet  (  ExpandedMetric metric )  {  return  enabled . contains  ( metric ) ; } } }