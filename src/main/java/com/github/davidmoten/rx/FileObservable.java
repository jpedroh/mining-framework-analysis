  package    com . github . davidmoten . rx ;   import   java . io . File ;  import    java . nio . charset . Charset ;  import    java . nio . file . Path ;  import    java . nio . file . Paths ;  import    java . nio . file . StandardWatchEventKinds ;  import    java . nio . file . WatchEvent ;  import     java . nio . file . WatchEvent . Kind ;  import    java . nio . file . WatchService ;  import    java . util . concurrent . TimeUnit ;  import  rx . Observable ;  import   rx . Observable . OnSubscribe ;  import  rx . Subscriber ;  import   rx . functions . Action0 ;  import   rx . functions . Action1 ;  import   rx . functions . Func1 ;  import   rx . observables . StringObservable ;  import      com . github . davidmoten . rx . operators . OperatorFileTailer ;  import      com . github . davidmoten . rx . operators . OperatorWatchServiceEvents ;  import   rx . observables . GroupedObservable ;   public final class FileObservable  {   public static final  int  DEFAULT_MAX_BYTES_PER_EMISSION = 8192 ;   public final static  Observable  <   byte  [ ] > tailFile  (  File file ,   long startPosition ,   long sampleTimeMs ,   int chunkSize )  {   Observable  < Object >  events =    from  ( file ,  StandardWatchEventKinds . ENTRY_CREATE ,  StandardWatchEventKinds . ENTRY_MODIFY ,  StandardWatchEventKinds . OVERFLOW ) . cast  (  Object . class ) . startWith  (  new Object  ( ) ) ;  return  tailFile  ( file , startPosition , sampleTimeMs , chunkSize , events ) ; }   public final static  Observable  <   byte  [ ] > tailFile  (  File file ,   long startPosition ,   long sampleTimeMs ,   int chunkSize ,   Observable  <  ? > events )  {  return   sampleModifyOrOverflowEventsOnly  ( events , sampleTimeMs ) . lift  (  new OperatorFileTailer  ( file , startPosition , chunkSize ) ) ; }   public final static  Observable  < String > tailTextFile  (  File file ,   long startPosition ,   long sampleTimeMs ,  Charset charset )  {  return  toLines  (  tailFile  ( file , startPosition , sampleTimeMs , DEFAULT_MAX_BYTES_PER_EMISSION ) , charset ) ; }   public final static  Observable  < String > tailTextFile  (  File file ,   long startPosition ,   int chunkSize ,  Charset charset ,   Observable  <  ? > events )  {  return  toLines  (  events . lift  (  new OperatorFileTailer  ( file , startPosition , chunkSize ) ) , charset ) ; }   public final static  Observable  <  WatchEvent  <  ? > > from  (  WatchService watchService )  {  return   Observable . from  ( watchService ) . lift  (  new OperatorWatchServiceEvents  ( ) ) ; }    @ SafeVarargs public final static  Observable  <  WatchEvent  <  ? > > from  (   final File file ,   Kind  <  ? > ...  kinds )  {  return  from  ( file , null , kinds ) ; }   public final static  Observable  <  WatchEvent  <  ? > > from  (   final File file ,   final Action0 onWatchStarted ,   Kind  <  ? > ...  kinds )  {  return     watchService  ( file , kinds ) . doOnNext  (  new  Action1  < WatchService >  ( )  {    @ Override public void call  (  WatchService w )  {  if  (  onWatchStarted != null )   onWatchStarted . call  ( ) ; } } ) . flatMap  ( TO_WATCH_EVENTS ) . filter  (  onlyRelatedTo  ( file ) ) ; }    @ SafeVarargs public final static  Observable  < WatchService > watchService  (   final File file ,   final  Kind  <  ? > ...  kinds )  {  return  Observable . create  (  new  OnSubscribe  < WatchService >  ( )  {    @ Override public void call  (   Subscriber  <  ? super WatchService > subscriber )  {  try  {   final Path  path =  getBasePath  ( file ) ;  WatchService  watchService =   path . getFileSystem  ( ) . newWatchService  ( ) ;   path . register  ( watchService , kinds ) ;   subscriber . onNext  ( watchService ) ;   subscriber . onCompleted  ( ) ; }  catch (   Exception e )  {   subscriber . onError  ( e ) ; } } } ) ; }   private final static Path getBasePath  (   final File file )  {   final Path  path ;  if  (   file . exists  ( ) &&  file . isDirectory  ( ) )   path =  Paths . get  (  file . toURI  ( ) ) ; else   path =  Paths . get  (   file . getParentFile  ( ) . toURI  ( ) ) ;  return path ; }   private final static  Func1  <  WatchEvent  <  ? > , Boolean > onlyRelatedTo  (   final File file )  {  return  new  Func1  <  WatchEvent  <  ? > , Boolean >  ( )  {    @ Override public Boolean call  (   WatchEvent  <  ? > event )  {   final boolean  ok ;  if  (  file . isDirectory  ( ) )   ok = true ; else  if  (   StandardWatchEventKinds . OVERFLOW . equals  (  event . kind  ( ) ) )   ok = true ; else  {  Object  context =  event . context  ( ) ;  if  (   context != null &&  context instanceof Path )  {  Path  p =  ( Path ) context ;  Path  basePath =  getBasePath  ( file ) ;  File  pFile =  new File  (  basePath . toFile  ( ) ,  p . toString  ( ) ) ;   ok =   pFile . getAbsolutePath  ( ) . equals  (  file . getAbsolutePath  ( ) ) ; } else   ok = false ; }  return ok ; } } ; }   private static  Observable  < String > toLines  (   Observable  <   byte  [ ] > bytes ,  Charset charset )  {  return  StringObservable . split  (  StringObservable . decode  ( bytes , charset ) , "\n" ) ; }   private final static  Func1  < WatchService ,  Observable  <  WatchEvent  <  ? > > >  TO_WATCH_EVENTS =  new  Func1  < WatchService ,  Observable  <  WatchEvent  <  ? > > >  ( )  {    @ Override public  Observable  <  WatchEvent  <  ? > > call  (  WatchService watchService )  {  return  from  ( watchService ) ; } } ;   public static Builder tailer  ( )  {  return  new Builder  ( ) ; }   public static class Builder  {   private File  file = null ;   private  long  startPosition = 0 ;   private  long  sampleTimeMs = 500 ;   private  int  chunkSize = 8192 ;   private Charset  charset =  Charset . defaultCharset  ( ) ;   private  Observable  <  ? >  source = null ;   private Action0  onWatchStarted =  new Action0  ( )  {    @ Override public void call  ( )  { } } ;   private Builder  ( )  { }   public Builder file  (  File file )  {    this . file = file ; 
<<<<<<<
=======
   this . source =  from  ( file ,  StandardWatchEventKinds . ENTRY_CREATE ,  StandardWatchEventKinds . ENTRY_MODIFY ,  StandardWatchEventKinds . OVERFLOW ) ;
>>>>>>>
  return this ; }   public Builder file  (  String filename )  {  return  file  (  new File  ( filename ) ) ; }   public Builder onWatchStarted  (  Action0 onWatchStarted )  {    this . onWatchStarted = onWatchStarted ;  return this ; }   public Builder startPosition  (   long startPosition )  {    this . startPosition = startPosition ;  return this ; }   public Builder sampleTimeMs  (   long sampleTimeMs )  {    this . sampleTimeMs = sampleTimeMs ;  return this ; }   public Builder chunkSize  (   int chunkSize )  {    this . chunkSize = chunkSize ;  return this ; }   public Builder charset  (  Charset charset )  {    this . charset = charset ;  return this ; }   public Builder charset  (  String charset )  {  return  charset  (  Charset . forName  ( charset ) ) ; }   public Builder utf8  ( )  {  return  charset  ( "UTF-8" ) ; }   public Builder source  (   Observable  <  ? > source )  {    this . source = source ;  return this ; }   public  Observable  <   byte  [ ] > tail  ( )  {  return  tailFile  ( file , startPosition , sampleTimeMs , chunkSize ,  getSource  ( ) ) ; }   public  Observable  < String > tailText  ( )  {  return  tailTextFile  ( file , startPosition , chunkSize , charset ,  getSource  ( ) ) ; }   private  Observable  <  ? > getSource  ( )  {  if  (  source == null )  return  from  ( file , onWatchStarted ,  StandardWatchEventKinds . ENTRY_CREATE ,  StandardWatchEventKinds . ENTRY_DELETE ,  StandardWatchEventKinds . ENTRY_MODIFY ,  StandardWatchEventKinds . OVERFLOW ) ; else  return source ; } }   private static  Observable  < Object > sampleModifyOrOverflowEventsOnly  (   Observable  <  ? > events ,   final  long sampleTimeMs )  {  return   events . groupBy  ( IS_MODIFY_OR_OVERFLOW ) . flatMap  (  sampleIfTrue  ( sampleTimeMs ) ) ; }   private static  Func1  <  GroupedObservable  < Boolean ,  ? > ,  Observable  <  ? > > sampleIfTrue  (   final  long sampleTimeMs )  {  return  new  Func1  <  GroupedObservable  < Boolean ,  ? > ,  Observable  <  ? > >  ( )  {    @ Override public  Observable  <  ? > call  (   GroupedObservable  < Boolean ,  ? > group )  {  if  (  group . getKey  ( ) )  return  group . sample  ( sampleTimeMs ,  TimeUnit . MILLISECONDS ) ; else  return group ; } } ; }   private static  Func1  < Object , Boolean >  IS_MODIFY_OR_OVERFLOW =  new  Func1  < Object , Boolean >  ( )  {    @ Override public Boolean call  (  Object event )  {  if  (  event instanceof WatchEvent )  {   WatchEvent  <  ? >  w =  (  WatchEvent  <  ? > ) event ;  String  kind =   w . kind  ( ) . name  ( ) ;  if  (   kind . equals  (   StandardWatchEventKinds . ENTRY_MODIFY . name  ( ) ) ||  kind . equals  (   StandardWatchEventKinds . OVERFLOW . name  ( ) ) )  {  return true ; } else  return false ; } else  return false ; } } ; }