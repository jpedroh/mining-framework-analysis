  package    com . github . javafaker . service ;   import    java . lang . reflect . Constructor ;  import    java . lang . reflect . InvocationTargetException ;  import    java . lang . reflect . Method ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . List ;  import   java . util . Locale ;  import   java . util . Map ;  import    java . util . logging . Level ;  import    java . util . logging . Logger ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import     org . apache . commons . lang3 . ClassUtils ;  import     org . apache . commons . lang3 . StringUtils ;  import    com . github . javafaker . Address ;  import    com . github . javafaker . Faker ;  import    com . github . javafaker . Name ;  import      com . github . javafaker . service . files . EnFile ;  import     com . mifmif . common . regex . Generex ;   public class FakeValuesService  {   private static final Pattern  EXPRESSION_PATTERN =  Pattern . compile  ( "#\\{([a-z0-9A-Z_.]+)\\s?(?:'([^']+)')?(?:,'([^']+)')*}" ) ;   private final Logger  log =  Logger . getLogger  ( "faker" ) ;   private final  List  < FakeValuesInterface >  fakeValuesList ;   private final RandomService  randomService ;    @ SuppressWarnings  (  { "unchecked" , "rawtypes" } ) public FakeValuesService  (  Locale locale ,  RandomService randomService )  {  if  (  locale == null )  {  throw  new IllegalArgumentException  ( "locale is required" ) ; }    this . randomService = randomService ;   locale =  normalizeLocale  ( locale ) ;   final  List  < Locale >  locales =  localeChain  ( locale ) ;   final  List  < FakeValuesInterface >  all =  new ArrayList  (  locales . size  ( ) ) ;  for (  final Locale l : locales )  {  boolean  isEnglish =  l . equals  (  Locale . ENGLISH ) ;  if  ( isEnglish )  {  FakeValuesGrouping  fakeValuesGrouping =  new FakeValuesGrouping  ( ) ;  for ( EnFile file :  EnFile . getFiles  ( ) )  {   fakeValuesGrouping . add  (  new FakeValues  ( l ,  file . getFile  ( ) ,  file . getPath  ( ) ) ) ; }   all . add  ( fakeValuesGrouping ) ; } else  {   all . add  (  new FakeValues  ( locale ) ) ; } }    this . fakeValuesList =  Collections . unmodifiableList  ( all ) ; }   protected  List  < Locale > localeChain  (  Locale from )  {  if  (   Locale . ENGLISH . equals  ( from ) )  {  return  Collections . singletonList  (  Locale . ENGLISH ) ; }   final Locale  normalized =  normalizeLocale  ( from ) ;   final  List  < Locale >  chain =  new  ArrayList  < Locale >  ( 3 ) ;   chain . add  ( normalized ) ;  if  (   !  "" . equals  (  normalized . getCountry  ( ) ) &&  !    Locale . ENGLISH . getLanguage  ( ) . equals  (  normalized . getLanguage  ( ) ) )  {   chain . add  (  new Locale  (  normalized . getLanguage  ( ) ) ) ; }   chain . add  (  Locale . ENGLISH ) ;  return chain ; }   private Locale normalizeLocale  (  Locale locale )  {   final  String  [ ]  parts =   locale . toString  ( ) . split  ( "[-_]" ) ;  if  (   parts . length == 1 )  {  return  new Locale  (  parts [ 0 ] ) ; } else  {  return  new Locale  (  parts [ 0 ] ,  parts [ 1 ] ) ; } }   public Object fetch  (  String key )  {   List  <  ? >  valuesArray =  new  ArrayList  < Object >  ( ) ;  if  (   fetchObject  ( key ) instanceof ArrayList )   valuesArray =  (  ArrayList  <  ? > )  fetchObject  ( key ) ;  return   valuesArray == null ? null :  valuesArray . get  (  randomService . nextInt  (  valuesArray . size  ( ) ) ) ; }   public String fetchString  (  String key )  {  return  ( String )  fetch  ( key ) ; }    @ SuppressWarnings  ( "unchecked" ) public String safeFetch  (  String key ,  String defaultIfNull )  {  Object  o =  fetchObject  ( key ) ;  if  (  o == null )  return defaultIfNull ;  if  (  o instanceof List )  {   List  < String >  values =  (  List  < String > ) o ;  if  (  values . isEmpty  ( ) )  {  return defaultIfNull ; }  return  values . get  (  randomService . nextInt  (  values . size  ( ) ) ) ; } else  if  (  isSlashDelimitedRegex  (  o . toString  ( ) ) )  {  return  String . format  ( "#{regexify '%s'}" ,  trimRegexSlashes  (  o . toString  ( ) ) ) ; } else  {  return  ( String ) o ; } }   public Object fetchObject  (  String key )  {   String  [ ]  path =  key . split  ( "\\." ) ;  Object  result = null ;  for ( FakeValuesInterface fakeValuesInterface : fakeValuesList )  {  Object  currentValue = fakeValuesInterface ;  for (   int  p = 0 ;   currentValue != null &&  p <  path . length ;  p ++ )  {  String  currentPath =  path [ p ] ;  if  (  currentValue instanceof Map )  {   currentValue =   (  (  Map  <  ? ,  ? > ) currentValue ) . get  ( currentPath ) ; } else  {   currentValue =   (  ( FakeValuesInterface ) currentValue ) . get  ( currentPath ) ; } }   result = currentValue ;  if  (  result != null )  {  break ; } }  return result ; }   public String numerify  (  String numberString )  {  StringBuilder  sb =  new StringBuilder  ( ) ;  for (   int  i = 0 ;  i <  numberString . length  ( ) ;  i ++ )  {  if  (   numberString . charAt  ( i ) == '#' )  {   sb . append  (  randomService . nextInt  ( 10 ) ) ; } else  {   sb . append  (  numberString . charAt  ( i ) ) ; } }  return  sb . toString  ( ) ; }   public String bothify  (  String string )  {  return  letterify  (  numerify  ( string ) ) ; }   public String bothify  (  String string ,  boolean isUpper )  {  return  letterify  (  numerify  ( string ) , isUpper ) ; }   public String regexify  (  String regex )  {  Generex  generex =  new Generex  ( regex ) ;   generex . setSeed  (  randomService . nextLong  ( ) ) ;  return  generex . random  ( ) ; }   public String letterify  (  String letterString )  {  return  this . letterify  ( letterString , false ) ; }   public String letterify  (  String letterString ,  boolean isUpper )  {  return  letterHelper  (   ( isUpper ) ? 65 : 97 , letterString ) ; }   private String letterHelper  (   int baseChar ,  String letterString )  {  StringBuilder  sb =  new StringBuilder  ( ) ;  for (   int  i = 0 ;  i <  letterString . length  ( ) ;  i ++ )  {  if  (   letterString . charAt  ( i ) == '?' )  {   sb . append  (  (  char )  (  baseChar +  randomService . nextInt  ( 26 ) ) ) ; } else  {   sb . append  (  letterString . charAt  ( i ) ) ; } }  return  sb . toString  ( ) ; }   public String resolve  (  String key ,  Object current ,  Faker root )  {   final String  expression =  safeFetch  ( key , null ) ;  if  (  expression == null )  {  throw  new RuntimeException  (  key + " resulted in null expression" ) ; }  return  resolveExpression  ( expression , current , root ) ; }   public String expression  (  String expression ,  Faker faker )  {  return  resolveExpression  ( expression , null , faker ) ; }   protected String resolveExpression  (  String expression ,  Object current ,  Faker root )  {   final Matcher  matcher =  EXPRESSION_PATTERN . matcher  ( expression ) ;  String  result = expression ;  while  (  matcher . find  ( ) )  {   final String  escapedDirective =  matcher . group  ( 0 ) ;   final String  directive =  matcher . group  ( 1 ) ;   List  < String >  args =  new  ArrayList  < String >  ( ) ;  for (   int  i = 2 ;   i <   matcher . groupCount  ( ) + 1 &&   matcher . group  ( i ) != null ;  i ++ )  {   args . add  (  matcher . group  ( i ) ) ; }  String  resolved =  resolveExpression  ( directive , args , current , root ) ;  if  (  resolved == null )  {  throw  new RuntimeException  (   "Unable to resolve " + escapedDirective + " directive." ) ; }   resolved =  resolveExpression  ( resolved , current , root ) ;   result =  StringUtils . replaceOnce  ( result , escapedDirective , resolved ) ; }  return result ; }   private String resolveExpression  (  String directive ,   List  < String > args ,  Object current ,  Faker root )  {   final String  simpleDirective =   (   isDotDirective  ( directive ) ||  current == null ) ? directive :    classNameToYamlName  ( current ) + "." + directive ;  String  resolved = null ;  if  (  !  isDotDirective  ( directive ) )  {   resolved =  resolveFromMethodOn  ( current , directive , args ) ; }  if  (  resolved == null )  {   resolved =  safeFetch  ( simpleDirective , null ) ; }  if  (   resolved == null &&  !  isDotDirective  ( directive ) )  {   resolved =  resolveFromMethodOn  ( root , directive , args ) ; }  if  (   resolved == null &&  isDotDirective  ( directive ) )  {   resolved =  resolveFakerObjectAndMethod  ( root , directive , args ) ; }  if  (   resolved == null &&  isDotDirective  ( directive ) )  {   resolved =  safeFetch  (  javaNameToYamlName  ( simpleDirective ) , null ) ; }  return resolved ; }   private boolean isSlashDelimitedRegex  (  String expression )  {  return    expression != null &&  expression . startsWith  ( "/" ) &&  expression . endsWith  ( "/" ) ; }   private String trimRegexSlashes  (  String slashDelimitedRegex )  {  return  slashDelimitedRegex . substring  ( 1 ,   slashDelimitedRegex . length  ( ) - 1 ) ; }   private boolean isDotDirective  (  String directive )  {  return  directive . contains  ( "." ) ; }   private String classNameToYamlName  (  Object current )  {  return  javaNameToYamlName  (   current . getClass  ( ) . getSimpleName  ( ) ) ; }   private String javaNameToYamlName  (  String expression )  {  return    expression . replaceAll  ( "([A-Z])" , "_$1" ) . substring  ( 1 ) . toLowerCase  ( ) ; }   private String resolveFromMethodOn  (  Object obj ,  String directive ,   List  < String > args )  {  if  (  obj == null )  {  return null ; }  try  {   final MethodAndCoercedArgs  accessor =  accessor  ( obj , directive , args ) ;  return   (  accessor == null ) ? null :  string  (  accessor . invoke  ( obj ) ) ; }  catch (   Exception e )  {   log . log  (  Level . FINE ,    "Can't call " + directive + " on " + obj , e ) ;  return null ; } }   private String resolveFakerObjectAndMethod  (  Faker faker ,  String key ,   List  < String > args )  {   final  String  [ ]  classAndMethod =  key . split  ( "\\." , 2 ) ;  try  {  String  fakerMethodName =   classAndMethod [ 0 ] . replaceAll  ( "_" , "" ) ;  MethodAndCoercedArgs  fakerAccessor =  accessor  ( faker , fakerMethodName ,  Collections .  < String > emptyList  ( ) ) ;  if  (  fakerAccessor == null )  {   log . fine  (   "Can't find top level faker object named " + fakerMethodName + "." ) ;  return null ; }  Object  objectWithMethodToInvoke =  fakerAccessor . invoke  ( faker ) ;  String  nestedMethodName =   classAndMethod [ 1 ] . replaceAll  ( "_" , "" ) ;   final MethodAndCoercedArgs  accessor =  accessor  ( objectWithMethodToInvoke ,   classAndMethod [ 1 ] . replaceAll  ( "_" , "" ) , args ) ;  if  (  accessor == null )  {  throw  new Exception  (     "Can't find method on " +   objectWithMethodToInvoke . getClass  ( ) . getSimpleName  ( ) + " called " + nestedMethodName + "." ) ; }  return  string  (  accessor . invoke  ( objectWithMethodToInvoke ) ) ; }  catch (   Exception e )  {   log . fine  (  e . getMessage  ( ) ) ;  return null ; } }   private MethodAndCoercedArgs accessor  (  Object onObject ,  String name ,   List  < String > args )  {   log . log  (  Level . FINE ,      "Find accessor named " + name + " on " +   onObject . getClass  ( ) . getSimpleName  ( ) + " with args " + args ) ;  for ( Method m :   onObject . getClass  ( ) . getMethods  ( ) )  {  if  (    m . getName  ( ) . equalsIgnoreCase  ( name ) &&    m . getParameterTypes  ( ) . length ==  args . size  ( ) )  {   final  List  < Object >  coercedArguments =  coerceArguments  ( m , args ) ;  if  (  coercedArguments != null )  {  return  new MethodAndCoercedArgs  ( m , coercedArguments ) ; } } }  if  (  name . contains  ( "_" ) )  {  return  accessor  ( onObject ,  name . replaceAll  ( "_" , "" ) , args ) ; }  return null ; }   private  List  < Object > coerceArguments  (  Method accessor ,   List  < String > args )  {   final  List  < Object >  coerced =  new  ArrayList  < Object >  ( ) ;  for (   int  i = 0 ;  i <   accessor . getParameterTypes  ( ) . length ;  i ++ )  {   Class  <  ? >  toType =  ClassUtils . primitiveToWrapper  (   accessor . getParameterTypes  ( ) [ i ] ) ;  try  {  if  (  toType . isEnum  ( ) )  {  Method  method =  toType . getMethod  ( "valueOf" ,  String . class ) ;  String  enumArg =   args . get  ( i ) . substring  (    args . get  ( i ) . indexOf  ( "." ) + 1 ) ;  Object  coercedArg =  method . invoke  ( null , enumArg ) ;   coerced . add  ( coercedArg ) ; } else  {   final  Constructor  <  ? >  ctor =  toType . getConstructor  (  String . class ) ;   final Object  coercedArgument =  ctor . newInstance  (  args . get  ( i ) ) ;   coerced . add  ( coercedArgument ) ; } }  catch (   Exception e )  {   log . fine  (       "Unable to coerce " +  args . get  ( i ) + " to " +  toType . getSimpleName  ( ) + " via " +  toType . getSimpleName  ( ) + "(String) constructor." ) ;  return null ; } }  return coerced ; }   private String string  (  Object obj )  {  return   (  obj == null ) ? null :  obj . toString  ( ) ; }   private static class MethodAndCoercedArgs  {   private final Method  method ;   private final  List  < Object >  coerced ;   private MethodAndCoercedArgs  (  Method m ,   List  < Object > coerced )  {    this . method =  requireNonNull  ( m , "method cannot be null" ) ;    this . coerced =  requireNonNull  ( coerced , "coerced arguments cannot be null" ) ; }   private Object invoke  (  Object on )  throws InvocationTargetException , IllegalAccessException  {  return  method . invoke  ( on ,  coerced . toArray  ( ) ) ; }   private  <  T > T requireNonNull  (  T instance ,  String messageIfNull )  {  if  (  instance == null )  {  throw  new NullPointerException  ( messageIfNull ) ; }  return instance ; } } }