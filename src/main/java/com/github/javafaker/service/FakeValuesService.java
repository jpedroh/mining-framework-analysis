  package    com . github . javafaker . service ;   import   java . io . File ;  import   java . io . InputStream ;  import    java . lang . reflect . Constructor ;  import    java . lang . reflect . InvocationTargetException ;  import    java . lang . reflect . Method ;  import   java . net . URL ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Locale ;  import   java . util . Map ;  import   java . util . Set ;  import    java . util . logging . Level ;  import    java . util . logging . Logger ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import     org . apache . commons . lang3 . ClassUtils ;  import     org . apache . commons . lang3 . StringUtils ;  import    org . yaml . snakeyaml . Yaml ;  import    com . github . javafaker . Address ;  import    com . github . javafaker . Faker ;  import    com . github . javafaker . Name ;  import     com . mifmif . common . regex . Generex ;  import   java . io . IOException ;  import   java . net . JarURLConnection ;  import    java . util . jar . JarEntry ;  import    java . util . jar . JarFile ;   public class FakeValuesService  {   private static final Pattern  EXPRESSION_PATTERN =  Pattern . compile  ( "#\\{([a-z0-9A-Z_.]+)\\s?(?:'([^']+)')?(?:,'([^']+)')*\\}" ) ;   private final Logger  log =  Logger . getLogger  ( "faker" ) ;   private final  List  <  Map  < String , Object > >  fakeValuesMaps ;   private final RandomService  randomService ;   public FakeValuesService  (  Locale locale ,  RandomService randomService )  {  if  (  locale == null )  {  throw  new IllegalArgumentException  ( "locale is required" ) ; }    this . randomService = randomService ;   locale =  normalizeLocale  ( locale ) ;   final  List  < Locale >  locales =  localeChain  ( locale ) ;   final  List  <  Map  < String , Object > >  all =  new  ArrayList  <  Map  < String , Object > >  ( ) ;   final  Set  < Locale >  loadedLocales =  new  HashSet  < Locale >  ( ) ;  for (  final Locale l : locales )  {   final StringBuilder  filename =  new StringBuilder  (  language  ( l ) ) ;  if  (  !  "" . equals  (  l . getCountry  ( ) ) )  {    filename . append  ( "-" ) . append  (  l . getCountry  ( ) ) ; } 
<<<<<<<
 for ( File resourceFolderFile : files )  {  String  fileToLoad =   filename + "/" +  resourceFolderFile . getName  ( ) ;   final InputStream  stream =    getClass  ( ) . getClassLoader  ( ) . getResourceAsStream  ( fileToLoad ) ;  if  (  stream != null )  {   Map  < String , Object >  map =  fakerFromStream  ( stream ,  filename . toString  ( ) ) ;   all . add  ( map ) ;   loadedLocales . add  ( l ) ; } }
=======
>>>>>>>
  if  (  isJarFile  (  filename . toString  ( ) ) )  {   loadFromJarFile  ( all , loadedLocales , l , filename ) ; } else  {   File  [ ]  files =  listFilesInDirectoryOnClasspath  (  filename . toString  ( ) ) ;  for ( File resourceFolderFile : files )  {  String  fileToLoad =   filename + "/" +  resourceFolderFile . getName  ( ) ;   final InputStream  stream =    getClass  ( ) . getClassLoader  ( ) . getResourceAsStream  ( fileToLoad ) ;  if  (  stream != null )  {  Map  map =  fakerFromStream  ( stream ,  filename . toString  ( ) ) ;   all . add  ( map ) ;   loadedLocales . add  ( l ) ; } }   final InputStream  stream =  findStream  (  filename . toString  ( ) ) ;  if  (  stream != null )  {   all . add  (  fakerFromStream  ( stream ,  filename . toString  ( ) ) ) ;   loadedLocales . add  ( l ) ; } } }  if  (     loadedLocales . size  ( ) == 1 &&  loadedLocales . contains  (  Locale . ENGLISH ) &&  !  locale . equals  (  Locale . ENGLISH ) )  {  throw  new LocaleDoesNotExistException  (   locale . toString  ( ) + " does not exist" ) ; }    this . fakeValuesMaps =  Collections . unmodifiableList  ( all ) ; }   private  File  [ ] listFilesInDirectoryOnClasspath  (  String dir )  {  ClassLoader  loader =   getClass  ( ) . getClassLoader  ( ) ;  URL  url =  loader . getResource  ( dir ) ;  if  (  url == null )  {  return  new File  [ 0 ] ; } else  {  return   new File  (  url . getPath  ( ) ) . listFiles  ( ) ; } }   private String language  (  Locale l )  {  if  (   l . getLanguage  ( ) . equals  ( "iw" ) )  {  return "he" ; }  return  l . getLanguage  ( ) ; }    @ SuppressWarnings  ( "unchecked" ) protected  Map  < String , Object > fakerFromStream  (  InputStream stream ,  String localeName )  {   final  Map  < String , Object >  valuesMap =   new Yaml  ( ) . loadAs  ( stream ,  Map . class ) ;   final  Map  < String , Object >  localeBased =  (  (  Map  < String , Object > )  valuesMap . get  ( localeName ) ) ;  return  (  Map  < String , Object > )  localeBased . get  ( "faker" ) ; }   protected  List  < Locale > localeChain  (  Locale from )  {  if  (   Locale . ENGLISH . equals  ( from ) )  {  return  Collections . singletonList  (  Locale . ENGLISH ) ; }   final Locale  normalized =  normalizeLocale  ( from ) ;   final  List  < Locale >  chain =  new  ArrayList  < Locale >  ( 3 ) ;   chain . add  ( normalized ) ;  if  (   !  "" . equals  (  normalized . getCountry  ( ) ) &&  !    Locale . ENGLISH . getLanguage  ( ) . equals  (  normalized . getLanguage  ( ) ) )  {   chain . add  (  new Locale  (  normalized . getLanguage  ( ) ) ) ; }   chain . add  (  Locale . ENGLISH ) ;  return chain ; }   private Locale normalizeLocale  (  Locale locale )  {   final  String  [ ]  parts =   locale . toString  ( ) . split  ( "[-\\_]" ) ;  if  (   parts . length == 1 )  {  return  new Locale  (  parts [ 0 ] ) ; } else  {  return  new Locale  (  parts [ 0 ] ,  parts [ 1 ] ) ; } }   private InputStream findStream  (  String filename )  {  String  filenameWithExtension =   "/" + filename + ".yml" ;  InputStream  streamOnClass =   this . getClass  ( ) . getResourceAsStream  ( filenameWithExtension ) ;  if  (  streamOnClass != null )  {  return streamOnClass ; }  return  ClassLoader . getSystemResourceAsStream  ( filenameWithExtension ) ; }    @ SuppressWarnings  ( "unchecked" ) public Object fetch  (  String key )  {   List  < Object >  valuesArray =  (  List  < Object > )  fetchObject  ( key ) ;  return   valuesArray == null ? null :  valuesArray . get  (  randomService . nextInt  (  valuesArray . size  ( ) ) ) ; }   public String fetchString  (  String key )  {  return  ( String )  fetch  ( key ) ; }    @ SuppressWarnings  ( "unchecked" ) public String safeFetch  (  String key ,  String defaultIfNull )  {  Object  o =  fetchObject  ( key ) ;  if  (  o == null )  return defaultIfNull ;  if  (  o instanceof List )  {   List  < String >  values =  (  List  < String > ) o ;  if  (   values . size  ( ) == 0 )  {  return defaultIfNull ; }  return  values . get  (  randomService . nextInt  (  values . size  ( ) ) ) ; } else  if  (  isSlashDelimitedRegex  (  o . toString  ( ) ) )  {  return  String . format  ( "#{regexify '%s'}" ,  trimRegexSlashes  (  o . toString  ( ) ) ) ; } else  {  return  ( String ) o ; } }    @ SuppressWarnings  ( "unchecked" ) public String safeFetch  (  String key ,  String defaultIfNull ,   int size )  {  Object  o =  fetchObject  ( key ) ;  if  (  o == null )  return defaultIfNull ;  if  (  o instanceof List )  {   List  < String >  values =  (  List  < String > ) o ;  if  (   values . size  ( ) == 0 )  {  return defaultIfNull ; }   List  < String >  subset =  new  ArrayList  < String >  ( ) ;  for (   int  i = 0 ;  i <  values . size  ( ) ;  i ++ )  if  (     values . get  ( i ) . length  ( ) == size &&  StringUtils . isNoneEmpty  (  values . get  ( i ) ) )   subset . add  (  values . get  ( i ) ) ;  if  (   subset . size  ( ) == 0 )  {  return defaultIfNull ; }  return  subset . get  (  randomService . nextInt  (  subset . size  ( ) ) ) ; } else  if  (  isSlashDelimitedRegex  (  o . toString  ( ) ) )  {  return  String . format  ( "#{regexify '%s'}" ,  trimRegexSlashes  (  o . toString  ( ) ) ) ; } else  {  return  ( String ) o ; } }    @ SuppressWarnings  ( "unchecked" ) public Object fetchObject  (  String key )  {   String  [ ]  path =  key . split  ( "\\." ) ;  Object  result = null ;  for (  Map  < String , Object > fakeValuesMap : fakeValuesMaps )  {  Object  currentValue = fakeValuesMap ;  for (   int  p = 0 ;   currentValue != null &&  p <  path . length ;  p ++ )  {   currentValue =   (  (  Map  < String , Object > ) currentValue ) . get  (  path [ p ] ) ; }   result = currentValue ;  if  (  result != null )  {  break ; } }  return result ; }   public String numerify  (  String numberString )  {  StringBuilder  sb =  new StringBuilder  ( ) ;  for (   int  i = 0 ;  i <  numberString . length  ( ) ;  i ++ )  {  if  (   numberString . charAt  ( i ) == '#' )  {   sb . append  (  randomService . nextInt  ( 10 ) ) ; } else  {   sb . append  (  numberString . charAt  ( i ) ) ; } }  return  sb . toString  ( ) ; }   public String bothify  (  String string )  {  return  letterify  (  numerify  ( string ) ) ; }   public String bothify  (  String string ,  boolean isUpper )  {  return  letterify  (  numerify  ( string ) , isUpper ) ; }   public String regexify  (  String regex )  {  Generex  generex =  new Generex  ( regex ) ;   generex . setSeed  (  randomService . nextLong  ( ) ) ;  return  generex . random  ( ) ; }   public String letterify  (  String letterString )  {  return  this . letterify  ( letterString , false ) ; }   public String letterify  (  String letterString ,  boolean isUpper )  {  return  letterHelper  (   ( isUpper ) ? 65 : 97 , letterString ) ; }   private String letterHelper  (   int baseChar ,  String letterString )  {  StringBuilder  sb =  new StringBuilder  ( ) ;  for (   int  i = 0 ;  i <  letterString . length  ( ) ;  i ++ )  {  if  (   letterString . charAt  ( i ) == '?' )  {   sb . append  (  (  char )  (  baseChar +  randomService . nextInt  ( 26 ) ) ) ; } else  {   sb . append  (  letterString . charAt  ( i ) ) ; } }  return  sb . toString  ( ) ; }   public String resolve  (  String key ,  Object current ,  Faker root )  {   final String  expression =  safeFetch  ( key , null ) ;  if  (  expression == null )  {  throw  new RuntimeException  (  key + " resulted in null expression" ) ; }  return  resolveExpression  ( expression , current , root ) ; }   public String resolve  (  String key ,  Object current ,  Faker root ,   int size )  {   final String  expression =  safeFetch  ( key , null , size ) ;  if  (  expression == null )  {  throw  new RuntimeException  (    key + " with size " + size + " resulted in null expression" ) ; }  return  resolveExpression  ( expression , current , root ) ; }   public String expression  (  String expression ,  Faker faker )  {  return  resolveExpression  ( expression , null , faker ) ; }   protected String resolveExpression  (  String expression ,  Object current ,  Faker root )  {   final Matcher  matcher =  EXPRESSION_PATTERN . matcher  ( expression ) ;  String  result = expression ;  while  (  matcher . find  ( ) )  {   final String  escapedDirective =  matcher . group  ( 0 ) ;   final String  directive =  matcher . group  ( 1 ) ;   List  < String >  args =  new  ArrayList  < String >  ( ) ;  for (   int  i = 2 ;   i <   matcher . groupCount  ( ) + 1 &&   matcher . group  ( i ) != null ;  i ++ )  {   args . add  (  matcher . group  ( i ) ) ; }  String  resolved =  resolveExpression  ( directive , args , current , root ) ;  if  (  resolved == null )  {  throw  new RuntimeException  (   "Unable to resolve " + escapedDirective + " directive." ) ; }   resolved =  resolveExpression  ( resolved , current , root ) ;   result =  StringUtils . replaceOnce  ( result , escapedDirective , resolved ) ; }  return result ; }   private String resolveExpression  (  String directive ,   List  < String > args ,  Object current ,  Faker root )  {   final String  simpleDirective =   (   isDotDirective  ( directive ) ||  current == null ) ? directive :    classNameToYamlName  ( current ) + "." + directive ;  String  resolved = null ;  if  (  !  isDotDirective  ( directive ) )  {   resolved =  resolveFromMethodOn  ( current , directive , args ) ; }  if  (  resolved == null )  {   resolved =  safeFetch  ( simpleDirective , null ) ; }  if  (   resolved == null &&  !  isDotDirective  ( directive ) )  {   resolved =  resolveFromMethodOn  ( root , directive , args ) ; }  if  (   resolved == null &&  isDotDirective  ( directive ) )  {   resolved =  resolveFakerObjectAndMethod  ( root , directive , args ) ; }  if  (   resolved == null &&  isDotDirective  ( directive ) )  {   resolved =  safeFetch  (  javaNameToYamlName  ( simpleDirective ) , null ) ; }  return resolved ; }   private boolean isSlashDelimitedRegex  (  String expression )  {  return    expression != null &&  expression . startsWith  ( "/" ) &&  expression . endsWith  ( "/" ) ; }   private String trimRegexSlashes  (  String slashDelimitedRegex )  {  return  slashDelimitedRegex . substring  ( 1 ,   slashDelimitedRegex . length  ( ) - 1 ) ; }   private boolean isDotDirective  (  String directive )  {  return  directive . contains  ( "." ) ; }   private String classNameToYamlName  (  Object current )  {  return  javaNameToYamlName  (   current . getClass  ( ) . getSimpleName  ( ) ) ; }   private String javaNameToYamlName  (  String expression )  {  return    expression . replaceAll  ( "([A-Z])" , "_$1" ) . substring  ( 1 ) . toLowerCase  ( ) ; }   private String resolveFromMethodOn  (  Object obj ,  String directive ,   List  < String > args )  {  if  (  obj == null )  {  return null ; }  try  {   final MethodAndCoercedArgs  accessor =  accessor  ( obj , directive , args ) ;  return   (  accessor == null ) ? null :  string  (  accessor . invoke  ( obj ) ) ; }  catch (   Exception e )  {   log . log  (  Level . FINE ,    "Can't call " + directive + " on " + obj , e ) ;  return null ; } }   private String resolveFakerObjectAndMethod  (  Faker faker ,  String key ,   List  < String > args )  {   final  String  [ ]  classAndMethod =  key . split  ( "\\." , 2 ) ;  try  {  String  fakerMethodName =   classAndMethod [ 0 ] . replaceAll  ( "_" , "" ) ;  MethodAndCoercedArgs  fakerAccessor =  accessor  ( faker , fakerMethodName ,  Collections .  < String > emptyList  ( ) ) ;  if  (  fakerAccessor == null )  {   log . fine  (   "Can't find top level faker object named " + fakerMethodName + "." ) ;  return null ; }  Object  objectWithMethodToInvoke =  fakerAccessor . invoke  ( faker ) ;  String  nestedMethodName =   classAndMethod [ 1 ] . replaceAll  ( "_" , "" ) ;   final MethodAndCoercedArgs  accessor =  accessor  ( objectWithMethodToInvoke ,   classAndMethod [ 1 ] . replaceAll  ( "_" , "" ) , args ) ;  if  (  accessor == null )  {  throw  new Exception  (     "Can't find method on " +   objectWithMethodToInvoke . getClass  ( ) . getSimpleName  ( ) + " called " + nestedMethodName + "." ) ; }  return  string  (  accessor . invoke  ( objectWithMethodToInvoke ) ) ; }  catch (   Exception e )  {   log . fine  (  e . getMessage  ( ) ) ;  return null ; } }   private MethodAndCoercedArgs accessor  (  Object onObject ,  String name ,   List  < String > args )  {   log . log  (  Level . FINE ,      "Find accessor named " + name + " on " +   onObject . getClass  ( ) . getSimpleName  ( ) + " with args " + args ) ;  for ( Method m :   onObject . getClass  ( ) . getMethods  ( ) )  {  if  (    m . getName  ( ) . equalsIgnoreCase  ( name ) &&    m . getParameterTypes  ( ) . length ==  args . size  ( ) )  {   final  List  < Object >  coercedArguments =  coerceArguments  ( m , args ) ;  if  (  coercedArguments != null )  {  return  new MethodAndCoercedArgs  ( m , coercedArguments ) ; } } }  if  (  name . contains  ( "_" ) )  {  return  accessor  ( onObject ,  name . replaceAll  ( "_" , "" ) , args ) ; }  return null ; }   private  List  < Object > coerceArguments  (  Method accessor ,   List  < String > args )  {   final  List  < Object >  coerced =  new  ArrayList  < Object >  ( ) ;  for (   int  i = 0 ;  i <   accessor . getParameterTypes  ( ) . length ;  i ++ )  {   Class  <  ? >  toType =  ClassUtils . primitiveToWrapper  (   accessor . getParameterTypes  ( ) [ i ] ) ;  try  {   final  Constructor  <  ? >  ctor =  toType . getConstructor  (  String . class ) ;   final Object  coercedArgument =  ctor . newInstance  (  args . get  ( i ) ) ;   coerced . add  ( coercedArgument ) ; }  catch (   Exception e )  {   log . fine  (       "Unable to coerce " +  args . get  ( i ) + " to " +  toType . getSimpleName  ( ) + " via " +  toType . getSimpleName  ( ) + "(String) constructor." ) ;  return null ; } }  return coerced ; }   private String string  (  Object obj )  {  return   (  obj == null ) ? null :  obj . toString  ( ) ; }   private class MethodAndCoercedArgs  {   private final Method  method ;   private final  List  < Object >  coerced ;   private MethodAndCoercedArgs  (  Method m ,   List  < Object > coerced )  {    this . method =  requireNonNull  ( m , "method cannot be null" ) ;    this . coerced =  requireNonNull  ( coerced , "coerced arguments cannot be null" ) ; }   private Object invoke  (  Object on )  throws InvocationTargetException , IllegalAccessException  {  return  method . invoke  ( on ,  coerced . toArray  ( ) ) ; }   private  <  T > T requireNonNull  (  T instance ,  String messageIfNull )  {  if  (  instance == null )  {  throw  new NullPointerException  ( messageIfNull ) ; }  return instance ; } }   private void loadFromJarFile  (   List  <  Map  < String , Object > > all ,   Set  < Locale > loadedLocales ,  Locale locale ,  StringBuilder filename )  {  try  {  ClassLoader  loader =   getClass  ( ) . getClassLoader  ( ) ;  URL  url =  loader . getResource  (  filename . toString  ( ) ) ;  JarURLConnection  connection =  ( JarURLConnection )  url . openConnection  ( ) ;  JarFile  jarFile =  connection . getJarFile  ( ) ;   Enumeration  < JarEntry >  entries =  jarFile . entries  ( ) ;  while  (  entries . hasMoreElements  ( ) )  {  JarEntry  jarEntry =  entries . nextElement  ( ) ;  String  jarEntryName =  jarEntry . getName  ( ) ;  if  (   jarEntryName . contains  (   filename . toString  ( ) + "/" ) &&  jarEntryName . endsWith  ( ".yml" ) )  {  InputStream  inputStream =  jarFile . getInputStream  ( jarEntry ) ;  if  (  inputStream != null )  {  Map  map =  fakerFromStream  ( inputStream ,  filename . toString  ( ) ) ;   all . add  ( map ) ;   loadedLocales . add  ( locale ) ; } } } }  catch (   IOException e )  {  throw  new LocaleDoesNotExistException  (  filename . toString  ( ) ) ; } }   private boolean isJarFile  (  String fileName )  {  ClassLoader  loader =   getClass  ( ) . getClassLoader  ( ) ;  URL  url =  loader . getResource  ( fileName ) ;  return   url != null &&   url . getProtocol  ( ) . equals  ( "jar" ) ; } }