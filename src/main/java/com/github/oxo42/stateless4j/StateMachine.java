  package    com . github . oxo42 . stateless4j ;   import      com . github . oxo42 . stateless4j . delegates . Action1 ;  import      com . github . oxo42 . stateless4j . delegates . Action2 ;  import      com . github . oxo42 . stateless4j . delegates . Func ;  import      com . github . oxo42 . stateless4j . transitions . Transition ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import   java . util . ArrayList ;  import   java . util . List ;  import      com . github . oxo42 . stateless4j . triggers . TriggerBehaviour ;  import      com . github . oxo42 . stateless4j . triggers . TriggerWithParameters ;  import      com . github . oxo42 . stateless4j . triggers . TriggerWithParameters1 ;  import      com . github . oxo42 . stateless4j . triggers . TriggerWithParameters2 ;  import      com . github . oxo42 . stateless4j . triggers . TriggerWithParameters3 ;   public class StateMachine  <  S ,  T >  {   public static final String  TRIGGER_IS_NULL = "trigger is null" ;   protected final  StateMachineConfig  < S , T >  config ;   protected final  Func  < S >  stateAccessor ;   protected final  Action1  < S >  stateMutator ;   private final Logger  logger =  LoggerFactory . getLogger  (  getClass  ( ) ) ;   private boolean  shouldLog = true ;   protected  Action2  < S , T >  unhandledTriggerAction =  new  Action2  < S , T >  ( )  {   public  @ Override void doIt  (  S state ,  T trigger )  {  throw  new IllegalStateException  (  String . format  ( "No valid leaving transitions are permitted from state '%s' for trigger '%s'. Consider ignoring the trigger." , state , trigger ) ) ; } } ;   public StateMachine  (  S intialState )  {  this  ( intialState ,  new  StateMachineConfig  < S , T >  ( ) ) ; }   public StateMachine  (  S initialState ,   StateMachineConfig  < S , T > config )  {    this . config = config ;   final  StateReference  < S , T >  reference =  new  StateReference  < >  ( ) ;   reference . setState  ( initialState ) ;   stateAccessor =  new  Func  < S >  ( )  {    @ Override public S call  ( )  {  return  reference . getState  ( ) ; } } ;   stateMutator =  new  Action1  < S >  ( )  {    @ Override public void doIt  (  S s )  {   reference . setState  ( s ) ; } } ;  if  (  config . isEntryActionOfInitialStateEnabled  ( ) )  {   Transition  < S , T >  initialTransition =  new Transition  ( initialState , initialState , null ) ;    getCurrentRepresentation  ( ) . enter  ( initialTransition ) ; } }   public StateMachine  (  S initialState ,   Func  < S > stateAccessor ,   Action1  < S > stateMutator ,   StateMachineConfig  < S , T > config )  {    this . config = config ;    this . stateAccessor = stateAccessor ;    this . stateMutator = stateMutator ;   stateMutator . doIt  ( initialState ) ; }   public  StateConfiguration  < S , T > configure  (  S state )  {  return  config . configure  ( state ) ; }   public  StateMachineConfig  < S , T > configuration  ( )  {  return config ; }   public S getState  ( )  {  return  stateAccessor . call  ( ) ; }   private void setState  (  S value )  {   stateMutator . doIt  ( value ) ; }   public boolean getShouldLog  ( )  {  return shouldLog ; }   public void setShouldLog  (  boolean enabled )  {   shouldLog = enabled ; }   public Logger getLogger  ( )  {  return logger ; }   protected void log  (  T trigger ,  Object ...  args )  {    getLogger  ( ) . info  (  "Firing " + trigger ) ; }   public  List  < T > getPermittedTriggers  ( )  {  return   getCurrentRepresentation  ( ) . getPermittedTriggers  ( ) ; }   StateRepresentation  < S , T > getCurrentRepresentation  ( )  {   StateRepresentation  < S , T >  representation =  config . getRepresentation  (  getState  ( ) ) ;  return   representation == null ?  new  StateRepresentation  < S , T >  (  getState  ( ) ) : representation ; }   public void fire  (  T trigger )  {   publicFire  ( trigger ) ; }   public  <  TArg0 > void fire  (   TriggerWithParameters1  < TArg0 , S , T > trigger ,  TArg0 arg0 )  {  assert  trigger != null : TRIGGER_IS_NULL ;   publicFire  (  trigger . getTrigger  ( ) , arg0 ) ; }   public  <  TArg0 ,  TArg1 > void fire  (   TriggerWithParameters2  < TArg0 , TArg1 , S , T > trigger ,  TArg0 arg0 ,  TArg1 arg1 )  {  assert  trigger != null : TRIGGER_IS_NULL ;   publicFire  (  trigger . getTrigger  ( ) , arg0 , arg1 ) ; }   public  <  TArg0 ,  TArg1 ,  TArg2 > void fire  (   TriggerWithParameters3  < TArg0 , TArg1 , TArg2 , S , T > trigger ,  TArg0 arg0 ,  TArg1 arg1 ,  TArg2 arg2 )  {  assert  trigger != null : TRIGGER_IS_NULL ;   publicFire  (  trigger . getTrigger  ( ) , arg0 , arg1 , arg2 ) ; }   protected void publicFire  (  T trigger ,  Object ...  args )  { 
<<<<<<<
 if  ( shouldLog )  {   log  ( trigger , args ) ; }
=======
  logger . info  ( "Firing {}" , trigger ) ;
>>>>>>>
   TriggerWithParameters  < S , T >  configuration =  config . getTriggerConfiguration  ( trigger ) ;  if  (  configuration != null )  {   configuration . validateParameters  ( args ) ; }   TriggerBehaviour  < S , T >  triggerBehaviour =   getCurrentRepresentation  ( ) . tryFindHandler  ( trigger ) ;  if  (  triggerBehaviour == null )  {   unhandledTriggerAction . doIt  (   getCurrentRepresentation  ( ) . getUnderlyingState  ( ) , trigger ) ;  return ; }  if  (  triggerBehaviour . isInternal  ( ) )  {   triggerBehaviour . performAction  ( args ) ; } else  {  S  source =  getState  ( ) ;  S  destination =  triggerBehaviour . transitionsTo  ( source , args ) ;   Transition  < S , T >  transition =  new  Transition  < >  ( source , destination , trigger ) ;    getCurrentRepresentation  ( ) . exit  ( transition ) ;   triggerBehaviour . performAction  ( args ) ;   setState  ( destination ) ;    getCurrentRepresentation  ( ) . enter  ( transition , args ) ; }  if  (  logger . isDebugEnabled  ( ) )  {   logger . debug  ( "Fired [{}]--{}-->[{}]" ,  new Object  [ ]  { source ,  TriggerWithParameters . toString  ( trigger , args ) ,  destination . toString  ( ) } ) ; } }   public void onUnhandledTrigger  (   Action2  < S , T > unhandledTriggerAction )  {  if  (  unhandledTriggerAction == null )  {  throw  new IllegalStateException  ( "unhandledTriggerAction" ) ; }    this . unhandledTriggerAction = unhandledTriggerAction ; }   public boolean isInState  (  S state )  {  return   getCurrentRepresentation  ( ) . isIncludedIn  ( state ) ; }   public boolean canFire  (  T trigger )  {  return   getCurrentRepresentation  ( ) . canHandle  ( trigger ) ; }    @ Override public String toString  ( )  {   List  < T >  permittedTriggers =  getPermittedTriggers  ( ) ;   List  < String >  parameters =  new  ArrayList  < >  ( ) ;  for ( T tTrigger : permittedTriggers )  {   parameters . add  (  tTrigger . toString  ( ) ) ; }  StringBuilder  params =  new StringBuilder  ( ) ;  String  delim = "" ;  for ( String param : parameters )  {   params . append  ( delim ) ;   params . append  ( param ) ;   delim = ", " ; }  return  String . format  ( "StateMachine {{ State = %s, PermittedTriggers = {{ %s }}}}" ,  getState  ( ) ,  params . toString  ( ) ) ; } }