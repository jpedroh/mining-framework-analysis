  package  com . pff ;   import  java . io .  * ;  import  java . util .  * ;  import   java . util . zip .  * ;  import    java . nio . file . Files ;  import    java . nio . file . Paths ;   public class PSTNodeInputStream  extends InputStream  {   private PSTFileContent  in ;   private PSTFile  pstFile ;   private  LinkedList  < Long >  skipPoints =  new  LinkedList  < Long >  ( ) ;   private  LinkedList  < OffsetIndexItem >  indexItems =  new  LinkedList  < OffsetIndexItem >  ( ) ;   private  int  currentBlock = 0 ;   private  long  currentLocation = 0 ;   private   byte  [ ]  allData = null ;   private  long  length = 0 ;   private boolean  encrypted = false ;  PSTNodeInputStream  (  PSTFile pstFile ,    byte  [ ] attachmentData )  throws PSTException  {    this . allData = attachmentData ;    this . length =   this . allData . length ;   encrypted =   pstFile . getEncryptionType  ( ) ==  PSTFile . ENCRYPTION_TYPE_COMPRESSIBLE ;    this . currentBlock = 0 ;    this . currentLocation = 0 ;   this . detectZlib  ( ) ; }  PSTNodeInputStream  (  PSTFile pstFile ,    byte  [ ] attachmentData ,  boolean encrypted )  throws PSTException  {    this . allData = attachmentData ;    this . encrypted = encrypted ;    this . length =   this . allData . length ;    this . currentBlock = 0 ;    this . currentLocation = 0 ;   this . detectZlib  ( ) ; }  PSTNodeInputStream  (  PSTFile pstFile ,  PSTDescriptorItem descriptorItem )  throws IOException , PSTException  {    this . in =  pstFile . getContentHandle  ( ) ;    this . pstFile = pstFile ;    this . encrypted =   pstFile . getEncryptionType  ( ) ==  PSTFile . ENCRYPTION_TYPE_COMPRESSIBLE ;  OffsetIndexItem  offsetItem =  pstFile . getOffsetIndexNode  (  descriptorItem . offsetIndexIdentifier ) ;   loadFromOffsetItem  ( offsetItem ) ;    this . currentBlock = 0 ;    this . currentLocation = 0 ;   this . detectZlib  ( ) ; }  PSTNodeInputStream  (  PSTFile pstFile ,  OffsetIndexItem offsetItem )  throws IOException , PSTException  {    this . in =  pstFile . getContentHandle  ( ) ;    this . pstFile = pstFile ;    this . encrypted =   pstFile . getEncryptionType  ( ) ==  PSTFile . ENCRYPTION_TYPE_COMPRESSIBLE ;   loadFromOffsetItem  ( offsetItem ) ;    this . currentBlock = 0 ;    this . currentLocation = 0 ;   this . detectZlib  ( ) ; }   private boolean  isZlib = false ;   private void detectZlib  ( )  throws PSTException  {  if  (   this . length < 4 )  {  return ; }  try  {  if  (    this . read  ( ) == 0x78 &&   this . read  ( ) == 0x9c )  {   int  uncompressedLength =  (  int )  this . length ;  if  (    this . indexItems . size  ( ) > 0 )  {   uncompressedLength = 0 ;  for ( OffsetIndexItem i :  this . indexItems )  {   uncompressedLength +=  i . size ; } }    byte  [ ]  inData =  new  byte  [ uncompressedLength ] ;   this . seek  ( 0 ) ;   int  lengthRead =  this . read  ( inData ) ;  if  (  lengthRead != uncompressedLength )  {  throw  new PSTException  (  "Bad assumption: " + lengthRead ) ; }  Inflater  inflater =  new Inflater  ( ) ;  ByteArrayOutputStream  outputStream =  new ByteArrayOutputStream  (  (  int )  this . length ) ;  InflaterOutputStream  inflaterStream =  new InflaterOutputStream  ( outputStream ) ;   inflaterStream . write  ( inData ) ;   inflaterStream . close  ( ) ;   outputStream . close  ( ) ;    byte  [ ]  output =  outputStream . toByteArray  ( ) ;    this . allData = output ;    this . currentLocation = 0 ;    this . currentBlock = 0 ;    this . length =   this . allData . length ; }   this . seek  ( 0 ) ; }  catch (   IOException err )  {  throw  new PSTException  ( "Unable to compress reportedly compressed block" , err ) ; } }   private void loadFromOffsetItem  (  OffsetIndexItem offsetItem )  throws IOException , PSTException  {  boolean  bInternal =   (   offsetItem . indexIdentifier & 0x02 ) != 0 ;   in . seek  (  offsetItem . fileOffset ) ;    byte  [ ]  data =  new  byte  [  offsetItem . size ] ;   in . read  ( data ) ;  if  ( bInternal )  {  if  (   offsetItem . size < 8 )  {  throw  new PSTException  ( "Invalid internal block size" ) ; }  if  (   data [ 0 ] == 0x1 )  {   bInternal = false ;    this . length =  PSTObject . convertLittleEndianBytesToLong  ( data , 4 , 8 ) ;   this . getBlockSkipPoints  ( data ) ;  return ; } }  if  ( bInternal )  {    this . encrypted = false ; }    this . allData = data ;    this . length =   this . allData . length ; }   public boolean isEncrypted  ( )  {  return  this . encrypted ; }   private void getBlockSkipPoints  (    byte  [ ] data )  throws IOException , PSTException  {  if  (   data [ 0 ] != 0x1 )  {  throw  new PSTException  ( "Unable to process XBlock, incorrect identifier" ) ; }   int  numberOfEntries =  (  int )  PSTObject . convertLittleEndianBytesToLong  ( data , 2 , 4 ) ;   int  arraySize = 8 ;  if  (    this . pstFile . getPSTFileType  ( ) ==  PSTFile . PST_TYPE_ANSI )  {   arraySize = 4 ; }  if  (   data [ 1 ] == 0x2 )  {   int  offset = 8 ;  for (   int  x = 0 ;  x < numberOfEntries ;  x ++ )  {   long  bid =  PSTObject . convertLittleEndianBytesToLong  ( data , offset ,  offset + arraySize ) ;   bid &= 0xfffffffe ;  OffsetIndexItem  offsetItem =   this . pstFile . getOffsetIndexNode  ( bid ) ;   in . seek  (  offsetItem . fileOffset ) ;    byte  [ ]  blockData =  new  byte  [  offsetItem . size ] ;   in . read  ( blockData ) ;   this . getBlockSkipPoints  ( blockData ) ;   offset += arraySize ; } } else  if  (   data [ 1 ] == 0x1 )  {   int  offset = 8 ;  for (   int  x = 0 ;  x < numberOfEntries ;  x ++ )  {   long  bid =  PSTObject . convertLittleEndianBytesToLong  ( data , offset ,  offset + arraySize ) ;   bid &= 0xfffffffe ;  OffsetIndexItem  offsetItem =  pstFile . getOffsetIndexNode  ( bid ) ;    this . indexItems . add  ( offsetItem ) ;    this . skipPoints . add  (  this . currentLocation ) ;    this . currentLocation +=  offsetItem . size ;   offset += arraySize ; } } }   public  long length  ( )  {  return  this . length ; }    @ Override public  int read  ( )  throws IOException  {  if  (   this . allData != null )  {  if  (   this . currentLocation ==  this . length )  {  return  - 1 ; }   int  value =    this . allData [  (  int )  this . currentLocation ] & 0xFF ;    this . currentLocation ++ ;  if  (  this . encrypted )  {   value =   PSTObject . compEnc [ value ] ; }  return value ; }  OffsetIndexItem  item =   this . indexItems . get  (  this . currentBlock ) ;   long  skipPoint =   this . skipPoints . get  ( currentBlock ) ;  if  (    this . currentLocation + 1 >  skipPoint +  item . size )  {    this . currentBlock ++ ;  if  (   this . currentBlock >=   this . indexItems . size  ( ) )  {  return  - 1 ; }   item =   this . indexItems . get  (  this . currentBlock ) ;   skipPoint =   this . skipPoints . get  ( currentBlock ) ; }   long  pos =  (   item . fileOffset +  (   this . currentLocation - skipPoint ) ) ;  if  (   in . getFilePointer  ( ) != pos )  {   in . seek  ( pos ) ; }   int  output =  in . read  ( ) ;  if  (  output < 0 )  {  return  - 1 ; }  if  (  this . encrypted )  {   output =   PSTObject . compEnc [ output ] ; }    this . currentLocation ++ ;  return output ; }   private  int  totalLoopCount = 0 ;    @ Override public  int read  (    byte  [ ] output )  throws IOException  {  if  (   this . currentLocation ==  this . length )  {  return  - 1 ; }  if  (   this . allData != null )  {   int  bytesRemaining =  (  int )  (   this . length -  this . currentLocation ) ;  if  (   output . length >= bytesRemaining )  {   System . arraycopy  (  this . allData ,  (  int )  this . currentLocation , output , 0 , bytesRemaining ) ;  if  (  this . encrypted )  {   PSTObject . decode  ( output ) ; }    this . currentLocation += bytesRemaining ;  return bytesRemaining ; } else  {   System . arraycopy  (  this . allData ,  (  int )  this . currentLocation , output , 0 ,  output . length ) ;  if  (  this . encrypted )  {   PSTObject . decode  ( output ) ; }    this . currentLocation +=  output . length ;  return  output . length ; } }  boolean  filled = false ;   int  totalBytesFilled = 0 ;  while  (  ! filled )  {  OffsetIndexItem  offset =   this . indexItems . get  (  this . currentBlock ) ;   long  skipPoint =   this . skipPoints . get  ( currentBlock ) ;   int  currentPosInBlock =  (  int )  (   this . currentLocation - skipPoint ) ;   in . seek  (   offset . fileOffset + currentPosInBlock ) ;   long  nextSkipPoint =  skipPoint +  offset . size ;   int  bytesRemaining =  (   output . length - totalBytesFilled ) ;  if  (  bytesRemaining >  (  (  int )  (   this . length -  this . currentLocation ) ) )  {   bytesRemaining =  (  int )  (   this . length -  this . currentLocation ) ; }  if  (  nextSkipPoint >=   this . currentLocation + bytesRemaining )  {    byte  [ ]  chunk =  new  byte  [ bytesRemaining ] ;   in . read  ( chunk ) ;   System . arraycopy  ( chunk , 0 , output , totalBytesFilled , bytesRemaining ) ;   totalBytesFilled += bytesRemaining ;   filled = true ;    this . currentLocation += bytesRemaining ; } else  {   int  bytesToRead =   offset . size - currentPosInBlock ;    byte  [ ]  chunk =  new  byte  [ bytesToRead ] ;   in . read  ( chunk ) ;   System . arraycopy  ( chunk , 0 , output , totalBytesFilled , bytesToRead ) ;   totalBytesFilled += bytesToRead ;    this . currentBlock ++ ;    this . currentLocation += bytesToRead ; }   totalLoopCount ++ ; }  if  (  this . encrypted )  {   PSTObject . decode  ( output ) ; }  return totalBytesFilled ; }    @ Override public  int read  (    byte  [ ] output ,   int offset ,   int length )  throws IOException  {  if  (   this . currentLocation ==  this . length )  {  return  - 1 ; }  if  (   output . length < length )  {   length =  output . length ; }    byte  [ ]  buf =  new  byte  [ length ] ;   int  lengthRead =  this . read  ( buf ) ;   System . arraycopy  ( buf , 0 , output , offset , lengthRead ) ;  return lengthRead ; }    @ Override public void reset  ( )  {    this . currentBlock = 0 ;    this . currentLocation = 0 ; }    @ Override public boolean markSupported  ( )  {  return false ; }   public  Long  [ ] getBlockOffsets  ( )  {  if  (    this . skipPoints . size  ( ) == 0 )  {   Long  [ ]  output =  new Long  [ 1 ] ;    output [ 0 ] =  this . length ;  return output ; } else  {   Long  [ ]  output =  new Long  [   this . skipPoints . size  ( ) ] ;  for (   int  x = 0 ;  x <  output . length ;  x ++ )  {    output [ x ] =  new Long  (    this . skipPoints . get  ( x ) +    this . indexItems . get  ( x ) . size ) ; }  return output ; } }   public void seek  (   long location )  throws IOException , PSTException  {  if  (  location >  this . length )  {  throw  new PSTException  (    "Unable to seek past end of item! size = " +  this . length + ", seeking to:" + location ) ; }  if  (   this . currentLocation == location )  {  return ; }   long  skipPoint = 0 ;    this . currentBlock = 0 ;  if  (   this . allData == null )  {   skipPoint =   this . skipPoints . get  (   this . currentBlock + 1 ) ;  while  (  location >= skipPoint )  {    this . currentBlock ++ ;  if  (   this . currentBlock ==    this . skipPoints . size  ( ) - 1 )  {  break ; } else  {   skipPoint =   this . skipPoints . get  (   this . currentBlock + 1 ) ; } } }    this . currentLocation = location ;   long  blockStart = 0 ;  if  (   this . allData == null )  {   blockStart =    this . indexItems . get  ( currentBlock ) . fileOffset ; }   long  newFilePos =  blockStart +  (  location - skipPoint ) ;    this . in . seek  ( newFilePos ) ; }   public  long seekAndReadLong  (   long location ,   int bytes )  throws IOException , PSTException  {   this . seek  ( location ) ;    byte  [ ]  buffer =  new  byte  [ bytes ] ;   this . read  ( buffer ) ;  return  PSTObject . convertLittleEndianBytesToLong  ( buffer ) ; }   public PSTFile getPSTFile  ( )  {  return  this . pstFile ; } }