  package  com . pff ;   import   java . io . File ;  import   java . io . RandomAccessFile ;  import   java . io . FileNotFoundException ;  import   java . io . IOException ;  import   java . io . InputStream ;  import   java . util . HashMap ;  import   java . util . LinkedHashMap ;  import   java . util . LinkedList ;  import   java . util . Properties ;  import   java . util . UUID ;   public class PSTFile  {   public static final  int  ENCRYPTION_TYPE_NONE = 0 ;   public static final  int  ENCRYPTION_TYPE_COMPRESSIBLE = 1 ;   private static final  int  MESSAGE_STORE_DESCRIPTOR_IDENTIFIER = 33 ;   private static final  int  ROOT_FOLDER_DESCRIPTOR_IDENTIFIER = 290 ;   public static final  int  PST_TYPE_ANSI = 14 ;   protected static final  int  PST_TYPE_ANSI_2 = 15 ;   public static final  int  PST_TYPE_UNICODE = 23 ;   public static final  int  PST_TYPE_2013_UNICODE = 36 ;   public static final  int  PS_PUBLIC_STRINGS = 0 ;   public static final  int  PSETID_Common = 1 ;   public static final  int  PSETID_Address = 2 ;   public static final  int  PS_INTERNET_HEADERS = 3 ;   public static final  int  PSETID_Appointment = 4 ;   public static final  int  PSETID_Meeting = 5 ;   public static final  int  PSETID_Log = 6 ;   public static final  int  PSETID_Messaging = 7 ;   public static final  int  PSETID_Note = 8 ;   public static final  int  PSETID_PostRss = 9 ;   public static final  int  PSETID_Task = 10 ;   public static final  int  PSETID_UnifiedMessaging = 11 ;   public static final  int  PS_MAPI = 12 ;   public static final  int  PSETID_AirSync = 13 ;   public static final  int  PSETID_Sharing = 14 ;   private static final String  guidStrings  [ ] =  { "00020329-0000-0000-C000-000000000046" , "00062008-0000-0000-C000-000000000046" , "00062004-0000-0000-C000-000000000046" , "00020386-0000-0000-C000-000000000046" , "00062002-0000-0000-C000-000000000046" , "6ED8DA90-450B-101B-98DA-00AA003F1305" , "0006200A-0000-0000-C000-000000000046" , "41F28F13-83F4-4114-A584-EEDB5A6B0BFF" , "0006200E-0000-0000-C000-000000000046" , "00062041-0000-0000-C000-000000000046" , "00062003-0000-0000-C000-000000000046" , "4442858E-A9E3-4E80-B900-317A210CC15B" , "00020328-0000-0000-C000-000000000046" , "71035549-0739-4DCB-9163-00F0580DBBDF" , "00062040-0000-0000-C000-000000000046" } ;   private  HashMap  < UUID , Integer >  guidMap =  new  HashMap  < UUID , Integer >  ( ) ;   private  int  encryptionType = 0 ;   private  LinkedHashMap  < Integer ,  LinkedList  < DescriptorIndexNode > >  childrenDescriptorTree = null ;   private  HashMap  < Long , Integer >  nameToId =  new  HashMap  < Long , Integer >  ( ) ;   private  HashMap  < String , Integer >  stringToId =  new  HashMap  < String , Integer >  ( ) ;   private static  HashMap  < Integer , Long >  idToName =  new  HashMap  < Integer , Long >  ( ) ;   private  HashMap  < Integer , String >  idToString =  new  HashMap  < Integer , String >  ( ) ;   private   byte  [ ]  guids = null ;   private  int  itemCount = 0 ;   private PSTFileContent  in ;   public PSTFile  (  String fileName )  throws FileNotFoundException , PSTException , IOException  {  this  (  new File  ( fileName ) ) ; }   public PSTFile  (  File file )  throws FileNotFoundException , PSTException , IOException  {  this  (  new PSTRAFileContent  ( file ) ) ; 
<<<<<<<
 try  {    byte  [ ]  temp =  new  byte  [ 4 ] ;   in . read  ( temp ) ;  String  strValue =  new String  ( temp ) ;  if  (  !  strValue . equals  ( "!BDN" ) )  {  throw  new PSTException  (   "Invalid file header: " + strValue + ", expected: !BDN" ) ; }    byte  [ ]  fileTypeBytes =  new  byte  [ 2 ] ;   in . seek  ( 10 ) ;   in . read  ( fileTypeBytes ) ;  if  (   fileTypeBytes [ 0 ] ==  PSTFile . PST_TYPE_ANSI_2 )  {    fileTypeBytes [ 0 ] =  PSTFile . PST_TYPE_ANSI ; }  if  (     fileTypeBytes [ 0 ] !=  PSTFile . PST_TYPE_ANSI &&   fileTypeBytes [ 0 ] !=  PSTFile . PST_TYPE_UNICODE &&   fileTypeBytes [ 0 ] !=  PSTFile . PST_TYPE_2013_UNICODE )  {  throw  new PSTException  (  "Unrecognised PST File version: " +  fileTypeBytes [ 0 ] ) ; }    this . pstFileType =  fileTypeBytes [ 0 ] ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   in . seek  ( 461 ) ; } else  {   in . seek  ( 513 ) ; }   encryptionType =  in . readByte  ( ) ;  if  (  encryptionType == 0x02 )  {  throw  new PSTException  ( "Only unencrypted and compressable PST files are supported at this time" ) ; }   processNameToIdMap  ( in ) ; }  catch (   IOException err )  {  throw  new PSTException  ( "Unable to read PST Sig" , err ) ; }
=======
>>>>>>>
 }   private  int  pstFileType = 0 ;   public  int getPSTFileType  ( )  {  return pstFileType ; }   private   byte  [ ] getData  (  PSTTableItem item ,   HashMap  < Integer , PSTDescriptorItem > localDescriptorItems )  throws IOException , PSTException  {  if  (    item . data . length != 0 )  {  return  item . data ; }  if  (  localDescriptorItems == null )  {  throw  new PSTException  ( "External reference but no localDescriptorItems in PSTFile.getData()" ) ; }  if  (   item . entryValueType != 0x0102 )  {  throw  new PSTException  ( "Attempting to get non-binary data in PSTFile.getData()" ) ; }  PSTDescriptorItem  mapDescriptorItem =  localDescriptorItems . get  (  item . entryValueReference ) ;  if  (  mapDescriptorItem == null )  {  throw  new PSTException  (    "not here " +  item . entryValueReference + "\n" +  localDescriptorItems . keySet  ( ) ) ; }  return  mapDescriptorItem . getData  ( ) ; }   int getNameToIdMapItem  (   int key ,   int propertySetIndex )  {   long  lKey =   (   (  long ) propertySetIndex << 32 ) |  (  long ) key ;  Integer  i =  nameToId . get  ( lKey ) ;  if  (  i == null )  {  return  - 1 ; }  return i ; }   int getPublicStringToIdMapItem  (  String key )  {  Integer  i =   this . stringToId . get  ( key ) ;  if  (  i == null )  {  return  - 1 ; }  return i ; }   static  long getNameToIdMapKey  (   int id )  {  Long  i =  idToName . get  ( id ) ;  if  (  i == null )  {  return  - 1 ; }  return i ; }   static private Properties  propertyInternetCodePages = null ;   static private boolean  bCPFirstTime = true ;   static String getInternetCodePageCharset  (   int propertyId )  {  if  ( bCPFirstTime )  {   bCPFirstTime = false ;   propertyInternetCodePages =  new Properties  ( ) ;  try  {  InputStream  propertyStream =   PSTFile . class . getResourceAsStream  ( "/InternetCodepages.txt" ) ;  if  (  propertyStream != null )  {   propertyInternetCodePages . load  ( propertyStream ) ; } else  {   propertyInternetCodePages = null ; } }  catch (   FileNotFoundException e )  {   propertyInternetCodePages = null ;   e . printStackTrace  ( ) ; }  catch (   IOException e )  {   propertyInternetCodePages = null ;   e . printStackTrace  ( ) ; } }  if  (  propertyInternetCodePages != null )  {  return  propertyInternetCodePages . getProperty  (  propertyId + "" ) ; }  return null ; }   static private Properties  propertyNames = null ;   static private boolean  bFirstTime = true ;   static String getPropertyName  (   int propertyId ,  boolean bNamed )  {  if  ( bFirstTime )  {   bFirstTime = false ;   propertyNames =  new Properties  ( ) ;  try  {  InputStream  propertyStream =   PSTFile . class . getResourceAsStream  ( "/PropertyNames.txt" ) ;  if  (  propertyStream != null )  {   propertyNames . load  ( propertyStream ) ; } else  {   propertyNames = null ; } }  catch (   FileNotFoundException e )  {   propertyNames = null ;   e . printStackTrace  ( ) ; }  catch (   IOException e )  {   propertyNames = null ;   e . printStackTrace  ( ) ; } }  if  (  propertyNames != null )  {  String  key =  String . format  (  (  bNamed ? "%08X" : "%04X" ) , propertyId ) ;  return  propertyNames . getProperty  ( key ) ; }  return null ; }   static String getPropertyDescription  (   int entryType ,   int entryValueType )  {  String  ret = "" ;  if  (  entryType < 0x8000 )  {  String  name =  PSTFile . getPropertyName  ( entryType , false ) ;  if  (  name != null )  {   ret =  String . format  ( "%s:%04X: " , name , entryValueType ) ; } else  {   ret =  String . format  ( "0x%04X:%04X: " , entryType , entryValueType ) ; } } else  {   long  type =  PSTFile . getNameToIdMapKey  ( entryType ) ;  if  (  type ==  - 1 )  {   ret =  String . format  ( "0xFFFF(%04X):%04X: " , entryType , entryValueType ) ; } else  {  String  name =  PSTFile . getPropertyName  (  (  int ) type , true ) ;  if  (  name != null )  {   ret =  String . format  ( "%s(%04X):%04X: " , name , entryType , entryValueType ) ; } else  {   ret =  String . format  ( "0x%04X(%04X):%04X: " , type , entryType , entryValueType ) ; } } }  return ret ; }    @ Override protected void finalize  ( )  throws IOException  {   in . close  ( ) ; }   public  int getEncryptionType  ( )  {  return  this . encryptionType ; }   public RandomAccessFile getFileHandle  ( )  {  if  (   this . in instanceof PSTRAFileContent )  {  return   (  ( PSTRAFileContent )  this . in ) . getFile  ( ) ; } else  {  return null ; } }   public PSTMessageStore getMessageStore  ( )  throws PSTException , IOException  {  DescriptorIndexNode  messageStoreDescriptor =  getDescriptorIndexNode  ( MESSAGE_STORE_DESCRIPTOR_IDENTIFIER ) ;  return  new PSTMessageStore  ( this , messageStoreDescriptor ) ; }   public PSTFolder getRootFolder  ( )  throws PSTException , IOException  {  DescriptorIndexNode  rootFolderDescriptor =  getDescriptorIndexNode  ( ROOT_FOLDER_DESCRIPTOR_IDENTIFIER ) ;  PSTFolder  output =  new PSTFolder  ( this , rootFolderDescriptor ) ;  return output ; }  PSTNodeInputStream readLeaf  (   long bid )  throws IOException , PSTException  {  PSTNodeInputStream  ret = null ;  OffsetIndexItem  offsetItem =  getOffsetIndexNode  ( bid ) ;  return  new PSTNodeInputStream  ( this , offsetItem ) ; }   public  int getLeafSize  (   long bid )  throws IOException , PSTException  {  OffsetIndexItem  offsetItem =  getOffsetIndexNode  ( bid ) ;  if  (   (   offsetItem . indexIdentifier & 0x02 ) == 0 )  {  return  offsetItem . size ; }    byte  [ ]  data =  new  byte  [ 8 ] ;   in . seek  (  offsetItem . fileOffset ) ;   in . read  ( data ) ;  return  (  int )  PSTObject . convertLittleEndianBytesToLong  ( data , 4 , 8 ) ; }   protected  long extractLEFileOffset  (   long startOffset )  throws IOException  {   long  offset = 0 ;  if  (   this . getPSTFileType  ( ) ==  PSTFile . PST_TYPE_ANSI )  {   in . seek  ( startOffset ) ;    byte  [ ]  temp =  new  byte  [ 4 ] ;   in . read  ( temp ) ;   offset |=   temp [ 3 ] & 0xff ;   offset <<= 8 ;   offset |=   temp [ 2 ] & 0xff ;   offset <<= 8 ;   offset |=   temp [ 1 ] & 0xff ;   offset <<= 8 ;   offset |=   temp [ 0 ] & 0xff ; } else  {   in . seek  ( startOffset ) ;    byte  [ ]  temp =  new  byte  [ 8 ] ;   in . read  ( temp ) ;   offset =   temp [ 7 ] & 0xff ;   long  tmpLongValue ;  for (   int  x = 6 ;  x >= 0 ;  x -- )  {   offset =  offset << 8 ;   tmpLongValue =   (  long )  temp [ x ] & 0xff ;   offset |= tmpLongValue ; } }  return offset ; } 
<<<<<<<
  private   byte  [ ] findBtreeItem  (  RandomAccessFile in ,   long index ,  boolean descTree )  throws IOException , PSTException  {   long  btreeStartOffset ;   int  fileTypeAdjustment ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   btreeStartOffset =  this . extractLEFileOffset  ( 196 ) ;  if  ( descTree )  {   btreeStartOffset =  this . extractLEFileOffset  ( 188 ) ; } } else  {   btreeStartOffset =  this . extractLEFileOffset  ( 240 ) ;  if  ( descTree )  {   btreeStartOffset =  this . extractLEFileOffset  ( 224 ) ; } }    byte  [ ]  temp =  new  byte  [ 2 ] ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   fileTypeAdjustment = 500 ; } else  if  (   this . getPSTFileType  ( ) == PST_TYPE_2013_UNICODE )  {   fileTypeAdjustment =  0x1000 - 24 ; } else  {   fileTypeAdjustment = 496 ; }   in . seek  (  btreeStartOffset + fileTypeAdjustment ) ;   in . read  ( temp ) ;  while  (   (     temp [ 0 ] == 0xffffff80 &&   temp [ 1 ] == 0xffffff80 &&  ! descTree ) ||  (     temp [ 0 ] == 0xffffff81 &&   temp [ 1 ] == 0xffffff81 && descTree ) )  {    byte  [ ]  branchNodeItems ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   branchNodeItems =  new  byte  [ 496 ] ; } else  if  (   this . getPSTFileType  ( ) == PST_TYPE_2013_UNICODE )  {   branchNodeItems =  new  byte  [ 4056 ] ; } else  {   branchNodeItems =  new  byte  [ 488 ] ; }   in . seek  ( btreeStartOffset ) ;   in . read  ( branchNodeItems ) ;   long  numberOfItems = 0 ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_2013_UNICODE )  {    byte  [ ]  numberOfItemsBytes =  new  byte  [ 2 ] ;   in . read  ( numberOfItemsBytes ) ;   numberOfItems =  PSTObject . convertLittleEndianBytesToLong  ( numberOfItemsBytes ) ;   in . read  ( numberOfItemsBytes ) ;   long  maxNumberOfItems =  PSTObject . convertLittleEndianBytesToLong  ( numberOfItemsBytes ) ; } else  {   numberOfItems =  in . read  ( ) ;   in . read  ( ) ; }   int  itemSize =  (  int )  in . read  ( ) ;   int  levelsToLeaf =  in . read  ( ) ;  if  (  levelsToLeaf > 0 )  {  boolean  found = false ;  for (   long  x = 0 ;  x < numberOfItems ;  x ++ )  {  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   long  indexIdOfFirstChildNode =  extractLEFileOffset  (  btreeStartOffset +  (  x * 12 ) ) ;  if  (  indexIdOfFirstChildNode > index )  {   btreeStartOffset =  extractLEFileOffset  (   btreeStartOffset +  (   (  x - 1 ) * 12 ) + 8 ) ;   in . seek  (  btreeStartOffset + 500 ) ;   in . read  ( temp ) ;   found = true ;  break ; } } else  {   long  indexIdOfFirstChildNode =  extractLEFileOffset  (  btreeStartOffset +  (  x * 24 ) ) ;  if  (  indexIdOfFirstChildNode > index )  {   btreeStartOffset =  extractLEFileOffset  (   btreeStartOffset +  (   (  x - 1 ) * 24 ) + 16 ) ;   in . seek  (  btreeStartOffset + fileTypeAdjustment ) ;   in . read  ( temp ) ;   found = true ;  break ; } } }  if  (  ! found )  {  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   btreeStartOffset =  extractLEFileOffset  (   btreeStartOffset +  (   (  numberOfItems - 1 ) * 12 ) + 8 ) ;   in . seek  (  btreeStartOffset + 500 ) ;   in . read  ( temp ) ; } else  {   btreeStartOffset =  extractLEFileOffset  (   btreeStartOffset +  (   (  numberOfItems - 1 ) * 24 ) + 16 ) ;   in . seek  (  btreeStartOffset + fileTypeAdjustment ) ;   in . read  ( temp ) ; } } } else  {  for (   long  x = 0 ;  x < numberOfItems ;  x ++ )  {  if  (   this . getPSTFileType  ( ) ==  PSTFile . PST_TYPE_ANSI )  {  if  ( descTree )  {   in . seek  (  btreeStartOffset +  (  x * 16 ) ) ;   temp =  new  byte  [ 4 ] ;   in . read  ( temp ) ;  if  (   PSTObject . convertLittleEndianBytesToLong  ( temp ) == index )  {   in . seek  (  btreeStartOffset +  (  x * 16 ) ) ;   temp =  new  byte  [ 16 ] ;   in . read  ( temp ) ;  return temp ; } } else  {   long  indexIdOfFirstChildNode =  extractLEFileOffset  (  btreeStartOffset +  (  x * 12 ) ) ;  if  (  indexIdOfFirstChildNode == index )  {   in . seek  (  btreeStartOffset +  (  x * 12 ) ) ;   temp =  new  byte  [ 12 ] ;   in . read  ( temp ) ;  return temp ; } } } else  {  if  ( descTree )  {   in . seek  (  btreeStartOffset +  (  x * 32 ) ) ;   temp =  new  byte  [ 4 ] ;   in . read  ( temp ) ;  if  (   PSTObject . convertLittleEndianBytesToLong  ( temp ) == index )  {   in . seek  (  btreeStartOffset +  (  x * 32 ) ) ;   temp =  new  byte  [ 32 ] ;   in . read  ( temp ) ;  return temp ; } } else  {   long  indexIdOfFirstChildNode =  extractLEFileOffset  (  btreeStartOffset +  (  x * 24 ) ) ;  if  (  indexIdOfFirstChildNode == index )  {   in . seek  (  btreeStartOffset +  (  x * 24 ) ) ;   temp =  new  byte  [ 24 ] ;   in . read  ( temp ) ;  return temp ; } } } }  throw  new PSTException  (    "Unable to find " + index + " is desc: " + descTree ) ; } }  throw  new PSTException  (    "Unable to find node: " + index + " is desc: " + descTree ) ; }
=======
>>>>>>>
  DescriptorIndexNode getDescriptorIndexNode  (   long identifier )  throws IOException , PSTException  {  return  new DescriptorIndexNode  (  findBtreeItem  ( in , identifier , true ) ,  this . getPSTFileType  ( ) ) ; }  OffsetIndexItem getOffsetIndexNode  (   long identifier )  throws IOException , PSTException  {  return  new OffsetIndexItem  (  findBtreeItem  ( in , identifier , false ) ,  this . getPSTFileType  ( ) ) ; }   HashMap  < Integer , PSTDescriptorItem > getPSTDescriptorItems  (   long localDescriptorsOffsetIndexIdentifier )  throws PSTException , IOException  {  return  this . getPSTDescriptorItems  (  this . readLeaf  ( localDescriptorsOffsetIndexIdentifier ) ) ; }   HashMap  < Integer , PSTDescriptorItem > getPSTDescriptorItems  (  PSTNodeInputStream in )  throws PSTException , IOException  {   in . seek  ( 0 ) ;   int  sig =  in . read  ( ) ;  if  (  sig != 0x2 )  {  throw  new PSTException  (  "Unable to process descriptor node, bad signature: " + sig ) ; }   HashMap  < Integer , PSTDescriptorItem >  output =  new  HashMap  < Integer , PSTDescriptorItem >  ( ) ;   int  numberOfItems =  (  int )  in . seekAndReadLong  ( 2 , 2 ) ;   int  offset ;  if  (   this . getPSTFileType  ( ) ==  PSTFile . PST_TYPE_ANSI )  {   offset = 4 ; } else  {   offset = 8 ; }    byte  [ ]  data =  new  byte  [  (  int )  in . length  ( ) ] ;   in . seek  ( 0 ) ;   in . read  ( data ) ;  for (   int  x = 0 ;  x < numberOfItems ;  x ++ )  {  PSTDescriptorItem  item =  new PSTDescriptorItem  ( data , offset , this ) ;   output . put  (  item . descriptorIdentifier , item ) ;  if  (   this . getPSTFileType  ( ) ==  PSTFile . PST_TYPE_ANSI )  {   offset += 12 ; } else  {   offset += 24 ; } }  return output ; }   LinkedHashMap  < Integer ,  LinkedList  < DescriptorIndexNode > > getChildDescriptorTree  ( )  throws IOException , PSTException  {  if  (   this . childrenDescriptorTree == null )  {   long  btreeStartOffset = 0 ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   btreeStartOffset =  this . extractLEFileOffset  ( 188 ) ; } else  {   btreeStartOffset =  this . extractLEFileOffset  ( 224 ) ; }    this . childrenDescriptorTree =  new  LinkedHashMap  < Integer ,  LinkedList  < DescriptorIndexNode > >  ( ) ;   processDescriptorBTree  ( btreeStartOffset ) ; }  return  this . childrenDescriptorTree ; }   private void processDescriptorBTree  (   long btreeStartOffset )  throws IOException , PSTException  {   int  fileTypeAdjustment ;    byte  [ ]  temp =  new  byte  [ 2 ] ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   fileTypeAdjustment = 500 ; } else  if  (   this . getPSTFileType  ( ) == PST_TYPE_2013_UNICODE )  {   fileTypeAdjustment =  0x1000 - 24 ; } else  {   fileTypeAdjustment = 496 ; }   in . seek  (  btreeStartOffset + fileTypeAdjustment ) ;   in . read  ( temp ) ;  if  (  (    temp [ 0 ] == 0xffffff81 &&   temp [ 1 ] == 0xffffff81 ) )  {  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   in . seek  (  btreeStartOffset + 496 ) ; } else  if  (   this . getPSTFileType  ( ) == PST_TYPE_2013_UNICODE )  {   in . seek  (  btreeStartOffset + 4056 ) ; } else  {   in . seek  (  btreeStartOffset + 488 ) ; }   long  numberOfItems = 0 ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_2013_UNICODE )  {    byte  [ ]  numberOfItemsBytes =  new  byte  [ 2 ] ;   in . read  ( numberOfItemsBytes ) ;   numberOfItems =  PSTObject . convertLittleEndianBytesToLong  ( numberOfItemsBytes ) ;   in . read  ( numberOfItemsBytes ) ;   long  maxNumberOfItems =  PSTObject . convertLittleEndianBytesToLong  ( numberOfItemsBytes ) ; } else  {   numberOfItems =  in . read  ( ) ;   in . read  ( ) ; }   in . read  ( ) ;   int  levelsToLeaf =  in . read  ( ) ;  if  (  levelsToLeaf > 0 )  {  for (   long  x = 0 ;  x < numberOfItems ;  x ++ )  {  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   long  branchNodeItemStartIndex =  (  btreeStartOffset +  (  12 * x ) ) ;   long  nextLevelStartsAt =  this . extractLEFileOffset  (  branchNodeItemStartIndex + 8 ) ;   processDescriptorBTree  ( nextLevelStartsAt ) ; } else  {   long  branchNodeItemStartIndex =  (  btreeStartOffset +  (  24 * x ) ) ;   long  nextLevelStartsAt =  this . extractLEFileOffset  (  branchNodeItemStartIndex + 16 ) ;   processDescriptorBTree  ( nextLevelStartsAt ) ; } } } else  {  for (   long  x = 0 ;  x < numberOfItems ;  x ++ )  {  if  (   this . getPSTFileType  ( ) ==  PSTFile . PST_TYPE_ANSI )  {   in . seek  (  btreeStartOffset +  (  x * 16 ) ) ;   temp =  new  byte  [ 16 ] ;   in . read  ( temp ) ; } else  {   in . seek  (  btreeStartOffset +  (  x * 32 ) ) ;   temp =  new  byte  [ 32 ] ;   in . read  ( temp ) ; }  DescriptorIndexNode  tempNode =  new DescriptorIndexNode  ( temp ,  this . getPSTFileType  ( ) ) ;  if  (   tempNode . parentDescriptorIndexIdentifier ==  tempNode . descriptorIdentifier )  { } else  if  (  childrenDescriptorTree . containsKey  (  tempNode . parentDescriptorIndexIdentifier ) )  {   LinkedList  < DescriptorIndexNode >  children =  childrenDescriptorTree . get  (  tempNode . parentDescriptorIndexIdentifier ) ;   children . add  ( tempNode ) ; } else  {   LinkedList  < DescriptorIndexNode >  children =  new  LinkedList  < DescriptorIndexNode >  ( ) ;   children . add  ( tempNode ) ;   childrenDescriptorTree . put  (  tempNode . parentDescriptorIndexIdentifier , children ) ; }    this . itemCount ++ ; } } } else  {   PSTObject . printHexFormatted  ( temp , true ) ;  throw  new PSTException  ( "Unable to read descriptor node, is not a descriptor" ) ; } }   public void close  ( )  throws IOException  {   in . close  ( ) ; }   public PSTFile  (    byte  [ ] bytes )  throws FileNotFoundException , PSTException , IOException  {  this  (  new PSTByteFileContent  ( bytes ) ) ; }   public PSTFile  (  PSTFileContent content )  throws FileNotFoundException , PSTException , IOException  {    this . in = content ;  try  {    byte  [ ]  temp =  new  byte  [ 4 ] ;   in . read  ( temp ) ;  String  strValue =  new String  ( temp ) ;  if  (  !  strValue . equals  ( "!BDN" ) )  {  throw  new PSTException  (   "Invalid file header: " + strValue + ", expected: !BDN" ) ; }    byte  [ ]  fileTypeBytes =  new  byte  [ 2 ] ;   in . seek  ( 10 ) ;   in . read  ( fileTypeBytes ) ;  if  (   fileTypeBytes [ 0 ] ==  PSTFile . PST_TYPE_ANSI_2 )  {    fileTypeBytes [ 0 ] =  PSTFile . PST_TYPE_ANSI ; }  if  (    fileTypeBytes [ 0 ] !=  PSTFile . PST_TYPE_ANSI &&   fileTypeBytes [ 0 ] !=  PSTFile . PST_TYPE_UNICODE )  {  throw  new PSTException  (  "Unrecognised PST File version: " +  fileTypeBytes [ 0 ] ) ; }    this . pstFileType =  fileTypeBytes [ 0 ] ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   in . seek  ( 461 ) ; } else  {   in . seek  ( 513 ) ; }   encryptionType =  in . readByte  ( ) ;  if  (  encryptionType == 0x02 )  {  throw  new PSTException  ( "Only unencrypted and compressable PST files are supported at this time" ) ; }   processNameToIdMap  ( in ) ; }  catch (   IOException err )  {  throw  new PSTException  ( "Unable to read PST Sig" , err ) ; } }   private void processNameToIdMap  (  PSTFileContent in )  throws IOException , PSTException  {  for (   int  i = 0 ;  i <  guidStrings . length ;  ++ i )  {  UUID  uuid =  UUID . fromString  (  guidStrings [ i ] ) ;   guidMap . put  ( uuid , i ) ; }  DescriptorIndexNode  nameToIdMapDescriptorNode =  (  getDescriptorIndexNode  ( 97 ) ) ;   HashMap  < Integer , PSTDescriptorItem >  localDescriptorItems = null ;  if  (   nameToIdMapDescriptorNode . localDescriptorsOffsetIndexIdentifier != 0 )  {   localDescriptorItems =  this . getPSTDescriptorItems  (  nameToIdMapDescriptorNode . localDescriptorsOffsetIndexIdentifier ) ; }  OffsetIndexItem  off =  this . getOffsetIndexNode  (  nameToIdMapDescriptorNode . dataOffsetIndexIdentifier ) ;  PSTNodeInputStream  nodein =  new PSTNodeInputStream  ( this , off ) ;    byte  [ ]  tmp =  new  byte  [ 1024 ] ;   nodein . read  ( tmp ) ;  PSTTableBC  bcTable =  new PSTTableBC  ( nodein ) ;   HashMap  < Integer , PSTTableBCItem >  tableItems =  (  bcTable . getItems  ( ) ) ;  PSTTableBCItem  guidEntry =  tableItems . get  ( 2 ) ;   guids =  getData  ( guidEntry , localDescriptorItems ) ;   int  nGuids =   guids . length / 16 ;   UUID  [ ]  uuidArray =  new UUID  [ nGuids ] ;    int  [ ]  uuidIndexes =  new  int  [ nGuids ] ;   int  offset = 0 ;  for (   int  i = 0 ;  i < nGuids ;  ++ i )  {   long  mostSigBits =    (   PSTObject . convertLittleEndianBytesToLong  ( guids , offset ,  offset + 4 ) << 32 ) |  (   PSTObject . convertLittleEndianBytesToLong  ( guids ,  offset + 4 ,  offset + 6 ) << 16 ) |  PSTObject . convertLittleEndianBytesToLong  ( guids ,  offset + 6 ,  offset + 8 ) ;   long  leastSigBits =  PSTObject . convertBigEndianBytesToLong  ( guids ,  offset + 8 ,  offset + 16 ) ;    uuidArray [ i ] =  new UUID  ( mostSigBits , leastSigBits ) ;  if  (  guidMap . containsKey  (  uuidArray [ i ] ) )  {    uuidIndexes [ i ] =  guidMap . get  (  uuidArray [ i ] ) ; } else  {    uuidIndexes [ i ] =  - 1 ; }   offset += 16 ; }  PSTTableBCItem  mapEntries =  tableItems . get  ( 3 ) ;    byte  [ ]  nameToIdByte =  getData  ( mapEntries , localDescriptorItems ) ;  PSTTableBCItem  stringMapEntries =  tableItems . get  ( 4 ) ;    byte  [ ]  stringNameToIdByte =  getData  ( stringMapEntries , localDescriptorItems ) ;  for (   int  x = 0 ;   x + 8 <  nameToIdByte . length ;  x += 8 )  {   int  dwPropertyId =  (  int )  PSTObject . convertLittleEndianBytesToLong  ( nameToIdByte , x ,  x + 4 ) ;   int  wGuid =  (  int )  PSTObject . convertLittleEndianBytesToLong  ( nameToIdByte ,  x + 4 ,  x + 6 ) ;   int  wPropIdx =  (  (  int )  PSTObject . convertLittleEndianBytesToLong  ( nameToIdByte ,  x + 6 ,  x + 8 ) ) ;  if  (   (  wGuid & 0x0001 ) == 0 )  {   wPropIdx += 0x8000 ;   wGuid >>= 1 ;   int  guidIndex ;  if  (  wGuid == 1 )  {   guidIndex = PS_MAPI ; } else  if  (  wGuid == 2 )  {   guidIndex = PS_PUBLIC_STRINGS ; } else  {   guidIndex =  uuidIndexes [  wGuid - 3 ] ; }   nameToId . put  (   (  long ) dwPropertyId |  (   (  long ) guidIndex << 32 ) , wPropIdx ) ;   idToName . put  ( wPropIdx ,  (  long ) dwPropertyId ) ; } else  {   int  len =  (  int )  PSTObject . convertLittleEndianBytesToLong  ( stringNameToIdByte , dwPropertyId ,  dwPropertyId + 4 ) ;    byte  [ ]  keyByteValue =  new  byte  [ len ] ;   System . arraycopy  ( stringNameToIdByte ,  dwPropertyId + 4 , keyByteValue , 0 ,  keyByteValue . length ) ;   wPropIdx += 0x8000 ;  String  key =  new String  ( keyByteValue , "UTF-16LE" ) ;   stringToId . put  ( key , wPropIdx ) ;   idToString . put  ( wPropIdx , key ) ; } } }   public PSTFileContent getContentHandle  ( )  {  return  this . in ; }   private   byte  [ ] findBtreeItem  (  PSTFileContent in ,   long index ,  boolean descTree )  throws IOException , PSTException  {   long  btreeStartOffset ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   btreeStartOffset =  this . extractLEFileOffset  ( 196 ) ;  if  ( descTree )  {   btreeStartOffset =  this . extractLEFileOffset  ( 188 ) ; } } else  {   btreeStartOffset =  this . extractLEFileOffset  ( 240 ) ;  if  ( descTree )  {   btreeStartOffset =  this . extractLEFileOffset  ( 224 ) ; } }    byte  [ ]  temp =  new  byte  [ 2 ] ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   in . seek  (  btreeStartOffset + 500 ) ; } else  {   in . seek  (  btreeStartOffset + 496 ) ; }   in . read  ( temp ) ;  while  (   (     temp [ 0 ] == 0xffffff80 &&   temp [ 1 ] == 0xffffff80 &&  ! descTree ) ||  (     temp [ 0 ] == 0xffffff81 &&   temp [ 1 ] == 0xffffff81 && descTree ) )  {    byte  [ ]  branchNodeItems ;  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   branchNodeItems =  new  byte  [ 496 ] ; } else  {   branchNodeItems =  new  byte  [ 488 ] ; }   in . seek  ( btreeStartOffset ) ;   in . read  ( branchNodeItems ) ;   int  numberOfItems =  in . read  ( ) ;   in . read  ( ) ;   in . read  ( ) ;   int  levelsToLeaf =  in . read  ( ) ;  if  (  levelsToLeaf > 0 )  {  boolean  found = false ;  for (   int  x = 0 ;  x < numberOfItems ;  x ++ )  {  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   long  indexIdOfFirstChildNode =  extractLEFileOffset  (  btreeStartOffset +  (  x * 12 ) ) ;  if  (  indexIdOfFirstChildNode > index )  {   btreeStartOffset =  extractLEFileOffset  (   btreeStartOffset +  (   (  x - 1 ) * 12 ) + 8 ) ;   in . seek  (  btreeStartOffset + 500 ) ;   in . read  ( temp ) ;   found = true ;  break ; } } else  {   long  indexIdOfFirstChildNode =  extractLEFileOffset  (  btreeStartOffset +  (  x * 24 ) ) ;  if  (  indexIdOfFirstChildNode > index )  {   btreeStartOffset =  extractLEFileOffset  (   btreeStartOffset +  (   (  x - 1 ) * 24 ) + 16 ) ;   in . seek  (  btreeStartOffset + 496 ) ;   in . read  ( temp ) ;   found = true ;  break ; } } }  if  (  ! found )  {  if  (   this . getPSTFileType  ( ) == PST_TYPE_ANSI )  {   btreeStartOffset =  extractLEFileOffset  (   btreeStartOffset +  (   (  numberOfItems - 1 ) * 12 ) + 8 ) ;   in . seek  (  btreeStartOffset + 500 ) ;   in . read  ( temp ) ; } else  {   btreeStartOffset =  extractLEFileOffset  (   btreeStartOffset +  (   (  numberOfItems - 1 ) * 24 ) + 16 ) ;   in . seek  (  btreeStartOffset + 496 ) ;   in . read  ( temp ) ; } } } else  {  for (   int  x = 0 ;  x < numberOfItems ;  x ++ )  {  if  (   this . getPSTFileType  ( ) ==  PSTFile . PST_TYPE_ANSI )  {  if  ( descTree )  {   in . seek  (  btreeStartOffset +  (  x * 16 ) ) ;   temp =  new  byte  [ 4 ] ;   in . read  ( temp ) ;  if  (   PSTObject . convertLittleEndianBytesToLong  ( temp ) == index )  {   in . seek  (  btreeStartOffset +  (  x * 16 ) ) ;   temp =  new  byte  [ 16 ] ;   in . read  ( temp ) ;  return temp ; } } else  {   long  indexIdOfFirstChildNode =  extractLEFileOffset  (  btreeStartOffset +  (  x * 12 ) ) ;  if  (  indexIdOfFirstChildNode == index )  {   in . seek  (  btreeStartOffset +  (  x * 12 ) ) ;   temp =  new  byte  [ 12 ] ;   in . read  ( temp ) ;  return temp ; } } } else  {  if  ( descTree )  {   in . seek  (  btreeStartOffset +  (  x * 32 ) ) ;   temp =  new  byte  [ 4 ] ;   in . read  ( temp ) ;  if  (   PSTObject . convertLittleEndianBytesToLong  ( temp ) == index )  {   in . seek  (  btreeStartOffset +  (  x * 32 ) ) ;   temp =  new  byte  [ 32 ] ;   in . read  ( temp ) ;  return temp ; } } else  {   long  indexIdOfFirstChildNode =  extractLEFileOffset  (  btreeStartOffset +  (  x * 24 ) ) ;  if  (  indexIdOfFirstChildNode == index )  {   in . seek  (  btreeStartOffset +  (  x * 24 ) ) ;   temp =  new  byte  [ 24 ] ;   in . read  ( temp ) ;  return temp ; } } } }  throw  new PSTException  (  "Unable to find " + index ) ; } }  throw  new PSTException  (  "Unable to find node: " + index ) ; } }