  package    com . relayrides . pushy . apns ;   import     io . netty . channel . nio . NioEventLoopGroup ;  import    java . lang . Thread . UncaughtExceptionHandler ;  import   java . util . ArrayList ;  import   java . util . Collection ;  import   java . util . Date ;  import   java . util . HashSet ;  import   java . util . List ;  import    java . util . concurrent . BlockingQueue ;  import    java . util . concurrent . ExecutorService ;  import    java . util . concurrent . Executors ;  import    java . util . concurrent . LinkedBlockingQueue ;  import    java . util . concurrent . TimeUnit ;  import    javax . net . ssl . SSLContext ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import    javax . net . ssl . SSLHandshakeException ;   public class PushManager  <  T  extends ApnsPushNotification >  implements   ApnsConnectionListener  < T >  {   private final  BlockingQueue  < T >  queue ;   private final  LinkedBlockingQueue  < T >  retryQueue ;   private final ApnsEnvironment  environment ;   private final SSLContext  sslContext ;   private final  int  concurrentConnectionCount ;   private final  HashSet  <  ApnsConnection  < T > >  activeConnections ;   private final  ApnsConnectionPool  < T >  writableConnectionPool ;   private final FeedbackServiceClient  feedbackServiceClient ;   private final  ArrayList  <  RejectedNotificationListener  <  ? super T > >  rejectedNotificationListeners ;   private final  ArrayList  <  FailedConnectionListener  <  ? super T > >  failedConnectionListeners ;   private Thread  dispatchThread ;   private boolean  dispatchThreadShouldContinue = true ;   private final NioEventLoopGroup  eventLoopGroup ;   private final boolean  shouldShutDownEventLoopGroup ;   private final ExecutorService  listenerExecutorService ;   private final boolean  shouldShutDownListenerExecutorService ;   private boolean  shutDownStarted = false ;   private boolean  shutDownFinished = false ;   private static final Logger  log =  LoggerFactory . getLogger  (  PushManager . class ) ;   private static class DispatchThreadExceptionHandler  <  T  extends ApnsPushNotification >  implements  UncaughtExceptionHandler  {   private final Logger  log =  LoggerFactory . getLogger  (  DispatchThreadExceptionHandler . class ) ;   final  PushManager  < T >  manager ;   public DispatchThreadExceptionHandler  (   final  PushManager  < T > manager )  {    this . manager = manager ; }   public void uncaughtException  (   final Thread t ,   final Throwable e )  {   log . error  ( "Dispatch thread died unexpectedly. Please file a bug with the exception details." , e ) ;  if  (   this . manager . isStarted  ( ) )  {    this . manager . createAndStartDispatchThread  ( ) ; } } }   protected PushManager  (   final ApnsEnvironment environment ,   final SSLContext sslContext ,   final  int concurrentConnectionCount ,   final NioEventLoopGroup eventLoopGroup ,   final ExecutorService listenerExecutorService ,   final  BlockingQueue  < T > queue )  {    this . queue =   queue != null ? queue :  new  LinkedBlockingQueue  < T >  ( ) ;    this . retryQueue =  new  LinkedBlockingQueue  < T >  ( ) ;    this . rejectedNotificationListeners =  new  ArrayList  <  RejectedNotificationListener  <  ? super T > >  ( ) ;    this . failedConnectionListeners =  new  ArrayList  <  FailedConnectionListener  <  ? super T > >  ( ) ;    this . environment = environment ;    this . sslContext = sslContext ;    this . concurrentConnectionCount = concurrentConnectionCount ;    this . writableConnectionPool =  new  ApnsConnectionPool  < T >  ( ) ;    this . activeConnections =  new  HashSet  <  ApnsConnection  < T > >  ( ) ;  if  (  eventLoopGroup != null )  {    this . eventLoopGroup = eventLoopGroup ;    this . shouldShutDownEventLoopGroup = false ; } else  {    this . eventLoopGroup =  new NioEventLoopGroup  ( ) ;    this . shouldShutDownEventLoopGroup = true ; }  if  (  listenerExecutorService != null )  {    this . listenerExecutorService = listenerExecutorService ;    this . shouldShutDownListenerExecutorService = false ; } else  {    this . listenerExecutorService =  Executors . newSingleThreadExecutor  ( ) ;    this . shouldShutDownListenerExecutorService = true ; }    this . feedbackServiceClient =  new FeedbackServiceClient  (  this . environment ,  this . sslContext ,  this . eventLoopGroup ) ; }   public synchronized void start  ( )  {  if  (  this . isStarted  ( ) )  {  throw  new IllegalStateException  ( "Push manager has already been started." ) ; }  if  (  this . isShutDown  ( ) )  {  throw  new IllegalStateException  ( "Push manager has already been shut down and may not be restarted." ) ; }   log . info  ( "Push manager starting." ) ;  for (   int  i = 0 ;  i <  this . concurrentConnectionCount ;  i ++ )  {   this . startNewConnection  ( ) ; }   this . createAndStartDispatchThread  ( ) ; }   private void createAndStartDispatchThread  ( )  {    this . dispatchThread =  createDispatchThread  ( ) ;    this . dispatchThread . setUncaughtExceptionHandler  (  new  DispatchThreadExceptionHandler  < T >  ( this ) ) ;    this . dispatchThread . start  ( ) ; }   protected Thread createDispatchThread  ( )  {  return  new Thread  (  new Runnable  ( )  {   public void run  ( )  {  while  ( dispatchThreadShouldContinue )  {  try  {   final  ApnsConnection  < T >  connection =  writableConnectionPool . getNextConnection  ( ) ;   final T  notificationToRetry =  retryQueue . poll  ( ) ;  if  (  notificationToRetry != null )  {   connection . sendNotification  ( notificationToRetry ) ; } else  {  if  ( shutDownStarted )  {   connection . shutdownGracefully  ( ) ;   writableConnectionPool . removeConnection  ( connection ) ; } else  {   connection . sendNotification  (  queue . take  ( ) ) ; } } }  catch (   InterruptedException e )  {  continue ; } } } } ) ; }   public boolean isStarted  ( )  {  if  (  this . isShutDown  ( ) )  {  return false ; } else  {  return   this . dispatchThread != null ; } }   public boolean isShutDown  ( )  {  return  this . shutDownStarted ; }   public synchronized void shutdown  ( )  throws InterruptedException  {   this . shutdown  ( 0 ) ; }   public synchronized  List  < T > shutdown  (   long timeout )  throws InterruptedException  {  if  (  this . isShutDown  ( ) )  {   log . warn  (  "Push manager has already been shut down; shutting down multiple times is harmless, but may " + "indicate a problem elsewhere." ) ; } else  {   log . info  ( "Push manager shutting down." ) ; }  if  (  this . shutDownFinished )  {  return  new  ArrayList  < T >  (  this . retryQueue ) ; }  if  (  !  this . isStarted  ( ) )  {  throw  new IllegalStateException  ( "Push manager has not yet been started and cannot be shut down." ) ; }    this . shutDownStarted = true ;    this . dispatchThread . interrupt  ( ) ;   final Date  deadline =   timeout > 0 ?  new Date  (   System . currentTimeMillis  ( ) + timeout ) : null ;   this . waitForAllConnectionsToFinish  ( deadline ) ;    this . dispatchThreadShouldContinue = false ;    this . dispatchThread . interrupt  ( ) ;    this . dispatchThread . join  ( ) ;  if  (  deadline == null )  {  assert   this . retryQueue . isEmpty  ( ) ;  assert   this . activeConnections . isEmpty  ( ) ; }  synchronized  (  this . activeConnections )  {  for (  final  ApnsConnection  < T > connection :  this . activeConnections )  {   connection . shutdownImmediately  ( ) ; } }  synchronized  (  this . rejectedNotificationListeners )  {    this . rejectedNotificationListeners . clear  ( ) ; }  synchronized  (  this . failedConnectionListeners )  {    this . failedConnectionListeners . clear  ( ) ; }  if  (  this . shouldShutDownListenerExecutorService )  {    this . listenerExecutorService . shutdown  ( ) ; }  if  (  this . shouldShutDownEventLoopGroup )  {     this . eventLoopGroup . shutdownGracefully  ( ) . await  ( ) ; }    this . shutDownFinished = true ;  return  new  ArrayList  < T >  (  this . retryQueue ) ; }   public void registerRejectedNotificationListener  (   final  RejectedNotificationListener  <  ? super T > listener )  {  if  (  this . isShutDown  ( ) )  {  throw  new IllegalStateException  ( "Rejected notification listeners may not be registered after a push manager has been shut down." ) ; }  synchronized  (  this . rejectedNotificationListeners )  {    this . rejectedNotificationListeners . add  ( listener ) ; } }   public boolean unregisterRejectedNotificationListener  (   final  RejectedNotificationListener  <  ? super T > listener )  {  synchronized  (  this . rejectedNotificationListeners )  {  return   this . rejectedNotificationListeners . remove  ( listener ) ; } }   public void registerFailedConnectionListener  (   final  FailedConnectionListener  <  ? super T > listener )  {  if  (  this . isShutDown  ( ) )  {  throw  new IllegalStateException  ( "Failed connection listeners may not be registered after a push manager has been shut down." ) ; }  synchronized  (  this . failedConnectionListeners )  {    this . failedConnectionListeners . add  ( listener ) ; } }   public boolean unregisterFailedConnectionListener  (   final  FailedConnectionListener  <  ? super T > listener )  {  synchronized  (  this . failedConnectionListeners )  {  return   this . failedConnectionListeners . remove  ( listener ) ; } }   public  BlockingQueue  < T > getQueue  ( )  {  return  this . queue ; }   protected  BlockingQueue  < T > getRetryQueue  ( )  {  return  this . retryQueue ; }   public  List  < ExpiredToken > getExpiredTokens  ( )  throws InterruptedException , FeedbackConnectionException  {  return  this . getExpiredTokens  ( 1 ,  TimeUnit . SECONDS ) ; }   public  List  < ExpiredToken > getExpiredTokens  (   final  long timeout ,   final TimeUnit timeoutUnit )  throws InterruptedException , FeedbackConnectionException  {  if  (  !  this . isStarted  ( ) )  {  throw  new IllegalStateException  ( "Push manager has not been started yet." ) ; }  if  (  this . isShutDown  ( ) )  {  throw  new IllegalStateException  ( "Push manager has already been shut down." ) ; }  return   this . feedbackServiceClient . getExpiredTokens  ( timeout , timeoutUnit ) ; }   public void handleConnectionSuccess  (   final  ApnsConnection  < T > connection )  {   log . trace  ( "Connection succeeded: {}" , connection ) ;  if  (  this . dispatchThreadShouldContinue )  {    this . writableConnectionPool . addConnection  ( connection ) ; } else  {   connection . shutdownImmediately  ( ) ; } }   public void handleConnectionFailure  (   final  ApnsConnection  < T > connection ,   final Throwable cause )  {   log . trace  ( "Connection failed: {}" , connection , cause ) ;   this . removeActiveConnection  ( connection ) ;   final  PushManager  < T >  pushManager = this ;  synchronized  (  this . failedConnectionListeners )  {  for (  final  FailedConnectionListener  <  ? super T > listener :  this . failedConnectionListeners )  {    this . listenerExecutorService . submit  (  new Runnable  ( )  {   public void run  ( )  {   listener . handleFailedConnection  ( pushManager , cause ) ; } } ) ; } }  if  (  this . shouldReplaceClosedConnection  ( ) )  {   this . startNewConnection  ( ) ; } }   public void handleConnectionWritabilityChange  (   final  ApnsConnection  < T > connection ,   final boolean writable )  {   log . trace  ( "Writability for {} changed to {}" , connection , writable ) ;  if  ( writable )  {    this . writableConnectionPool . addConnection  ( connection ) ; } else  {    this . writableConnectionPool . removeConnection  ( connection ) ;    this . dispatchThread . interrupt  ( ) ; } }   public void handleConnectionClosure  (   final  ApnsConnection  < T > connection )  {   log . trace  ( "Connection closed: {}" , connection ) ;    this . writableConnectionPool . removeConnection  ( connection ) ;    this . dispatchThread . interrupt  ( ) ;   final  PushManager  < T >  pushManager = this ;    this . listenerExecutorService . execute  (  new Runnable  ( )  {   public void run  ( )  {  try  {   connection . waitForPendingWritesToFinish  ( ) ;  if  (  pushManager . shouldReplaceClosedConnection  ( ) )  {   pushManager . startNewConnection  ( ) ; }   removeActiveConnection  ( connection ) ; }  catch (   InterruptedException e )  {   log . warn  ( "Interrupted while waiting for closed connection's pending operations to finish." ) ; } } } ) ; }   public void handleWriteFailure  (   ApnsConnection  < T > connection ,  T notification ,  Throwable cause )  {    this . retryQueue . add  ( notification ) ;    this . dispatchThread . interrupt  ( ) ; }   public void handleRejectedNotification  (   final  ApnsConnection  < T > connection ,   final T rejectedNotification ,   final RejectedNotificationReason reason )  {   log . trace  ( "{} rejected {}: {}" , connection , rejectedNotification , reason ) ;   final  PushManager  < T >  pushManager = this ;  synchronized  (  this . rejectedNotificationListeners )  {  for (  final  RejectedNotificationListener  <  ? super T > listener :  this . rejectedNotificationListeners )  {    this . listenerExecutorService . execute  (  new Runnable  ( )  {   public void run  ( )  {   listener . handleRejectedNotification  ( pushManager , rejectedNotification , reason ) ; } } ) ; } } }   public void handleUnprocessedNotifications  (   ApnsConnection  < T > connection ,   Collection  < T > unprocessedNotifications )  {   log . trace  ( "{} returned {} unprocessed notifications" , connection ,  unprocessedNotifications . size  ( ) ) ;    this . retryQueue . addAll  ( unprocessedNotifications ) ;    this . dispatchThread . interrupt  ( ) ; }   private void startNewConnection  ( )  {  synchronized  (  this . activeConnections )  {   final  ApnsConnection  < T >  connection =  new  ApnsConnection  < T >  (  this . environment ,  this . sslContext ,  this . eventLoopGroup , this ) ;   connection . connect  ( ) ;    this . activeConnections . add  ( connection ) ; } }   private void removeActiveConnection  (   final  ApnsConnection  < T > connection )  {  synchronized  (  this . activeConnections )  {   final boolean  removedConnection =   this . activeConnections . remove  ( connection ) ;  assert removedConnection ;  if  (   this . activeConnections . isEmpty  ( ) )  {    this . activeConnections . notifyAll  ( ) ; } } }   private void waitForAllConnectionsToFinish  (   final Date deadline )  throws InterruptedException  {  synchronized  (  this . activeConnections )  {  while  (   !   this . activeConnections . isEmpty  ( ) &&  !  PushManager . hasDeadlineExpired  ( deadline ) )  {  if  (  deadline != null )  {    this . activeConnections . wait  (  PushManager . getMillisToWaitForDeadline  ( deadline ) ) ; } else  {    this . activeConnections . wait  ( ) ; } } } }   private static  long getMillisToWaitForDeadline  (   final Date deadline )  {  return  Math . max  (   deadline . getTime  ( ) -  System . currentTimeMillis  ( ) , 1 ) ; }   private static boolean hasDeadlineExpired  (   final Date deadline )  {  if  (  deadline != null )  {  return   System . currentTimeMillis  ( ) >  deadline . getTime  ( ) ; } else  {  return false ; } }   private boolean shouldReplaceClosedConnection  ( )  {  if  (  this . shutDownStarted )  {  if  (  this . dispatchThreadShouldContinue )  {  return  !   this . retryQueue . isEmpty  ( ) ; } else  {  return false ; } } else  {  return true ; } } }