  package    com . relayrides . pushy . apns ;   import    io . netty . bootstrap . Bootstrap ;  import    io . netty . buffer . ByteBuf ;  import    io . netty . buffer . PooledByteBufAllocator ;  import    io . netty . channel . Channel ;  import    io . netty . channel . ChannelFuture ;  import    io . netty . channel . ChannelHandlerContext ;  import    io . netty . channel . ChannelInitializer ;  import    io . netty . channel . ChannelOption ;  import    io . netty . channel . ChannelPipeline ;  import    io . netty . channel . SimpleChannelInboundHandler ;  import     io . netty . channel . nio . NioEventLoopGroup ;  import     io . netty . channel . socket . SocketChannel ;  import      io . netty . channel . socket . nio . NioSocketChannel ;  import     io . netty . handler . codec . ByteToMessageDecoder ;  import     io . netty . handler . codec . MessageToByteEncoder ;  import     io . netty . handler . ssl . SslHandler ;  import     io . netty . util . concurrent . Future ;  import     io . netty . util . concurrent . GenericFutureListener ;  import    java . nio . charset . Charset ;  import   java . util . Collection ;  import   java . util . Date ;  import   java . util . List ;  import     java . util . concurrent . atomic . AtomicInteger ;  import    javax . net . ssl . SSLContext ;  import    javax . net . ssl . SSLEngine ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;   public class ApnsConnection  <  T  extends ApnsPushNotification >  {   private final ApnsEnvironment  environment ;   private final SSLContext  sslContext ;   private final NioEventLoopGroup  eventLoopGroup ;   private final  ApnsConnectionListener  < T >  listener ;   private static final AtomicInteger  connectionCounter =  new AtomicInteger  ( 0 ) ;   private final String  name ;   private ChannelFuture  connectFuture ;   private volatile boolean  handshakeCompleted = false ;   private boolean  closeOnRegistration ;   private  int  sequenceNumber = 0 ;   private final Object  pendingWriteMonitor =  new Object  ( ) ;   private  int  pendingWriteCount = 0 ;   private  SendableApnsPushNotification  < KnownBadPushNotification >  shutdownNotification ;   private boolean  rejectionReceived = false ;   private final  SentNotificationBuffer  < T >  sentNotificationBuffer =  new  SentNotificationBuffer  < T >  ( 4096 ) ;   private static final Logger  log =  LoggerFactory . getLogger  (  ApnsConnection . class ) ;   private class RejectedNotificationDecoder  extends ByteToMessageDecoder  {   private static final  int  EXPECTED_BYTES = 6 ;   private static final  byte  EXPECTED_COMMAND = 8 ;    @ Override protected void decode  (   final ChannelHandlerContext context ,   final ByteBuf in ,   final  List  < Object > out )  {  if  (   in . readableBytes  ( ) >= EXPECTED_BYTES )  {   final  byte  command =  in . readByte  ( ) ;   final  byte  code =  in . readByte  ( ) ;   final  int  notificationId =  in . readInt  ( ) ;  if  (  command != EXPECTED_COMMAND )  {   log . error  ( "Unexpected command: {}" , command ) ; }   final RejectedNotificationReason  errorCode =  RejectedNotificationReason . getByErrorCode  ( code ) ;   out . add  (  new RejectedNotification  ( notificationId , errorCode ) ) ; } } }   private class ApnsPushNotificationEncoder  extends  MessageToByteEncoder  <  SendableApnsPushNotification  < T > >  {   private static final  byte  ENHANCED_PUSH_NOTIFICATION_COMMAND = 1 ;   private static final  int  EXPIRE_IMMEDIATELY = 0 ;   private final Charset  utf8 =  Charset . forName  ( "UTF-8" ) ;    @ Override protected void encode  (   final ChannelHandlerContext context ,   final  SendableApnsPushNotification  < T > sendablePushNotification ,   final ByteBuf out )  throws Exception  {   out . writeByte  ( ENHANCED_PUSH_NOTIFICATION_COMMAND ) ;   out . writeInt  (  sendablePushNotification . getSequenceNumber  ( ) ) ;  if  (    sendablePushNotification . getPushNotification  ( ) . getDeliveryInvalidationTime  ( ) != null )  {   out . writeInt  (  this . getTimestampInSeconds  (   sendablePushNotification . getPushNotification  ( ) . getDeliveryInvalidationTime  ( ) ) ) ; } else  {   out . writeInt  ( EXPIRE_IMMEDIATELY ) ; }   out . writeShort  (    sendablePushNotification . getPushNotification  ( ) . getToken  ( ) . length ) ;   out . writeBytes  (   sendablePushNotification . getPushNotification  ( ) . getToken  ( ) ) ;   final   byte  [ ]  payloadBytes =    sendablePushNotification . getPushNotification  ( ) . getPayload  ( ) . getBytes  ( utf8 ) ;   out . writeShort  (  payloadBytes . length ) ;   out . writeBytes  ( payloadBytes ) ; }   private  int getTimestampInSeconds  (   final Date date )  {  return  (  int )  (   date . getTime  ( ) / 1000 ) ; } }   private class ApnsConnectionHandler  extends  SimpleChannelInboundHandler  < RejectedNotification >  {   private final  ApnsConnection  < T >  apnsConnection ;   public ApnsConnectionHandler  (   final  ApnsConnection  < T > clientThread )  {    this . apnsConnection = clientThread ; }    @ Override public void channelRegistered  (   final ChannelHandlerContext context )  throws Exception  {   super . channelRegistered  ( context ) ;  synchronized  (   this . apnsConnection . connectFuture )  {  if  (   this . apnsConnection . closeOnRegistration )  {   log . debug  ( "Channel registered for {}, but shutting down immediately." ,   this . apnsConnection . name ) ;     context . channel  ( ) . eventLoop  ( ) . execute  (   this . apnsConnection . getImmediateShutdownRunnable  ( ) ) ; } } }    @ Override protected void channelRead0  (   final ChannelHandlerContext context ,   final RejectedNotification rejectedNotification )  {   log . debug  ( "APNs gateway rejected notification with sequence number {} from {} ({})." ,  rejectedNotification . getSequenceNumber  ( ) ,   this . apnsConnection . name ,  rejectedNotification . getReason  ( ) ) ;     this . apnsConnection . rejectionReceived = true ;     this . apnsConnection . sentNotificationBuffer . clearNotificationsBeforeSequenceNumber  (  rejectedNotification . getSequenceNumber  ( ) ) ;   final boolean  isKnownBadRejection =     this . apnsConnection . shutdownNotification != null &&   rejectedNotification . getSequenceNumber  ( ) ==    this . apnsConnection . shutdownNotification . getSequenceNumber  ( ) ;  if  (   ! isKnownBadRejection &&  !   RejectedNotificationReason . SHUTDOWN . equals  (  rejectedNotification . getReason  ( ) ) )  {   final T  notification =    this . apnsConnection . sentNotificationBuffer . getNotificationWithSequenceNumber  (  rejectedNotification . getSequenceNumber  ( ) ) ;  if  (  notification != null )  {     this . apnsConnection . listener . handleRejectedNotification  (  this . apnsConnection , notification ,  rejectedNotification . getReason  ( ) ) ; } else  {   log . error  (  "{} failed to find rejected notification with sequence number {}; this may mean the " + "sent notification buffer is too small. Please report this as a bug." ,   this . apnsConnection . name ,  rejectedNotification . getSequenceNumber  ( ) ) ; } }   final  Collection  < T >  unprocessedNotifications =    this . apnsConnection . sentNotificationBuffer . getAllNotificationsAfterSequenceNumber  (  rejectedNotification . getSequenceNumber  ( ) ) ;  if  (  !  unprocessedNotifications . isEmpty  ( ) )  {     this . apnsConnection . listener . handleUnprocessedNotifications  (  this . apnsConnection , unprocessedNotifications ) ; }     this . apnsConnection . sentNotificationBuffer . clearAllNotifications  ( ) ; }    @ Override public void exceptionCaught  (   final ChannelHandlerContext context ,   final Throwable cause )  {   log . debug  ( "{} caught an exception." ,   this . apnsConnection . name , cause ) ; }    @ Override public void channelInactive  (   final ChannelHandlerContext context )  throws Exception  {   super . channelInactive  ( context ) ;  if  (   this . apnsConnection . handshakeCompleted )  {     this . apnsConnection . listener . handleConnectionClosure  (  this . apnsConnection ) ; } }    @ Override public void channelWritabilityChanged  (   final ChannelHandlerContext context )  throws Exception  {   super . channelWritabilityChanged  ( context ) ;     this . apnsConnection . listener . handleConnectionWritabilityChange  (  this . apnsConnection ,   context . channel  ( ) . isWritable  ( ) ) ; } }   public ApnsConnection  (   final ApnsEnvironment environment ,   final SSLContext sslContext ,   final NioEventLoopGroup eventLoopGroup ,   final  ApnsConnectionListener  < T > listener )  {  if  (  listener == null )  {  throw  new NullPointerException  ( "Listener must not be null." ) ; }    this . environment = environment ;    this . sslContext = sslContext ;    this . eventLoopGroup = eventLoopGroup ;    this . listener = listener ;    this . name =  String . format  ( "ApnsConnection-%d" ,   ApnsConnection . connectionCounter . getAndIncrement  ( ) ) ; }    @ SuppressWarnings  ( "deprecation" ) public synchronized void connect  ( )  {   final  ApnsConnection  < T >  apnsConnection = this ;  if  (   this . connectFuture != null )  {  throw  new IllegalStateException  (  String . format  ( "%s already started a connection attempt." ,  this . name ) ) ; }   final Bootstrap  bootstrap =  new Bootstrap  ( ) ;   bootstrap . group  (  this . eventLoopGroup ) ;   bootstrap . channel  (  NioSocketChannel . class ) ;   bootstrap . option  (  ChannelOption . SO_KEEPALIVE , true ) ;   bootstrap . option  (  ChannelOption . ALLOCATOR ,  PooledByteBufAllocator . DEFAULT ) ;   bootstrap . option  (  ChannelOption . AUTO_CLOSE , false ) ;   bootstrap . handler  (  new  ChannelInitializer  < SocketChannel >  ( )  {    @ Override protected void initChannel  (   final SocketChannel channel )  {   final ChannelPipeline  pipeline =  channel . pipeline  ( ) ;   final SSLEngine  sslEngine =   apnsConnection . sslContext . createSSLEngine  ( ) ;   sslEngine . setUseClientMode  ( true ) ;   pipeline . addLast  ( "ssl" ,  new SslHandler  ( sslEngine ) ) ;   pipeline . addLast  ( "decoder" ,  new RejectedNotificationDecoder  ( ) ) ;   pipeline . addLast  ( "encoder" ,  new ApnsPushNotificationEncoder  ( ) ) ;   pipeline . addLast  ( "handler" ,  new ApnsConnectionHandler  ( apnsConnection ) ) ; } } ) ;   log . debug  ( "{} beginning connection process." ,  apnsConnection . name ) ;    this . connectFuture =  bootstrap . connect  (   this . environment . getApnsGatewayHost  ( ) ,   this . environment . getApnsGatewayPort  ( ) ) ;    this . connectFuture . addListener  (  new  GenericFutureListener  < ChannelFuture >  ( )  {   public void operationComplete  (   final ChannelFuture connectFuture )  {  if  (  connectFuture . isSuccess  ( ) )  {   log . debug  ( "{} connected; waiting for TLS handshake." ,  apnsConnection . name ) ;   final SslHandler  sslHandler =    connectFuture . channel  ( ) . pipeline  ( ) . get  (  SslHandler . class ) ;  try  {    sslHandler . handshakeFuture  ( ) . addListener  (  new  GenericFutureListener  <  Future  < Channel > >  ( )  {   public void operationComplete  (   final  Future  < Channel > handshakeFuture )  {  if  (  handshakeFuture . isSuccess  ( ) )  {   log . debug  ( "{} successfully completed TLS handshake." ,  apnsConnection . name ) ;    apnsConnection . handshakeCompleted = true ;    apnsConnection . listener . handleConnectionSuccess  ( apnsConnection ) ; } else  {   log . debug  ( "{} failed to complete TLS handshake with APNs gateway." ,  apnsConnection . name ,  handshakeFuture . cause  ( ) ) ;    connectFuture . channel  ( ) . close  ( ) ;    apnsConnection . listener . handleConnectionFailure  ( apnsConnection ,  handshakeFuture . cause  ( ) ) ; } } } ) ; }  catch (   NullPointerException e )  {   log . warn  ( "{} failed to get SSL handler and could not wait for a TLS handshake." ,  apnsConnection . name ) ;    connectFuture . channel  ( ) . close  ( ) ;    apnsConnection . listener . handleConnectionFailure  ( apnsConnection , e ) ; } } else  {   log . debug  ( "{} failed to connect to APNs gateway." ,  apnsConnection . name ,  connectFuture . cause  ( ) ) ;    apnsConnection . listener . handleConnectionFailure  ( apnsConnection ,  connectFuture . cause  ( ) ) ; } } } ) ; }   public synchronized void sendNotification  (   final T notification )  {   final  ApnsConnection  < T >  apnsConnection = this ;  if  (  !  this . handshakeCompleted )  {  throw  new IllegalStateException  (  String . format  ( "%s has not completed handshake." ,  this . name ) ) ; }      this . connectFuture . channel  ( ) . eventLoop  ( ) . execute  (  new Runnable  ( )  {   public void run  ( )  {   final  SendableApnsPushNotification  < T >  sendableNotification =  new  SendableApnsPushNotification  < T >  ( notification ,   apnsConnection . sequenceNumber ++ ) ;   log . trace  ( "{} sending {}" ,  apnsConnection . name , sendableNotification ) ;    apnsConnection . pendingWriteCount += 1 ;      apnsConnection . connectFuture . channel  ( ) . writeAndFlush  ( sendableNotification ) . addListener  (  new  GenericFutureListener  < ChannelFuture >  ( )  {   public void operationComplete  (   final ChannelFuture writeFuture )  {  if  (  writeFuture . isSuccess  ( ) )  {   log . trace  ( "{} successfully wrote notification {}" ,  apnsConnection . name ,  sendableNotification . getSequenceNumber  ( ) ) ;  if  (  apnsConnection . rejectionReceived )  {    apnsConnection . listener . handleUnprocessedNotifications  ( apnsConnection ,    java . util . Collections . singletonList  ( notification ) ) ; } else  {    apnsConnection . sentNotificationBuffer . addSentNotification  ( sendableNotification ) ; } } else  {   log . trace  ( "{} failed to write notification {}" ,  apnsConnection . name , sendableNotification ,  writeFuture . cause  ( ) ) ;    apnsConnection . listener . handleWriteFailure  ( apnsConnection , notification ,  writeFuture . cause  ( ) ) ; }    apnsConnection . pendingWriteCount -= 1 ;  assert   apnsConnection . pendingWriteCount >= 0 ;  if  (   apnsConnection . pendingWriteCount == 0 )  {  synchronized  (  apnsConnection . pendingWriteMonitor )  {    apnsConnection . pendingWriteMonitor . notifyAll  ( ) ; } } } } ) ; } } ) ; }   public protected void waitForPendingWritesToFinish  ( )  throws InterruptedException  {  synchronized  (  this . pendingWriteMonitor )  {  while  (   this . pendingWriteCount > 0 )  {    this . pendingWriteMonitor . wait  ( ) ; } } }   public synchronized void shutdownGracefully  ( )  {   final  ApnsConnection  < T >  apnsConnection = this ;  if  (   this . handshakeCompleted &&    this . connectFuture . channel  ( ) . isActive  ( ) )  {      this . connectFuture . channel  ( ) . eventLoop  ( ) . execute  (  new Runnable  ( )  {   public void run  ( )  {  if  (   apnsConnection . shutdownNotification == null )  {   log . debug  ( "{} sending known-bad notification to shut down." ,  apnsConnection . name ) ;    apnsConnection . shutdownNotification =  new  SendableApnsPushNotification  < KnownBadPushNotification >  (  new KnownBadPushNotification  ( ) ,   apnsConnection . sequenceNumber ++ ) ;    apnsConnection . pendingWriteCount += 1 ;      apnsConnection . connectFuture . channel  ( ) . writeAndFlush  (  apnsConnection . shutdownNotification ) . addListener  (  new  GenericFutureListener  < ChannelFuture >  ( )  {   public void operationComplete  (   final ChannelFuture future )  {  if  (  future . isSuccess  ( ) )  {   log . trace  ( "{} successfully wrote known-bad notification {}" ,  apnsConnection . name ,   apnsConnection . shutdownNotification . getSequenceNumber  ( ) ) ; } else  {   log . trace  ( "{} failed to write known-bad notification {}" ,  apnsConnection . name ,  apnsConnection . shutdownNotification ,  future . cause  ( ) ) ;    apnsConnection . shutdownNotification = null ;   apnsConnection . shutdownGracefully  ( ) ; }    apnsConnection . pendingWriteCount -= 1 ;  assert   apnsConnection . pendingWriteCount >= 0 ;  if  (   apnsConnection . pendingWriteCount == 0 )  {  synchronized  (  apnsConnection . pendingWriteMonitor )  {    apnsConnection . pendingWriteMonitor . notifyAll  ( ) ; } } } } ) ; } } } ) ; } else  {   this . shutdownImmediately  ( ) ; } }   public synchronized void shutdownImmediately  ( )  {  if  (   this . connectFuture != null )  {  synchronized  (  this . connectFuture )  {  if  (    this . connectFuture . channel  ( ) . isRegistered  ( ) )  {      this . connectFuture . channel  ( ) . eventLoop  ( ) . execute  (  this . getImmediateShutdownRunnable  ( ) ) ; } else  {    this . closeOnRegistration = true ; } } } }   private Runnable getImmediateShutdownRunnable  ( )  {   final  ApnsConnection  < T >  apnsConnection = this ;  return  new Runnable  ( )  {   public void run  ( )  {   final SslHandler  sslHandler =     apnsConnection . connectFuture . channel  ( ) . pipeline  ( ) . get  (  SslHandler . class ) ;  if  (   apnsConnection . connectFuture . isCancellable  ( ) )  {    apnsConnection . connectFuture . cancel  ( true ) ; } else  if  (   sslHandler != null &&   sslHandler . handshakeFuture  ( ) . isCancellable  ( ) )  {    sslHandler . handshakeFuture  ( ) . cancel  ( true ) ; } else  {     apnsConnection . connectFuture . channel  ( ) . close  ( ) ; } } } ; }    @ Override public String toString  ( )  {  return   "ApnsConnection [name=" + name + "]" ; } }