  package    com . softinstigate . restheart . db ;   import   com . mongodb . BasicDBObject ;  import   com . mongodb . DB ;  import   com . mongodb . DBCollection ;  import   com . mongodb . DBCursor ;  import   com . mongodb . DBObject ;  import   com . mongodb . MongoClient ;  import    com . mongodb . util . JSON ;  import    com . mongodb . util . JSONParseException ;  import     com . softinstigate . restheart . utils . HttpStatus ;  import   java . time . Instant ;  import   java . util . ArrayList ;  import   java . util . Deque ;  import   org . bson . BSONObject ;  import    org . bson . types . ObjectId ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;   public class CollectionDAO  {   private static final BasicDBObject  PROPS_QUERY =  new BasicDBObject  ( "_id" , "_properties" ) ;   private static final BasicDBObject  DOCUMENTS_QUERY =  new BasicDBObject  ( "_id" ,  new BasicDBObject  ( "$ne" , "_properties" ) ) ;   private static final BasicDBObject  fieldsToReturn ;  static  {   fieldsToReturn =  new BasicDBObject  ( ) ;   fieldsToReturn . put  ( "_id" , 1 ) ;   fieldsToReturn . put  ( "_created_on" , 1 ) ; }   private static final BasicDBObject  fieldsToReturnIndexes ;  static  {   fieldsToReturnIndexes =  new BasicDBObject  ( ) ;   fieldsToReturnIndexes . put  ( "key" , 1 ) ;   fieldsToReturnIndexes . put  ( "name" , 1 ) ; }   public static boolean doesCollectionExist  (  String dbName ,  String collName )  {  if  (    dbName == null ||  dbName . isEmpty  ( ) ||  dbName . contains  ( " " ) )  {  return false ; }  BasicDBObject  query =  new BasicDBObject  ( "name" ,   dbName + "." + collName ) ;  return     CLIENT . getDB  ( dbName ) . getCollection  ( "system.namespaces" ) . findOne  ( query ) != null ; }   public static DBCollection getCollection  (  String dbName ,  String collName )  {  return   CLIENT . getDB  ( dbName ) . getCollection  ( collName ) ; }   public static boolean isCollectionEmpty  (  DBCollection coll )  {  return   coll . count  ( DOCUMENTS_QUERY ) == 0 ; }   public static  long getCollectionSize  (  DBCollection coll ,   Deque  < String > filters )  {   final BasicDBObject  query =  new BasicDBObject  ( DOCUMENTS_QUERY ) ;  if  (  filters != null )  {  try  {    filters . stream  ( ) . forEach  (  f ->  {   query . putAll  (  ( BSONObject )  JSON . parse  ( f ) ) ; } ) ; }  catch (   JSONParseException jpe )  {   LOGGER . warn  ( "****** error parsing filter expression {}" , filters , jpe ) ; } }  return  coll . count  ( query ) ; }   public static DBObject getCollectionProps  (  String dbName ,  String collName )  {  DBCollection  coll =  CollectionDAO . getCollection  ( dbName , collName ) ;  DBObject  properties =  coll . findOne  ( PROPS_QUERY ) ;  if  (  properties != null )  {   properties . put  ( "_id" , collName ) ;  Object  etag =  properties . get  ( "_etag" ) ;  if  (   etag != null &&  ObjectId . isValid  (  "" + etag ) )  {  ObjectId  oid =  new ObjectId  (  "" + etag ) ;   properties . put  ( "_lastupdated_on" ,   Instant . ofEpochSecond  (  oid . getTimestamp  ( ) ) . toString  ( ) ) ; } }  return properties ; }   public static  int upsertCollection  (  String dbName ,  String collName ,  DBObject content ,  ObjectId etag ,  boolean updating ,  boolean patching )  {  DB  db =  DBDAO . getDB  ( dbName ) ;  DBCollection  coll =  db . getCollection  ( collName ) ;  if  (  patching &&  ! updating )  {  return  HttpStatus . SC_NOT_FOUND ; }  if  ( updating )  {  if  (  etag == null )  {  return  HttpStatus . SC_CONFLICT ; }  BasicDBObject  idAndEtagQuery =  new BasicDBObject  ( "_id" , "_properties" ) ;   idAndEtagQuery . append  ( "_etag" , etag ) ;  if  (   coll . count  ( idAndEtagQuery ) < 1 )  {  return  HttpStatus . SC_PRECONDITION_FAILED ; } }  ObjectId  timestamp =  new ObjectId  ( ) ;  Instant  now =  Instant . ofEpochSecond  (  timestamp . getTimestamp  ( ) ) ;  if  (  content == null )  {   content =  new BasicDBObject  ( ) ; }   content . removeField  ( "_id" ) ;  if  ( updating )  {   content . removeField  ( "_crated_on" ) ;   content . put  ( "_etag" , timestamp ) ; } else  {   content . put  ( "_id" , "_properties" ) ;   content . put  ( "_created_on" ,  now . toString  ( ) ) ;   content . put  ( "_etag" , timestamp ) ; }  if  ( patching )  {   coll . update  ( PROPS_QUERY ,  new BasicDBObject  ( "$set" , content ) , true , false ) ;  return  HttpStatus . SC_OK ; } else  {  DBObject  old =  coll . findAndModify  ( PROPS_QUERY , fieldsToReturn , null , false , content , false , true ) ;  if  (  old != null )  {  Object  oldTimestamp =  old . get  ( "_created_on" ) ;  if  (  oldTimestamp == null )  {   oldTimestamp =  now . toString  ( ) ;   LOGGER . warn  ( "properties of collection {} had no @created_on field. set to now" ,  coll . getFullName  ( ) ) ; }  BasicDBObject  createdContet =  new BasicDBObject  ( "_created_on" ,  "" + oldTimestamp ) ;   createdContet . markAsPartialObject  ( ) ;   coll . update  ( PROPS_QUERY ,  new BasicDBObject  ( "$set" , createdContet ) , true , false ) ;  return  HttpStatus . SC_OK ; } else  {  BasicDBObject  createdContet =  new BasicDBObject  ( "_created_on" ,  now . toString  ( ) ) ;   createdContet . markAsPartialObject  ( ) ;   coll . update  ( PROPS_QUERY ,  new BasicDBObject  ( "$set" , createdContet ) , true , false ) ;   initDefaultIndexes  ( coll ) ;  return  HttpStatus . SC_CREATED ; } } }   public static  int deleteCollection  (  String dbName ,  String collName ,  ObjectId etag )  {  DBCollection  coll =  getCollection  ( dbName , collName ) ;  BasicDBObject  checkEtag =  new BasicDBObject  ( "_id" , "_properties" ) ;   checkEtag . append  ( "_etag" , etag ) ;  DBObject  exists =  coll . findOne  ( checkEtag , fieldsToReturn ) ;  if  (  exists == null )  {  return  HttpStatus . SC_PRECONDITION_FAILED ; } else  {   coll . drop  ( ) ;  return  HttpStatus . SC_NO_CONTENT ; } }   private static void initDefaultIndexes  (  DBCollection coll )  {   coll . createIndex  (   new BasicDBObject  ( "_id" , 1 ) . append  ( "_etag" , 1 ) ,  new BasicDBObject  ( "name" , "_id_etag_idx" ) ) ;   coll . createIndex  (  new BasicDBObject  ( "_etag" , 1 ) ,  new BasicDBObject  ( "name" , "_etag_idx" ) ) ;   coll . createIndex  (  new BasicDBObject  ( "_created_on" , 1 ) ,  new BasicDBObject  ( "name" , "_created_on_idx" ) ) ; }   private static void replaceObjectIds  (  BSONObject source )  {  if  (  source == null )  {  return ; }     source . keySet  ( ) . stream  ( ) . forEach  (   ( key ) ->  {  Object  o =  source . get  ( key ) ;  if  (  o instanceof BSONObject )  {   replaceObjectIds  (  ( BSONObject ) o ) ; } else  if  (  ObjectId . isValid  (  o . toString  ( ) ) )  {   source . put  ( key ,  new ObjectId  (  o . toString  ( ) ) ) ; } } ) ; }   private static final MongoClient  CLIENT =   MongoDBClientSingleton . getInstance  ( ) . getClient  ( ) ;   private static final Logger  LOGGER =  LoggerFactory . getLogger  (  CollectionDAO . class ) ;   protected static DBCursor getCollectionDBCursor  (  DBCollection coll ,   Deque  < String > sortBy ,   Deque  < String > filters )  throws JSONParseException  {  DBObject  sort =  new BasicDBObject  ( ) ;  if  (   sortBy == null ||  sortBy . isEmpty  ( ) )  {   sort . put  ( "_created_on" ,  - 1 ) ; } else  {    sortBy . stream  ( ) . forEach  (   ( s ) ->  {  String  _s =  s . trim  ( ) ;   _s =  _s . replaceAll  ( "_lastupdated_on" , "_etag" ) ;  if  (  _s . startsWith  ( "-" ) )  {   sort . put  (  _s . substring  ( 1 ) ,  - 1 ) ; } else  if  (  _s . startsWith  ( "+" ) )  {   sort . put  (  _s . substring  ( 1 ) , 1 ) ; } else  {   sort . put  ( _s , 1 ) ; } } ) ; }   final BasicDBObject  query =  new BasicDBObject  ( DOCUMENTS_QUERY ) ;  if  (  filters != null )  {    filters . stream  ( ) . forEach  (   (  String f ) ->  {  BSONObject  filterQuery =  ( BSONObject )  JSON . parse  ( f ) ;   replaceObjectIds  ( filterQuery ) ;   query . putAll  ( filterQuery ) ; } ) ; }  return   coll . find  ( query ) . sort  ( sort ) ; }   public static  ArrayList  < DBObject > getCollectionData  (  DBCollection coll ,   int page ,   int pagesize ,   Deque  < String > sortBy ,   Deque  < String > filters ,   DBCursorPool . EAGER_CURSOR_ALLOCATION_POLICY eager )  throws JSONParseException  {   ArrayList  < DBObject >  ret =  new  ArrayList  < >  ( ) ;   int  toskip =  pagesize *  (  page - 1 ) ;  DBCursor  cursor ;  SkippedDBCursor  _cursor = null ;  if  (  eager !=   DBCursorPool . EAGER_CURSOR_ALLOCATION_POLICY . NONE )  {   _cursor =   DBCursorPool . getInstance  ( ) . get  (  new DBCursorPoolEntryKey  ( coll , sortBy , filters , toskip , 0 ) , eager ) ; }   int  alreadySkipped ;  if  (  _cursor == null )  {   cursor =  getCollectionDBCursor  ( coll , sortBy , filters ) ;   alreadySkipped = 0 ; } else  {   cursor =  _cursor . getCursor  ( ) ;   alreadySkipped =  _cursor . getAlreadySkipped  ( ) ; }  if  (   toskip - alreadySkipped > 0 )  {   cursor . skip  (  toskip - alreadySkipped ) ; }  while  (   pagesize > 0 &&  cursor . hasNext  ( ) )  {   ret . add  (  cursor . next  ( ) ) ;   pagesize -- ; }   ret . forEach  (  row ->  {  Object  etag =  row . get  ( "_etag" ) ;  if  (   etag != null &&  ObjectId . isValid  (  "" + etag ) )  {  ObjectId  _etag =  new ObjectId  (  "" + etag ) ;   row . put  ( "_lastupdated_on" ,   Instant . ofEpochSecond  (  _etag . getTimestamp  ( ) ) . toString  ( ) ) ; } } ) ;  return ret ; } }