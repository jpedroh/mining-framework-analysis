  package    com . sun . syndication . io ;   import   java . io . ByteArrayInputStream ;  import   java . io . File ;  import   java . io . FileNotFoundException ;  import   java . io . FileReader ;  import   java . io . IOException ;  import   java . io . Reader ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . WeakHashMap ;  import   org . jdom2 . Document ;  import   org . jdom2 . JDOMException ;  import    org . jdom2 . input . DOMBuilder ;  import    org . jdom2 . input . JDOMParseException ;  import     org . jdom2 . input . sax . XMLReaders ;  import    org . xml . sax . EntityResolver ;  import    org . xml . sax . InputSource ;  import    org . xml . sax . SAXNotRecognizedException ;  import    org . xml . sax . SAXNotSupportedException ;  import    org . xml . sax . XMLReader ;  import     com . sun . syndication . feed . WireFeed ;  import      com . sun . syndication . io . impl . FeedParsers ;  import      com . sun . syndication . io . impl . XmlFixerReader ;   public class WireFeedInput  {   private static  Map  < ClassLoader , FeedParsers >  clMap =  new  WeakHashMap  < ClassLoader , FeedParsers >  ( ) ;   private static FeedParsers getFeedParsers  ( )  {  synchronized  (  WireFeedInput . class )  {  FeedParsers  parsers =  clMap . get  (   Thread . currentThread  ( ) . getContextClassLoader  ( ) ) ;  if  (  parsers == null )  {   parsers =  new FeedParsers  ( ) ;   clMap . put  (   Thread . currentThread  ( ) . getContextClassLoader  ( ) , parsers ) ; }  return parsers ; } }   private static final InputSource  EMPTY_INPUTSOURCE =  new InputSource  (  new ByteArrayInputStream  (  new  byte  [ 0 ] ) ) ;   private static final EntityResolver  RESOLVER =  new EmptyEntityResolver  ( ) ;   private static class EmptyEntityResolver  implements  EntityResolver  {    @ Override public InputSource resolveEntity  (   final String publicId ,   final String systemId )  {  if  (   systemId != null &&  systemId . endsWith  ( ".dtd" ) )  {  return EMPTY_INPUTSOURCE ; }  return null ; } }   private final boolean  validate ;   private boolean  xmlHealerOn ;   public static  List  < String > getSupportedFeedTypes  ( )  {  return   getFeedParsers  ( ) . getSupportedFeedTypes  ( ) ; }   public WireFeedInput  ( )  {  this  ( false ) ; }   public WireFeedInput  (   final boolean validate )  {    this . validate = false ;   xmlHealerOn = true ; }   public void setXmlHealerOn  (   final boolean heals )  {   xmlHealerOn = heals ; }   public boolean getXmlHealerOn  ( )  {  return xmlHealerOn ; }   public WireFeed build  (   final File file )  throws FileNotFoundException , IOException , IllegalArgumentException , FeedException  {  WireFeed  feed ;  Reader  reader =  new FileReader  ( file ) ;  if  ( xmlHealerOn )  {   reader =  new XmlFixerReader  ( reader ) ; }   feed =  this . build  ( reader ) ;   reader . close  ( ) ;  return feed ; }   public WireFeed build  (  Reader reader )  throws IllegalArgumentException , FeedException  {   final SAXBuilder  saxBuilder =  createSAXBuilder  ( ) ;  try  {  if  ( xmlHealerOn )  {   reader =  new XmlFixerReader  ( reader ) ; }   final Document  document =  saxBuilder . build  ( reader ) ;  return  this . build  ( document ) ; }  catch (   final  JDOMParseException ex )  {  throw  new ParsingFeedException  (  "Invalid XML: " +  ex . getMessage  ( ) , ex ) ; }  catch (   final  IllegalArgumentException ex )  {  throw ex ; }  catch (   final  Exception ex )  {  throw  new ParsingFeedException  ( "Invalid XML" , ex ) ; } }   public WireFeed build  (   final InputSource is )  throws IllegalArgumentException , FeedException  {   final SAXBuilder  saxBuilder =  createSAXBuilder  ( ) ;  try  {   final Document  document =  saxBuilder . build  ( is ) ;  return  this . build  ( document ) ; }  catch (   final  JDOMParseException ex )  {  throw  new ParsingFeedException  (  "Invalid XML: " +  ex . getMessage  ( ) , ex ) ; }  catch (   final  IllegalArgumentException ex )  {  throw ex ; }  catch (   final  Exception ex )  {  throw  new ParsingFeedException  ( "Invalid XML" , ex ) ; } }   public WireFeed build  (   final    org . w3c . dom . Document document )  throws IllegalArgumentException , FeedException  {   final DOMBuilder  domBuilder =  new DOMBuilder  ( ) ;  try  {   final Document  jdomDoc =  domBuilder . build  ( document ) ;  return  this . build  ( jdomDoc ) ; }  catch (   final  IllegalArgumentException ex )  {  throw ex ; }  catch (   final  Exception ex )  {  throw  new ParsingFeedException  ( "Invalid XML" , ex ) ; } }   public WireFeed build  (   final Document document )  throws IllegalArgumentException , FeedException  {   final WireFeedParser  parser =   getFeedParsers  ( ) . getParserFor  ( document ) ;  if  (  parser == null )  {  throw  new IllegalArgumentException  ( "Invalid document" ) ; }  return  parser . parse  ( document , validate ) ; }   protected SAXBuilder createSAXBuilder  ( )  {  SAXBuilder  saxBuilder =  new SAXBuilder  (  validate ?  XMLReaders . DTDVALIDATING :  XMLReaders . NONVALIDATING ) ;  if  ( validate )  {   saxBuilder =  new SAXBuilder  (  XMLReaders . DTDVALIDATING ) ; } else  {   saxBuilder =  new SAXBuilder  (  XMLReaders . NONVALIDATING ) ; }   saxBuilder . setEntityResolver  ( RESOLVER ) ;  try  {   final XMLReader  parser =  saxBuilder . createParser  ( ) ;  try  {   parser . setFeature  ( "http://xml.org/sax/features/external-general-entities" , false ) ;   saxBuilder . setFeature  ( "http://xml.org/sax/features/external-general-entities" , false ) ; }  catch (   final  SAXNotRecognizedException e )  { }  catch (   final  SAXNotSupportedException e )  { }  try  {   parser . setFeature  ( "http://xml.org/sax/features/external-parameter-entities" , false ) ;   saxBuilder . setFeature  ( "http://xml.org/sax/features/external-parameter-entities" , false ) ; }  catch (   final  SAXNotRecognizedException e )  { }  catch (   final  SAXNotSupportedException e )  { }  try  {   parser . setFeature  ( "http://apache.org/xml/features/nonvalidating/load-external-dtd" , false ) ;   saxBuilder . setFeature  ( "http://apache.org/xml/features/nonvalidating/load-external-dtd" , false ) ; }  catch (   final  SAXNotRecognizedException e )  { }  catch (   final  SAXNotSupportedException e )  { } }  catch (   final  JDOMException e )  {  throw  new IllegalStateException  ( "JDOM could not create a SAX parser" ) ; }   saxBuilder . setExpandEntities  ( false ) ;  return saxBuilder ; } }