  package     com . sun . syndication . io . impl ;   import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . HashMap ;  import   java . util . Iterator ;  import   java . util . List ;  import   java . util . Map ;  import     com . sun . syndication . io . DelegatingModuleGenerator ;  import     com . sun . syndication . io . DelegatingModuleParser ;  import     com . sun . syndication . io . WireFeedGenerator ;  import     com . sun . syndication . io . WireFeedParser ;   public abstract class PluginManager  <  T >  {   private final  String  [ ]  propertyValues ;   private  Map  < String , T >  pluginsMap ;   private  List  < T >  pluginsList ;   private final  List  < String >  keys ;   private final WireFeedParser  parentParser ;   private final WireFeedGenerator  parentGenerator ;   protected PluginManager  (   final String propertyKey )  {  this  ( propertyKey , null , null ) ; }   protected PluginManager  (   final String propertyKey ,   final WireFeedParser parentParser ,   final WireFeedGenerator parentGenerator )  {    this . parentParser = parentParser ;    this . parentGenerator = parentGenerator ;   propertyValues =   PropertiesLoader . getPropertiesLoader  ( ) . getTokenizedProperty  ( propertyKey , ", " ) ;   loadPlugins  ( ) ;   pluginsMap =  Collections . unmodifiableMap  ( pluginsMap ) ;   pluginsList =  Collections . unmodifiableList  ( pluginsList ) ;   keys =  Collections . unmodifiableList  (  new  ArrayList  < String >  (  pluginsMap . keySet  ( ) ) ) ; }   protected abstract String getKey  (  T obj ) ;   protected  List  < String > getKeys  ( )  {  return keys ; }   protected  List  < T > getPlugins  ( )  {  return pluginsList ; }   protected  Map  < String , T > getPluginMap  ( )  {  return pluginsMap ; }   protected T getPlugin  (   final String key )  {  return  pluginsMap . get  ( key ) ; }   private void loadPlugins  ( )  {   final  List  < T >  finalPluginsList =  new  ArrayList  < T >  ( ) ;   pluginsList =  new  ArrayList  < T >  ( ) ;   pluginsMap =  new  HashMap  < String , T >  ( ) ;  String  className = null ;  try  {   final   Class  < T >  [ ]  classes =  getClasses  ( ) ;  for (  final  Class  < T > classe : classes )  {   className =  classe . getName  ( ) ;   final T  plugin =  classe . newInstance  ( ) ;  if  (  plugin instanceof DelegatingModuleParser )  {    (  ( DelegatingModuleParser ) plugin ) . setFeedParser  ( parentParser ) ; }  if  (  plugin instanceof DelegatingModuleGenerator )  {    (  ( DelegatingModuleGenerator ) plugin ) . setFeedGenerator  ( parentGenerator ) ; }   pluginsMap . put  (  getKey  ( plugin ) , plugin ) ;   pluginsList . add  ( plugin ) ; }   Iterator  < T >  i =   pluginsMap . values  ( ) . iterator  ( ) ;  while  (  i . hasNext  ( ) )  {   finalPluginsList . add  (  i . next  ( ) ) ; }   i =  pluginsList . iterator  ( ) ;  while  (  i . hasNext  ( ) )  {   final Object  plugin =  i . next  ( ) ;  if  (  !  finalPluginsList . contains  ( plugin ) )  {   i . remove  ( ) ; } } }  catch (   final  Exception ex )  {  throw  new RuntimeException  (  "could not instantiate plugin " + className , ex ) ; }  catch (   final  ExceptionInInitializerError er )  {  throw  new RuntimeException  (  "could not instantiate plugin " + className , er ) ; } }   private   Class  < T >  [ ] getClasses  ( )  throws ClassNotFoundException  {   final ClassLoader  classLoader =   Thread . currentThread  ( ) . getContextClassLoader  ( ) ;   final  List  <  Class  < T > >  classes =  new  ArrayList  <  Class  < T > >  ( ) ;   final boolean  useLoadClass =   Boolean . valueOf  (  System . getProperty  ( "rome.pluginmanager.useloadclass" , "false" ) ) . booleanValue  ( ) ;  for (  final String propertyValue : propertyValues )  {    @ SuppressWarnings  ( "unchecked" ) final  Class  < T >  mClass =  (  Class  < T > )  (  useLoadClass ?  classLoader . loadClass  ( _propertyValue ) :  Class . forName  ( _propertyValue , true , classLoader ) ) ;  if  ( useLoadClass )  {   mClass =  classLoader . loadClass  ( propertyValue ) ; } else  {   mClass =  Class . forName  ( propertyValue , true , classLoader ) ; }   classes . add  ( mClass ) ; }    @ SuppressWarnings  ( "unchecked" ) final   Class  < T >  [ ]  array =  (   Class  < T >  [ ] )  new Class  [  classes . size  ( ) ] ;   classes . toArray  ( array ) ;  return array ; } }