  package     com . sun . syndication . feed . impl ;   import   java . beans . PropertyDescriptor ;  import   java . io . Serializable ;  import    java . lang . reflect . Array ;  import    java . lang . reflect . Method ;  import   java . util . Collection ;  import   java . util . Iterator ;  import   java . util . Map ;  import    java . util . Map . Entry ;  import   java . util . Stack ;   public class ToStringBean  implements  Serializable  {   private static final  long  serialVersionUID =  - 5850496718959612854L ;   private static final  ThreadLocal  <  Stack  <  String  [ ] > >  PREFIX_TL =  new  ThreadLocal  <  Stack  <  String  [ ] > >  ( )  {    @ Override public  Stack  <  String  [ ] > get  ( )  {   Stack  <  String  [ ] >  o =  super . get  ( ) ;  if  (  o == null )  {   o =  new  Stack  <  String  [ ] >  ( ) ;   set  ( o ) ; }  return o ; } } ;   private static final  Object  [ ]  NO_PARAMS =  new Object  [ 0 ] ;   private final  Class  <  ? >  beanClass ;   private final Object  obj ;   protected ToStringBean  (   final  Class  <  ? > beanClass )  {    this . beanClass = beanClass ;   obj = this ; }   public ToStringBean  (   final  Class  <  ? > beanClass ,   final Object obj )  {    this . beanClass = beanClass ;    this . obj = obj ; }    @ Override public String toString  ( )  {   final  Stack  <  String  [ ] >  stack = 
<<<<<<<
 PREFIX_TL . get  ( )
=======
 (  Stack  <  String  [ ] > )  PREFIX_TL . get  ( )
>>>>>>>
 ;   final  String  [ ]  tsInfo =  (   stack . isEmpty  ( ) ? null :  stack . peek  ( ) ) ;  if  (  stack . isEmpty  ( ) )  {   tsInfo = null ; } else  {   tsInfo =  stack . peek  ( ) ; }   final String  prefix ;  if  (  tsInfo == null )  {   final String  className =   obj . getClass  ( ) . getName  ( ) ;   prefix =  className . substring  (   className . lastIndexOf  ( "." ) + 1 ) ; } else  {   prefix =  tsInfo [ 0 ] ;    tsInfo [ 1 ] = prefix ; }  return  this . toString  ( prefix ) ; }   private String toString  (   final String prefix )  {   final StringBuffer  sb =  new StringBuffer  ( 128 ) ;  try  {   final  PropertyDescriptor  [ ]  pds =  BeanIntrospector . getPropertyDescriptors  ( beanClass ) ;  if  (  pds != null )  {  for (  final PropertyDescriptor pd : pds )  {   final String  pName =  pd . getName  ( ) ;   final Method  pReadMethod =  pd . getReadMethod  ( ) ;  if  (    pReadMethod != null &&   pReadMethod . getDeclaringClass  ( ) !=  Object . class &&    pReadMethod . getParameterTypes  ( ) . length == 0 )  {   final Object  value =  pReadMethod . invoke  ( obj , NO_PARAMS ) ;   printProperty  ( sb ,   prefix + "." + pName , value ) ; } } } }  catch (   final  Exception ex )  {   sb . append  (     "\n\nEXCEPTION: Could not complete " +  obj . getClass  ( ) + ".toString(): " +  ex . getMessage  ( ) + "\n" ) ; }  return  sb . toString  ( ) ; }   private void printProperty  (   final StringBuffer sb ,   final String prefix ,   final Object value )  {  if  (  value == null )  {    sb . append  ( prefix ) . append  ( "=null\n" ) ; } else  if  (   value . getClass  ( ) . isArray  ( ) )  {   printArrayProperty  ( sb , prefix , value ) ; } else  if  (  value instanceof Map )  {    @ SuppressWarnings  ( "unchecked" ) final  Map  < Object , Object >  map =  (  Map  < Object , Object > ) value ;   final  Iterator  <  Entry  < Object , Object > >  i =   map . entrySet  ( ) . iterator  ( ) ;  if  (  i . hasNext  ( ) )  {  while  (  i . hasNext  ( ) )  {   final   Map . Entry  < Object , Object >  me =  i . next  ( ) ;   final String  ePrefix =    prefix + "[" +  me . getKey  ( ) + "]" ;   final Object  eValue =  me . getValue  ( ) ;   final  String  [ ]  tsInfo =  new String  [ 2 ] ;    tsInfo [ 0 ] = ePrefix ;   final  Stack  <  String  [ ] >  stack =  PREFIX_TL . get  ( ) ;   stack . push  ( tsInfo ) ;   final String  s =   eValue != null ?  eValue . toString  ( ) : "null" ;  if  (  eValue != null )  {   s =  eValue . toString  ( ) ; } else  {   s = "null" ; }   stack . pop  ( ) ;  if  (   tsInfo [ 1 ] == null )  {      sb . append  ( ePrefix ) . append  ( "=" ) . append  ( s ) . append  ( "\n" ) ; } else  {   sb . append  ( s ) ; } } } else  {    sb . append  ( prefix ) . append  ( "=[]\n" ) ; } } else  if  (  value instanceof Collection )  {    @ SuppressWarnings  ( "unchecked" ) final  Collection  < Object >  collection =  (  Collection  < Object > ) value ;   final  Iterator  < Object >  i =  collection . iterator  ( ) ;  if  (  i . hasNext  ( ) )  {   int  c = 0 ;  while  (  i . hasNext  ( ) )  {   final String  cPrefix =    prefix + "[" +  c ++ + "]" ;   final Object  cValue =  i . next  ( ) ;   final  String  [ ]  tsInfo =  new String  [ 2 ] ;    tsInfo [ 0 ] = cPrefix ;   final  Stack  <  String  [ ] >  stack =  PREFIX_TL . get  ( ) ;   stack . push  ( tsInfo ) ;   final String  s =   cValue != null ?  cValue . toString  ( ) : "null" ;  if  (  cValue != null )  {   s =  cValue . toString  ( ) ; } else  {   s = "null" ; }   stack . pop  ( ) ;  if  (   tsInfo [ 1 ] == null )  {      sb . append  ( cPrefix ) . append  ( "=" ) . append  ( s ) . append  ( "\n" ) ; } else  {   sb . append  ( s ) ; } } } else  {    sb . append  ( prefix ) . append  ( "=[]\n" ) ; } } else  {   final  String  [ ]  tsInfo =  new String  [ 2 ] ;    tsInfo [ 0 ] = prefix ;   final  Stack  <  String  [ ] >  stack =  PREFIX_TL . get  ( ) ;   stack . push  ( tsInfo ) ;   final String  s =  value . toString  ( ) ;   stack . pop  ( ) ;  if  (   tsInfo [ 1 ] == null )  {      sb . append  ( prefix ) . append  ( "=" ) . append  ( s ) . append  ( "\n" ) ; } else  {   sb . append  ( s ) ; } } }   private void printArrayProperty  (   final StringBuffer sb ,   final String prefix ,   final Object array )  {   final  int  length =  Array . getLength  ( array ) ;  for (   int  i = 0 ;  i < length ;  i ++ )  {   final Object  obj =  Array . get  ( array , i ) ;   printProperty  ( sb ,    prefix + "[" + i + "]" , obj ) ; } } }