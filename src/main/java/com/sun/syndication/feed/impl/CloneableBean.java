  package     com . sun . syndication . feed . impl ;   import   java . beans . PropertyDescriptor ;  import   java . io . Serializable ;  import    java . lang . reflect . Array ;  import    java . lang . reflect . Method ;  import    java . lang . reflect . Modifier ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . Iterator ;  import   java . util . Map ;  import    java . util . Map . Entry ;  import   java . util . Set ;   public class CloneableBean  implements  Serializable , Cloneable  {   private static final  long  serialVersionUID =  - 6520053043831187823L ;   private static final   Class  <  ? >  [ ]  NO_PARAMS_DEF =  new Class  [ 0 ] ;   private static final  Object  [ ]  NO_PARAMS =  new Object  [ 0 ] ;   private final Object  obj ;   private  Set  < String >  ignoreProperties ;   protected CloneableBean  ( )  {   obj = this ; }   public CloneableBean  (   final Object obj )  {  this  ( obj , null ) ; }   public CloneableBean  (   final Object obj ,   final  Set  < String > ignoreProperties )  {    this . obj = obj ;    this . ignoreProperties =   ignoreProperties != null ? ignoreProperties :  Collections .  < String > emptySet  ( ) ; }    @ Override public Object clone  ( )  throws CloneNotSupportedException  {  return  beanClone  ( ) ; }   public Object beanClone  ( )  throws CloneNotSupportedException  {  Object  clonedBean ;  try  {   clonedBean =   obj . getClass  ( ) . newInstance  ( ) ;   final  PropertyDescriptor  [ ]  pds =  BeanIntrospector . getPropertyDescriptors  (  obj . getClass  ( ) ) ;  if  (  pds != null )  {  for (   int  i = 0 ;  i <  pds . length ;  i ++ )  {   final Method  pReadMethod =   pds [ i ] . getReadMethod  ( ) ;   final Method  pWriteMethod =   pds [ i ] . getWriteMethod  ( ) ;  if  (      pReadMethod != null &&  pWriteMethod != null &&  !  ignoreProperties . contains  (   pds [ i ] . getName  ( ) ) &&   pReadMethod . getDeclaringClass  ( ) !=  Object . class &&    pReadMethod . getParameterTypes  ( ) . length == 0 )  {  Object  value =  pReadMethod . invoke  ( obj , NO_PARAMS ) ;  if  (  value != null )  {   value =  doClone  ( value ) ;   pWriteMethod . invoke  ( clonedBean ,  new Object  [ ]  { value } ) ; } } } } }  catch (   final  CloneNotSupportedException cnsEx )  {  throw cnsEx ; }  catch (   final  Exception ex )  {    System . out . println  ( ex ) ;   ex . printStackTrace  (  System . out ) ;  throw  new CloneNotSupportedException  (   "Cannot clone a " +  obj . getClass  ( ) + " object" ) ; }  return clonedBean ; }    @ SuppressWarnings  ( "unchecked" ) private  <  T  extends Object > T doClone  (  T value )  throws Exception  {  if  (  value != null )  {   final  Class  <  ? >  vClass =  value . getClass  ( ) ;  if  (  vClass . isArray  ( ) )  {   value =  ( T )  cloneArray  (  (  T  [ ] ) value ) ; } else  if  (  value instanceof Collection )  {   value =  ( T )  cloneCollection  (  (  Collection  < Object > ) value ) ; } else  if  (  value instanceof Map )  {   value =  ( T )  cloneMap  (  (  Map  < Object , Object > ) value ) ; } else  if  (  isBasicType  ( vClass ) )  { } else  if  (  value instanceof Cloneable )  {   final Method  cloneMethod =  vClass . getMethod  ( "clone" , NO_PARAMS_DEF ) ;  if  (  Modifier . isPublic  (  cloneMethod . getModifiers  ( ) ) )  {   value =  ( T )  cloneMethod . invoke  ( value , NO_PARAMS ) ; } else  {  throw  new CloneNotSupportedException  (   "Cannot clone a " +  value . getClass  ( ) + " object, clone() is not public" ) ; } } else  {  throw  new CloneNotSupportedException  (   "Cannot clone a " +  vClass . getName  ( ) + " object" ) ; } }  return value ; }   private  <  T >  T  [ ] cloneArray  (   final  T  [ ] array )  throws Exception  {   final  Class  <  ? >  elementClass =   array . getClass  ( ) . getComponentType  ( ) ;   final  int  length =  Array . getLength  ( array ) ;    @ SuppressWarnings  ( "unchecked" ) final  T  [ ]  newArray =  (  T  [ ] )  Array . newInstance  ( elementClass , length ) ;  for (   int  i = 0 ;  i < length ;  i ++ )  {   Array . set  ( newArray , i ,  doClone  (  Array . get  ( array , i ) ) ) ; }  return newArray ; }   private  <  T >  Collection  < T > cloneCollection  (   final  Collection  < T > collection )  throws Exception  {    @ SuppressWarnings  ( "unchecked" ) final  Class  <  Collection  < T > >  mClass =  (  Class  <  Collection  < T > > )  collection . getClass  ( ) ;   final  Collection  < T >  newColl =  (  Collection  < T > )  mClass . newInstance  ( ) ;   final  Iterator  < T >  i =  collection . iterator  ( ) ;  while  (  i . hasNext  ( ) )  {   newColl . add  (  doClone  (  i . next  ( ) ) ) ; }  return newColl ; }   private  <  S ,  T >  Map  < S , T > cloneMap  (   final  Map  < S , T > map )  throws Exception  {    @ SuppressWarnings  ( "unchecked" ) final  Class  <  Map  < S , T > >  mClass =  (  Class  <  Map  < S , T > > )  map . getClass  ( ) ;   final  Map  < S , T >  newMap =  (  Map  < S , T > )  mClass . newInstance  ( ) ;   final  Iterator  <  Entry  < S , T > >  entries =   map . entrySet  ( ) . iterator  ( ) ;  while  (  entries . hasNext  ( ) )  {   final   Map . Entry  < S , T >  entry =  (   Map . Entry  < S , T > )  entries . next  ( ) ;   newMap . put  (  doClone  (  entry . getKey  ( ) ) ,  doClone  (  entry . getValue  ( ) ) ) ; }  return newMap ; }   private static final  Set  <  Class  <  ? > >  BASIC_TYPES =  new  HashSet  <  Class  <  ? > >  ( ) ;  static  {   BASIC_TYPES . add  (  Boolean . class ) ;   BASIC_TYPES . add  (  Byte . class ) ;   BASIC_TYPES . add  (  Character . class ) ;   BASIC_TYPES . add  (  Double . class ) ;   BASIC_TYPES . add  (  Float . class ) ;   BASIC_TYPES . add  (  Integer . class ) ;   BASIC_TYPES . add  (  Long . class ) ;   BASIC_TYPES . add  (  Short . class ) ;   BASIC_TYPES . add  (  String . class ) ; }   private static final  Map  <  Class  <  ? > ,   Class  <  ? >  [ ] >  CONSTRUCTOR_BASIC_TYPES =  new  HashMap  <  Class  <  ? > ,   Class  <  ? >  [ ] >  ( ) ;  static  {   CONSTRUCTOR_BASIC_TYPES . put  (  Boolean . class ,  new Class  [ ]  {  Boolean . TYPE } ) ;   CONSTRUCTOR_BASIC_TYPES . put  (  Byte . class ,  new Class  [ ]  {  Byte . TYPE } ) ;   CONSTRUCTOR_BASIC_TYPES . put  (  Character . class ,  new Class  [ ]  {  Character . TYPE } ) ;   CONSTRUCTOR_BASIC_TYPES . put  (  Double . class ,  new Class  [ ]  {  Double . TYPE } ) ;   CONSTRUCTOR_BASIC_TYPES . put  (  Float . class ,  new Class  [ ]  {  Float . TYPE } ) ;   CONSTRUCTOR_BASIC_TYPES . put  (  Integer . class ,  new Class  [ ]  {  Integer . TYPE } ) ;   CONSTRUCTOR_BASIC_TYPES . put  (  Long . class ,  new Class  [ ]  {  Long . TYPE } ) ;   CONSTRUCTOR_BASIC_TYPES . put  (  Short . class ,  new Class  [ ]  {  Short . TYPE } ) ;   CONSTRUCTOR_BASIC_TYPES . put  (  String . class ,  new Class  [ ]  {  String . class } ) ; }   private boolean isBasicType  (   final  Class  <  ? > vClass )  {  return  BASIC_TYPES . contains  ( vClass ) ; } 
<<<<<<<
=======
  public CloneableBean  (   final Object obj ,   final Set ignoreProperties )  {    this . obj = obj ;  if  (  ignoreProperties == null )  {    this . ignoreProperties =  Collections . emptySet  ( ) ; } else  {    this . ignoreProperties = ignoreProperties ; } }
>>>>>>>
 }