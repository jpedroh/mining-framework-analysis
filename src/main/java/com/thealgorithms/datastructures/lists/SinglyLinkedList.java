  package    com . thealgorithms . datastructures . lists ;   import   java . util . StringJoiner ;   public class SinglyLinkedList  extends Node  {   private Node  head ;   private  int  size ;   public SinglyLinkedList  ( )  {   head = null ;   size = 0 ; }   public SinglyLinkedList  (  Node head ,   int size )  {    this . head = head ;    this . size = size ; }   public boolean detectLoop  ( )  {  Node  currentNodeFast = head ;  Node  currentNodeSlow = head ;  boolean  flag = false ;  while  (     currentNodeFast != null &&   currentNodeFast . next != null &&  currentNodeSlow != null &&   currentNodeSlow . next != null )  {   currentNodeFast =   currentNodeFast . next . next ;   currentNodeSlow =  currentNodeSlow . next ;  if  (  currentNodeFast == currentNodeSlow )  {   flag = true ;  break ; } }  return flag ; } 
<<<<<<<
  public void swapNodes  (   int valueFirst ,   int valueSecond )  {  if  (  valueFirst == valueSecond )  {  return ; }  Node  previousA = null ,  currentA = head ;  while  (   currentA != null &&   currentA . value != valueFirst )  {   previousA = currentA ;   currentA =  currentA . next ; }  Node  previousB = null ,  currentB = head ;  while  (   currentB != null &&   currentB . value != valueSecond )  {   previousB = currentB ;   currentB =  currentB . next ; }  if  (   currentA == null ||  currentB == null )  {  return ; }  if  (  previousA != null )  {    previousA . next = currentB ; } else  {   head = currentB ; }  if  (  previousB != null )  {    previousB . next = currentA ; } else  {   head = currentA ; }  Node  temp =  currentA . next ;    currentA . next =  currentB . next ;    currentB . next = temp ; }
=======
>>>>>>>
  Node reverseList  (  Node node )  {  Node  prev = null ,  curr = node ,  next ;  while  (  curr != null )  {   next =  curr . next ;    curr . next = prev ;   prev = curr ;   curr = next ; }   node = prev ;  return node ; }   public void clear  ( )  {  Node  cur = head ;  while  (  cur != null )  {  Node  prev = cur ;   cur =  cur . next ;   prev = null ; }   head = null ;   size = 0 ; }   public boolean isEmpty  ( )  {  return  size == 0 ; }   public  int size  ( )  {  return size ; }   public Node getHead  ( )  {  return head ; }   public  int count  ( )  {   int  count = 0 ;  Node  cur = head ;  while  (  cur != null )  {   cur =  cur . next ;   count ++ ; }  return count ; }   public boolean search  (   int key )  {  Node  cur = head ;  while  (  cur != null )  {  if  (   cur . value == key )  {  return true ; }   cur =  cur . next ; }  return false ; }    @ Override public String toString  ( )  {  StringJoiner  joiner =  new StringJoiner  ( "->" ) ;  Node  cur = head ;  while  (  cur != null )  {   joiner . add  (   cur . value + "" ) ;   cur =  cur . next ; }  return  joiner . toString  ( ) ; }   public static void main  (   String  [ ] arg )  {  SinglyLinkedList  list =  new SinglyLinkedList  ( ) ;  assert  list . isEmpty  ( ) ;  assert    list . size  ( ) == 0 &&   list . count  ( ) == 0 ;  assert   list . toString  ( ) . equals  ( "" ) ;   list . insertHead  ( 5 ) ;   list . insertHead  ( 7 ) ;   list . insertHead  ( 10 ) ;   list . insert  ( 3 ) ;   list . insertNth  ( 1 , 4 ) ;  assert   list . toString  ( ) . equals  ( "10->7->5->3->1" ) ;  assert     list . search  ( 10 ) &&  list . search  ( 5 ) &&  list . search  ( 1 ) &&  !  list . search  ( 100 ) ;  assert     list . getNth  ( 0 ) == 10 &&   list . getNth  ( 2 ) == 5 &&   list . getNth  ( 4 ) == 1 ;   list . deleteHead  ( ) ;   list . deleteNth  ( 1 ) ;   list . delete  ( ) ;  assert   list . toString  ( ) . equals  ( "7->3" ) ;  assert    list . size == 2 &&   list . size  ( ) ==  list . count  ( ) ;   list . clear  ( ) ;  assert  list . isEmpty  ( ) ;  try  {   list . delete  ( ) ;  assert false ; }  catch (   Exception e )  {  assert true ; }  Node  instance =  new Node  ( ) ;  Node  head =  new Node  ( 0 ,  new Node  ( 2 ,  new Node  ( 3 ,  new Node  ( 3 ,  new Node  ( 4 ) ) ) ) ) ;   head =  instance . deleteDuplicates  ( head ) ;   instance . print  ( head ) ; } }  class Node  {   int  value ;  Node  next ;  Node  ( )  { }  Node  (   int value )  {  this  ( value , null ) ; }  Node  (   int value ,  Node next )  {    this . value = value ;    this . next = next ; }   public Node  head ;   public  int  size ;   public Node deleteDuplicates  (  Node head )  {  Node  sentinel =  new Node  ( 0 , head ) ;  Node  pred = sentinel ;  while  (  head != null )  {  if  (    head . next != null &&   head . value ==   head . next . value )  {  while  (    head . next != null &&   head . value ==   head . next . value )  {   head =  head . next ; }    pred . next =  head . next ; } else  {   pred =  pred . next ; }   head =  head . next ; }  return  sentinel . next ; }   public void print  (  Node head )  {  Node  temp = head ;  while  (   temp != null &&   temp . next != null )  {    System . out . print  (   temp . value + "->" ) ;   temp =  temp . next ; }  if  (  temp != null )  {    System . out . print  (  temp . value ) ; } }   public void insertHead  (   int x )  {   insertNth  ( x , 0 ) ; }   public void insert  (   int data )  {   insertNth  ( data , size ) ; }   public void insertNth  (   int data ,   int position )  {   checkBounds  ( position , 0 , size ) ;  Node  newNode =  new Node  ( data ) ;  if  (  head == null )  {   head = newNode ;   size ++ ;  return ; } else  if  (  position == 0 )  {    newNode . next = head ;   head = newNode ;   size ++ ;  return ; }  Node  cur = head ;  for (   int  i = 0 ;  i <  position - 1 ;  ++ i )  {   cur =  cur . next ; }    newNode . next =  cur . next ;    cur . next = newNode ;   size ++ ; }   public void swapNodes  (   int a ,   int b )  {  Node  currentNode = head ;  Node  temp = null ;  while  (  currentNode != null )  {  if  (    currentNode . next . value == a )  {   temp =  currentNode . next ; }  if  (    currentNode . next . value == b )  {    currentNode . next = temp ; }   currentNode =  currentNode . next ; } }   public void deleteHead  ( )  {   deleteNth  ( 0 ) ; }   public void delete  ( )  {   deleteNth  (  size - 1 ) ; }   public void deleteNth  (   int position )  {   checkBounds  ( position , 0 ,  size - 1 ) ;  if  (  position == 0 )  {  Node  destroy = head ;   head =  head . next ;   destroy = null ;   size -- ;  return ; }  Node  cur = head ;  for (   int  i = 0 ;  i <  position - 1 ;  ++ i )  {   cur =  cur . next ; }  Node  destroy =  cur . next ;    cur . next =   cur . next . next ;   destroy = null ;   size -- ; }   public  int getNth  (   int index )  {   checkBounds  ( index , 0 ,  size - 1 ) ;  Node  cur = head ;  for (   int  i = 0 ;  i < index ;  ++ i )  {   cur =  cur . next ; }  return  cur . value ; }   public void checkBounds  (   int position ,   int low ,   int high )  {  if  (   position > high ||  position < low )  {  throw  new IndexOutOfBoundsException  (  position + "" ) ; } } }