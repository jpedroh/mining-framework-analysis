  package   jenkins . plugins . coverity ;   import  hudson . EnvVars ;  import  hudson . Extension ;  import  hudson . Launcher ;  import  hudson . LauncherDecorator ;  import  hudson . model .  * ;  import     org . apache . commons . io . FilenameUtils ;  import   java . io . File ;    @ Extension public class CoverityLauncherDecorator  extends LauncherDecorator  {   public static  ThreadLocal  < Boolean >  CoverityPostBuildAction =  new  ThreadLocal  < Boolean >  ( )  {    @ Override protected Boolean initialValue  ( )  {  return false ; } } ;   public static  ThreadLocal  < Boolean >  CoverityBuildStep =  new  ThreadLocal  < Boolean >  ( )  {    @ Override protected Boolean initialValue  ( )  {  return false ; } } ;    @ Override public Launcher decorate  (  Launcher launcher ,  Node node )  {  Executor  executor =  Executor . currentExecutor  ( ) ;  if  (  executor == null )  {  return launcher ; }   Queue . Executable  exec =  executor . getCurrentExecutable  ( ) ;  if  (  !  (  exec instanceof AbstractBuild ) )  {  return launcher ; }  AbstractBuild  build =  ( AbstractBuild ) exec ;  AbstractProject  project =  build . getProject  ( ) ;  CoverityPublisher  publisher =  ( CoverityPublisher )   project . getPublishersList  ( ) . get  (  CoverityPublisher . class ) ;  if  (  publisher == null )  {  return launcher ; }  CoverityVersion  version =   CheckConfig . checkNode  ( publisher , build , launcher ,  launcher . getListener  ( ) ) . getVersion  ( ) ;  TaOptionBlock  ta =  publisher . getTaOptionBlock  ( ) ;  ScmOptionBlock  scm =  publisher . getScmOptionBlock  ( ) ;  InvocationAssistance  invocationAssistance =  publisher . getInvocationAssistance  ( ) ;  boolean  isUsingTA = false ;  boolean  isUsingMisra = false ;  if  (  ta != null )  {  String  taCheck =  ta . checkTaConfig  ( ) ;  if  (  !  taCheck . equals  ( "Pass" ) )  {  throw  new RuntimeException  ( taCheck ) ; }   isUsingTA = true ; }  if  (  invocationAssistance != null )  {  String  taCheck =  invocationAssistance . checkIAConfig  ( ) ;  if  (  !  taCheck . equals  ( "Pass" ) )  {  throw  new RuntimeException  ( taCheck ) ; }   isUsingMisra =  invocationAssistance . getIsUsingMisra  ( ) ; }  if  (  isUsingTA && isUsingMisra )  {  String  errorText =  "Errors with your \"Perform Coverity build/analyze/commit\" options: \n " + "[Error] MISRA and Test Advisor options are not compatible. \n" ;  throw  new RuntimeException  ( errorText ) ; }  if  (  scm != null )  {  String  scmCheck =  scm . checkScmConfig  ( version ) ;  if  (  !  scmCheck . equals  ( "Pass" ) )  {  throw  new RuntimeException  ( scmCheck ) ; } }  return  new CoverityLauncher  ( launcher , node ) ; } 
<<<<<<<
  public class DecoratedLauncher  extends Launcher  {   private final Launcher  decorated ;   private  String  [ ]  prefix ;   private final String  toolsDir ;   private final Node  node ;   private EnvVars  envVars ;   public DecoratedLauncher  (  Launcher decorated ,  Node node )  {  super  ( decorated ) ;    this . decorated = decorated ;    this . node = node ;    this . toolsDir =    node . getRootPath  ( ) . child  ( "tools" ) . getRemote  ( ) ; }   private  String  [ ] getPrefix  ( )  {   String  [ ]  tp =  prefix . clone  ( ) ;  if  (   tp . length > 0 )  {    tp [ 0 ] =  CoverityUtils . getCovBuild  (  decorated . getListener  ( ) , node ) ; }  return tp ; }    @ Override public Proc launch  (  ProcStarter starter )  throws IOException  {  EnvVars  buildEnvVars =  CoverityUtils . getBuildEnvVars  ( listener ) ;  if  (   envVars == null ||  envVars . isEmpty  ( ) )  {   envVars = buildEnvVars ; } else  if  (  buildEnvVars != null )  {   envVars . overrideAll  ( buildEnvVars ) ; }  AbstractBuild  build =  CoverityUtils . getBuild  ( ) ;  AbstractProject  project =  build . getProject  ( ) ;  CoverityPublisher  publisher =  ( CoverityPublisher )   project . getPublishersList  ( ) . get  (  CoverityPublisher . class ) ;   setupIntermediateDirectory  ( build ,  this . getListener  ( ) , node , envVars ) ;  if  (  CoverityPostBuildAction . get  ( ) )  {  return  decorated . launch  ( starter ) ; }  boolean  isCoverityBuildStepEnabled = false ;  if  (  project instanceof Project )  {   List  < Builder >  builders =   (  ( Project ) project ) . getBuilders  ( ) ;  for ( Builder buildStep : builders )  {  if  (   buildStep . getDescriptor  ( ) instanceof  CoverityBuildStep . CoverityBuildStepDescriptor )  {   isCoverityBuildStepEnabled = true ;  break ; } } }  if  (   ! isCoverityBuildStepEnabled ||  (  isCoverityBuildStepEnabled &&  CoverityBuildStep . get  ( ) ) )  {  InvocationAssistance  invocationAssistance =  CoverityUtils . getInvocationAssistance  ( ) ;  String  home =   publisher . getDescriptor  ( ) . getHome  ( node , envVars ) ;  if  (   invocationAssistance != null &&   invocationAssistance . getSaOverride  ( ) != null )  {   home =    new CoverityInstallation  (  CoverityUtils . evaluateEnvVars  (  invocationAssistance . getSaOverride  ( ) , envVars ,  invocationAssistance . getUseAdvancedParser  ( ) ) ) . forEnvironment  ( envVars ) . getHome  ( ) ; }   List  < String >  cmds =  starter . cmds  ( ) ;  if  (  invocationAssistance != null )  {   List  < String >  args =   new CovBuildCompileCommand  ( build , decorated ,  decorated . getListener  ( ) , publisher , home , envVars ) . constructArguments  ( ) ;   prefix =  args . toArray  (  new String  [  args . size  ( ) ] ) ;   cmds . addAll  ( 0 , args ) ; } else  {   prefix =  new String  [ 0 ] ; }  boolean  useAdvancedParser = false ;  if  (   invocationAssistance != null &&  invocationAssistance . getUseAdvancedParser  ( ) )  {   useAdvancedParser = true ; }  String  lastArg =  cmds . get  (   cmds . size  ( ) - 1 ) ;  if  (   lastArg . startsWith  ( toolsDir ) &&  lastArg . endsWith  ( ".sh" ) )  {   logger . info  (  lastArg + " is a tools script, skipping cov-build" ) ;  return  decorated . launch  ( starter ) ; }   String  [ ]  starterEnvVars =  starter . envs  ( ) ;   starterEnvVars =  CoverityUtils . addEnvVars  ( starterEnvVars , envVars ) ;   starter =  starter . envs  ( starterEnvVars ) ;   cmds =  CoverityUtils . prepareCmds  ( cmds , envVars , useAdvancedParser ) ;     getListener  ( ) . getLogger  ( ) . println  (   CoverityUtils . prepareCmds  ( cmds , envVars , true ) . toString  ( ) ) ;   starter =  starter . cmds  ( cmds ) ;   boolean  [ ]  masks =  starter . masks  ( ) ;  if  (  masks == null )  {   masks =  new boolean  [  cmds . size  ( ) ] ;   starter =  starter . masks  ( masks ) ; } else  {   starter =  starter . masks  (  prefix  ( masks ) ) ; }   CoverityBuildStep . set  ( false ) ; }  return  decorated . launch  ( starter ) ; }    @ Override public Channel launchChannel  (   String  [ ] cmd ,  OutputStream out ,  FilePath workDir ,   Map  < String , String > envVars )  throws IOException , InterruptedException  {  String  lastArg =  cmd [   cmd . length - 1 ] ;  if  (   lastArg . startsWith  ( toolsDir ) &&  lastArg . endsWith  ( ".sh" ) )  {   logger . info  (  lastArg + " is a tools script, skipping cov-build" ) ;   decorated . launchChannel  ( cmd , out , workDir , envVars ) ; }  return  decorated . launchChannel  (  prefix  ( cmd ) , out , workDir , envVars ) ; }    @ Override public boolean isUnix  ( )  {  return  decorated . isUnix  ( ) ; }    @ Override public void kill  (   Map  < String , String > modelEnvVars )  throws IOException , InterruptedException  {   decorated . kill  ( modelEnvVars ) ; }   private  String  [ ] prefix  (   String  [ ] args )  {   String  [ ]  newArgs =  new String  [   args . length +  prefix . length ] ;   System . arraycopy  (  getPrefix  ( ) , 0 , newArgs , 0 ,  prefix . length ) ;   System . arraycopy  ( args , 0 , newArgs ,  prefix . length ,  args . length ) ;  return newArgs ; }   private  boolean  [ ] prefix  (   boolean  [ ] args )  {   boolean  [ ]  newArgs =  new boolean  [   args . length +  prefix . length ] ;   System . arraycopy  ( args , 0 , newArgs ,  prefix . length ,  args . length ) ;  return newArgs ; }   public FilePath resolveIntermediateDirectory  (   AbstractBuild  <  ? ,  ? > build ,  TaskListener listener ,  Node node ,  String idirInput )  {  FilePath  idirFilePath = null ;  try  {  String  idir =  EnvParser . interpolateRecursively  ( idirInput , 1 , envVars ) ;  if  (   idir == null ||  idir . isEmpty  ( ) )  {  throw  new Exception  (  "The specified Intermediate Directory is not valid: " + idirInput ) ; }   idirFilePath =  new FilePath  (  node . getChannel  ( ) , idir ) ; }  catch (   ParseException e )  {   CoverityUtils . handleException  (  e . getMessage  ( ) , build , listener , e ) ; }  catch (   Exception e )  {   CoverityUtils . handleException  (  "An error occured while setting intermediate directory: " + idirInput , build , listener , e ) ; }  return idirFilePath ; }   public void setupIntermediateDirectory  (    @ Nonnull  AbstractBuild  <  ? ,  ? > build ,    @ Nonnull TaskListener listener ,    @ Nonnull Node node ,    @ Nonnull EnvVars envVars )  {   Validate . notNull  ( build ,    AbstractBuild . class . getName  ( ) + " object can't be null" ) ;   Validate . notNull  ( listener ,    TaskListener . class . getName  ( ) + " object can't be null" ) ;   Validate . notNull  ( node ,    Node . class . getName  ( ) + " object can't be null" ) ;   Validate . notNull  ( envVars ,    EnvVars . class . getName  ( ) + " object can't be null" ) ;  if  (  !  envVars . containsKey  ( "COV_IDIR" ) )  {  FilePath  temp ;  InvocationAssistance  invocationAssistance =  CoverityUtils . getInvocationAssistance  ( build ) ;  try  {  if  (    invocationAssistance == null ||   invocationAssistance . getIntermediateDir  ( ) == null ||   invocationAssistance . getIntermediateDir  ( ) . isEmpty  ( ) )  {  FilePath  coverityDir =   node . getRootPath  ( ) . child  ( "coverity" ) ;   coverityDir . mkdirs  ( ) ;   temp =  coverityDir . createTempDir  ( "temp-" , null ) ; } else  {   temp =  resolveIntermediateDirectory  ( build , listener , node ,  invocationAssistance . getIntermediateDir  ( ) ) ;  if  (  temp != null )  {  File  idir =  new File  (  temp . getRemote  ( ) ) ;  if  (   idir != null &&  !  idir . isAbsolute  ( ) )  {   temp =  new FilePath  (  temp . getChannel  ( ) ,  FilenameUtils . concat  (  envVars . get  ( "WORKSPACE" ) ,  temp . getRemote  ( ) ) ) ; }   temp . mkdirs  ( ) ; } }  if  (  invocationAssistance != null )  {   build . addAction  (  new CoverityTempDir  ( temp ,   invocationAssistance . getIntermediateDir  ( ) == null ) ) ; } else  {   build . addAction  (  new CoverityTempDir  ( temp , true ) ) ; } }  catch (   IOException e )  {  throw  new RuntimeException  ( "Error while creating temporary directory for Coverity" , e ) ; }  catch (   InterruptedException e )  {  throw  new RuntimeException  ( "Interrupted while creating temporary directory for Coverity" ) ; }  if  (  temp != null )  {   envVars . put  ( "COV_IDIR" ,  temp . getRemote  ( ) ) ; } } } }
=======
>>>>>>>
 }