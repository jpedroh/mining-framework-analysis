  package    jenkins . security . plugins . ldap ;   import      edu . umd . cs . findbugs . annotations . SuppressFBWarnings ;  import   groovy . lang . Binding ;  import  hudson . DescriptorExtensionList ;  import  hudson . Extension ;  import  hudson . Util ;  import   hudson . model . AbstractDescribableImpl ;  import   hudson . model . Descriptor ;  import   hudson . security . LDAPSecurityRealm ;  import   hudson . security . SecurityRealm ;  import   hudson . util . FormValidation ;  import   hudson . util . Secret ;  import    hudson . util . spring . BeanBuilder ;  import   jenkins . model . Jenkins ;  import    org . acegisecurity . ldap . InitialDirContextFactory ;  import    org . acegisecurity . ldap . LdapTemplate ;  import     org . acegisecurity . ldap . search . FilterBasedLdapUserSearch ;  import     org . acegisecurity . providers . ldap . LdapAuthoritiesPopulator ;  import     org . apache . commons . codec . Charsets ;  import      org . apache . commons . codec . binary . Base64 ;  import      org . apache . commons . codec . digest . DigestUtils ;  import      org . apache . commons . io . input . AutoCloseInputStream ;  import     org . apache . commons . lang . StringUtils ;  import    org . kohsuke . accmod . Restricted ;  import     org . kohsuke . accmod . restrictions . NoExternalUse ;  import    org . kohsuke . stapler . DataBoundConstructor ;  import    org . kohsuke . stapler . DataBoundSetter ;  import    org . kohsuke . stapler . QueryParameter ;  import     org . springframework . web . context . WebApplicationContext ;  import   javax . annotation . Nonnull ;  import   javax . naming . Context ;  import   javax . naming . NamingException ;  import    javax . naming . directory . Attribute ;  import    javax . naming . directory . Attributes ;  import    javax . naming . directory . DirContext ;  import    javax . naming . directory . InitialDirContext ;  import   java . io . File ;  import   java . io . FileInputStream ;  import   java . io . FileNotFoundException ;  import   java . io . IOException ;  import   java . net . InetAddress ;  import   java . net . Socket ;  import   java . net . URI ;  import   java . net . URISyntaxException ;  import   java . net . UnknownHostException ;  import   java . security . MessageDigest ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Collections ;  import   java . util . Hashtable ;  import   java . util . List ;  import   java . util . Map ;  import    java . util . logging . Level ;  import    java . util . logging . Logger ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import static   hudson . Util . fixEmpty ;  import static   hudson . Util . fixEmptyAndTrim ;  import static   hudson . Util . fixNull ;  import static      org . apache . commons . lang . StringUtils . isBlank ;  import static      org . apache . commons . lang . StringUtils . isNotBlank ;   public class LDAPConfiguration  extends  AbstractDescribableImpl  < LDAPConfiguration >  {   private static final Logger  LOGGER =  LDAPSecurityRealm . LOGGER ;    @ Restricted  (  NoExternalUse . class ) public static final String  SECURITY_REALM_LDAPBIND_GROOVY = "LDAPBindSecurityRealm.groovy" ;   private final String  server ;   private final String  rootDN ;   private final boolean  inhibitInferRootDN ;   private String  userSearchBase ;   private String  userSearch ;   private String  groupSearchBase ;   private String  groupSearchFilter ;   private LDAPGroupMembershipStrategy  groupMembershipStrategy ;   private final String  managerDN ;   private final Secret  managerPasswordSecret ;   private String  displayNameAttributeName ;   private String  mailAddressAttributeName ;   private boolean  ignoreIfUnavailable ;   private  Map  < String , String >  extraEnvVars ;   private transient LDAPExtendedTemplate  ldapTemplate ;   private transient String  id ;    @ DataBoundConstructor public LDAPConfiguration  (    @ Nonnull String server ,  String rootDN ,  boolean inhibitInferRootDN ,  String managerDN ,  Secret managerPasswordSecret )  {    this . server =  server . trim  ( ) ;    this . managerDN =  fixEmpty  ( managerDN ) ;    this . managerPasswordSecret = managerPasswordSecret ;    this . inhibitInferRootDN = inhibitInferRootDN ;  if  (   ! inhibitInferRootDN &&   fixEmptyAndTrim  ( rootDN ) == null )  {   rootDN =  fixNull  (  inferRootDN  ( server ) ) ; }    this . rootDN = rootDN ;    this . displayNameAttributeName =   LDAPSecurityRealm . DescriptorImpl . DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME ;    this . mailAddressAttributeName =   LDAPSecurityRealm . DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ;    this . userSearchBase = "" ;    this . userSearch =   LDAPSecurityRealm . DescriptorImpl . DEFAULT_USER_SEARCH ;    this . groupMembershipStrategy =  new FromGroupSearchLDAPGroupMembershipStrategy  ( "" ) ;    this . groupSearchBase = "" ; }   public String getServer  ( )  {  return server ; }   public String getServerUrl  ( )  {  StringBuilder  buf =  new StringBuilder  ( ) ;  boolean  first = true ;  for ( String s :   Util . fixNull  ( server ) . split  ( "\\s+" ) )  {  if  (    s . trim  ( ) . length  ( ) == 0 )  continue ;  if  ( first )   first = false ; else   buf . append  ( ' ' ) ;   buf . append  (  addPrefix  ( s ) ) ; }  return  buf . toString  ( ) ; }   public String getRootDN  ( )  {  return rootDN ; }   public String getLDAPURL  ( )  {  return  LDAPSecurityRealm . toProviderUrl  (  getServerUrl  ( ) ,  fixNull  ( rootDN ) ) ; }   public boolean isInhibitInferRootDN  ( )  {  return inhibitInferRootDN ; }   public String getUserSearchBase  ( )  {  return userSearchBase ; }    @ DataBoundSetter public void setUserSearchBase  (  String userSearchBase )  {    this . userSearchBase =   fixNull  ( userSearchBase ) . trim  ( ) ; }   public String getUserSearch  ( )  {  return userSearch ; }    @ DataBoundSetter public void setUserSearch  (  String userSearch )  {   userSearch =  fixEmptyAndTrim  ( userSearch ) ;    this . userSearch =   userSearch != null ? userSearch :   LDAPSecurityRealm . DescriptorImpl . DEFAULT_USER_SEARCH ; }   public String getGroupSearchBase  ( )  {  return groupSearchBase ; }    @ DataBoundSetter public void setGroupSearchBase  (  String groupSearchBase )  {    this . groupSearchBase =  fixEmptyAndTrim  ( groupSearchBase ) ; }   public String getGroupSearchFilter  ( )  {  return groupSearchFilter ; }    @ DataBoundSetter public void setGroupSearchFilter  (  String groupSearchFilter )  {    this . groupSearchFilter =  fixEmptyAndTrim  ( groupSearchFilter ) ; }   public LDAPGroupMembershipStrategy getGroupMembershipStrategy  ( )  {  return groupMembershipStrategy ; }    @ DataBoundSetter public void setGroupMembershipStrategy  (  LDAPGroupMembershipStrategy groupMembershipStrategy )  {    this . groupMembershipStrategy =   groupMembershipStrategy == null ?  new FromGroupSearchLDAPGroupMembershipStrategy  ( "" ) : groupMembershipStrategy ; }   public String getManagerDN  ( )  {  return managerDN ; }   public String getManagerPassword  ( )  {  return  Secret . toString  ( managerPasswordSecret ) ; }   public Secret getManagerPasswordSecret  ( )  {  return managerPasswordSecret ; }   public String getDisplayNameAttributeName  ( )  {  return  StringUtils . defaultString  ( displayNameAttributeName ,   LDAPSecurityRealm . DescriptorImpl . DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME ) ; }    @ DataBoundSetter public void setDisplayNameAttributeName  (  String displayNameAttributeName )  {    this . displayNameAttributeName = displayNameAttributeName ; }   public String getMailAddressAttributeName  ( )  {  return  StringUtils . defaultString  ( mailAddressAttributeName ,   LDAPSecurityRealm . DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ) ; }    @ DataBoundSetter public void setMailAddressAttributeName  (  String mailAddressAttributeName )  {    this . mailAddressAttributeName = mailAddressAttributeName ; }   public boolean isIgnoreIfUnavailable  ( )  {  return ignoreIfUnavailable ; }    @ DataBoundSetter public void setIgnoreIfUnavailable  (  boolean ignoreIfUnavailable )  {    this . ignoreIfUnavailable = ignoreIfUnavailable ; }   public  Map  < String , String > getExtraEnvVars  ( )  {  return    extraEnvVars == null ||  extraEnvVars . isEmpty  ( ) ?  Collections .  < String , String > emptyMap  ( ) :  Collections . unmodifiableMap  ( extraEnvVars ) ; }    @ Restricted  (  NoExternalUse . class ) public void setExtraEnvVars  (   Map  < String , String > extraEnvVars )  {    this . extraEnvVars = extraEnvVars ; }   public   LDAPSecurityRealm . EnvironmentProperty  [ ] getEnvironmentProperties  ( )  {  if  (   extraEnvVars == null ||  extraEnvVars . isEmpty  ( ) )  {  return  new  LDAPSecurityRealm . EnvironmentProperty  [ 0 ] ; }    LDAPSecurityRealm . EnvironmentProperty  [ ]  result =  new  LDAPSecurityRealm . EnvironmentProperty  [  extraEnvVars . size  ( ) ] ;   int  i = 0 ;  for (   Map . Entry  < String , String > entry :  extraEnvVars . entrySet  ( ) )  {    result [  i ++ ] =  new  LDAPSecurityRealm . EnvironmentProperty  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; }  return result ; }    @ DataBoundSetter public void setEnvironmentProperties  (    LDAPSecurityRealm . EnvironmentProperty  [ ] environmentProperties )  {    this . extraEnvVars =    environmentProperties == null ||   environmentProperties . length == 0 ? null :   LDAPSecurityRealm . EnvironmentProperty . toMap  (  Arrays . asList  ( environmentProperties ) ) ; }   public String getId  ( )  {  if  (  StringUtils . isEmpty  (  this . id ) )  {    this . id =  generateId  ( ) ; }  return  this . id ; }   public boolean isConfiguration  (  String id )  {  return   getId  ( ) . equals  ( id ) ; }    @ Extension public static final class LDAPConfigurationDescriptor  extends  Descriptor  < LDAPConfiguration >  {   public static final String  DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME =   LDAPSecurityRealm . DescriptorImpl . DEFAULT_DISPLAYNAME_ATTRIBUTE_NAME ;   public static final String  DEFAULT_MAILADDRESS_ATTRIBUTE_NAME =   LDAPSecurityRealm . DescriptorImpl . DEFAULT_MAILADDRESS_ATTRIBUTE_NAME ;   public static final String  DEFAULT_USER_SEARCH =   LDAPSecurityRealm . DescriptorImpl . DEFAULT_USER_SEARCH ;    @ Override public String getDisplayName  ( )  {  return "ldap" ; }   public boolean noCustomBindScript  ( )  {  return  !   getLdapBindOverrideFile  (  Jenkins . getActiveInstance  ( ) ) . exists  ( ) ; }    @ SuppressFBWarnings  (  value = "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE" ,  justification = "Only on newer core versions" ) public FormValidation doCheckServer  (    @ QueryParameter String value ,    @ QueryParameter String managerDN ,    @ QueryParameter Secret managerPasswordSecret )  {  String  server = value ;  String  managerPassword =  Secret . toString  ( managerPasswordSecret ) ;   final Jenkins  jenkins =  Jenkins . getInstance  ( ) ;  if  (  jenkins == null )  {  return  FormValidation . error  ( "Jenkins is not ready. Cannot validate the field" ) ; }  if  (  !  jenkins . hasPermission  (  Jenkins . ADMINISTER ) )  return  FormValidation . ok  ( ) ;  try  {   Hashtable  < String , String >  props =  new  Hashtable  < String , String >  ( ) ;  if  (    managerDN != null &&    managerDN . trim  ( ) . length  ( ) > 0 &&  !  "undefined" . equals  ( managerDN ) )  {   props . put  (  Context . SECURITY_PRINCIPAL , managerDN ) ; }  if  (    managerPassword != null &&    managerPassword . trim  ( ) . length  ( ) > 0 &&  !  "undefined" . equals  ( managerPassword ) )  {   props . put  (  Context . SECURITY_CREDENTIALS , managerPassword ) ; }   props . put  (  Context . INITIAL_CONTEXT_FACTORY , "com.sun.jndi.ldap.LdapCtxFactory" ) ;   props . put  (  Context . PROVIDER_URL ,  LDAPSecurityRealm . toProviderUrl  ( server , "" ) ) ;  DirContext  ctx =  new InitialDirContext  ( props ) ;   ctx . getAttributes  ( "" ) ;  return  FormValidation . ok  ( ) ; }  catch (   NamingException e )  {  Matcher  m =   Pattern . compile  ( "(ldaps?://)?([^:]+)(?:\\:(\\d+))?(\\s+(ldaps?://)?([^:]+)(?:\\:(\\d+))?)*" ) . matcher  (  server . trim  ( ) ) ;  if  (  !  m . matches  ( ) )  return  FormValidation . error  (    hudson . security . Messages . LDAPSecurityRealm_SyntaxOfServerField  ( ) ) ;  try  {  InetAddress  adrs =  InetAddress . getByName  (  m . group  ( 2 ) ) ;   int  port =    m . group  ( 1 ) != null ? 636 : 389 ;  if  (   m . group  ( 3 ) != null )   port =  Integer . parseInt  (  m . group  ( 3 ) ) ;  Socket  s =  new Socket  ( adrs , port ) ;   s . close  ( ) ; }  catch (   UnknownHostException x )  {  return  FormValidation . error  (    hudson . security . Messages . LDAPSecurityRealm_UnknownHost  (  x . getMessage  ( ) ) ) ; }  catch (   IOException x )  {  return  FormValidation . error  ( x ,    hudson . security . Messages . LDAPSecurityRealm_UnableToConnect  ( server ,  x . getMessage  ( ) ) ) ; }  return  FormValidation . error  ( e ,    hudson . security . Messages . LDAPSecurityRealm_UnableToConnect  ( server , e ) ) ; }  catch (   NumberFormatException x )  {  return  FormValidation . error  (    hudson . security . Messages . LDAPSecurityRealm_InvalidPortNumber  ( ) ) ; } }    @ SuppressFBWarnings  (  value = "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE" ,  justification = "Only on newer core versions" ) public  DescriptorExtensionList  < LDAPGroupMembershipStrategy ,  Descriptor  < LDAPGroupMembershipStrategy > > getGroupMembershipStrategies  ( )  {   final Jenkins  jenkins =  Jenkins . getInstance  ( ) ;  if  (  jenkins != null )  {  return  jenkins . getDescriptorList  (  LDAPGroupMembershipStrategy . class ) ; } else  {  return  DescriptorExtensionList . createDescriptorList  (  ( Jenkins ) null ,  LDAPGroupMembershipStrategy . class ) ; } } }   private String inferRootDN  (  String server )  {  try  {   Hashtable  < String , String >  props =  new  Hashtable  < String , String >  ( ) ;  if  (  managerDN != null )  {   props . put  (  Context . SECURITY_PRINCIPAL , managerDN ) ;   props . put  (  Context . SECURITY_CREDENTIALS ,  getManagerPassword  ( ) ) ; }   props . put  (  Context . INITIAL_CONTEXT_FACTORY , "com.sun.jndi.ldap.LdapCtxFactory" ) ;   props . put  (  Context . PROVIDER_URL ,  LDAPSecurityRealm . toProviderUrl  (  getServerUrl  ( ) , "" ) ) ;  DirContext  ctx =  new InitialDirContext  ( props ) ;  Attributes  atts =  ctx . getAttributes  ( "" ) ;  Attribute  a =  atts . get  ( "defaultNamingContext" ) ;  if  (   a != null &&   a . get  ( ) != null )  return   a . get  ( ) . toString  ( ) ;   a =  atts . get  ( "namingcontexts" ) ;  if  (  a == null )  {   LOGGER . warning  (  "namingcontexts attribute not found in root DSE of " + server ) ;  return null ; }  return   a . get  ( ) . toString  ( ) ; }  catch (   NamingException e )  {   LOGGER . log  (  Level . WARNING ,  "Failed to connect to LDAP to infer Root DN for " + server , e ) ;  return null ; } }   private static String addPrefix  (  String server )  {  if  (  server . contains  ( "://" ) )  return server ; else  return  "ldap://" + server ; }   private String generateId  ( )  {  return  generateId  ( server , rootDN , userSearchBase , userSearch ) ; }    @ Restricted  (  NoExternalUse . class ) static String generateId  (  String serverUrl ,  String rootDN ,  String userSearchBase ,  String userSearch )  {   final MessageDigest  digest =  DigestUtils . getMd5Digest  ( ) ;   digest . update  (   normalizeServer  ( serverUrl ) . getBytes  (  Charsets . UTF_8 ) ) ;  String  userSearchBaseNormalized =  normalizeUserSearchBase  ( rootDN , userSearchBase ) ;  if  (  isNotBlank  ( userSearchBaseNormalized ) )  {   digest . update  (  userSearchBaseNormalized . getBytes  (  Charsets . UTF_8 ) ) ; } else  {   digest . update  (  new  byte  [ ]  { 0 } ) ; }  if  (  isNotBlank  ( userSearch ) )  {   digest . update  (  userSearch . getBytes  (  Charsets . UTF_8 ) ) ; } else  {   digest . update  (   LDAPConfigurationDescriptor . DEFAULT_USER_SEARCH . getBytes  (  Charsets . UTF_8 ) ) ; }  return  Base64 . encodeBase64String  (  digest . digest  ( ) ) ; }   private static String normalizeUserSearchBase  (  String rootDN ,  String userSearchBase )  {  if  (   isBlank  ( rootDN ) &&  isBlank  ( userSearchBase ) )  {  return "" ; }  if  (  isBlank  ( rootDN ) )  {  return userSearchBase ; }  if  (  isBlank  ( userSearchBase ) )  {  return rootDN ; }   rootDN =  rootDN . trim  ( ) ;   userSearchBase =  userSearchBase . trim  ( ) ;  return   userSearchBase + "," + rootDN ; }    @ Restricted  (  NoExternalUse . class ) static String normalizeServer  (  String server )  {   String  [ ]  urls =   Util . fixNull  ( server ) . split  ( "\\s+" ) ;   List  < String >  normalised =  new  ArrayList  < >  (  urls . length ) ;  for ( String url : urls )  {  if  (  isBlank  ( url ) )  {  continue ; }   url =  addPrefix  ( url ) ;  try  {  URI  uri =  new URI  ( url ) ;  if  (   uri . getPort  ( ) < 0 )  {   uri =  new URI  (  uri . getScheme  ( ) ,  uri . getUserInfo  ( ) ,  uri . getHost  ( ) , 389 ,  uri . getPath  ( ) ,  uri . getQuery  ( ) ,  uri . getFragment  ( ) ) ; }   normalised . add  (  uri . toString  ( ) ) ; }  catch (   URISyntaxException e )  {   LOGGER . warning  (   "Unable to parse " + url + " into an URI" ) ; } }   Collections . sort  ( normalised ) ;  return  StringUtils . join  ( normalised , ' ' ) ; }    @ Restricted  (  NoExternalUse . class ) public WebApplicationContext createApplicationContext  (  LDAPSecurityRealm realm ,  boolean usePotentialUserProvidedBinding )  {  Binding  binding =  new Binding  ( ) ;   binding . setVariable  ( "instance" , this ) ;   binding . setVariable  ( "realmInstance" , realm ) ;   final Jenkins  jenkins =  Jenkins . getInstance  ( ) ;  if  (  jenkins == null )  {  throw  new IllegalStateException  ( "Jenkins has not been started, or was already shut down" ) ; }  BeanBuilder  builder =  new BeanBuilder  (   jenkins . pluginManager . uberClassLoader ) ;  try  {  File  override =  getLdapBindOverrideFile  ( jenkins ) ;  if  (  usePotentialUserProvidedBinding &&  override . exists  ( ) )  {   builder . parse  (  new AutoCloseInputStream  (  new FileInputStream  ( override ) ) , binding ) ; } else  {  if  (  override . exists  ( ) )  {   LOGGER . warning  (  "Not loading custom " + SECURITY_REALM_LDAPBIND_GROOVY ) ; }   builder . parse  (  new AutoCloseInputStream  (   LDAPSecurityRealm . class . getResourceAsStream  ( SECURITY_REALM_LDAPBIND_GROOVY ) ) , binding ) ; } }  catch (   FileNotFoundException e )  {  throw  new IllegalStateException  (  "Failed to load " + SECURITY_REALM_LDAPBIND_GROOVY , e ) ; }  WebApplicationContext  appContext =  builder . createApplicationContext  ( ) ;   ldapTemplate =  new LDAPExtendedTemplate  (  SecurityRealm . findBean  (  InitialDirContextFactory . class , appContext ) ) ;  if  (  groupMembershipStrategy != null )  {   groupMembershipStrategy . setAuthoritiesPopulator  (  SecurityRealm . findBean  (  LdapAuthoritiesPopulator . class , appContext ) ) ; }  return appContext ; }    @ Restricted  (  NoExternalUse . class ) public LDAPExtendedTemplate getLdapTemplate  ( )  {  return ldapTemplate ; }    @ Restricted  (  NoExternalUse . class ) public static File getLdapBindOverrideFile  (  Jenkins jenkins )  {  return  new File  (  jenkins . getRootDir  ( ) , SECURITY_REALM_LDAPBIND_GROOVY ) ; } }