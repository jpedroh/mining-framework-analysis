  package   si . mazi . rescu ;   import     com . fasterxml . jackson . databind . DeserializationFeature ;  import     com . fasterxml . jackson . databind . ObjectMapper ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     si . mazi . rescu . utils . AssertUtil ;  import   java . io . BufferedReader ;  import   java . io . IOException ;  import   java . io . InputStream ;  import   java . io . InputStreamReader ;  import  java . net .  * ;  import   java . util . HashMap ;  import   java . util . Map ;  import    java . util . zip . GZIPInputStream ;  class HttpTemplate  {   public final static String  CHARSET_UTF_8 = "UTF-8" ;   private final Logger  log =  LoggerFactory . getLogger  (  HttpTemplate . class ) ;   private ObjectMapper  objectMapper ;   private  Map  < String , String >  defaultHttpHeaders =  new  HashMap  < String , String >  ( ) ;   private final  int  readTimeout =  Config . getHttpReadTimeout  ( ) ;   private final Proxy  proxy ;   public HttpTemplate  ( )  {   objectMapper =  new ObjectMapper  ( ) ;   objectMapper . configure  (  DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES , false ) ;   defaultHttpHeaders . put  ( "Accept-Charset" , CHARSET_UTF_8 ) ;   defaultHttpHeaders . put  ( "Content-Type" , "application/x-www-form-urlencoded" ) ;   defaultHttpHeaders . put  ( "Accept" , "application/json" ) ;   defaultHttpHeaders . put  ( "User-Agent" , "ResCU JDK/6 AppleWebKit/535.7 Chrome/16.0.912.36 Safari/535.7" ) ;  if  (    Config . getProxyPort  ( ) == null ||   Config . getProxyHost  ( ) == null )  {   proxy =  Proxy . NO_PROXY ; } else  {   proxy =  new Proxy  (   Proxy . Type . HTTP ,  new InetSocketAddress  (  Config . getProxyHost  ( ) ,  Config . getProxyPort  ( ) ) ) ;   log . info  ( "Using proxy {}" , proxy ) ; } }   public  <  T > T executeRequest  (  String urlString ,   Class  < T > returnType ,  String requestBody ,   Map  < String , String > httpHeaders ,  HttpMethod method ,  String contentType ,   Class  <  ? extends RuntimeException > exceptionType )  throws IOException  {   log . debug  ( "Executing {} request at {}" , method , urlString ) ;   log . trace  ( "Request body = {}" , requestBody ) ;   log . trace  ( "Request headers = {}" , httpHeaders ) ;   AssertUtil . notNull  ( urlString , "urlString cannot be null" ) ;   AssertUtil . notNull  ( httpHeaders , "httpHeaders should not be null" ) ;  if  (  contentType != null )  {   httpHeaders . put  ( "Content-Type" , contentType ) ; }   int  contentLength =   requestBody == null ? 0 :  requestBody . length  ( ) ;  HttpURLConnection  connection =  configureURLConnection  ( method , urlString , httpHeaders , contentLength ) ;  if  (  contentLength > 0 )  {    connection . getOutputStream  ( ) . write  (  requestBody . getBytes  ( CHARSET_UTF_8 ) ) ; }   int  httpStatus =  connection . getResponseCode  ( ) ;   log . debug  ( "Request http status = {}" , httpStatus ) ; 
<<<<<<<
 if  (   httpStatus / 100 != 2 )  {  String  httpBody =  readInputStreamAsEncodedString  (  connection . getErrorStream  ( ) , connection ) ;   log . trace  ( "Http call returned {}; response body:\n{}" , httpStatus , httpBody ) ;  if  (  exceptionType != null )  {  RuntimeException  exception = null ;  try  {   exception =  objectMapper . readValue  ( httpBody , exceptionType ) ; }  catch (   IOException e )  {   log . warn  (  "Error parsing error output: " +  e . toString  ( ) ) ; }  if  (  exception != null )  {  throw exception ; } }  throw  new IOException  (  String . format  ( "HTTP status code was %d; response body: %s" , httpStatus , httpBody ) ) ; }
=======
 switch  ( httpStatus )  {   case 200 :   case 201 :  InputStream  inputStream =  connection . getInputStream  ( ) ;  String  responseString =  readInputStreamAsEncodedString  ( inputStream , connection ) ;   log . trace  ( "Response body: {}" , responseString ) ;  return  objectMapper . readValue  ( responseString , returnType ) ;   case 204 :  return null ;   default :  String  httpBody =  readInputStreamAsEncodedString  (  connection . getErrorStream  ( ) , connection ) ;   log . trace  ( "Http call returned {}; response body:\n{}" , httpStatus , httpBody ) ;  if  (  exceptionType != null )  {  RuntimeException  exception = null ;  try  {   exception =  objectMapper . readValue  ( httpBody , exceptionType ) ; }  catch (   IOException e )  {   log . warn  (  "Error parsing error output: " +  e . toString  ( ) ) ; }  if  (  exception != null )  {  throw exception ; } }  throw  new IOException  (  String . format  ( "HTTP status code was %d; response body: %s" , httpStatus , httpBody ) ) ; }
>>>>>>>
 }   private HttpURLConnection configureURLConnection  (  HttpMethod method ,  String urlString ,   Map  < String , String > httpHeaders ,   int contentLength )  throws IOException  {   AssertUtil . notNull  ( method , "method cannot be null" ) ;   AssertUtil . notNull  ( urlString , "urlString cannot be null" ) ;   AssertUtil . notNull  ( httpHeaders , "httpHeaders cannot be null" ) ;  HttpURLConnection  connection =  getHttpURLConnection  ( urlString ) ;   connection . setRequestMethod  (  method . name  ( ) ) ;   Map  < String , String >  headerKeyValues =  new  HashMap  < String , String >  ( defaultHttpHeaders ) ;   headerKeyValues . putAll  ( httpHeaders ) ;  for (   Map . Entry  < String , String > entry :  headerKeyValues . entrySet  ( ) )  {   connection . setRequestProperty  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ;   log . trace  ( "Header request property: key='{}', value='{}'" ,  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; }  if  (  contentLength > 0 )  {   connection . setDoOutput  ( true ) ;   connection . setDoInput  ( true ) ;   connection . setRequestProperty  ( "Content-Length" ,  Integer . toString  ( contentLength ) ) ; }  return connection ; }   protected HttpURLConnection getHttpURLConnection  (  String urlString )  throws IOException  {  HttpURLConnection  connection =  ( HttpURLConnection )   new URL  ( urlString ) . openConnection  ( proxy ) ;  if  (  readTimeout > 0 )  {   connection . setReadTimeout  ( readTimeout ) ; }  return connection ; }  String readInputStreamAsEncodedString  (  InputStream inputStream ,  HttpURLConnection connection )  throws IOException  {  if  (  inputStream == null )  {  return null ; }  BufferedReader  reader = null ;  try  {  String  responseEncoding =  getResponseEncoding  ( connection ) ;  if  (  izGzipped  ( connection ) )  {   inputStream =  new GZIPInputStream  ( inputStream ) ; }   final InputStreamReader  in =   responseEncoding != null ?  new InputStreamReader  ( inputStream , responseEncoding ) :  new InputStreamReader  ( inputStream ) ;   reader =  new BufferedReader  ( in ) ;  StringBuilder  sb =  new StringBuilder  ( ) ;  for (  String  line ;   (  line =  reader . readLine  ( ) ) != null ; )  {   sb . append  ( line ) ; }  return  sb . toString  ( ) ; }  finally  {   inputStream . close  ( ) ;  if  (  reader != null )   reader . close  ( ) ; } }  boolean izGzipped  (  HttpURLConnection connection )  {  return  "gzip" . equalsIgnoreCase  (  connection . getHeaderField  ( "Content-Encoding" ) ) ; }  String getResponseEncoding  (  URLConnection connection )  {  String  charset = null ;  String  contentType =  connection . getHeaderField  ( "Content-Type" ) ;  if  (  contentType != null )  {  for ( String param :   contentType . replace  ( " " , "" ) . split  ( ";" ) )  {  if  (  param . startsWith  ( "charset=" ) )  {   charset =   param . split  ( "=" , 2 ) [ 1 ] ;  break ; } } }  return charset ; } }