  package  org . concurrentunit ;   import    java . util . concurrent . ExecutorService ;  import    java . util . concurrent . TimeoutException ;  import     java . util . concurrent . atomic . AtomicInteger ;  import static    org . junit . Assert . assertEquals ;  import static    org . junit . Assert . assertFalse ;  import static    org . junit . Assert . assertNotNull ;  import static    org . junit . Assert . assertNull ;  import static    org . junit . Assert . assertTrue ;  import static    org . junit . Assert . fail ;  import    java . util . concurrent . TimeUnit ;   public abstract class ConcurrentTestCase  {   private static final String  TIMEOUT_MESSAGE = "Test timed out while waiting for an expected result" ;   private final Thread  mainThread ;   private AtomicInteger  waitCount ;   private Throwable  failure ;   public ConcurrentTestCase  ( )  {   mainThread =  Thread . currentThread  ( ) ; }   protected void resume  ( )  {   resume  ( mainThread ) ; }   protected void resume  (  Thread thread )  {  if  (    thread != mainThread ||  waitCount == null ||   waitCount . decrementAndGet  ( ) == 0 )   thread . interrupt  ( ) ; }   public void threadFail  (  String reason )  {   threadFail  (  new AssertionError  ( reason ) ) ; }   public void threadFail  (  Throwable e )  {   failure = e ;   resume  ( mainThread ) ; }   public void threadAssertTrue  (  boolean b )  {  try  {   assertTrue  ( b ) ; }  catch (   AssertionError e )  {   threadFail  ( e ) ; } }   public void threadAssertFalse  (  boolean b )  {  try  {   assertFalse  ( b ) ; }  catch (   AssertionError e )  {   threadFail  ( e ) ; } }   public void threadAssertNull  (  Object x )  {  try  {   assertNull  ( x ) ; }  catch (   AssertionError e )  {   threadFail  ( e ) ; } }   public void threadAssertNotNull  (  Object object )  {  try  {   assertNotNull  ( object ) ; }  catch (   AssertionError e )  {   threadFail  ( e ) ; } }   public void threadAssertEquals  (  Object x ,  Object y )  {  try  {   assertEquals  ( x , y ) ; }  catch (   AssertionError e )  {   threadFail  ( e ) ; } }   protected void sleep  (   long sleepDuration )  throws Throwable , TimeoutException  {  try  {   Thread . sleep  ( sleepDuration ) ;  throw  new TimeoutException  ( TIMEOUT_MESSAGE ) ; }  catch (   InterruptedException ignored )  { }  finally  {  if  (  failure != null )  throw failure ; } }   protected void threadWait  (   long waitDuration ,   int resumeThreshold )  throws Throwable  {  if  (  waitDuration == 0 )  {   waitCount =  new AtomicInteger  ( resumeThreshold ) ;   threadWait  ( ) ;   waitCount = null ; } else   sleep  ( waitDuration , resumeThreshold ) ; }   protected void threadWait  (   long waitDuration )  throws Throwable , TimeoutException  {  if  (  waitDuration == 0 )   threadWait  ( ) ; else   sleep  ( waitDuration ) ; }   public void joinPool  (  ExecutorService executor ,   long waitDuration ,  TimeUnit waitUnits )  {  try  {   executor . shutdown  ( ) ;   assertTrue  (  executor . awaitTermination  ( waitDuration , waitUnits ) ) ; }  catch (   SecurityException ok )  { }  catch (   InterruptedException e )  {   fail  ( "Unexpected InterruptedException" ) ; } }   protected void sleep  (   long sleepDuration ,   int resumeThreshold )  throws Throwable  {  if  (   Thread . currentThread  ( ) != mainThread )  throw  new IllegalStateException  ( "Must be called from within the main test thread" ) ;   waitCount =  new AtomicInteger  ( resumeThreshold ) ;   sleep  ( sleepDuration ) ;   waitCount = null ; }   protected void threadResume  ( )  {   resume  ( mainThread ) ; }   protected void threadWait  ( )  throws Throwable  {  if  (   Thread . currentThread  ( ) != mainThread )  throw  new IllegalStateException  ( "Must be called from within the main test thread" ) ;  synchronized  ( this )  {  while  ( true )  {  try  {   wait  ( ) ;  throw  new TimeoutException  ( TIMEOUT_MESSAGE ) ; }  catch (   InterruptedException e )  {  if  (  failure != null )  throw failure ;  break ; } } } } }