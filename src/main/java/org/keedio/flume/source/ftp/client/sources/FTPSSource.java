  package       org . keedio . flume . source . ftp . client . sources ;   import   java . io . IOException ;  import   java . io . InputStream ;  import   java . security . GeneralSecurityException ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . List ;  import      org . apache . commons . net . ftp . FTP ;  import       org . keedio . flume . source . ftp . client . KeedioSource ;  import      org . apache . commons . net . ftp . FTPSClient ;  import   java . io . File ;  import      org . apache . commons . net . ftp . FTPFile ;  import      org . apache . commons . net . ftp . FTPReply ;  import      org . apache . commons . net . util . TrustManagerUtils ;  import      org . apache . commons . net . util . KeyManagerUtils ;  import    javax . net . ssl . KeyManager ;  import        org . keedio . flume . source . ftp . client . filters . KeedioFileFilter ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;   public class FTPSSource  extends  KeedioSource  < FTPFile >  {   private static final Logger  LOGGER =  LoggerFactory . getLogger  (  FTPSSource . class ) ;   private boolean  securityMode ,  securityCert ;   private String  protocolSec ,  pathTokesytore ,  storePass ;   private FTPSClient  ftpsClient ;   public FTPSSource  ( )  { }   public FTPSSource  (  boolean securityMode ,  String protocolSec ,  boolean securityCert ,  String pathTokeystore ,  String storePass )  {    this . securityMode = securityMode ;    this . protocolSec = protocolSec ;    this . securityCert = securityCert ;   ftpsClient =  new FTPSClient  ( protocolSec ) ;    this . pathTokesytore = pathTokeystore ;    this . storePass = storePass ;   checkIfCertificate  ( ) ; }    @ Override public boolean connect  ( )  {   setConnected  ( true ) ;  try  {   ftpsClient . connect  (  getServer  ( ) ,  getPort  ( ) ) ;   int  replyCode =  ftpsClient . getReplyCode  ( ) ;  if  (  !  FTPReply . isPositiveCompletion  ( replyCode ) )  {   ftpsClient . disconnect  ( ) ;   LOGGER . error  ( "Connect Failed due to FTPS, server refused connection." ) ;   this . setConnected  ( false ) ; }  if  (  !  (  ftpsClient . login  ( user , password ) ) )  {   LOGGER . error  ( "Could not login to the server" ) ;   this . setConnected  ( false ) ; }   ftpsClient . enterLocalPassiveMode  ( ) ;   ftpsClient . setControlKeepAliveTimeout  ( 300 ) ;  if  (   getWorkingDirectory  ( ) != null )  {   ftpsClient . changeWorkingDirectory  (  getWorkingDirectory  ( ) ) ; }  if  (   getBufferSize  ( ) != null )  {   ftpsClient . setBufferSize  (  getBufferSize  ( ) ) ; } }  catch (   IOException e )  {   this . setConnected  ( false ) ;   LOGGER . error  ( "" , e ) ; }  return  isConnected  ( ) ; }    @ Override public void disconnect  ( )  {  try  {   ftpsClient . logout  ( ) ;   ftpsClient . disconnect  ( ) ;   setConnected  ( false ) ; }  catch (   IOException e )  {   LOGGER . error  (   "Source " +   this . getClass  ( ) . getName  ( ) + " failed disconnect" , e ) ; } }    @ Override public void changeToDirectory  (  String directory )  throws IOException  {   ftpsClient . changeWorkingDirectory  ( directory ) ; }    @ Override public  List  < FTPFile > listElements  (  String dir )  throws IOException  {   FTPFile  [ ]  subFiles =   getFtpsClient  ( ) . listFiles  ( dir ) ;  return  Arrays . asList  ( subFiles ) ; }    @ Override public InputStream getInputStream  (  FTPFile file )  throws IOException  {  if  (  isFlushLines  ( ) )  {   this . setFileType  (  FTP . ASCII_FILE_TYPE ) ; } else  {   this . setFileType  (  FTP . BINARY_FILE_TYPE ) ; }  return   getFtpsClient  ( ) . retrieveFileStream  (  file . getName  ( ) ) ; }    @ Override public String getObjectName  (  FTPFile file )  {  return  file . getName  ( ) ; }    @ Override public boolean isDirectory  (  FTPFile file )  {  return  file . isDirectory  ( ) ; }    @ Override public boolean isFile  (  FTPFile file )  {  return  file . isFile  ( ) ; }    @ Override public boolean particularCommand  ( )  {  boolean  success = true ;  try  {   success =   getFtpsClient  ( ) . completePendingCommand  ( ) ; }  catch (   IOException e )  {   LOGGER . error  ( "Error on command completePendingCommand of FTPClient" , e ) ; }  return success ; }    @ Override public  long getObjectSize  (  FTPFile file )  {  return  file . getSize  ( ) ; }    @ Override public boolean isLink  (  FTPFile file )  {  return  file . isSymbolicLink  ( ) ; }    @ Override public String getLink  (  FTPFile file )  {  return  file . getLink  ( ) ; }    @ Override public String getDirectoryserver  ( )  throws IOException  {  return   getFtpsClient  ( ) . printWorkingDirectory  ( ) ; }   public FTPSClient getFtpsClient  ( )  {  return ftpsClient ; }   public void setFtpsClient  (  FTPSClient ftpClient )  {    this . ftpsClient = ftpClient ; }    @ Override public Object getClientSource  ( )  {  return ftpsClient ; }    @ Override public void setFileType  (   int fileType )  throws IOException  {   ftpsClient . setFileType  ( fileType ) ; }   public boolean isSecurityMode  ( )  {  return securityMode ; }   public void setSecurityMode  (  boolean securityMode )  {    this . securityMode = securityMode ; }   public boolean isSecurityCert  ( )  {  return securityCert ; }   public void setSecurityCert  (  boolean securityCert )  {    this . securityCert = securityCert ; }   public String getProtocolSec  ( )  {  return protocolSec ; }   public void setProtocolSec  (  String protocolSec )  {    this . protocolSec = protocolSec ; }   public void checkIfCertificate  ( )  {  if  ( securityCert )  {   ftpsClient . setTrustManager  (  TrustManagerUtils . getValidateServerCertificateTrustManager  ( ) ) ;  KeyManager  keyManager = null ;  try  {   keyManager =  KeyManagerUtils . createClientKeyManager  (  new File  ( pathTokesytore ) , storePass ) ; }  catch (   IOException e )  {   LOGGER . error  ( "" , e ) ; }  catch (   GeneralSecurityException e )  {   LOGGER . error  ( "" , e ) ; }   ftpsClient . setKeyManager  ( keyManager ) ; } else  {   ftpsClient . setTrustManager  (  TrustManagerUtils . getAcceptAllTrustManager  ( ) ) ; } }    @ Override public  List  < FTPFile > listElements  (  String dirToList ,  KeedioFileFilter filter )  throws IOException  {   List  < FTPFile >  list =  new  ArrayList  < >  ( ) ;   FTPFile  [ ]  subFiles =   getFtpsClient  ( ) . listFiles  ( dirToList , filter ) ;   list =  Arrays . asList  ( subFiles ) ;  return list ; }    @ Override public  long getModifiedTime  (  FTPFile file )  {  return   file . getTimestamp  ( ) . getTimeInMillis  ( ) ; } }