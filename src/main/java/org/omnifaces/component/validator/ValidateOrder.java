  package    org . omnifaces . component . validator ;   import static    java . util . Arrays . asList ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . List ;  import   java . util . TreeSet ;  import    javax . faces . component . FacesComponent ;  import    javax . faces . component . UIInput ;  import    javax . faces . context . FacesContext ;  import    org . omnifaces . util . Callback ;  import    org . omnifaces . util . State ;  import    org . omnifaces . validator . MultiFieldValidator ;    @ FacesComponent  (  ValidateOrder . COMPONENT_TYPE )  @ SuppressWarnings  (  { "unchecked" , "rawtypes" } ) public class ValidateOrder  extends ValidateMultipleFields  {   public static final String  COMPONENT_TYPE = "org.omnifaces.component.validator.ValidateOrder" ;   private enum Type  {  LT  (  new   Callback . ReturningWithArgument  < Boolean ,  List  < Comparable > >  ( )  {    @ Override public Boolean invoke  (   List  < Comparable > values )  {  return   new  ArrayList  < Comparable >  (  new  TreeSet  < Comparable >  ( values ) ) . equals  ( values ) ; } } ) ,  LTE  (  new   Callback . ReturningWithArgument  < Boolean ,  List  < Comparable > >  ( )  {    @ Override public Boolean invoke  (   List  < Comparable > values )  {   List  < Comparable >  sortedValues =  new  ArrayList  < Comparable >  ( values ) ;   Collections . sort  ( sortedValues ) ;  return  sortedValues . equals  ( values ) ; } } ) ,  GT  (  new   Callback . ReturningWithArgument  < Boolean ,  List  < Comparable > >  ( )  {    @ Override public Boolean invoke  (   List  < Comparable > values )  {   List  < Comparable >  sortedValues =  new  ArrayList  < Comparable >  (  new  TreeSet  < Comparable >  ( values ) ) ;   Collections . reverse  ( sortedValues ) ;  return  sortedValues . equals  ( values ) ; } } ) ,  GTE  (  new   Callback . ReturningWithArgument  < Boolean ,  List  < Comparable > >  ( )  {    @ Override public Boolean invoke  (   List  < Comparable > values )  {   List  < Comparable >  sortedValues =  new  ArrayList  < Comparable >  ( values ) ;   Collections . sort  ( sortedValues ,  Collections . reverseOrder  ( ) ) ;  return  sortedValues . equals  ( values ) ; } } )  ;   private   Callback . ReturningWithArgument  < Boolean ,  List  < Comparable > >  callback ;   private Type  (    Callback . ReturningWithArgument  < Boolean ,  List  < Comparable > > callback )  {    this . callback = callback ; }   public boolean validateOrder  (   List  < Comparable > values )  {  return  callback . invoke  ( values ) ; } }   private static final String  DEFAULT_TYPE =   Type . LT . name  ( ) ;   private static final String  ERROR_INVALID_TYPE = "Invalid type '%s'. Only 'lt', 'lte', 'gt' and 'gte' are allowed." ;   private static final String  ERROR_VALUES_NOT_COMPARABLE = "All values must implement java.lang.Comparable." ;   private enum PropertyKeys  {  type  ; }   private final State  state =  new State  (  getStateHelper  ( ) ) ;    @ Override public boolean validateValues  (  FacesContext context ,   List  < UIInput > components ,   List  < Object > values )  {  try  {  Object  tmp = values ;   List  < Comparable >  comparableValues =  new  ArrayList  < Comparable >  (  (  List  < Comparable > ) tmp ) ;   comparableValues . removeAll  (  asList  ( null , "" ) ) ;  return   Type . valueOf  (   getType  ( ) . toUpperCase  ( ) ) . validateOrder  ( comparableValues ) ; }  catch (   ClassCastException e )  {  throw  new IllegalArgumentException  ( ERROR_VALUES_NOT_COMPARABLE , e ) ; } }   public String getType  ( )  {  return  state . get  (  PropertyKeys . type , DEFAULT_TYPE ) ; }   public void setType  (  String type )  {  try  {   Type . valueOf  (  type . toUpperCase  ( ) ) ; }  catch (   IllegalArgumentException e )  {  throw  new IllegalArgumentException  (  String . format  ( ERROR_INVALID_TYPE , type ) , e ) ; }   state . put  (  PropertyKeys . type , type ) ; } }