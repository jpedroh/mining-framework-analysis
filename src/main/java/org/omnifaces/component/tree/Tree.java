  package    org . omnifaces . component . tree ;   import static     org . omnifaces . util . Components . getClosestParent ;  import   java . util . HashMap ;  import   java . util . Map ;  import   javax . el . ValueExpression ;  import    javax . faces . component . FacesComponent ;  import    javax . faces . component . NamingContainer ;  import    javax . faces . component . UIComponent ;  import    javax . faces . component . UINamingContainer ;  import     javax . faces . component . visit . VisitCallback ;  import     javax . faces . component . visit . VisitContext ;  import     javax . faces . component . visit . VisitResult ;  import    javax . faces . context . FacesContext ;  import    javax . faces . event . AbortProcessingException ;  import    javax . faces . event . FacesEvent ;  import    javax . faces . event . PhaseId ;  import    org . omnifaces . component . EditableValueHolderStateHelper ;  import    org . omnifaces . event . FacesEventWrapper ;  import     org . omnifaces . model . tree . AbstractTreeModel ;  import     org . omnifaces . model . tree . ListTreeModel ;  import     org . omnifaces . model . tree . SortedTreeModel ;  import     org . omnifaces . model . tree . TreeModel ;  import    org . omnifaces . util . Callback ;  import    org . omnifaces . util . State ;    @ FacesComponent  (  Tree . COMPONENT_TYPE )  @ SuppressWarnings  ( "rawtypes" ) public class Tree  extends TreeFamily  implements  NamingContainer  {   public static final String  COMPONENT_TYPE = "org.omnifaces.component.tree.Tree" ;   private static final String  ERROR_EXPRESSION_DISALLOWED = "A value expression is disallowed on 'var' and 'varNode' attributes of Tree." ;   private static final String  ERROR_INVALID_MODEL = "Tree accepts only model of type TreeModel. Encountered model of type '%s'." ;   private static final String  ERROR_NESTING_DISALLOWED = "Nesting Tree components is disallowed. Use TreeNode instead to markup specific levels." ;   private static final String  ERROR_NO_CHILDREN = "Tree must have children of type TreeNode. Currently none are encountered." ;   private static final String  ERROR_INVALID_CHILD = "Tree accepts only children of type TreeNode. Encountered child of type '%s'." ;   private static final String  ERROR_DUPLICATE_NODE = "TreeNode with level '%s' is already declared. Choose a different level or remove it." ;   private enum PropertyKeys  {  value ,  var ,  varNode  ; }   private final State  state =  new State  (  getStateHelper  ( ) ) ;   private TreeModel  model ;   private  Map  < Integer , TreeNode >  nodes ;   private TreeModel  currentModelNode ;    @ Override public String getContainerClientId  (  FacesContext context )  {  String  containerClientId =  super . getContainerClientId  ( context ) ;  String  currentModelNodeIndex =   (  currentModelNode != null ) ?  currentModelNode . getIndex  ( ) : null ;  if  (  currentModelNodeIndex != null )  {   containerClientId =     new StringBuilder  ( containerClientId ) . append  (  UINamingContainer . getSeparatorChar  ( context ) ) . append  ( currentModelNodeIndex ) . toString  ( ) ; }  return containerClientId ; }    @ Override public void setValueExpression  (  String name ,  ValueExpression binding )  {  if  (     PropertyKeys . var . toString  ( ) . equals  ( name ) ||    PropertyKeys . varNode . toString  ( ) . equals  ( name ) )  {  throw  new IllegalArgumentException  ( ERROR_EXPRESSION_DISALLOWED ) ; }   super . setValueExpression  ( name , binding ) ; }    @ Override public void queueEvent  (  FacesEvent event )  {   super . queueEvent  (  new TreeFacesEvent  ( event , this ,  getCurrentModelNode  ( ) ) ) ; }    @ Override protected void validateHierarchy  ( )  {  if  (   getClosestParent  ( this ,  Tree . class ) != null )  {  throw  new IllegalArgumentException  ( ERROR_NESTING_DISALLOWED ) ; }  if  (   getChildCount  ( ) == 0 )  {  throw  new IllegalArgumentException  ( ERROR_NO_CHILDREN ) ; } }    @ Override protected void process  (   final FacesContext context ,   final PhaseId phaseId )  {  if  (  !  isRendered  ( ) )  {  return ; }   process  ( context ,  getModel  ( phaseId ) ,  new   Callback . Returning  < Void >  ( )  {    @ Override public Void invoke  ( )  {   processTreeNode  ( context , phaseId ) ;  return null ; } } ) ; }    @ Override public boolean visitTree  (   final VisitContext context ,   final VisitCallback callback )  {  if  (  !  isVisitable  ( context ) )  {  return false ; }  return  process  (  context . getFacesContext  ( ) ,  getModel  (  PhaseId . ANY_PHASE ) ,  new   Callback . Returning  < Boolean >  ( )  {    @ Override public Boolean invoke  ( )  {  VisitResult  result =  context . invokeVisitCallback  (  Tree . this , callback ) ;  if  (  result ==  VisitResult . COMPLETE )  {  return true ; }  if  (   result ==  VisitResult . ACCEPT &&  !   context . getSubtreeIdsToVisit  (  Tree . this ) . isEmpty  ( ) )  {  return  visitTreeNode  ( context , callback ) ; }  return false ; } } ) ; }    @ Override public void broadcast  (  FacesEvent event )  throws AbortProcessingException  {  if  (  event instanceof TreeFacesEvent )  {  FacesContext  context =  FacesContext . getCurrentInstance  ( ) ;  TreeFacesEvent  treeEvent =  ( TreeFacesEvent ) event ;   final FacesEvent  wrapped =  treeEvent . getWrapped  ( ) ;   process  ( context ,  treeEvent . getNode  ( ) ,  new   Callback . Returning  < Void >  ( )  {    @ Override public Void invoke  ( )  {    wrapped . getComponent  ( ) . broadcast  ( wrapped ) ;  return null ; } } ) ; } else  {   super . broadcast  ( event ) ; } }   protected void processTreeNode  (   final FacesContext context ,   final PhaseId phaseId )  {   processTreeNode  ( phaseId ,  new   Callback . ReturningWithArgument  < Void , TreeNode >  ( )  {    @ Override public Void invoke  (  TreeNode treeNode )  {  if  (  treeNode != null )  {   treeNode . process  ( context , phaseId ) ; }  return null ; } } ) ; }   protected boolean visitTreeNode  (   final VisitContext context ,   final VisitCallback callback )  {  return  processTreeNode  (  PhaseId . ANY_PHASE ,  new   Callback . ReturningWithArgument  < Boolean , TreeNode >  ( )  {    @ Override public Boolean invoke  (  TreeNode treeNode )  {  if  (  treeNode != null )  {  return  treeNode . visitTree  ( context , callback ) ; }  return false ; } } ) ; }   private  <  R > R process  (  FacesContext context ,  TreeModel node ,    Callback . Returning  < R > callback )  {   Object  [ ]  originalVars =  captureOriginalVars  ( context ) ;  TreeModel  originalModelNode = currentModelNode ;   pushComponentToEL  ( context , null ) ;  try  {   setCurrentModelNode  ( context , node ) ;  return  callback . invoke  ( ) ; }  finally  {   popComponentFromEL  ( context ) ;   setCurrentModelNode  ( context , originalModelNode ) ;   setVars  ( context , originalVars ) ; } }   private  <  R > R processTreeNode  (  PhaseId phaseId ,    Callback . ReturningWithArgument  < R , TreeNode > callback )  {  TreeNode  treeNode = null ;  if  (  !  currentModelNode . isLeaf  ( ) )  {   treeNode =   getNodes  ( phaseId ) . get  (  currentModelNode . getLevel  ( ) ) ;  if  (  treeNode == null )  {   treeNode =   getNodes  ( phaseId ) . get  ( null ) ; } }  return  callback . invoke  ( treeNode ) ; }   private  Map  < Integer , TreeNode > getNodes  (  PhaseId phaseId )  {  if  (   phaseId ==  PhaseId . RENDER_RESPONSE ||  nodes == null )  {   nodes =  new  HashMap  < Integer , TreeNode >  (  getChildCount  ( ) ) ;  for ( UIComponent child :  getChildren  ( ) )  {  if  (  child instanceof TreeNode )  {  TreeNode  node =  ( TreeNode ) child ;  if  (   nodes . put  (  node . getLevel  ( ) , node ) != null )  {  throw  new IllegalArgumentException  (  String . format  ( ERROR_DUPLICATE_NODE ,  node . getLevel  ( ) ) ) ; } } else  {  throw  new IllegalArgumentException  (  String . format  ( ERROR_INVALID_CHILD ,   child . getClass  ( ) . getName  ( ) ) ) ; } } }  return nodes ; }   private TreeModel getModel  (  PhaseId phaseId )  {  if  (   phaseId ==  PhaseId . RENDER_RESPONSE ||  model == null )  {  Object  value =  getValue  ( ) ;  if  (  value == null )  {   model =  new ListTreeModel  ( ) ; } else  if  (  value instanceof TreeModel )  {   model =  ( TreeModel ) value ; } else  {  throw  new IllegalArgumentException  (  String . format  ( ERROR_INVALID_MODEL ,   value . getClass  ( ) . getName  ( ) ) ) ; } }  return model ; }   private  Object  [ ] captureOriginalVars  (  FacesContext context )  {   Map  < String , Object >  requestMap =   context . getExternalContext  ( ) . getRequestMap  ( ) ;   String  [ ]  names =  {  getVar  ( ) ,  getVarNode  ( ) } ;   Object  [ ]  vars =  new Object  [  names . length ] ;  for (   int  i = 0 ;  i <  names . length ;  i ++ )  {  if  (   names [ i ] != null )  {    vars [ i ] =  requestMap . get  (  names [ i ] ) ; } }  return vars ; }   private void setVars  (  FacesContext context ,  Object ...  vars )  {   Map  < String , Object >  requestMap =   context . getExternalContext  ( ) . getRequestMap  ( ) ;   String  [ ]  names =  {  getVar  ( ) ,  getVarNode  ( ) } ;  for (   int  i = 0 ;  i <  names . length ;  i ++ )  {  if  (   names [ i ] != null )  {  if  (   vars [ i ] != null )  {   requestMap . put  (  names [ i ] ,  vars [ i ] ) ; } else  {   requestMap . remove  (  names [ i ] ) ; } } } }   protected void setCurrentModelNode  (  FacesContext context ,  TreeModel currentModelNode )  {   EditableValueHolderStateHelper . save  ( context ,  getStateHelper  ( ) ,  getFacetsAndChildren  ( ) ) ;    this . currentModelNode = currentModelNode ;   setVars  ( context ,  (   currentModelNode != null ?  currentModelNode . getData  ( ) : null ) , currentModelNode ) ;   EditableValueHolderStateHelper . restore  ( context ,  getStateHelper  ( ) ,  getFacetsAndChildren  ( ) ) ; }   protected TreeModel getCurrentModelNode  ( )  {  return currentModelNode ; }   public Object getValue  ( )  {  return  state . get  (  PropertyKeys . value ) ; }   public void setValue  (  Object value )  {   state . put  (  PropertyKeys . value , value ) ; }   public String getVar  ( )  {  return  state . get  (  PropertyKeys . var ) ; }   public void setVar  (  String var )  {   state . put  (  PropertyKeys . var , var ) ; }   public String getVarNode  ( )  {  return  state . get  (  PropertyKeys . varNode ) ; }   public void setVarNode  (  String varNode )  {   state . put  (  PropertyKeys . varNode , varNode ) ; }   private static class TreeFacesEvent  extends FacesEventWrapper  {   private static final  long  serialVersionUID =  - 7751061713837227515L ;   private TreeModel  node ;   public TreeFacesEvent  (  FacesEvent wrapped ,  Tree tree ,  TreeModel node )  {  super  ( wrapped , tree ) ;    this . node = node ; }   public TreeModel getNode  ( )  {  return node ; } } }