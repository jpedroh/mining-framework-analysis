  package    org . omnifaces . component . tree ;   import static     org . omnifaces . util . Components . getClosestParent ;  import static     org . omnifaces . util . Components . shouldVisitSkipIteration ;  import static     org . omnifaces . util . Components . validateHasParent ;  import   java . io . IOException ;  import    javax . faces . component . FacesComponent ;  import    javax . faces . component . UIComponent ;  import     javax . faces . component . visit . VisitCallback ;  import     javax . faces . component . visit . VisitContext ;  import    javax . faces . context . FacesContext ;  import    javax . faces . event . PhaseId ;  import     org . omnifaces . model . tree . TreeModel ;  import    org . omnifaces . util . Callback ;    @ FacesComponent  (  TreeNodeItem . COMPONENT_TYPE ) public class TreeNodeItem  extends TreeFamily  {   public static final String  COMPONENT_TYPE = "org.omnifaces.component.tree.TreeNodeItem" ;   private static final String  ERROR_NESTING_DISALLOWED = "Nesting TreeNodeItem components is disallowed. Use TreeNode instead to markup specific levels." ;    @ Override protected void validateHierarchy  ( )  {   validateHasParent  ( this ,  Tree . class ) ;  if  (   getClosestParent  ( this ,  TreeNodeItem . class ) != null )  {  throw  new IllegalArgumentException  ( ERROR_NESTING_DISALLOWED ) ; } }    @ Override public void encodeAll  (  FacesContext context )  throws IOException  {   encodeChildren  ( context ) ; }    @ Override  @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) protected void process  (   final FacesContext context ,   final PhaseId phaseId )  {  if  (   getChildCount  ( ) == 0 )  {  return ; }   process  ( context ,  new   Callback . ReturningWithArgument  < Void , Tree >  ( )  {    @ Override public Void invoke  (  Tree tree )  {  if  (   tree . getCurrentModelNode  ( ) != null )  {  for ( TreeModel childModelNode :  (  Iterable  < TreeModel > )  tree . getCurrentModelNode  ( ) )  {   tree . setCurrentModelNode  ( context , childModelNode ) ;  if  (  isRendered  ( ) )  {   processSuper  ( context , phaseId ) ; } } }  return null ; } } ) ; }    @ Override  @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public boolean visitTree  (   final VisitContext context ,   final VisitCallback callback )  {  if  (  shouldVisitSkipIteration  ( context ) )  {  return  super . visitTree  ( context , callback ) ; }  if  (   !  isVisitable  ( context ) ||   getChildCount  ( ) == 0 )  {  return false ; }  return  process  (  context . getFacesContext  ( ) ,  new   Callback . ReturningWithArgument  < Boolean , Tree >  ( )  {    @ Override public Boolean invoke  (  Tree tree )  {  if  (   tree . getCurrentModelNode  ( ) != null )  {  for ( TreeModel childModelNode :  (  Iterable  < TreeModel > )  tree . getCurrentModelNode  ( ) )  {   tree . setCurrentModelNode  (  context . getFacesContext  ( ) , childModelNode ) ;  if  (  TreeNodeItem . super . visitTree  ( context , callback ) )  {  return true ; } } }  return false ; } } ) ; }    @ SuppressWarnings  ( "rawtypes" ) private  <  R > R process  (  FacesContext context ,    Callback . ReturningWithArgument  < R , Tree > callback )  {  Tree  tree =  getClosestParent  ( this ,  Tree . class ) ;  TreeModel  originalModelNode =  tree . getCurrentModelNode  ( ) ;  try  {  return  callback . invoke  ( tree ) ; }  finally  {   tree . setCurrentModelNode  ( context , originalModelNode ) ; } } }