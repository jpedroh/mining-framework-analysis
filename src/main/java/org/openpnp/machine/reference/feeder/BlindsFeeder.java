  package     org . openpnp . machine . reference . feeder ;   import   java . awt . Color ;  import    java . awt . geom . AffineTransform ;  import    java . awt . geom . NoninvertibleTransformException ;  import    java . awt . geom . Point2D ;  import    java . awt . image . BufferedImage ;  import   java . io . File ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . Comparator ;  import   java . util . List ;  import   javax . swing . Action ;  import     org . apache . commons . io . IOUtils ;  import    org . opencv . core . Mat ;  import    org . opencv . core . RotatedRect ;  import    org . opencv . core . Size ;  import    org . opencv . imgcodecs . Imgcodecs ;  import    org . opencv . imgproc . Imgproc ;  import   org . openpnp . ConfigurationListener ;  import    org . openpnp . gui . MainFrame ;  import     org . openpnp . gui . support . Wizard ;  import     org . openpnp . machine . reference . ReferenceFeeder ;  import     org . openpnp . machine . reference . ReferenceMachine ;  import      org . openpnp . machine . reference . driver . GcodeDriver ;  import       org . openpnp . machine . reference . feeder . wizards . BlindsFeederConfigurationWizard ;  import    org . openpnp . model . Configuration ;  import    org . openpnp . model . Length ;  import    org . openpnp . model . LengthUnit ;  import    org . openpnp . model . Location ;  import    org . openpnp . model . Point ;  import    org . openpnp . spi . Camera ;  import    org . openpnp . spi . Feeder ;  import    org . openpnp . spi . Head ;  import    org . openpnp . spi . Machine ;  import    org . openpnp . spi . MachineListener ;  import    org . openpnp . spi . Nozzle ;  import    org . openpnp . spi . NozzleTip ;  import    org . openpnp . spi . PropertySheetHolder ;  import    org . openpnp . util . HslColor ;  import    org . openpnp . util . MovableUtils ;  import    org . openpnp . util . OpenCvUtils ;  import    org . openpnp . util . TravellingSalesman ;  import    org . openpnp . util . VisionUtils ;  import    org . openpnp . vision . FluentCv ;  import     org . openpnp . vision . Ransac . Line ;  import     org . openpnp . vision . pipeline . CvPipeline ;  import    org . pmw . tinylog . Logger ;  import    org . simpleframework . xml . Attribute ;  import    org . simpleframework . xml . Element ;  import     org . openpnp . machine . reference . ReferenceNozzleTip ;  import    org . openpnp . model . Part ;  import    org . openpnp . vision . SimpleHistogram ;   public class BlindsFeeder  extends ReferenceFeeder  {   static public final Location  nullLocation =  new Location  (  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private Location  fiducial1Location =  new Location  (  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private Location  fiducial2Location =  new Location  (  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private Location  fiducial3Location =  new Location  (  LengthUnit . Millimeters ) ;    @ Attribute  (  required = false ) private boolean  normalize = true ;    @ Element  (  required = false ) private Length  tapeLength =  new Length  ( 0 ,  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private Length  feederExtent =  new Length  ( 0 ,  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private Length  pocketCenterline =  new Length  ( 0 ,  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private Length  pocketPitch =  new Length  ( 0 ,  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private Length  pocketSize =  new Length  ( 0 ,  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private CvPipeline  pipeline =  createDefaultPipeline  ( ) ;    @ Attribute  (  required = false ) private boolean  visionEnabled = true ;    @ Attribute private  int  feedCount = 0 ;    @ Attribute  (  required = false ) private  int  feederNo = 0 ;    @ Attribute  (  required = false ) private  int  feedersTotal = 0 ;    @ Attribute  (  required = false ) private  int  pocketCount = 0 ;    @ Attribute  (  required = false ) private  int  firstPocket = 1 ;    @ Attribute  (  required = false ) private  int  lastPocket = 0 ;    @ Element  (  required = false ) private Length  sprocketPitch =  new Length  ( 4 ,  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private Length  edgeOpenDistance =  new Length  ( 2 ,  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private Length  edgeClosedDistance =  new Length  ( 2 ,  LengthUnit . Millimeters ) ;    @ Element  (  required = false ) private Length  pushZOffset =  new Length  ( 0.25 ,  LengthUnit . Millimeters ) ;    @ Attribute  (  required = false ) private  double  pushSpeed = 0.025 ;    @ Attribute  (  required = false ) private  int  fidLocMaxPasses = 3 ;    @ Attribute  (  required = false ) private  double  fidLocToleranceMm = 0.5 ;    @ Attribute  (  required = false ) private  double  pocketPosToleranceMm = 0.1 ;   private Length  coverPosition =  new Length  (  Double . NaN ,  LengthUnit . Millimeters ) ;   private Length  pocketDistance =  new Length  (  Double . NaN ,  LengthUnit . Millimeters ) ;   private boolean  calibrating = false ;   private boolean  calibrated = false ;    @ Override public boolean isParentIdChangable  ( )  {  return false ; }   private void checkHomedState  (  Machine machine )  {  if  (  !  machine . isHomed  ( ) )  {   this . setCalibrated  ( false ) ;   this . setCoverPosition  (  new Length  (  Double . NaN ,  LengthUnit . Millimeters ) ) ; } }   public BlindsFeeder  ( )  {    Configuration . get  ( ) . addListener  (  new  ConfigurationListener . Adapter  ( )  {    @ Override public void configurationComplete  (  Configuration configuration )  throws Exception  {     Configuration . get  ( ) . getMachine  ( ) . addListener  (  new  MachineListener . Adapter  ( )  {    @ Override public void machineHeadActivity  (  Machine machine ,  Head head )  {   checkHomedState  ( machine ) ; }    @ Override public void machineEnabled  (  Machine machine )  {   checkHomedState  ( machine ) ; } } ) ; } } ) ; }   private void recalculateGeometry  ( )  {  if  (   pocketPitch . getValue  ( ) > 0.0 )  {  boolean  isSmallPitch =   Math . round  (  sprocketPitch . divide  ( pocketPitch ) ) == 2 ;   setPocketCount  (   (  int )  (  Math . floor  (  tapeLength . divide  ( pocketPitch ) ) ) +  (  isSmallPitch ? 1 : 0 ) ) ;   double  pitchRelativePosition =  (   coverType ==  CoverType . BlindsCover ? 0.25 : 0.5 ) ;  Length  pocketAlign =  sprocketPitch . multiply  (  Math . round  (    pocketPitch . multiply  ( pitchRelativePosition ) . divide  ( sprocketPitch ) - 0.001 ) ) ;   setPocketDistance  (   sprocketPitch . multiply  (  isSmallPitch ? 0.0 : 0.5 ) . add  ( pocketAlign ) ) ; } }   private void assertCalibration  ( )  throws Exception  {  if  (  isVisionEnabled  ( ) )  {  if  (  !  isCalibrated  ( ) )  {   calibrateFeederLocations  ( ) ; } }   recalculateGeometry  ( ) ; }   public Location getUncalibratedPickLocation  (   double pocketNumber )  {   recalculateGeometry  ( ) ;  Length  feederX =    pocketPitch . multiply  (  pocketNumber - 1.0 ) . convertToUnits  (   getLocation  ( ) . getUnits  ( ) ) . add  ( pocketDistance ) ;  Length  feederY =  pocketCenterline . convertToUnits  (   getLocation  ( ) . getUnits  ( ) ) ;  Location  feederLocation =  new Location  (   getLocation  ( ) . getUnits  ( ) ,  feederX . getValue  ( ) ,  feederY . getValue  ( ) ,   getLocation  ( ) . getZ  ( ) ,  getPickRotationInTape  ( ) ) ;  Location  machineLocation =  transformFeederToMachineLocation  ( feederLocation ) ;  return machineLocation ; }   public Location getPickLocation  (   double pocketNumber )  throws Exception  {   assertCalibration  ( ) ;  return  getUncalibratedPickLocation  ( pocketNumber ) ; }    @ Override public Location getPickLocation  ( )  throws Exception  {  return  getPickLocation  (  this . getFedPocketNumber  ( ) ) ; }   private  int getFedPocketNumber  ( )  {  return    this . getFeedCount  ( ) +  this . getFirstPocket  ( ) - 1 ; }   public boolean isCoverOpenState  (  boolean openState )  {  if  (  coverType ==  CoverType . NoCover )  {  return  openState == true ; }  if  (  Double . isNaN  (  coverPosition . getValue  ( ) ) )  {  return false ; }  if  (  coverType ==  CoverType . BlindsCover )  {   double  positionError =  Math . abs  (    coverPosition . subtract  ( pocketDistance ) . convertToUnits  (  LengthUnit . Millimeters ) . getValue  ( ) ) ;  return   (  positionError < pocketPosToleranceMm ) == openState ; }  if  (  coverType ==  CoverType . PushCover )  {  return   (   coverPosition . getValue  ( ) > 0.0 ) == openState ; }  return false ; }   public boolean isCoverOpen  ( )  {  return  isCoverOpenState  ( true ) ; }   public boolean isCoverClosed  ( )  {  return  isCoverOpenState  ( false ) ; }   public boolean isCoverOpenChecked  ( )  throws Exception  {   assertCalibration  ( ) ;  if  (  Double . isNaN  (  coverPosition . getValue  ( ) ) )  {  Camera  camera =     Configuration . get  ( ) . getMachine  ( ) . getDefaultHead  ( ) . getDefaultCamera  ( ) ;  Location  cameraOpenPosition =  getPickLocation  (  Math . floor  (   (   this . getFirstPocket  ( ) +  this . getLastPocket  ( ) ) / 2.0 ) ) ;   MovableUtils . moveToLocationAtSafeZ  ( camera , cameraOpenPosition ) ;   findCoverPosition  ( camera ) ;   Logger . debug  ( "[BlindsFeeder.isCoverOpenChecked] pocketPosition: {}, pocketDistance {}, error {}" , coverPosition , pocketDistance ,  coverPosition . subtract  ( pocketDistance ) ) ; }  return  isCoverOpen  ( ) ; }   public void feed  (  Nozzle nozzle )  throws Exception  {  if  (    getFirstPocket  ( ) +  getFeedCount  ( ) >  getLastPocket  ( ) )  {  throw  new Exception  (     "Feeder " +  getName  ( ) + " part " +   getPart  ( ) . getId  ( ) + " empty." ) ; }   assertCalibration  ( ) ;  if  (  coverType ==  CoverType . BlindsCover )  {  if  (  coverActuation ==  CoverActuation . CheckOpen )  {  if  (  !  isCoverOpenChecked  ( ) )  {   coverPosition =  new Length  (  Double . NaN ,  LengthUnit . Millimeters ) ;  throw  new Exception  (     "Feeder " +  getName  ( ) + " " +   getPart  ( ) . getName  ( ) + ": cover is not open. Please open manually." ) ; } } else  if  (   coverActuation ==  CoverActuation . OpenOnFirstUse ||  coverActuation ==  CoverActuation . OpenOnJobStart )  {  if  (  !  isCoverOpen  ( ) )  {   actuateCover  ( nozzle , true , true , true ) ; } } } else  if  (  coverType ==  CoverType . PushCover )  {   actuateCover  ( nozzle , true ) ; }   setFeedCount  (   getFeedCount  ( ) + 1 ) ; }   public class FindFeatures  {   private Camera  camera ;   private CvPipeline  pipeline ;   private  long  showResultMilliseconds ;   private  List  < RotatedRect >  blinds ;   private  List  < RotatedRect >  fiducials ;   private  List  < Line >  lines ;   private  double  pocketSizeMm ;   private  double  pocketPositionMm ;   private  double  pocketPitchMm ;   private  double  pocketCenterlineMm ;   public FindFeatures  (  Camera camera ,  CvPipeline pipeline ,   final  long showResultMilliseconds )  {    this . camera = camera ;    this . pipeline = pipeline ;    this . showResultMilliseconds = showResultMilliseconds ; }   public  List  < RotatedRect > getBlinds  ( )  {  return blinds ; }   public  List  < RotatedRect > getFiducials  ( )  {  return fiducials ; }   public  List  < Line > getLines  ( )  {  return lines ; }   public  double getPocketSizeMm  ( )  {  return pocketSizeMm ; }   public  double getPocketPositionMm  ( )  {  return pocketPositionMm ; }   public  double getPocketPitchMm  ( )  {  return pocketPitchMm ; }   public  double getPocketCenterlineMm  ( )  {  return pocketCenterlineMm ; }   private void drawRotatedRects  (  Mat mat ,   List  < RotatedRect > features ,  Color color )  {  if  (   features == null ||  features . isEmpty  ( ) )  {  return ; }  Color  centerColor =   new HslColor  ( color ) . getComplementary  ( ) ;  for ( RotatedRect rect : features )  {   double  x =   rect . center . x ;   double  y =   rect . center . y ;   FluentCv . drawRotatedRect  ( mat , rect , color , 3 ) ;   Imgproc . circle  ( mat ,  new    org . opencv . core . Point  ( x , y ) , 2 ,  FluentCv . colorToScalar  ( centerColor ) , 3 ) ; } }   private void drawLines  (  Mat mat ,   List  < Line > lines ,  Color color )  {  if  (   lines == null ||  lines . isEmpty  ( ) )  {  return ; }  for ( Line line : lines )  {   Imgproc . line  ( mat ,  line . a ,  line . b ,  FluentCv . colorToScalar  ( color ) , 2 ) ; } }   private void drawPartNumbers  (  Mat mat ,  Color color )  {    int  [ ]  baseLine = null ;   double  feederPocketPitchMm =    getPocketPitch  ( ) . convertToUnits  (  LengthUnit . Millimeters ) . getValue  ( ) ;  if  (  feederPocketPitchMm < 1. )  {  return ; }   double  feederPocketSizeMm =    getPocketSize  ( ) . convertToUnits  (  LengthUnit . Millimeters ) . getValue  ( ) ;   double  fontScale = 1.0 ;  Size  size =  Imgproc . getTextSize  (  String . valueOf  (  getPocketCount  ( ) ) ,  Imgproc . FONT_HERSHEY_PLAIN , fontScale , 2 , baseLine ) ;  Location  textSizeMm =    camera . getUnitsPerPixel  ( ) . multiply  (  size . width ,  size . height , 0. , 0. ) . convertToUnits  (  LengthUnit . Millimeters ) ;  if  (   textSizeMm . getY  ( ) < 0.0 )  {   textSizeMm =  textSizeMm . multiply  ( 1.0 ,  - 1.0 , 0.0 , 0.0 ) ; }   final  double  minFontSizeMm = 0.6 ;  if  (   textSizeMm . getY  ( ) < minFontSizeMm )  {   fontScale =  minFontSizeMm /  textSizeMm . getY  ( ) ;   textSizeMm =  textSizeMm . multiply  ( fontScale , fontScale , 0.0 , 0.0 ) ; }   double  textSizePitchCount =   textSizeMm . getLinearDistanceTo  ( nullLocation ) / feederPocketPitchMm ;   int  step ;  if  (  textSizePitchCount < 0.75 )  {   step = 1 ; } else  if  (  textSizePitchCount < 1.5 )  {   step = 2 ; } else  if  (  textSizePitchCount < 4 )  {   step = 5 ; } else  {  return ; }  for (   int  i = step ;  i <=  getPocketCount  ( ) ;  i += step )  {  String  text =  String . valueOf  ( i ) ;  Size  textSize =  Imgproc . getTextSize  ( text ,  Imgproc . FONT_HERSHEY_PLAIN , fontScale , 2 , baseLine ) ;  Location  partLocation =   getUncalibratedPickLocation  ( i ) . convertToUnits  (  LengthUnit . Millimeters ) ;  Location  textLocation =  transformMachineToFeederLocation  ( partLocation ) ;   textLocation =  textLocation . add  (  new Location  (  LengthUnit . Millimeters , 0. ,    - feederPocketSizeMm * 0.5 -   textSizeMm . getY  ( ) * 0.25 , 0. , 0. ) ) ;   textLocation =   transformFeederToMachineLocation  ( textLocation ) . convertToUnits  (  LengthUnit . Millimeters ) ;  Point  p =  VisionUtils . getLocationPixels  ( camera , textLocation ) ;  if  (      p . x > 0 &&   p . x <  camera . getWidth  ( ) &&   p . y > 0 &&   p . y <  camera . getHeight  ( ) )  {   double  dx =   textLocation . getX  ( ) -  partLocation . getX  ( ) ;   double  dy =   textLocation . getY  ( ) -  partLocation . getY  ( ) ;   double  alignX ,  alignY ;  if  (   Math . abs  ( dx ) >  Math . abs  ( dy ) )  {  if  (  dx < 0 )  {   alignX =  -  textSize . width ;   alignY =   textSize . height / 2 ; } else  {   alignX = 0. ;   alignY =   textSize . height / 2 ; } } else  {  if  (  dy > 0 )  {   alignX =   -  textSize . width / 2 ;   alignY = 0.0 ; } else  {   alignX =   -  textSize . width / 2 ;   alignY =  textSize . height ; } }   Imgproc . putText  ( mat , text ,  new    org . opencv . core . Point  (   p . x + alignX ,   p . y + alignY ) ,  Imgproc . FONT_HERSHEY_PLAIN , fontScale ,  FluentCv . colorToScalar  ( color ) , 2 , 0 , false ) ; } } }   private  double angleNorm  (   double angle )  {  while  (  angle > 45 )  {   angle -= 90 ; }  while  (  angle <  - 45 )  {   angle += 90 ; }  return angle ; }    @ SuppressWarnings  ( "unchecked" ) public FindFeatures invoke  ( )  throws Exception  {   List  < RotatedRect >  results = null ;  try  {   results =  (  (  List  < RotatedRect > )   pipeline . getResult  (  VisionUtils . PIPELINE_RESULTS_NAME ) . model ) ;  if  (  results == null )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": No features found." ) ; }  Location  mmScale =   camera . getUnitsPerPixel  ( ) . convertToUnits  (  LengthUnit . Millimeters ) ;   final  double  fidMin = 1.4 ;   final  double  fidMax = 2.3 ;   final  double  fidAspect = 1.3 ;   final  double  tolerance = 1.4 ;   double  w =     getPocketPitch  ( ) . convertToUnits  (  LengthUnit . Millimeters ) . getValue  ( ) * 0.5 ;   double  h =    getPocketSize  ( ) . convertToUnits  (  LengthUnit . Millimeters ) . getValue  ( ) ;   double  blindMin =   Math . min  ( w , h ) / tolerance ;   double  blindMax =   Math . max  ( w , h ) * tolerance ;   double  blindAspect =    tolerance * tolerance * blindMax / blindMin ;  if  (  blindMax == 0 )  {   blindMax = 22 ;   blindAspect = 2 ; }  if  (  blindMin == 0 )  {   blindMin = 0.5 ;   blindAspect = 3 ; }   double  positionTolerance = 5 ;   double  angleTolerance = 20 ;   double  pocketSizePreset =   pocketSize . convertToUnits  (  LengthUnit . Millimeters ) . getValue  ( ) ;  if  (  pocketSizePreset > 0 )  {   positionTolerance =  pocketSizePreset * 0.45 ; }   double  pocketRange =   Math . max  ( w , 2 ) * 3.5 ;  Location  cameraFeederLocation =   transformMachineToFeederLocation  (  camera . getLocation  ( ) ) . convertToUnits  (  LengthUnit . Millimeters ) ;   double  cameraFeederX =  cameraFeederLocation . getX  ( ) ;   double  cameraFeederY =  cameraFeederLocation . getY  ( ) ;  boolean  angleTolerant =    BlindsFeeder . nullLocation . equals  (  getFiducial1Location  ( ) ) ||   BlindsFeeder . nullLocation . equals  (  getFiducial2Location  ( ) ) ;  boolean  positionTolerant = angleTolerant ;   blinds =  new  ArrayList  < >  ( ) ;   fiducials =  new  ArrayList  < >  ( ) ;  SimpleHistogram  histogramUpper =  new SimpleHistogram  ( 0.1 ) ;  SimpleHistogram  histogramLower =  new SimpleHistogram  ( 0.1 ) ;  for ( RotatedRect result : results )  {     org . opencv . core . Point  points  [ ] =  new    org . opencv . core . Point  [ 4 ] ;   result . points  ( points ) ;  boolean  isAtMargin = false ;  for (   int  i = 0 ;  i < 4 ;  i ++ )  {  if  (       points [ i ] . x <= 2 ||    points [ i ] . x >=   camera . getWidth  ( ) - 2 ||    points [ i ] . y <= 2 ||    points [ i ] . y >=   camera . getHeight  ( ) - 2 )  {   isAtMargin = true ; }   i ++ ; }  if  (  ! isAtMargin )  {  Location  center =   transformMachineToFeederLocation  (  VisionUtils . getPixelLocation  ( camera ,   result . center . x ,   result . center . y ) ) . convertToUnits  (  LengthUnit . Millimeters ) ;   double  angle =  transformPixelToFeederAngle  (  result . angle ) ;  Location  mmSize =  mmScale . multiply  (   result . size . width ,   result . size . height , 0 , 0 ) ;  if  (  positionTolerant ||   cameraFeederLocation . getLinearDistanceTo  ( center ) < positionTolerance )  {  if  (  angleTolerant ||   Math . abs  (  angleNorm  (  angle - 45 ) ) < angleTolerance )  {  if  (        mmSize . getX  ( ) > fidMin &&   mmSize . getX  ( ) < fidMax &&   mmSize . getY  ( ) > fidMin &&   mmSize . getY  ( ) < fidMax &&    mmSize . getX  ( ) /  mmSize . getY  ( ) < fidAspect &&    mmSize . getY  ( ) /  mmSize . getX  ( ) < fidAspect )  {   fiducials . add  ( result ) ;   Logger . debug  ( "[BlindsFeeder] accepted fiducal candidate: result {}, mmSize {}" , result , mmSize ) ; } else  {   Logger . debug  ( "[BlindsFeeder] dismissed fiducal candidate: result {}, mmSize {}" , result , mmSize ) ; } } else  {   Logger . debug  ( "[BlindsFeeder] dismissed fiducal candidate: result {}, angle {}" , result , angle ) ; } } else  {   Logger . debug  ( "[BlindsFeeder] dismissed fiducal candidate: result {}, center {}" , result , center ) ; }  if  (  positionTolerant ||   Math . abs  (  cameraFeederY -  center . getY  ( ) ) < positionTolerance )  {  if  (  positionTolerant ||   Math . abs  (  cameraFeederX -  center . getX  ( ) ) < pocketRange )  {  if  (  angleTolerant ||   Math . abs  (  angleNorm  (  angle - 0 ) ) < angleTolerance )  {  if  (        mmSize . getX  ( ) > blindMin &&   mmSize . getX  ( ) < blindMax &&   mmSize . getY  ( ) > blindMin &&   mmSize . getY  ( ) < blindMax &&    mmSize . getX  ( ) /  mmSize . getY  ( ) < blindAspect &&    mmSize . getY  ( ) /  mmSize . getX  ( ) < blindAspect )  {  if  (  ! positionTolerant )  {  for (    org . opencv . core . Point point : points )  {  Location  corner =   transformMachineToFeederLocation  (  VisionUtils . getPixelLocation  ( camera ,  point . x ,  point . y ) ) . convertToUnits  (  LengthUnit . Millimeters ) ;  if  (   corner . getY  ( ) < cameraFeederY )  {   histogramLower . add  (  corner . getY  ( ) , 1. ) ; } else  {   histogramUpper . add  (  corner . getY  ( ) , 1. ) ; } } }   blinds . add  ( result ) ;   Logger . debug  ( "[BlindsFeeder] accepted pocket candidate: result {}, mmSize {}" , result , mmSize ) ; } else  {   Logger . debug  ( "[BlindsFeeder] dismissed pocket candidate: result {}, mmSize {}" , result , mmSize ) ; } } else  {   Logger . debug  ( "[BlindsFeeder] dismissed pocket candidate: result {}, angle {}" , result , angle ) ; } } else  {   Logger . debug  ( "[BlindsFeeder] dismissed pocket candidate: result {}, X {}" , result ,  center . getX  ( ) ) ; } } else  {   Logger . debug  ( "[BlindsFeeder] dismissed pocket candidate: result {}, Y {}" , result ,  center . getY  ( ) ) ; } } }   Collections . sort  ( fiducials ,  new  Comparator  < RotatedRect >  ( )  {    @ Override public  int compare  (  RotatedRect o1 ,  RotatedRect o2 )  {   double  d1 =   VisionUtils . getPixelLocation  ( camera ,   o1 . center . x ,   o1 . center . y ) . getLinearDistanceTo  (  camera . getLocation  ( ) ) ;   double  d2 =   VisionUtils . getPixelLocation  ( camera ,   o2 . center . x ,   o2 . center . y ) . getLinearDistanceTo  (  camera . getLocation  ( ) ) ;  return  Double . compare  ( d1 , d2 ) ; } } ) ;   Collections . sort  ( blinds ,  new  Comparator  < RotatedRect >  ( )  {    @ Override public  int compare  (  RotatedRect o1 ,  RotatedRect o2 )  {   double  d1 =   transformMachineToFeederLocation  (  VisionUtils . getPixelLocation  ( camera ,   o1 . center . x ,   o1 . center . y ) ) . getX  ( ) ;   double  d2 =   transformMachineToFeederLocation  (  VisionUtils . getPixelLocation  ( camera ,   o2 . center . x ,   o2 . center . y ) ) . getX  ( ) ;  return  Double . compare  ( d1 , d2 ) ; } } ) ;   double  bestLowerY =  histogramLower . getMaximumKey  ( ) ;   double  bestUpperY =  histogramUpper . getMaximumKey  ( ) ;   pocketSizeMm =  bestUpperY - bestLowerY ;   pocketCenterlineMm =  Math . round  (   (  bestUpperY + bestLowerY ) * 0.5 ) ;   Logger . debug  ( "[BlindsFeeder] histogram in Y: pocketCenterlineMm {}, pocketSizeMm {}" , pocketCenterlineMm , pocketSizeMm ) ;   lines =  new  ArrayList  < >  ( ) ;  for ( Double bestY :  new  double  [ ]  { bestLowerY , pocketCenterlineMm , bestUpperY } )  {  if  (  !  Double . isNaN  ( bestY ) )  {  Location  l1 =  new Location  (  LengthUnit . Millimeters ,  - 100. , bestY , 0. , 0. ) ;  Location  l2 =  new Location  (  LengthUnit . Millimeters ,  + 100. , bestY , 0. , 0. ) ;   l1 =  transformFeederToMachineLocation  ( l1 ) ;   l2 =  transformFeederToMachineLocation  ( l2 ) ;  Point  p1 =  VisionUtils . getLocationPixels  ( camera , l1 ) ;  Point  p2 =  VisionUtils . getLocationPixels  ( camera , l2 ) ;  Line  line =  new Line  (  new    org . opencv . core . Point  (  p1 . x ,  p1 . y ) ,  new    org . opencv . core . Point  (  p2 . x ,  p2 . y ) ) ;   lines . add  ( line ) ; } }  Location  previous = null ;  SimpleHistogram  histogramPitch =  new SimpleHistogram  ( 2 ) ;  for ( RotatedRect rect : blinds )  {  Location  location =   transformMachineToFeederLocation  (  VisionUtils . getPixelLocation  ( camera ,   rect . center . x ,   rect . center . y ) ) . convertToUnits  (  LengthUnit . Millimeters ) ;  if  (  previous != null )  {   double  pitch =   location . getX  ( ) -  previous . getX  ( ) ;   histogramPitch . add  ( pitch , 1.0 ) ; }   previous = location ; }   pocketPitchMm =  histogramPitch . getMaximumKey  ( ) ;   Logger . debug  ( "[BlindsFeeder] histogram in pitch: pocketPitchMm {}" , pocketPitchMm ) ;   double  pocketPitchPosMm =  (     getPocketPitch  ( ) . getValue  ( ) != 0. ?    getPocketPitch  ( ) . convertToUnits  (  LengthUnit . Millimeters ) . getValue  ( ) : pocketPitchMm ) ;  SimpleHistogram  histogramDistance =  new SimpleHistogram  ( 0.05 ) ;  for ( RotatedRect rect : blinds )  {  Location  location =   transformMachineToFeederLocation  (  VisionUtils . getPixelLocation  ( camera ,   rect . center . x ,   rect . center . y ) ) . convertToUnits  (  LengthUnit . Millimeters ) ;  if  (   Math . abs  (   location . getX  ( ) - cameraFeederX ) <  (  2 +  pocketPitchPosMm * 1.5 ) )  {   double  position =   location . getX  ( ) % pocketPitchPosMm ;  if  (  position < 0. )  {   position += pocketPitchPosMm ; }   histogramDistance . add  (  position - pocketPitchPosMm , 1.0 ) ;   histogramDistance . add  ( position , 1.0 ) ;   histogramDistance . add  (  position + pocketPitchPosMm , 1.0 ) ; } }   pocketPositionMm =  histogramDistance . getMaximumKey  ( ) ;   Logger . debug  ( "[BlindsFeeder] histogram position: pocketPositionMm {} using pitch {}" , pocketPositionMm , pocketPitchPosMm ) ;  if  (  !  Double . isNaN  ( pocketPositionMm ) )  {  if  (  pocketPositionMm < 0.0 )  {   pocketPositionMm += pocketPitchMm ; }  if  (  pocketPositionMm > pocketPitchMm )  {   pocketPositionMm -= pocketPitchMm ; }  Location  l1 =  new Location  (  LengthUnit . Millimeters , pocketPositionMm ,  pocketCenterlineMm - 100. , 0. , 0. ) ;  Location  l2 =  new Location  (  LengthUnit . Millimeters , pocketPositionMm ,  pocketCenterlineMm + 100. , 0. , 0. ) ;   l1 =  transformFeederToMachineLocation  ( l1 ) ;   l2 =  transformFeederToMachineLocation  ( l2 ) ;  Point  p1 =  VisionUtils . getLocationPixels  ( camera , l1 ) ;  Point  p2 =  VisionUtils . getLocationPixels  ( camera , l2 ) ;  Line  line =  new Line  (  new    org . opencv . core . Point  (  p1 . x ,  p1 . y ) ,  new    org . opencv . core . Point  (  p2 . x ,  p2 . y ) ) ;   lines . add  ( line ) ; }  if  (  showResultMilliseconds > 0 )  {  Mat  resultMat =   pipeline . getWorkingImage  ( ) . clone  ( ) ;   drawRotatedRects  ( resultMat ,  getBlinds  ( ) ,  Color . blue ) ;   drawRotatedRects  ( resultMat ,  getFiducials  ( ) ,  Color . white ) ;   drawLines  ( resultMat ,  getLines  ( ) ,  new Color  ( 0 , 0 , 128 ) ) ;   drawPartNumbers  ( resultMat ,  Color . orange ) ;  if  (    Logger . getLevel  ( ) ==     org . pmw . tinylog . Level . DEBUG ||   Logger . getLevel  ( ) ==     org . pmw . tinylog . Level . TRACE )  {  File  file =   Configuration . get  ( ) . createResourceFile  (  getClass  ( ) , "blinds-feeder" , ".png" ) ;   Imgcodecs . imwrite  (  file . getAbsolutePath  ( ) , resultMat ) ; }  BufferedImage  showResult =  OpenCvUtils . toBufferedImage  ( resultMat ) ;   resultMat . release  ( ) ;      MainFrame . get  ( ) . getCameraViews  ( ) . getCameraView  ( camera ) . showFilteredImage  ( showResult , showResultMilliseconds ) ; } }  catch (   ClassCastException e )  {  throw  new Exception  (  "Unrecognized result type (should be RotatedRect): " + results ) ; }  return this ; } }   public void showFeatures  ( )  throws Exception  {  Camera  camera =     Configuration . get  ( ) . getMachine  ( ) . getDefaultHead  ( ) . getDefaultCamera  ( ) ;  try  (  CvPipeline pipeline =  getCvPipeline  ( camera , true ) )  {   pipeline . process  ( ) ;    new FindFeatures  ( camera , pipeline , 2000 ) . invoke  ( ) ; } }   public void findPocketsAndCenterline  (  Camera camera )  throws Exception  {   updateFromConnectedFeeder  (  camera . getLocation  ( ) , false ) ;  if  (    nullLocation . equals  ( fiducial1Location ) ||  nullLocation . equals  ( fiducial2Location ) ||  nullLocation . equals  ( fiducial3Location ) )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": Please set the fiducials first (camera center is outside any previously defined fiducial area)." ) ; }  if  (  coverType ==  CoverType . BlindsCover )  {  try  (  CvPipeline pipeline =  getCvPipeline  ( camera , true ) )  {   setPocketCenterline  (  new Length  ( 0. ,  LengthUnit . Millimeters ) ) ;   setPocketPitch  (  new Length  ( 0. ,  LengthUnit . Millimeters ) ) ;   setPocketSize  (  new Length  ( 0. ,  LengthUnit . Millimeters ) ) ;   pipeline . process  ( ) ;   BlindsFeeder . FindFeatures  findFeaturesResults =   new FindFeatures  ( camera , pipeline , 1000 ) . invoke  ( ) ;  if  (  Double . isNaN  (  findFeaturesResults . getPocketCenterlineMm  ( ) ) )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": Tape centerline not found." ) ; }  if  (  Double . isNaN  (  findFeaturesResults . getPocketPitchMm  ( ) ) )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": Pocket pitch not found." ) ; }  if  (  Double . isNaN  (  findFeaturesResults . getPocketSizeMm  ( ) ) )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": Pocket size not found." ) ; }   setPocketCenterline  (  new Length  (  findFeaturesResults . getPocketCenterlineMm  ( ) ,  LengthUnit . Millimeters ) ) ;   setPocketPitch  (  new Length  (  findFeaturesResults . getPocketPitchMm  ( ) ,  LengthUnit . Millimeters ) ) ;   setPocketSize  (  new Length  (  findFeaturesResults . getPocketSizeMm  ( ) ,  LengthUnit . Millimeters ) ) ; } } else  {  Location  cameraLocation =  camera . getLocation  ( ) ;  Location  feederLocation =   transformMachineToFeederLocation  ( cameraLocation ) . convertToUnits  (  LengthUnit . Millimeters ) ;   setPocketCenterline  (  new Length  (  Math . round  (  feederLocation . getY  ( ) ) ,  LengthUnit . Millimeters ) ) ; } }   public void findCoverPosition  (  Camera camera )  throws Exception  {  try  (  CvPipeline pipeline =  getCvPipeline  ( camera , true ) )  {   pipeline . process  ( ) ;   BlindsFeeder . FindFeatures  findFeaturesResults =   new FindFeatures  ( camera , pipeline , 1000 ) . invoke  ( ) ;  if  (  Double . isNaN  (  findFeaturesResults . getPocketPositionMm  ( ) ) )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": Pocket position not found." ) ; }   setCoverPosition  (  new Length  (  findFeaturesResults . getPocketPositionMm  ( ) ,  LengthUnit . Millimeters ) ) ; } }   public void calibrateCoverEdges  ( )  throws Exception  {  if  (  coverType !=  CoverType . BlindsCover )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": Only Blinds Cover can be calibrated." ) ; }  Camera  camera =     Configuration . get  ( ) . getMachine  ( ) . getDefaultHead  ( ) . getDefaultCamera  ( ) ;   assertCalibration  ( ) ;  Length  pitchHalf =   pocketPitch . multiply  ( 0.5 ) . convertToUnits  (  LengthUnit . Millimeters ) ;  Length  wantedOpenPosition =  getPocketDistance  ( ) ;  Length  wantedClosedPosition =    getPocketDistance  ( ) . add  ( pitchHalf ) . modulo  ( pocketPitch ) ;   double  cameraPocket =  Math . floor  (   (   getFirstPocket  ( ) +  getLastPocket  ( ) ) / 2.0 ) ;  Location  cameraOpenPosition =  getPickLocation  ( cameraPocket ) ;  Location  cameraClosedPosition =  getPickLocation  (  cameraPocket - 0.5 ) ;   double  damping = 1.0 ;   actuateCover  ( false ) ;  for (   int  i = 0 ;  i < 3 ;  i ++ )  {   actuateCover  ( true ) ;   MovableUtils . moveToLocationAtSafeZ  ( camera , cameraOpenPosition ) ;   findCoverPosition  ( camera ) ;  Length  offsetOpen =    getCoverPosition  ( ) . subtract  ( wantedOpenPosition ) . convertToUnits  (  LengthUnit . Millimeters ) ;  if  (   offsetOpen . getValue  ( ) >  pitchHalf . getValue  ( ) )  {   offsetOpen =  offsetOpen . subtract  ( pocketPitch ) ; }  if  (   offsetOpen . getValue  ( ) <  -  pitchHalf . getValue  ( ) )  {   offsetOpen =  offsetOpen . add  ( pocketPitch ) ; }   setEdgeOpenDistance  (   getEdgeOpenDistance  ( ) . add  (  offsetOpen . multiply  ( damping ) ) ) ;   actuateCover  ( false ) ;   MovableUtils . moveToLocationAtSafeZ  ( camera , cameraClosedPosition ) ;   findCoverPosition  ( camera ) ;  Length  offsetClosed =    getCoverPosition  ( ) . subtract  ( wantedClosedPosition ) . convertToUnits  (  LengthUnit . Millimeters ) ;  if  (   offsetClosed . getValue  ( ) >  pitchHalf . getValue  ( ) )  {   offsetClosed =  offsetClosed . subtract  ( pocketPitch ) ; }  if  (   offsetClosed . getValue  ( ) <  -  pitchHalf . getValue  ( ) )  {   offsetClosed =  offsetClosed . add  ( pocketPitch ) ; }   setEdgeClosedDistance  (   getEdgeClosedDistance  ( ) . subtract  (  offsetClosed . multiply  ( damping ) ) ) ;  if  (    Math . abs  (  offsetOpen . getValue  ( ) ) <  pocketPosToleranceMm * 0.5 &&   Math . abs  (  offsetClosed . getValue  ( ) ) <  pocketPosToleranceMm * 0.5 )  {  break ; } } }   private Location locateFiducial  (  Camera camera ,  Location location )  throws Exception  {  if  (  location . equals  ( nullLocation ) )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": Fiducial location not set." ) ; }   location =  location . derive  (  camera . getLocation  ( ) , false , false , true , false ) ;  try  (  CvPipeline pipeline =  getCvPipeline  ( camera , true ) )  {  for (   int  i = 0 ;  i < fidLocMaxPasses ;  i ++ )  {   MovableUtils . moveToLocationAtSafeZ  ( camera , location ) ;   pipeline . process  ( ) ;   BlindsFeeder . FindFeatures  findFeaturesResults =   new FindFeatures  ( camera , pipeline , 250 ) . invoke  ( ) ;   List  < RotatedRect >  fiducials =  findFeaturesResults . getFiducials  ( ) ;  if  (  fiducials . isEmpty  ( ) )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": Fiducial not found." ) ; }  RotatedRect  bestFiducial =  fiducials . get  ( 0 ) ;  Location  bestFiducialLocation =  VisionUtils . getPixelLocation  ( camera ,   bestFiducial . center . x ,   bestFiducial . center . y ) ;   double  mmDistance =    bestFiducialLocation . getLinearLengthTo  ( location ) . convertToUnits  (  LengthUnit . Millimeters ) . getValue  ( ) ;   Logger . debug  ( "[BlindsFeeder] bestFiducialLocation: {}, mmDistance {}" , bestFiducialLocation , mmDistance ) ;   location = bestFiducialLocation ;  if  (  mmDistance < fidLocToleranceMm )  {  break ; } }  return location ; } }   public void calibrateFeederLocations  ( )  throws Exception  {  if  (  !  isCalibrating  ( ) )  {  if  (  !    Configuration . get  ( ) . getMachine  ( ) . isHomed  ( ) )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": Machine not yet homed." ) ; }   setCalibrating  ( true ) ;  try  {  Camera  camera =     Configuration . get  ( ) . getMachine  ( ) . getDefaultHead  ( ) . getDefaultCamera  ( ) ;   setFiducial1Location  (  locateFiducial  ( camera ,  getFiducial1Location  ( ) ) ) ;   setFiducial3Location  (  locateFiducial  ( camera ,  getFiducial3Location  ( ) ) ) ;  Head  head =    Configuration . get  ( ) . getMachine  ( ) . getDefaultHead  ( ) ;  if  (  head . isInsideSoftLimits  ( camera ,  getFiducial2Location  ( ) ) )  {   setFiducial2Location  (  locateFiducial  ( camera ,  getFiducial2Location  ( ) ) ) ; } else  {  Location  yAxis =   getFiducial3Location  ( ) . subtract  (  getFiducial1Location  ( ) ) ;   double  distance =   getFiducial3Location  ( ) . getLinearDistanceTo  (  (  getFiducial1Location  ( ) ) ) ;   yAxis =  yAxis . multiply  (  1 / distance ,  1 / distance , 0. , 0. ) ;  Location  xAxis =  new Location  (  yAxis . getUnits  ( ) ,  yAxis . getY  ( ) ,  -  yAxis . getX  ( ) , 0. , 0. ) ;   double  scale =    getTapeLength  ( ) . convertToUnits  (  xAxis . getUnits  ( ) ) . getValue  ( ) ;  Location  reconstructedFiducial2 =   getFiducial1Location  ( ) . add  (  xAxis . multiply  ( scale , scale , 0. , 0. ) ) ;   setFiducial2Location  ( reconstructedFiducial2 ) ; }   setCalibrated  ( true ) ; }  finally  {   setCalibrating  ( false ) ; } } }   public enum CoverType  {  NoCover ,  BlindsCover ,  PushCover }   public enum CoverActuation  {  Manual ,  CheckOpen ,  OpenOnFirstUse ,  OpenOnJobStart }    @ Attribute  (  required = false ) private CoverType  coverType =  CoverType . BlindsCover ;    @ Attribute  (  required = false ) private CoverActuation  coverActuation =  CoverActuation . OpenOnJobStart ;   public static  List  < BlindsFeeder > getFeedersWithCoverToActuate  (   List  < Feeder > feederPool ,   CoverActuation  [ ] coverActuations ,  boolean openState )  {   List  < BlindsFeeder >  feederList =  new  ArrayList  < >  ( ) ;  for ( Feeder feeder : feederPool )  {  if  (  feeder instanceof BlindsFeeder )  {  BlindsFeeder  blindsFeeder =  ( BlindsFeeder ) feeder ;  if  (   blindsFeeder . getCoverType  ( ) ==  CoverType . BlindsCover )  {  for ( CoverActuation coverActuation : coverActuations )  {  if  (   blindsFeeder . getCoverActuation  ( ) == coverActuation )  {  if  (   feeder . isEnabled  ( ) ||  (   blindsFeeder . isCoverOpenState  ( true ) &&  ! openState ) )  {  if  (  !  blindsFeeder . isCoverOpenState  ( openState ) )  {   feederList . add  ( blindsFeeder ) ; } } } } } } }  return feederList ; }   public  double getPickRotationInTape  ( )  {  return    getLocation  ( ) . getRotation  ( ) + 180. ; }   public static class NozzleAndTipForPushing  {   private Nozzle  nozzle ;   private NozzleTip  nozzleTipLoadedBefore ;  void restoreNozzleTipLoadedBefore  ( )  throws Exception  {  if  (     this . nozzle != null &   this . nozzleTipLoadedBefore != null &&  this . changed )  {  if  (   this . nozzleTipLoadedBefore !=   this . nozzle . getNozzleTip  ( ) )  {    this . nozzle . loadNozzleTip  (  this . nozzleTipLoadedBefore ) ; } } }   public Nozzle getNozzle  ( )  {  return nozzle ; }   public NozzleTip getNozzleTip  ( )  {  if  (   this . nozzle != null )  {  return   this . nozzle . getNozzleTip  ( ) ; }  return null ; }   public NozzleTip getNozzleTipLoadedBefore  ( )  {  return nozzleTipLoadedBefore ; }   private boolean  changed ;   public NozzleAndTipForPushing  (  Nozzle nozzle ,  NozzleTip nozzleTipLoadedBefore ,  boolean changed )  {  super  ( ) ;    this . nozzle = nozzle ;    this . nozzleTipLoadedBefore = nozzleTipLoadedBefore ;    this . changed = changed ; }   public boolean isChanged  ( )  {  return changed ; } }   public void actuateCover  (  boolean openState )  throws Exception  {   actuateCover  ( null , openState ) ; } 
<<<<<<<
  public void actuateCover  (  boolean openState ,  boolean loadNozzleTipIfNeeded ,  boolean restoreNozzleTip )  throws Exception  {  if  (  coverType ==  CoverType . NoCover )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": has no cover to actuate." ) ; } else  {  if  (    getLocation  ( ) . getZ  ( ) == 0.0 )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + " Part Z not set." ) ; }  NozzleAndTipForPushing  nozzleAndTipForPushing =  BlindsFeeder . getNozzleAndTipForPushing  ( loadNozzleTipIfNeeded ) ;  Nozzle  nozzle =  nozzleAndTipForPushing . getNozzle  ( ) ;  NozzleTip  nozzleTip =  nozzleAndTipForPushing . getNozzleTip  ( ) ;  if  (  nozzleTip == null )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": loaded nozzle tips do not allow pushing. Check the nozzle tip configuration or change the nozzle tip." ) ; }  Length  nozzleTipDiameter =  nozzleTip . getDiameterLow  ( ) ;  if  (   nozzleTipDiameter . getValue  ( ) == 0. )  {  throw  new Exception  (     "Feeder " +  getName  ( ) + ": current nozzle tip " +  nozzleTip . getId  ( ) + " has push diameter not set. Check the nozzle tip configuration." ) ; }  Length  backlashOffset =  new Length  ( 0.0 ,   getFiducial2Location  ( ) . getUnits  ( ) ) ;   double  backlashOpen = 0.0 ;   double  backlashClose = 0.0 ;  ReferenceMachine  referenceMachine ;  if  (    Configuration . get  ( ) . getMachine  ( ) instanceof ReferenceMachine )  {   referenceMachine =  ( ReferenceMachine )   Configuration . get  ( ) . getMachine  ( ) ;  if  (   referenceMachine . getDriver  ( ) instanceof GcodeDriver )  {  GcodeDriver  gcodeDriver =  ( GcodeDriver )  referenceMachine . getDriver  ( ) ;  Location  backlashVector =  new Location  (  gcodeDriver . getUnits  ( ) ,  gcodeDriver . getBacklashOffsetX  ( ) ,  gcodeDriver . getBacklashOffsetY  ( ) , 0.0 , 0.0 ) ;  Location  unitVectorX =   getFiducial1Location  ( ) . unitVectorTo  (  getFiducial2Location  ( ) ) ;   backlashOffset =  unitVectorX . dotProduct  ( backlashVector ) ;   backlashOpen =    backlashOffset . getValue  ( ) > 0.0 ? 1.0 : 0.0 ;   backlashClose =    backlashOffset . getValue  ( ) < 0.0 ? 1.0 : 0.0 ; } }   assertCalibration  ( ) ;  if  (  coverType ==  CoverType . BlindsCover )  {  Length  feederX0 =    (  openState ?     edgeOpenDistance . multiply  (  - 1.0 ) . subtract  (  sprocketPitch . multiply  ( 0.5 ) ) . subtract  (  nozzleTipDiameter . multiply  ( 0.5 ) ) . subtract  (  backlashOffset . multiply  ( backlashOpen ) ) :    edgeClosedDistance . add  ( tapeLength ) . add  (  sprocketPitch . multiply  ( 0.5 ) ) . add  (  nozzleTipDiameter . multiply  ( 0.5 ) ) ) . subtract  (  backlashOffset . multiply  ( backlashClose ) ) . convertToUnits  (   getLocation  ( ) . getUnits  ( ) ) ;  Length  feederX1 =    (  openState ?    edgeOpenDistance . multiply  (  - 1.0 ) . subtract  (  nozzleTipDiameter . multiply  ( 0.5 ) ) . subtract  (  backlashOffset . multiply  ( backlashOpen ) ) :   edgeClosedDistance . add  ( tapeLength ) . add  (  nozzleTipDiameter . multiply  ( 0.5 ) ) ) . subtract  (  backlashOffset . multiply  ( backlashClose ) ) . convertToUnits  (   getLocation  ( ) . getUnits  ( ) ) ;  Length  feederY =  pocketCenterline . convertToUnits  (   getLocation  ( ) . getUnits  ( ) ) ;  Length  feederZ =    getLocation  ( ) . getLengthZ  ( ) . add  ( pushZOffset ) ;  Location  feederLocation0 =  new Location  (   getLocation  ( ) . getUnits  ( ) ,  feederX0 . getValue  ( ) ,  feederY . getValue  ( ) ,  feederZ . getValue  ( ) ,  getPickRotationInTape  ( ) ) ;  Location  feederLocation1 =  new Location  (   getLocation  ( ) . getUnits  ( ) ,  feederX1 . getValue  ( ) ,  feederY . getValue  ( ) ,  feederZ . getValue  ( ) ,  getPickRotationInTape  ( ) ) ;  Location  machineLocation0 =  transformFeederToMachineLocation  ( feederLocation0 ) ;  Location  machineLocation1 =  transformFeederToMachineLocation  ( feederLocation1 ) ;   MovableUtils . moveToLocationAtSafeZ  ( nozzle , machineLocation0 ) ;   nozzle . moveTo  ( machineLocation1 ,     nozzle . getHead  ( ) . getMachine  ( ) . getSpeed  ( ) * pushSpeed ) ;    nozzle . getHead  ( ) . moveToSafeZ  ( ) ;   setCoverPosition  (  openState ? pocketDistance :  pocketDistance . subtract  (  pocketPitch . multiply  ( 0.5 ) ) ) ; } else  if  (   coverType ==  CoverType . PushCover && openState )  {  Location  pickLocation =  getPickLocation  (   getFedPocketNumber  ( ) + 1 ) ;  Location  pickFeederLocation =  transformMachineToFeederLocation  ( pickLocation ) ;  Length  feederX0 =   (     getFeedCount  ( ) == 0 ||  !  isCoverOpen  ( ) ?   pocketPitch . multiply  (  - 0.5 ) . subtract  (  nozzleTipDiameter . multiply  ( 1 ) ) :   coverPosition . subtract  (  pocketPitch . multiply  ( 0.5 ) ) . subtract  (  nozzleTipDiameter . multiply  ( 1 ) ) ) . convertToUnits  (   getLocation  ( ) . getUnits  ( ) ) ;  Length  feederX1 =     pickFeederLocation . getLengthX  ( ) . add  (  pocketPitch . multiply  ( 0.5 ) ) . subtract  (  nozzleTipDiameter . multiply  ( 0.5 ) ) . convertToUnits  (   getLocation  ( ) . getUnits  ( ) ) ;  Length  feederY =   pickFeederLocation . getLengthY  ( ) . convertToUnits  (   getLocation  ( ) . getUnits  ( ) ) ;  Length  feederZ =    getLocation  ( ) . getLengthZ  ( ) . subtract  ( pushZOffset ) ;  Location  feederLocation0 =  new Location  (   getLocation  ( ) . getUnits  ( ) ,  feederX0 . getValue  ( ) ,  feederY . getValue  ( ) ,  feederZ . getValue  ( ) ,  getPickRotationInTape  ( ) ) ;  Location  feederLocation1 =  new Location  (   getLocation  ( ) . getUnits  ( ) ,  feederX1 . getValue  ( ) ,  feederY . getValue  ( ) ,  feederZ . getValue  ( ) ,  getPickRotationInTape  ( ) ) ;  Location  machineLocation0 =  transformFeederToMachineLocation  ( feederLocation0 ) ;  Location  machineLocation1 =  transformFeederToMachineLocation  ( feederLocation1 ) ;   MovableUtils . moveToLocationAtSafeZ  ( nozzle , machineLocation0 ) ;   nozzle . moveTo  ( machineLocation1 ,     nozzle . getHead  ( ) . getMachine  ( ) . getSpeed  ( ) * pushSpeed ) ;   nozzle . moveTo  (  pickLocation . derive  ( machineLocation1 , false , false , true , false ) ) ;   setCoverPosition  (  pickFeederLocation . getLengthX  ( ) ) ; }  if  ( restoreNozzleTip )  {   nozzleAndTipForPushing . restoreNozzleTipLoadedBefore  ( ) ; } } }
=======
>>>>>>>
   private AffineTransform  tx ;   private AffineTransform  txInverse ;   private  double  txRotation ;   public void invalidateFeederTransformation  ( )  {   tx = null ;   txInverse = null ; }   private boolean updateFeederToMachineTransform  ( )  {   txInverse = null ;  Location  origin = fiducial1Location ;   double  mm =    new Length  ( 1 ,  LengthUnit . Millimeters ) . convertToUnits  (  origin . getUnits  ( ) ) . getValue  ( ) ;   double  distance =  origin . getLinearDistanceTo  ( fiducial2Location ) ;  if  (    nullLocation . equals  ( fiducial1Location ) ||  nullLocation . equals  ( fiducial2Location ) ||  distance <  1 * mm )  {   tx =  new AffineTransform  ( ) ;   tx . translate  (  origin . getX  ( ) ,  origin . getY  ( ) ) ;   txRotation = 0. ;  return false ; }  if  (  ! normalize )  {   distance =    Math . round  (   distance / 2 / mm ) * 2 * mm ; }   setTapeLength  (  new Length  (    Math . round  (   distance / 2 / mm ) * 2 * mm ,  origin . getUnits  ( ) ) ) ;  Location  axisX ;  Location  axisY ;   axisX =    fiducial2Location . convertToUnits  (  origin . getUnits  ( ) ) . subtract  ( origin ) . multiply  (  1 / distance ,  1 / distance , 0 , 0 ) ;  Location  ref =   (     fiducial3Location . convertToUnits  (  origin . getUnits  ( ) ) . getLinearDistanceTo  ( fiducial2Location ) <   fiducial3Location . convertToUnits  (  origin . getUnits  ( ) ) . getLinearDistanceTo  ( fiducial1Location ) ? fiducial2Location : fiducial1Location ) . convertToUnits  (  origin . getUnits  ( ) ) ;   distance =   fiducial3Location . equals  ( nullLocation ) ? 0 :  ref . getLinearDistanceTo  ( fiducial3Location ) ;  if  (  normalize ||  distance <  1 * mm )  {   axisY =  new Location  (  axisX . getUnits  ( ) ,  -  axisX . getY  ( ) ,  axisX . getX  ( ) , 0 , 0 ) ;   setFeederExtent  (  new Length  (   Math . round  (  distance / mm ) * mm ,  origin . getUnits  ( ) ) ) ; } else  {   distance =   Math . round  (  distance / mm ) * mm ;   axisY =    fiducial3Location . convertToUnits  (  origin . getUnits  ( ) ) . subtract  ( ref ) . multiply  (  1 / distance ,  1 / distance , 0 , 0 ) ;   setFeederExtent  (  new Length  ( distance ,  origin . getUnits  ( ) ) ) ; }   tx =  new AffineTransform  (  axisX . getX  ( ) ,  axisX . getY  ( ) ,  axisY . getX  ( ) ,  axisY . getY  ( ) ,  origin . getX  ( ) ,  origin . getY  ( ) ) ;   txRotation =  Math . toDegrees  (  Math . atan2  (  axisX . getY  ( ) ,  axisX . getX  ( ) ) ) ;   recalculateGeometry  ( ) ;  return true ; }  AffineTransform getFeederToMachineTransform  ( )  {  if  (  tx == null )  {   updateFeederToMachineTransform  ( ) ; }  return tx ; }   double getFeederToMachineRotation  ( )  {  if  (  tx == null )  {   updateFeederToMachineTransform  ( ) ; }  return txRotation ; }   double getMachineToFeederRotation  ( )  {  if  (  tx == null )  {   updateFeederToMachineTransform  ( ) ; }  return  - txRotation ; }   private AffineTransform getMachineToFeederTransform  ( )  {  if  (  txInverse == null )  {   txInverse =  new AffineTransform  (  getFeederToMachineTransform  ( ) ) ;  try  {   txInverse . invert  ( ) ; }  catch (   NoninvertibleTransformException e )  {   txInverse =  new AffineTransform  ( ) ;   txInverse . translate  (  -  fiducial1Location . getX  ( ) ,  -  fiducial1Location . getY  ( ) ) ; } }  return txInverse ; }   public Location transformFeederToMachineLocation  (  Location feederLocation )  {  AffineTransform  tx =  getFeederToMachineTransform  ( ) ;   double  rotation =  getFeederToMachineRotation  ( ) ;   feederLocation =  feederLocation . convertToUnits  (  fiducial1Location . getUnits  ( ) ) ;   Point2D . Double  ptDst =  new  Point2D . Double  ( ) ;   tx . transform  (  new  Point2D . Double  (  feederLocation . getX  ( ) ,  feederLocation . getY  ( ) ) , ptDst ) ;  return  new Location  (  fiducial1Location . getUnits  ( ) ,  ptDst . getX  ( ) ,  ptDst . getY  ( ) ,  feederLocation . getZ  ( ) ,   feederLocation . getRotation  ( ) + rotation ) ; }   public Location transformMachineToFeederLocation  (  Location machineLocation )  {  AffineTransform  tx =  getMachineToFeederTransform  ( ) ;   double  rotation =  getMachineToFeederRotation  ( ) ;   machineLocation =  machineLocation . convertToUnits  (  fiducial1Location . getUnits  ( ) ) ;   Point2D . Double  ptDst =  new  Point2D . Double  ( ) ;   tx . transform  (  new  Point2D . Double  (  machineLocation . getX  ( ) ,  machineLocation . getY  ( ) ) , ptDst ) ;  return  new Location  (  fiducial1Location . getUnits  ( ) ,  ptDst . getX  ( ) ,  ptDst . getY  ( ) ,  machineLocation . getZ  ( ) ,   machineLocation . getRotation  ( ) + rotation ) ; }   public  double transformFeederToMachineAngle  (   double angle )  {  return  angle +  getFeederToMachineRotation  ( ) ; }   public  double transformMachineToFeederAngle  (   double angle )  {  return  angle +  getMachineToFeederRotation  ( ) ; }   public  double transformPixelToFeederAngle  (   double angle )  {  return  -  transformMachineToFeederAngle  ( angle ) ; }   public boolean isLocationInFeeder  (  Location location ,  boolean fiducial1MatchOnly )  {  if  (  nullLocation . equals  ( fiducial1Location ) )  {  return false ; }  if  (    fiducial1Location . convertToUnits  (  LengthUnit . Millimeters ) . getLinearDistanceTo  ( location ) < 2 )  {  return true ; } else  if  ( fiducial1MatchOnly )  {  return false ; }  Location  feederLocation =  transformMachineToFeederLocation  ( location ) ;   double  mm =    new Length  ( 1 ,  LengthUnit . Millimeters ) . convertToUnits  (  feederLocation . getUnits  ( ) ) . getValue  ( ) ;  if  (    feederLocation . getX  ( ) >=   - 1 * mm &&   feederLocation . getX  ( ) <=    tapeLength . convertToUnits  (  feederLocation . getUnits  ( ) ) . getValue  ( ) +  1 * mm )  {  if  (    feederLocation . getY  ( ) >=   - 1 * mm &&   feederLocation . getY  ( ) <=   feederExtent . getValue  ( ) +  1 * mm )  {  return true ; } }  return false ; }   public static  List  < BlindsFeeder > getAllBlindsFeeders  ( )  {   List  < BlindsFeeder >  list =  new  ArrayList  < >  ( ) ;  for ( Feeder feeder :    Configuration . get  ( ) . getMachine  ( ) . getFeeders  ( ) )  {  if  (  feeder instanceof BlindsFeeder )  {  BlindsFeeder  blindsFeeder =  ( BlindsFeeder ) feeder ;   list . add  ( blindsFeeder ) ; } }  return list ; }   public static  List  < BlindsFeeder > getConnectedFeedersByLocation  (  Location location ,  boolean fiducial1MatchOnly )  {   List  < BlindsFeeder >  list =  new  ArrayList  < >  ( ) ;  for ( Feeder feeder :    Configuration . get  ( ) . getMachine  ( ) . getFeeders  ( ) )  {  if  (  feeder instanceof BlindsFeeder )  {  BlindsFeeder  blindsFeeder =  ( BlindsFeeder ) feeder ;  if  (  blindsFeeder . isLocationInFeeder  ( location , fiducial1MatchOnly ) )  {   list . add  ( blindsFeeder ) ; } } }   Collections . sort  ( list ,  new  Comparator  < BlindsFeeder >  ( )  {    @ Override public  int compare  (  BlindsFeeder feeder1 ,  BlindsFeeder feeder2 )  {  return   new Double  (   feeder1 . getPocketCenterline  ( ) . getValue  ( ) ) . compareTo  (    feeder2 . getPocketCenterline  ( ) . convertToUnits  (   feeder1 . getPocketCenterline  ( ) . getUnits  ( ) ) . getValue  ( ) ) ; } } ) ;  return list ; }   public  List  < BlindsFeeder > getConnectedFeeders  ( )  {  return  getConnectedFeedersByLocation  ( fiducial1Location , true ) ; }   private boolean  isUpdating = false ;   public void updateFromConnectedFeeder  (  BlindsFeeder feeder )  {  if  (   this != feeder &&  ! isUpdating )  {  try  {   isUpdating = true ;   setFiducial1Location  (  feeder . fiducial1Location ) ;   setFiducial2Location  (  feeder . fiducial2Location ) ;   setFiducial3Location  (  feeder . fiducial3Location ) ;   setTapeLength  (  feeder . tapeLength ) ;   setFeederExtent  (  feeder . feederExtent ) ;   setNormalize  (  feeder . normalize ) ;  if  (   this . pocketCenterline . equals  (  feeder . pocketCenterline ) )  {   setCoverPosition  (  feeder . coverPosition ) ;   setEdgeOpenDistance  (  feeder . edgeOpenDistance ) ;   setEdgeClosedDistance  (  feeder . edgeClosedDistance ) ; }   setCalibrated  (  feeder . calibrated ) ;   setVisionEnabled  (  feeder . visionEnabled ) ; }  finally  {   isUpdating = false ; } } }   private void updateTapeNumbering  ( )  {   List  < BlindsFeeder >  list =  getConnectedFeedersByLocation  ( fiducial1Location , true ) ;   int  feedersTotal =  list . size  ( ) ;   int  feederNo = 0 ;  for ( BlindsFeeder feeder : list )  {   feeder . setFeedersTotal  ( feedersTotal ) ;   feeder . setFeederNo  (  ++ feederNo ) ; } }   public boolean updateFromConnectedFeeder  (  Location location ,  boolean fiducial1MatchOnly )  {  boolean  hasMatch = false ;  for ( BlindsFeeder feeder :  getConnectedFeedersByLocation  ( location , fiducial1MatchOnly ) )  {  if  (  feeder != this )  {   updateFromConnectedFeeder  ( feeder ) ;   hasMatch = true ;  break ; } }  if  (  !  nullLocation . equals  ( fiducial1Location ) )  {  Location  feederLocation =  transformMachineToFeederLocation  ( location ) ;   double  mm =    new Length  ( 1 ,  LengthUnit . Millimeters ) . convertToUnits  (  feederLocation . getUnits  ( ) ) . getValue  ( ) ;   this . setPocketCenterline  (  new Length  (   Math . round  (   feederLocation . getY  ( ) / mm ) * mm ,  feederLocation . getUnits  ( ) ) ) ; }   updateTapeNumbering  ( ) ;  return hasMatch ; }   public void updateConnectedFeedersFromThis  (  Location location ,  boolean fiducial1MatchOnly )  {  if  (  ! isUpdating )  {  try  {   isUpdating = true ;   updateFeederToMachineTransform  ( ) ;  for ( BlindsFeeder feeder :  getConnectedFeedersByLocation  ( location , fiducial1MatchOnly ) )  {  if  (  feeder != this )  {   feeder . updateFromConnectedFeeder  ( this ) ; } } }  finally  {   isUpdating = false ; } } }   public void updateConnectedFeedersFromThis  ( )  {   updateConnectedFeedersFromThis  ( fiducial1Location , true ) ; }   public CvPipeline getPipeline  ( )  {  return pipeline ; }   public void resetPipeline  ( )  {   pipeline =  createDefaultPipeline  ( ) ; }   public void setPipelineToAllFeeders  ( )  throws CloneNotSupportedException  {  for ( BlindsFeeder feeder :  getAllBlindsFeeders  ( ) )  {  if  (  feeder != this )  {    feeder . pipeline =  pipeline . clone  ( ) ; } } }   public CvPipeline getCvPipeline  (  Camera camera ,  boolean clone )  {  try  {  CvPipeline  pipeline =  getPipeline  ( ) ;  if  ( clone )  {   pipeline =  pipeline . clone  ( ) ; }   pipeline . setProperty  ( "camera" , camera ) ;   pipeline . setProperty  ( "feeder" , this ) ;  return pipeline ; }  catch (   CloneNotSupportedException e )  {  throw  new Error  ( e ) ; } }   public boolean isCalibrating  ( )  {  return calibrating ; }   private void setCalibrating  (  boolean calibrating )  {    this . calibrating = calibrating ; }   public boolean isCalibrated  ( )  {  return calibrated ; }   private void setCalibrated  (  boolean calibrated )  {  boolean  oldValue =  this . calibrated ;    this . calibrated = calibrated ;  if  (  oldValue != calibrated )  {   this . updateConnectedFeedersFromThis  ( ) ;   firePropertyChange  ( "calibrated" , oldValue , calibrated ) ; } }   public Location getFiducial1Location  ( )  {  return fiducial1Location ; }   public void setFiducial1Location  (  Location fiducial1Location )  {  Location  oldValue =  this . fiducial1Location ;    this . fiducial1Location = fiducial1Location ;  if  (  !  oldValue . equals  ( fiducial1Location ) )  {   this . invalidateFeederTransformation  ( ) ;   firePropertyChange  ( "fiducial1Location" , oldValue , fiducial1Location ) ;  if  (    oldValue . equals  ( nullLocation ) &&  fiducial2Location . equals  ( nullLocation ) &&  fiducial3Location . equals  ( nullLocation ) )  {   updateFromConnectedFeeder  ( fiducial1Location , true ) ; } else  {   this . updateConnectedFeedersFromThis  ( oldValue , true ) ;  if  (   (  !  oldValue . equals  ( nullLocation ) ) &&    oldValue . convertToUnits  (  LengthUnit . Millimeters ) . getLinearDistanceTo  ( fiducial1Location ) > 2 )  {  if  (  !  fiducial2Location . equals  ( nullLocation ) )  {  Location  oldValue2 = fiducial2Location ;   fiducial2Location =  new Location  (  fiducial2Location . getUnits  ( ) ) ;   setFiducial2Location  (  oldValue2 . add  (  fiducial1Location . subtract  ( oldValue ) ) ) ; }  if  (  !  fiducial3Location . equals  ( nullLocation ) )  {   setFiducial3Location  (  fiducial3Location . add  (  fiducial1Location . subtract  ( oldValue ) ) ) ; } } } } }   public Location getFiducial2Location  ( )  {  return fiducial2Location ; }   public void setFiducial2Location  (  Location fiducial2Location )  {  Location  oldValue =  this . fiducial2Location ;    this . fiducial2Location = fiducial2Location ;  if  (  !  oldValue . equals  ( fiducial2Location ) )  {   this . invalidateFeederTransformation  ( ) ;   this . updateConnectedFeedersFromThis  ( ) ;   firePropertyChange  ( "fiducial2Location" , oldValue , fiducial2Location ) ;  if  (   (  !  oldValue . equals  ( nullLocation ) ) &&    oldValue . convertToUnits  (  LengthUnit . Millimeters ) . getLinearDistanceTo  ( fiducial1Location ) > 2 )  {  if  (  !  (   fiducial3Location . equals  ( nullLocation ) ||  fiducial1Location . equals  ( nullLocation ) ) )  {  Location  unitX =  fiducial1Location . unitVectorTo  ( fiducial2Location ) ;  Location  unitY =  new Location  (  unitX . getUnits  ( ) ,  -  unitX . getY  ( ) ,  unitX . getX  ( ) , 0.0 , 0.0 ) ;  if  (   fiducial1Location . getLinearDistanceTo  ( fiducial3Location ) <  oldValue . getLinearDistanceTo  ( fiducial3Location ) )  {   double  feederExtent =  fiducial3Location . getLinearDistanceTo  ( fiducial1Location ) ;   setFiducial3Location  (  fiducial1Location . add  (  unitY . multiply  ( feederExtent , feederExtent , 0.0 , 0.0 ) ) ) ; } else  {   double  feederExtent =   fiducial3Location . convertToUnits  (  unitX . getUnits  ( ) ) . getLinearDistanceTo  ( oldValue ) ;   setFiducial3Location  (  fiducial2Location . add  (  unitY . multiply  ( feederExtent , feederExtent , 0.0 , 0.0 ) ) ) ; } } } } }   public Location getFiducial3Location  ( )  {  return fiducial3Location ; }   public void setFiducial3Location  (  Location fiducial3Location )  {  Location  oldValue =  this . fiducial3Location ;    this . fiducial3Location = fiducial3Location ;  if  (  !  oldValue . equals  ( fiducial3Location ) )  {   this . invalidateFeederTransformation  ( ) ;   this . updateConnectedFeedersFromThis  ( ) ;   firePropertyChange  ( "fiducial3Location" , oldValue , fiducial3Location ) ; } }   public boolean isNormalize  ( )  {  return normalize ; }   public void setNormalize  (  boolean normalize )  {  boolean  oldValue =  this . normalize ;    this . normalize = normalize ;  if  (  oldValue != normalize )  {   this . invalidateFeederTransformation  ( ) ;   this . updateConnectedFeedersFromThis  ( ) ;   firePropertyChange  ( "normalize" , oldValue , normalize ) ; } }   public Length getTapeLength  ( )  {  return tapeLength ; }   public void setTapeLength  (  Length tapeLength )  {  Length  oldValue =  this . tapeLength ;    this . tapeLength = tapeLength ;  if  (  !  oldValue . equals  ( tapeLength ) )  {   this . updateConnectedFeedersFromThis  ( ) ;   firePropertyChange  ( "tapeLength" , oldValue , tapeLength ) ; } }   public Length getFeederExtent  ( )  {  return feederExtent ; }   public void setFeederExtent  (  Length feederExtent )  {  Length  oldValue =  this . feederExtent ;    this . feederExtent = feederExtent ;  if  (  !  oldValue . equals  ( feederExtent ) )  {   this . updateConnectedFeedersFromThis  ( ) ;   firePropertyChange  ( "feederExtent" , oldValue , feederExtent ) ; } }   public Length getPocketCenterline  ( )  {  return pocketCenterline ; }   public void setPocketCenterline  (  Length pocketCenterline )  {  Length  oldValue =  this . pocketCenterline ;    this . pocketCenterline = pocketCenterline ;   firePropertyChange  ( "pocketCenterline" , oldValue , pocketCenterline ) ;   updateTapeNumbering  ( ) ; }   public Length getPocketPitch  ( )  {  return pocketPitch ; }   public void setPocketPitch  (  Length pocketPitch )  {  Length  oldValue =  this . pocketPitch ;    this . pocketPitch = pocketPitch ;   firePropertyChange  ( "pocketPitch" , oldValue , pocketPitch ) ; }   public Length getPocketSize  ( )  {  return pocketSize ; }   public void setPocketSize  (  Length pocketSize )  {  Length  oldValue =  this . pocketSize ;    this . pocketSize = pocketSize ;   firePropertyChange  ( "pocketSize" , oldValue , pocketSize ) ; }   public  int getPocketCount  ( )  {  return pocketCount ; }   public void setPocketCount  (   int pocketCount )  {   int  oldValue =  this . pocketCount ;    this . pocketCount = pocketCount ;   firePropertyChange  ( "pocketCount" , oldValue , pocketCount ) ;   this . setFirstPocket  (  Math . max  ( 1 ,  Math . min  ( pocketCount ,  this . getFirstPocket  ( ) ) ) ) ;   this . setLastPocket  (  Math . min  ( pocketCount ,  Math . max  (  this . getFirstPocket  ( ) ,    this . getLastPocket  ( ) - oldValue + pocketCount ) ) ) ; }   public  int getFirstPocket  ( )  {  return firstPocket ; }   public void setFirstPocket  (   int firstPocket )  {   int  oldValue =  this . firstPocket ;    this . firstPocket = firstPocket ;   firePropertyChange  ( "firstPocket" , oldValue , firstPocket ) ; }   public  int getLastPocket  ( )  {  return lastPocket ; }   public void setLastPocket  (   int lastPocket )  {   int  oldValue =  this . lastPocket ;    this . lastPocket = lastPocket ;   firePropertyChange  ( "lastPocket" , oldValue , lastPocket ) ; }   public Length getPocketDistance  ( )  {  return pocketDistance ; }   public void setPocketDistance  (  Length pocketDistance )  {  Length  oldValue =  this . pocketDistance ;    this . pocketDistance = pocketDistance ;   firePropertyChange  ( "pocketDistance" , oldValue , pocketDistance ) ; }   public Length getCoverPosition  ( )  {  return coverPosition ; }   public void setCoverPosition  (  Length coverPosition )  {  Length  oldValue =  this . coverPosition ;    this . coverPosition = coverPosition ;  if  (  !  (   oldValue . equals  ( coverPosition ) ||   Double . isNaN  (  oldValue . getValue  ( ) ) ==  Double . isNaN  (  coverPosition . getValue  ( ) ) ) )  {   firePropertyChange  ( "coverPosition" , oldValue , coverPosition ) ;   this . updateConnectedFeedersFromThis  ( ) ; } }   public  int getFeedCount  ( )  {  return feedCount ; }   public void setFeedCount  (   int feedCount )  {   int  oldValue =  this . feedCount ;    this . feedCount = feedCount ;   firePropertyChange  ( "feedCount" , oldValue , feedCount ) ; }   public boolean isVisionEnabled  ( )  {  return visionEnabled ; }   public void setVisionEnabled  (  boolean visionEnabled )  {  boolean  oldValue =  this . visionEnabled ;    this . visionEnabled = visionEnabled ;   firePropertyChange  ( "visionEnabled" , oldValue , visionEnabled ) ;  if  (  oldValue != visionEnabled )  {   firePropertyChange  ( "visionEnabled" , oldValue , visionEnabled ) ;   this . updateConnectedFeedersFromThis  ( ) ; } }   public  int getFeederNo  ( )  {  return feederNo ; }   public void setFeederNo  (   int feederNo )  {   int  oldValue =  this . feederNo ;    this . feederNo = feederNo ;   firePropertyChange  ( "feederNo" , oldValue , feederNo ) ; }   public  int getFeedersTotal  ( )  {  return feedersTotal ; }   public Length getEdgeOpenDistance  ( )  {  return edgeOpenDistance ; }   public void setEdgeOpenDistance  (  Length edgeOpenDistance )  {  Length  oldValue =  this . edgeOpenDistance ;    this . edgeOpenDistance = edgeOpenDistance ;  if  (  !  oldValue . equals  ( edgeOpenDistance ) )  {   this . updateConnectedFeedersFromThis  ( ) ;   firePropertyChange  ( "edgeOpenDistance" , oldValue , edgeOpenDistance ) ; } }   public Length getEdgeClosedDistance  ( )  {  return edgeClosedDistance ; }   public void setEdgeClosedDistance  (  Length edgeClosedDistance )  {  Length  oldValue =  this . edgeClosedDistance ;    this . edgeClosedDistance = edgeClosedDistance ;  if  (  !  oldValue . equals  ( edgeClosedDistance ) )  {   this . updateConnectedFeedersFromThis  ( ) ;   firePropertyChange  ( "edgeClosedDistance" , oldValue , edgeClosedDistance ) ; } }   public  double getPushSpeed  ( )  {  return pushSpeed ; }   public void setPushSpeed  (   double pushSpeed )  {    this . pushSpeed = pushSpeed ; }   public Length getPushZOffset  ( )  {  return pushZOffset ; }   public void setPushZOffset  (  Length pushZOffset )  {  Length  oldValue =  this . pushZOffset ;    this . pushZOffset = pushZOffset ;   firePropertyChange  ( "pushZOffset" , oldValue , pushZOffset ) ; }   public CoverType getCoverType  ( )  {  return coverType ; }   public void setCoverType  (  CoverType coverType )  {    this . coverType = coverType ; }   public CoverActuation getCoverActuation  ( )  {  return coverActuation ; }   public void setCoverActuation  (  CoverActuation coverActuation )  {    this . coverActuation = coverActuation ; }   public void setFeedersTotal  (   int feedersTotal )  {   int  oldValue =  this . feedersTotal ;    this . feedersTotal = feedersTotal ;   firePropertyChange  ( "feedersTotal" , oldValue , feedersTotal ) ; }    @ Override public String toString  ( )  {  return  getName  ( ) ; }    @ Override public Wizard getConfigurationWizard  ( )  {  return  new BlindsFeederConfigurationWizard  ( this ) ; }    @ Override public String getPropertySheetHolderTitle  ( )  {  return     getClass  ( ) . getSimpleName  ( ) + " " +  getName  ( ) ; }    @ Override public  PropertySheetHolder  [ ] getChildPropertySheetHolders  ( )  {  return null ; }    @ Override public  Action  [ ] getPropertySheetHolderActions  ( )  {  return null ; }   private static CvPipeline createDefaultPipeline  ( )  {  try  {  String  xml =  IOUtils . toString  (   BlindsFeeder . class . getResource  ( "BlindsFeeder-DefaultPipeline.xml" ) ) ;  return  new CvPipeline  ( xml ) ; }  catch (   Exception e )  {  throw  new Error  ( e ) ; } }   public static void actuateAllFeederCovers  (  Nozzle preferredNozzle ,  boolean openState )  throws Exception  {   List  < BlindsFeeder >  feederList =  getFeedersWithCoverToActuate  (    Configuration . get  ( ) . getMachine  ( ) . getFeeders  ( ) ,  new CoverActuation  [ ]  {  CoverActuation . Manual ,  CoverActuation . CheckOpen ,  CoverActuation . OpenOnFirstUse ,  CoverActuation . OpenOnJobStart } , openState ) ;  if  (   feederList . size  ( ) == 0 )  {  throw  new Exception  (  "[BlindsFeeder] No feeders found to " +  (  openState ? "open." : "close." ) ) ; }   actuateListedFeederCovers  ( preferredNozzle , feederList , openState , false ) ; }   public static void actuateListedFeederCovers  (  Nozzle preferredNozzle ,   List  < BlindsFeeder > feederList ,  boolean openState ,  boolean restoreNozzleTip )  throws Exception  {  if  (   feederList . size  ( ) == 0 )  {  return ; }  NozzleAndTipForPushing  nozzleAndTipForPushing =  BlindsFeeder . getNozzleAndTipForPushing  ( preferredNozzle , true ) ;   TravellingSalesman  < BlindsFeeder >  tsm =  new  TravellingSalesman  < >  ( feederList ,  new   TravellingSalesman . Locator  < BlindsFeeder >  ( )  {    @ Override public Location getLocation  (  BlindsFeeder locatable )  {  return  locatable . getUncalibratedPickLocation  (  openState ? 0 :   locatable . getPocketCount  ( ) + 1 ) ; } } ,   nozzleAndTipForPushing . getNozzle  ( ) . getLocation  ( ) , null ) ;   tsm . solve  ( ) ;  for ( BlindsFeeder blindsFeeder :  tsm . getTravel  ( ) )  {   blindsFeeder . actuateCover  ( openState ) ; }  if  ( restoreNozzleTip )  {   nozzleAndTipForPushing . restoreNozzleTipLoadedBefore  ( ) ; } }   public static NozzleAndTipForPushing getNozzleAndTipForPushing  (  Nozzle preferredNozzle ,  boolean loadNozzleTipIfNeeded )  throws Exception  {  if  (  preferredNozzle != null )  {  if  (   preferredNozzle . getPart  ( ) == null )  {  NozzleTip  nozzleTip =  preferredNozzle . getNozzleTip  ( ) ;  if  (  nozzleTip . isPushAndDragAllowed  ( ) )  {  return  new NozzleAndTipForPushing  ( preferredNozzle , nozzleTip , false ) ; } } }  Machine  machine =   Configuration . get  ( ) . getMachine  ( ) ;  for ( Head head :  machine . getHeads  ( ) )  {  for ( Nozzle nozzle :  head . getNozzles  ( ) )  {  if  (   nozzle . getPart  ( ) == null )  {  NozzleTip  nozzleTip =  nozzle . getNozzleTip  ( ) ;  if  (  nozzleTip . isPushAndDragAllowed  ( ) )  {  return  new NozzleAndTipForPushing  ( nozzle , nozzleTip , false ) ; } } } }  if  ( loadNozzleTipIfNeeded )  {  for ( Head head :  machine . getHeads  ( ) )  {  for ( Nozzle nozzle :  head . getNozzles  ( ) )  {  if  (   nozzle . getPart  ( ) == null )  {  for ( NozzleTip pushNozzleTip :  nozzle . getCompatibleNozzleTips  ( ) )  {  if  (  pushNozzleTip . isPushAndDragAllowed  ( ) )  {  NozzleTip  nozzleTip =  nozzle . getNozzleTip  ( ) ;   nozzle . loadNozzleTip  ( pushNozzleTip ) ;  return  new NozzleAndTipForPushing  ( nozzle , nozzleTip , true ) ; } } } } }  throw  new Exception  ( "BlindsFeeder: No empty Nozzle/NozzleTip found that allows pushing." ) ; }  return  new NozzleAndTipForPushing  ( null , null , false ) ; }    @ Override public Location getJobPreparationLocation  ( )  {  if  (    getCoverActuation  ( ) ==  CoverActuation . OpenOnJobStart &&  !  isCoverOpen  ( ) )  {  return  getUncalibratedPickLocation  ( 0 ) ; } else  {  return null ; } }   private NozzleAndTipForPushing  nozzleAndTipForPushing = null ;    @ Override public void prepareForJob  (  boolean visit )  throws Exception  {   super . prepareForJob  ( visit ) ;  if  (   visit &&   getCoverActuation  ( ) ==  CoverActuation . OpenOnJobStart &&  !  isCoverOpen  ( ) )  {   nozzleAndTipForPushing =  BlindsFeeder . getNozzleAndTipForPushing  ( null , true ) ;   actuateCover  ( true ) ;  if  (  !  nozzleAndTipForPushing . isChanged  ( ) )  {   nozzleAndTipForPushing = null ; } } else  if  (  ! visit )  {  if  (  nozzleAndTipForPushing != null )  {   nozzleAndTipForPushing . restoreNozzleTipLoadedBefore  ( ) ;   nozzleAndTipForPushing = null ; } } }   public void actuateCover  (  Nozzle preferredNozzle ,  boolean openState )  throws Exception  {   actuateCover  ( preferredNozzle , openState , true , false ) ; }   public void actuateCover  (  Nozzle preferredNozzle ,  boolean openState ,  boolean loadNozzleTipIfNeeded ,  boolean restoreNozzleTip )  throws Exception  {  if  (  coverType ==  CoverType . NoCover )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": has no cover to actuate." ) ; } else  {  if  (   location . getZ  ( ) == 0.0 )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + " Part Z not set." ) ; }  NozzleAndTipForPushing  nozzleAndTipForPushing =  BlindsFeeder . getNozzleAndTipForPushing  ( preferredNozzle , loadNozzleTipIfNeeded ) ;  Nozzle  nozzle =  nozzleAndTipForPushing . getNozzle  ( ) ;  NozzleTip  nozzleTip =  nozzleAndTipForPushing . getNozzleTip  ( ) ;  if  (  nozzleTip == null )  {  throw  new Exception  (   "Feeder " +  getName  ( ) + ": loaded nozzle tips do not allow pushing. Check the nozzle tip configuration or change the nozzle tip." ) ; }  Length  nozzleTipDiameter =  nozzleTip . getDiameterLow  ( ) ;  if  (   nozzleTipDiameter . getValue  ( ) == 0. )  {  throw  new Exception  (     "Feeder " +  getName  ( ) + ": current nozzle tip " +  nozzleTip . getId  ( ) + " has push diameter not set. Check the nozzle tip configuration." ) ; }  Length  backlashOffset =  new Length  ( 0.0 ,   getFiducial2Location  ( ) . getUnits  ( ) ) ;   double  backlashOpen = 0.0 ;   double  backlashClose = 0.0 ;  ReferenceMachine  referenceMachine ;  if  (    Configuration . get  ( ) . getMachine  ( ) instanceof ReferenceMachine )  {   referenceMachine =  ( ReferenceMachine )   Configuration . get  ( ) . getMachine  ( ) ;  if  (   referenceMachine . getDriver  ( ) instanceof GcodeDriver )  {  GcodeDriver  gcodeDriver =  ( GcodeDriver )  referenceMachine . getDriver  ( ) ;  Location  backlashVector =  new Location  (  gcodeDriver . getUnits  ( ) ,  gcodeDriver . getBacklashOffsetX  ( ) ,  gcodeDriver . getBacklashOffsetY  ( ) , 0.0 , 0.0 ) ;  Location  unitVectorX =   getFiducial1Location  ( ) . unitVectorTo  (  getFiducial2Location  ( ) ) ;   backlashOffset =  unitVectorX . dotProduct  ( backlashVector ) ;   backlashOpen =    backlashOffset . getValue  ( ) > 0.0 ? 1.0 : 0.0 ;   backlashClose =    backlashOffset . getValue  ( ) < 0.0 ? 1.0 : 0.0 ; } }   assertCalibration  ( ) ;  if  (  coverType ==  CoverType . BlindsCover )  {  Length  feederX0 =    (  openState ?     edgeOpenDistance . multiply  (  - 1.0 ) . subtract  (  sprocketPitch . multiply  ( 0.5 ) ) . subtract  (  nozzleTipDiameter . multiply  ( 0.5 ) ) . subtract  (  backlashOffset . multiply  ( backlashOpen ) ) :    edgeClosedDistance . add  ( tapeLength ) . add  (  sprocketPitch . multiply  ( 0.5 ) ) . add  (  nozzleTipDiameter . multiply  ( 0.5 ) ) ) . subtract  (  backlashOffset . multiply  ( backlashClose ) ) . convertToUnits  (  location . getUnits  ( ) ) ;  Length  feederX1 =    (  openState ?    edgeOpenDistance . multiply  (  - 1.0 ) . subtract  (  nozzleTipDiameter . multiply  ( 0.5 ) ) . subtract  (  backlashOffset . multiply  ( backlashOpen ) ) :   edgeClosedDistance . add  ( tapeLength ) . add  (  nozzleTipDiameter . multiply  ( 0.5 ) ) ) . subtract  (  backlashOffset . multiply  ( backlashClose ) ) . convertToUnits  (  location . getUnits  ( ) ) ;  Length  feederY =  pocketCenterline . convertToUnits  (  location . getUnits  ( ) ) ;  Length  feederZ =   location . getLengthZ  ( ) . add  ( pushZOffset ) ;  Location  feederLocation0 =  new Location  (  location . getUnits  ( ) ,  feederX0 . getValue  ( ) ,  feederY . getValue  ( ) ,  feederZ . getValue  ( ) ,  getPickRotationInTape  ( ) ) ;  Location  feederLocation1 =  new Location  (  location . getUnits  ( ) ,  feederX1 . getValue  ( ) ,  feederY . getValue  ( ) ,  feederZ . getValue  ( ) ,  getPickRotationInTape  ( ) ) ;  Location  machineLocation0 =  transformFeederToMachineLocation  ( feederLocation0 ) ;  Location  machineLocation1 =  transformFeederToMachineLocation  ( feederLocation1 ) ;   MovableUtils . moveToLocationAtSafeZ  ( nozzle , machineLocation0 ) ;   nozzle . moveTo  ( machineLocation1 ,     nozzle . getHead  ( ) . getMachine  ( ) . getSpeed  ( ) * pushSpeed ) ;    nozzle . getHead  ( ) . moveToSafeZ  ( ) ;   setCoverPosition  (  openState ? pocketDistance :  pocketDistance . subtract  (  pocketPitch . multiply  ( 0.5 ) ) ) ; } else  if  (   coverType ==  CoverType . PushCover && openState )  {  Location  pickLocation =  getPickLocation  (   getFedPocketNumber  ( ) + 1 ) ;  Location  pickFeederLocation =  transformMachineToFeederLocation  ( pickLocation ) ;  Length  feederX0 =   (     getFeedCount  ( ) == 0 ||  !  isCoverOpen  ( ) ?   pocketPitch . multiply  (  - 0.5 ) . subtract  (  nozzleTipDiameter . multiply  ( 1 ) ) :   coverPosition . subtract  (  pocketPitch . multiply  ( 0.5 ) ) . subtract  (  nozzleTipDiameter . multiply  ( 1 ) ) ) . convertToUnits  (  location . getUnits  ( ) ) ;  Length  feederX1 =     pickFeederLocation . getLengthX  ( ) . add  (  pocketPitch . multiply  ( 0.5 ) ) . subtract  (  nozzleTipDiameter . multiply  ( 0.5 ) ) . convertToUnits  (  location . getUnits  ( ) ) ;  Length  feederY =   pickFeederLocation . getLengthY  ( ) . convertToUnits  (  location . getUnits  ( ) ) ;  Length  feederZ =   location . getLengthZ  ( ) . subtract  ( pushZOffset ) ;  Location  feederLocation0 =  new Location  (  location . getUnits  ( ) ,  feederX0 . getValue  ( ) ,  feederY . getValue  ( ) ,  feederZ . getValue  ( ) ,  getPickRotationInTape  ( ) ) ;  Location  feederLocation1 =  new Location  (  location . getUnits  ( ) ,  feederX1 . getValue  ( ) ,  feederY . getValue  ( ) ,  feederZ . getValue  ( ) ,  getPickRotationInTape  ( ) ) ;  Location  machineLocation0 =  transformFeederToMachineLocation  ( feederLocation0 ) ;  Location  machineLocation1 =  transformFeederToMachineLocation  ( feederLocation1 ) ;   MovableUtils . moveToLocationAtSafeZ  ( nozzle , machineLocation0 ) ;   nozzle . moveTo  ( machineLocation1 ,     nozzle . getHead  ( ) . getMachine  ( ) . getSpeed  ( ) * pushSpeed ) ;   nozzle . moveTo  (  pickLocation . derive  ( machineLocation1 , false , false , true , false ) ) ;   setCoverPosition  (  pickFeederLocation . getLengthX  ( ) ) ; }  if  ( restoreNozzleTip )  {   nozzleAndTipForPushing . restoreNozzleTipLoadedBefore  ( ) ; } } } }