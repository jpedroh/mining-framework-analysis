  package   org . sonar . objectivec ;   import   java . io . File ;  import   java . util . Collection ;  import     org . sonar . objectivec . api . ObjectiveCGrammar ;  import     org . sonar . objectivec . api . ObjectiveCMetric ;  import     org . sonar . objectivec . parser . ObjectiveCParser ;  import    org . sonar . squidbridge . AstScanner ;  import    org . sonar . squidbridge . CommentAnalyser ;  import    org . sonar . squidbridge . SquidAstVisitor ;  import    org . sonar . squidbridge . SquidAstVisitorContextImpl ;  import     org . sonar . squidbridge . api . SourceCode ;  import     org . sonar . squidbridge . api . SourceFile ;  import     org . sonar . squidbridge . api . SourceProject ;  import     org . sonar . squidbridge . indexer . QueryByType ;  import     org . sonar . squidbridge . metrics . CommentsVisitor ;  import     org . sonar . squidbridge . metrics . LinesOfCodeVisitor ;  import     org . sonar . squidbridge . metrics . LinesVisitor ;  import     com . sonar . sslr . impl . Parser ;  import      com . sonar . sslr . squid . metrics . CounterVisitor ;   public class ObjectiveCAstScanner  {   private ObjectiveCAstScanner  ( )  { }   public static SourceFile scanSingleFile  (  File file ,   SquidAstVisitor  < ObjectiveCGrammar > ...  visitors )  {  if  (  !  file . isFile  ( ) )  {  throw  new IllegalArgumentException  (   "File '" + file + "' not found." ) ; }   AstScanner  < ObjectiveCGrammar >  scanner =  create  (  new ObjectiveCConfiguration  ( ) , visitors ) ;   scanner . scanFile  ( file ) ;   Collection  < SourceCode >  sources =   scanner . getIndex  ( ) . search  (  new QueryByType  (  SourceFile . class ) ) ;  if  (   sources . size  ( ) != 1 )  {  throw  new IllegalStateException  (   "Only one SourceFile was expected whereas " +  sources . size  ( ) + " has been returned." ) ; }  return  ( SourceFile )   sources . iterator  ( ) . next  ( ) ; }   public static  AstScanner  < ObjectiveCGrammar > create  (  ObjectiveCConfiguration conf ,   SquidAstVisitor  < ObjectiveCGrammar > ...  visitors )  {   final  SquidAstVisitorContextImpl  < ObjectiveCGrammar >  context =  new  SquidAstVisitorContextImpl  < ObjectiveCGrammar >  (  new SourceProject  ( "Objective-C Project" ) ) ;   final  Parser  < ObjectiveCGrammar >  parser =  ObjectiveCParser . create  ( conf ) ;     AstScanner . Builder < ObjectiveCGrammar >  builder =   AstScanner .  < ObjectiveCGrammar > builder  ( context ) . setBaseParser  ( parser ) ;   builder . withMetrics  (  ObjectiveCMetric . values  ( ) ) ;   builder . setCommentAnalyser  (  new CommentAnalyser  ( )  {    @ Override public boolean isBlank  (  String line )  {  for (   int  i = 0 ;  i <  line . length  ( ) ;  i ++ )  {  if  (  Character . isLetterOrDigit  (  line . charAt  ( i ) ) )  {  return false ; } }  return true ; }    @ Override public String getContents  (  String comment )  {  return   comment . startsWith  ( "//" ) ?  comment . substring  ( 2 ) :  comment . substring  ( 2 ,   comment . length  ( ) - 2 ) ; } } ) ;   builder . setFilesMetric  (  ObjectiveCMetric . FILES ) ;   builder . withSquidAstVisitor  (  new  LinesVisitor  < ObjectiveCGrammar >  (  ObjectiveCMetric . LINES ) ) ;   builder . withSquidAstVisitor  (  new  LinesOfCodeVisitor  < ObjectiveCGrammar >  (  ObjectiveCMetric . LINES_OF_CODE ) ) ;   builder . withSquidAstVisitor  (      CommentsVisitor .  < ObjectiveCGrammar > builder  ( ) . withCommentMetric  (  ObjectiveCMetric . COMMENT_LINES ) . withNoSonar  ( true ) . withIgnoreHeaderComment  (  conf . getIgnoreHeaderComments  ( ) ) . build  ( ) ) ;   builder . withSquidAstVisitor  (     CounterVisitor .  < ObjectiveCGrammar > builder  ( ) . setMetricDef  (  ObjectiveCMetric . STATEMENTS ) . subscribeTo  (   parser . getGrammar  ( ) . statement ) . build  ( ) ) ;  return  builder . build  ( ) ; } }