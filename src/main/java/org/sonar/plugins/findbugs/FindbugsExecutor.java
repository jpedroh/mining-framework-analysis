  package    org . sonar . plugins . findbugs ;   import     edu . umd . cs . findbugs . BugCollection ;  import     edu . umd . cs . findbugs . BugInstance ;  import     edu . umd . cs . findbugs . BugPattern ;  import     edu . umd . cs . findbugs . DetectorFactory ;  import     edu . umd . cs . findbugs . DetectorFactoryCollection ;  import     edu . umd . cs . findbugs . FindBugs ;  import     edu . umd . cs . findbugs . FindBugs2 ;  import     edu . umd . cs . findbugs . Plugin ;  import     edu . umd . cs . findbugs . PluginException ;  import     edu . umd . cs . findbugs . Priorities ;  import     edu . umd . cs . findbugs . Project ;  import     edu . umd . cs . findbugs . XMLBugReporter ;  import      edu . umd . cs . findbugs . config . UserPreferences ;  import      edu . umd . cs . findbugs . plugins . DuplicatePluginIdException ;  import     org . apache . commons . io . FileUtils ;  import     org . apache . commons . io . IOUtils ;  import     org . apache . commons . lang3 . StringUtils ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     org . sonar . api . batch . ScannerSide ;  import      org . sonar . api . batch . fs . FileSystem ;  import      org . sonar . api . batch . rule . ActiveRules ;  import     org . sonar . api . config . Configuration ;  import     org . sonar . api . rule . RuleKey ;  import      org . sonar . plugins . findbugs . rules . FindbugsRules ;  import   java . io . File ;  import   java . io . FileReader ;  import   java . io . IOException ;  import   java . io . OutputStream ;  import   java . io . PrintStream ;  import   java . net . URI ;  import   java . net . URISyntaxException ;  import   java . net . URL ;  import  java . util .  * ;  import    java . util . concurrent . Callable ;  import    java . util . concurrent . ExecutorService ;  import    java . util . concurrent . Executors ;  import    java . util . concurrent . TimeUnit ;  import    java . util . concurrent . TimeoutException ;    @ ScannerSide public class FindbugsExecutor  {   private static final String  FINDBUGS_CORE_PLUGIN_ID = "edu.umd.cs.findbugs.plugins.core" ;   private static final Logger  LOG =  LoggerFactory . getLogger  (  FindbugsExecutor . class ) ;   public static final  List  < String >  EXISTING_FINDBUGS_REPORT_PATHS =  Arrays . asList  ( "/target/findbugsXml.xml" , "/target/spotbugsXml.xml" ) ;   private FileSystem  fs ;   private Configuration  config ;   private static  Map  < String , Integer >  priorityNameToValueMap =  new  HashMap  < String , Integer >  ( ) ;  static  {   priorityNameToValueMap . put  ( "high" ,  Priorities . HIGH_PRIORITY ) ;   priorityNameToValueMap . put  ( "medium" ,  Priorities . NORMAL_PRIORITY ) ;   priorityNameToValueMap . put  ( "low" ,  Priorities . LOW_PRIORITY ) ;   priorityNameToValueMap . put  ( "experimental" ,  Priorities . EXP_PRIORITY ) ; }   private static final Integer  DEFAULT_PRIORITY =  Priorities . NORMAL_PRIORITY ;   private final FindbugsConfiguration  configuration ;   public FindbugsExecutor  (  FindbugsConfiguration configuration ,  FileSystem fs ,  Configuration config )  {    this . configuration = configuration ;    this . fs = fs ;    this . config = config ; }   public  Collection  < ReportedBug > execute  (  ActiveRules activeRules )  {  SecurityManager  currentSecurityManager =  System . getSecurityManager  ( ) ;  ClassLoader  initialClassLoader =   Thread . currentThread  ( ) . getContextClassLoader  ( ) ;    Thread . currentThread  ( ) . setContextClassLoader  (   FindBugs2 . class . getClassLoader  ( ) ) ;  Locale  initialLocale =  Locale . getDefault  ( ) ;   Locale . setDefault  (  Locale . ENGLISH ) ;  OutputStream  xmlOutput = null ;  ExecutorService  executorService =  Executors . newSingleThreadExecutor  ( ) ;  try  (  FindBugs2 engine =  new FindBugs2  ( ) ;  Project project =  new Project  ( ) )  {   configuration . initializeFindbugsProject  ( project ) ;  if  (   project . getFileCount  ( ) == 0 )  {   LOG . info  ( "Findbugs analysis skipped for this project." ) ;  return  new  ArrayList  < >  ( ) ; }   loadFindbugsPlugins  ( ) ;   disableUnnecessaryDetectors  (  project . getConfiguration  ( ) , activeRules ) ;   disableUpdateChecksOnEveryPlugin  ( ) ;   engine . setProject  ( project ) ;  XMLBugReporter  xmlBugReporter =  new XMLBugReporter  ( project ) ;   xmlBugReporter . setPriorityThreshold  (  determinePriorityThreshold  ( ) ) ;   xmlBugReporter . setAddMessages  ( true ) ;  File  xmlReport =  configuration . getTargetXMLReport  ( ) ;   LOG . info  (  "Findbugs output report: " +  xmlReport . getAbsolutePath  ( ) ) ;   xmlOutput =  FileUtils . openOutputStream  ( xmlReport ) ;   xmlBugReporter . setOutputStream  (  new PrintStream  ( xmlOutput ) ) ;   engine . setBugReporter  ( xmlBugReporter ) ;  UserPreferences  userPreferences =  UserPreferences . createDefaultUserPreferences  ( ) ;   userPreferences . setEffort  (  configuration . getEffort  ( ) ) ;   engine . setUserPreferences  ( userPreferences ) ;   engine . addFilter  (   configuration . saveIncludeConfigXml  ( ) . getAbsolutePath  ( ) , true ) ;  for ( File filterFile :  configuration . getExcludesFilters  ( ) )  {  if  (  filterFile . isFile  ( ) )  {   LOG . info  ( "Use filter-file: {}" , filterFile ) ;   engine . addFilter  (  filterFile . getAbsolutePath  ( ) , false ) ; } else  {   LOG . warn  ( "FindBugs filter-file not found: {}" , filterFile ) ; } }   engine . setDetectorFactoryCollection  (  DetectorFactoryCollection . instance  ( ) ) ;   engine . setAnalysisFeatureSettings  (  FindBugs . DEFAULT_EFFORT ) ;   engine . finishSettings  ( ) ;   List  < String >  potentialReportPaths =  new  ArrayList  < >  ( ) ;   potentialReportPaths . addAll  ( EXISTING_FINDBUGS_REPORT_PATHS ) ;   String  [ ]  paths =  config . getStringArray  (  FindbugsConstants . REPORT_PATHS ) ;  if  (  paths != null )   potentialReportPaths . addAll  (  Arrays . asList  ( paths ) ) ;  boolean  foundExistingReport = false ;  reportPaths :  for ( String potentialPath : potentialReportPaths )  {  File  findbugsReport =  new File  (  fs . baseDir  ( ) , potentialPath ) ;  if  (    findbugsReport . exists  ( ) &&  !  findbugsReport . isDirectory  ( ) &&   findbugsReport . length  ( ) > 0 )  {   LOG . info  ( "FindBugs report is already generated {}. Reusing the report." ,  findbugsReport . getAbsolutePath  ( ) ) ;    xmlBugReporter . getBugCollection  ( ) . readXML  (  new FileReader  ( findbugsReport ) ) ;   foundExistingReport = true ;  break reportPaths ; } }  if  (  ! foundExistingReport )  {    executorService . submit  (  new FindbugsTask  ( engine ) ) . get  (  configuration . getTimeout  ( ) ,  TimeUnit . MILLISECONDS ) ; }  return  toReportedBugs  (  xmlBugReporter . getBugCollection  ( ) ) ; }  catch (   TimeoutException e )  {  throw  new IllegalStateException  (   "Can not execute Findbugs with a timeout threshold value of " +  configuration . getTimeout  ( ) + " milliseconds" , e ) ; }  catch (   Exception e )  {  throw  new IllegalStateException  ( "Can not execute Findbugs" , e ) ; }  finally  {   System . setSecurityManager  ( currentSecurityManager ) ;   executorService . shutdown  ( ) ;   IOUtils . closeQuietly  ( xmlOutput ) ;    Thread . currentThread  ( ) . setContextClassLoader  ( initialClassLoader ) ;   Locale . setDefault  ( initialLocale ) ; } }   private static  Collection  < ReportedBug > toReportedBugs  (  BugCollection bugCollection )  {   final  Collection  < ReportedBug >  bugs =  new  ArrayList  < ReportedBug >  ( ) ;  for (  final BugInstance bugInstance : bugCollection )  {  if  (   bugInstance . getPrimarySourceLineAnnotation  ( ) == null )  {   LOG . warn  (  "No source line for " +  bugInstance . getType  ( ) ) ;  continue ; }   bugs . add  (  new ReportedBug  ( bugInstance ) ) ; }  return bugs ; }   private Integer determinePriorityThreshold  ( )  {  Integer  integer =  priorityNameToValueMap . get  (  configuration . getConfidenceLevel  ( ) ) ;  if  (  integer == null )  {   integer = DEFAULT_PRIORITY ; }  return integer ; }   private static class FindbugsTask  implements   Callable  < Object >  {   private final FindBugs2  engine ;   public FindbugsTask  (  FindBugs2 engine )  {    this . engine = engine ; }    @ Override public Object call  ( )  {  try  {   engine . execute  ( ) ;  return null ; }  catch (   InterruptedException e )  {   LOG . error  ( "Execution was interrupted" , e ) ;    Thread . currentThread  ( ) . interrupt  ( ) ;  throw  new FindbugsPluginException  ( "Execution was interrupted" , e ) ; }  catch (   IOException e )  {  throw  new FindbugsPluginException  (  "Analysis error: " +  e . getMessage  ( ) , e ) ; }  finally  {   engine . dispose  ( ) ; } } }   public static  Map  < String , Plugin > loadFindbugsPlugins  ( )  {  ClassLoader  contextClassLoader =   FindbugsExecutor . class . getClassLoader  ( ) ;   List  < String >  pluginJarPathList =  new  ArrayList  < >  ( ) ;  try  {   Enumeration  < URL >  urls =  contextClassLoader . getResources  ( "findbugs.xml" ) ;  while  (  urls . hasMoreElements  ( ) )  {  URL  url =  urls . nextElement  ( ) ;   pluginJarPathList . add  (  normalizeUrl  ( url ) ) ; } }  catch (   IOException e )  {  throw  new IllegalStateException  ( e ) ; }  catch (   URISyntaxException e )  {  throw  new IllegalStateException  ( e ) ; }   Map  < String , Plugin >  plugins =  new  HashMap  < >  ( ) ;  for ( String path : pluginJarPathList )  {  try  {  URI  uri =   new File  ( path ) . toURI  ( ) ;  Plugin  plugin =   Plugin . getAllPluginsMap  ( ) . get  ( uri ) ;  if  (  plugin == null )  {   LOG . info  (  "Loading findbugs plugin: " + path ) ;   plugin =  Plugin . addCustomPlugin  ( uri , contextClassLoader ) ; }  if  (  plugin != null )  {   plugins . put  (  plugin . getPluginId  ( ) , plugin ) ; } }  catch (   PluginException e )  {   LOG . warn  (  "Failed to load plugin for custom detector: " + path ) ;   LOG . debug  ( "Cause of failure" , e ) ; }  catch (   DuplicatePluginIdException e )  {  if  (  !  FINDBUGS_CORE_PLUGIN_ID . equals  (  e . getPluginId  ( ) ) )  {   LOG . debug  (  "Plugin already loaded: exception ignored: " +  e . getMessage  ( ) , e ) ; } } }  return plugins ; }   private static String normalizeUrl  (  URL url )  throws URISyntaxException  {  return  StringUtils . removeStart  (  StringUtils . substringBefore  (   url . toURI  ( ) . getSchemeSpecificPart  ( ) , "!" ) , "file:" ) ; }   private static void disableUpdateChecksOnEveryPlugin  ( )  {  for ( Plugin plugin :  Plugin . getAllPlugins  ( ) )  {   plugin . setMyGlobalOption  ( "noUpdateChecks" , "true" ) ; } }   public static void disableUnnecessaryDetectors  (  UserPreferences userPreferences ,  ActiveRules activeRules )  {  for ( DetectorFactory detectorFactory :   DetectorFactoryCollection . instance  ( ) . getFactories  ( ) )  {  boolean  enabled =   !  detectorFactory . isReportingDetector  ( ) ||  detectorFactoryHasActiveRules  ( detectorFactory , activeRules ) ;   userPreferences . enableDetector  ( detectorFactory , enabled ) ; } }   private static boolean detectorFactoryHasActiveRules  (  DetectorFactory detectorFactory ,  ActiveRules activeRules )  {   Collection  < String >  repositories =  FindbugsRules . repositoriesForPlugin  (  detectorFactory . getPlugin  ( ) ) ;  if  (  repositories . isEmpty  ( ) )  {   LOG . warn  ( "Detector {} is activated because it is not from a built-in plugin, cannot check if there are some active rules" , detectorFactory ) ;  return true ; }  for ( BugPattern bugPattern :  detectorFactory . getReportedBugPatterns  ( ) )  {  String  bugPatternType =  bugPattern . getType  ( ) ;  for ( String repository : repositories )  {  RuleKey  ruleKey =  RuleKey . of  ( repository , bugPatternType ) ;  if  (   activeRules . find  ( ruleKey ) != null )  {  return true ; } } }  return false ; } 
<<<<<<<
=======
  private static void resetCustomPluginList  (   Collection  < Plugin > customPlugins )  {  if  (  customPlugins != null )  {  for ( Plugin plugin : customPlugins )  {   Plugin . removeCustomPlugin  ( plugin ) ;  try  {   plugin . close  ( ) ; }  catch (   IOException e )  {   LOG . error  ( "Error closing plugin" , e ) ; } } } }
>>>>>>>
 }