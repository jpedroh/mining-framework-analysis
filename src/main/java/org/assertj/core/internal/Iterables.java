  package    org . assertj . core . internal ;   import static    java . util . Arrays . asList ;  import static    java . util . Arrays . stream ;  import static    java . util . Objects . requireNonNull ;  import static     java . util . stream . Collectors . toCollection ;  import static     java . util . stream . Collectors . toList ;  import static      org . assertj . core . error . AnyElementShouldMatch . anyElementShouldMatch ;  import static      org . assertj . core . error . ConditionAndGroupGenericParameterTypeShouldBeTheSame . shouldBeSameGenericBetweenIterableAndCondition ;  import static      org . assertj . core . error . ElementsShouldBe . elementsShouldBe ;  import static      org . assertj . core . error . ElementsShouldBeAtLeast . elementsShouldBeAtLeast ;  import static      org . assertj . core . error . ElementsShouldBeAtMost . elementsShouldBeAtMost ;  import static      org . assertj . core . error . ElementsShouldBeExactly . elementsShouldBeExactly ;  import static      org . assertj . core . error . ElementsShouldHave . elementsShouldHave ;  import static      org . assertj . core . error . ElementsShouldHaveAtLeast . elementsShouldHaveAtLeast ;  import static      org . assertj . core . error . ElementsShouldHaveAtMost . elementsShouldHaveAtMost ;  import static      org . assertj . core . error . ElementsShouldHaveExactly . elementsShouldHaveExactly ;  import static      org . assertj . core . error . ElementsShouldMatch . elementsShouldMatch ;  import static      org . assertj . core . error . ElementsShouldNotBe . elementsShouldNotBe ;  import static      org . assertj . core . error . ElementsShouldNotHave . elementsShouldNotHave ;  import static      org . assertj . core . error . ElementsShouldSatisfy . elementsShouldSatisfy ;  import static      org . assertj . core . error . ElementsShouldSatisfy . elementsShouldSatisfyAny ;  import static      org . assertj . core . error . NoElementsShouldMatch . noElementsShouldMatch ;  import static      org . assertj . core . error . NoElementsShouldSatisfy . noElementsShouldSatisfy ;  import static      org . assertj . core . error . ShouldBeEmpty . shouldBeEmpty ;  import static      org . assertj . core . error . ShouldBeNullOrEmpty . shouldBeNullOrEmpty ;  import static      org . assertj . core . error . ShouldBeSubsetOf . shouldBeSubsetOf ;  import static      org . assertj . core . error . ShouldContain . shouldContain ;  import static      org . assertj . core . error . ShouldContainAnyOf . shouldContainAnyOf ;  import static      org . assertj . core . error . ShouldContainExactly . elementsDifferAtIndex ;  import static      org . assertj . core . error . ShouldContainExactly . shouldContainExactly ;  import static      org . assertj . core . error . ShouldContainExactlyInAnyOrder . shouldContainExactlyInAnyOrder ;  import static      org . assertj . core . error . ShouldContainNull . shouldContainNull ;  import static      org . assertj . core . error . ShouldContainOnly . shouldContainOnly ;  import static      org . assertj . core . error . ShouldContainOnlyNulls . shouldContainOnlyNulls ;  import static      org . assertj . core . error . ShouldContainSequence . shouldContainSequence ;  import static      org . assertj . core . error . ShouldContainSubsequence . shouldContainSubsequence ;  import static      org . assertj . core . error . ShouldContainsOnlyOnce . shouldContainsOnlyOnce ;  import static      org . assertj . core . error . ShouldEndWith . shouldEndWith ;  import static      org . assertj . core . error . ShouldNotBeEmpty . shouldNotBeEmpty ;  import static      org . assertj . core . error . ShouldNotContain . shouldNotContain ;  import static      org . assertj . core . error . ShouldNotContainNull . shouldNotContainNull ;  import static      org . assertj . core . error . ShouldNotContainSequence . shouldNotContainSequence ;  import static      org . assertj . core . error . ShouldNotContainSubsequence . shouldNotContainSubsequence ;  import static      org . assertj . core . error . ShouldNotHaveDuplicates . shouldNotHaveDuplicates ;  import static      org . assertj . core . error . ShouldStartWith . shouldStartWith ;  import static      org . assertj . core . error . ZippedElementsShouldSatisfy . zippedElementsShouldSatisfy ;  import static      org . assertj . core . internal . Arrays . assertIsArray ;  import static      org . assertj . core . internal . CommonValidations . checkIsNotNull ;  import static      org . assertj . core . internal . CommonValidations . checkIsNotNullAndNotEmpty ;  import static      org . assertj . core . internal . CommonValidations . checkIterableIsNotNull ;  import static      org . assertj . core . internal . CommonValidations . checkSizeBetween ;  import static      org . assertj . core . internal . CommonValidations . checkSizeGreaterThan ;  import static      org . assertj . core . internal . CommonValidations . checkSizeGreaterThanOrEqualTo ;  import static      org . assertj . core . internal . CommonValidations . checkSizeLessThan ;  import static      org . assertj . core . internal . CommonValidations . checkSizeLessThanOrEqualTo ;  import static      org . assertj . core . internal . CommonValidations . checkSizes ;  import static      org . assertj . core . internal . CommonValidations . failIfEmptySinceActualIsNotEmpty ;  import static      org . assertj . core . internal . CommonValidations . hasSameSizeAsCheck ;  import static      org . assertj . core . internal . ErrorMessages . emptySequence ;  import static      org . assertj . core . internal . ErrorMessages . emptySubsequence ;  import static      org . assertj . core . internal . ErrorMessages . nullSequence ;  import static      org . assertj . core . internal . ErrorMessages . nullSubsequence ;  import static      org . assertj . core . internal . IterableDiff . diff ;  import static      org . assertj . core . util . Arrays . prepend ;  import static      org . assertj . core . util . IterableUtil . isNullOrEmpty ;  import static      org . assertj . core . util . IterableUtil . sizeOf ;  import static      org . assertj . core . util . Lists . newArrayList ;  import static      org . assertj . core . util . Streams . stream ;  import   java . util . ArrayList ;  import   java . util . Comparator ;  import   java . util . Iterator ;  import   java . util . LinkedHashSet ;  import   java . util . LinkedList ;  import   java . util . List ;  import   java . util . Optional ;  import   java . util . Set ;  import    java . util . function . BiConsumer ;  import    java . util . function . Consumer ;  import    java . util . function . Predicate ;  import     org . assertj . core . api . AssertionInfo ;  import     org . assertj . core . api . Condition ;  import      org . assertj . core . error . ElementsShouldSatisfy . UnsatisfiedRequirement ;  import      org . assertj . core . error . ZippedElementsShouldSatisfy . ZipSatisfyError ;  import     org . assertj . core . presentation . PredicateDescription ;  import     org . assertj . core . util . VisibleForTesting ;  import static      org . assertj . core . error . ShouldSatisfy . shouldSatisfy ;  import    java . util . function . Function ;   public class Iterables  {   private static final Iterables  INSTANCE =  new Iterables  ( ) ;   private final ComparisonStrategy  comparisonStrategy ;    @ VisibleForTesting Failures  failures =  Failures . instance  ( ) ;    @ VisibleForTesting Conditions  conditions =  Conditions . instance  ( ) ;    @ VisibleForTesting Predicates  predicates =  Predicates . instance  ( ) ;   public static Iterables instance  ( )  {  return INSTANCE ; }    @ VisibleForTesting Iterables  ( )  {  this  (  StandardComparisonStrategy . instance  ( ) ) ; }   public Iterables  (  ComparisonStrategy comparisonStrategy )  {    this . comparisonStrategy = comparisonStrategy ; }    @ VisibleForTesting public  Comparator  <  ? > getComparator  ( )  {  if  (  comparisonStrategy instanceof ComparatorBasedComparisonStrategy )  {  return   (  ( ComparatorBasedComparisonStrategy ) comparisonStrategy ) . getComparator  ( ) ; }  return null ; }    @ VisibleForTesting public ComparisonStrategy getComparisonStrategy  ( )  {  return comparisonStrategy ; }   public void assertNullOrEmpty  (  AssertionInfo info ,   Iterable  <  ? > actual )  {  if  (  !  isNullOrEmpty  ( actual ) )  throw  failures . failure  ( info ,  shouldBeNullOrEmpty  ( actual ) ) ; }   public void assertEmpty  (  AssertionInfo info ,   Iterable  <  ? > actual )  {   assertNotNull  ( info , actual ) ;  if  (  !  isNullOrEmpty  ( actual ) )  throw  failures . failure  ( info ,  shouldBeEmpty  ( actual ) ) ; }   public void assertNotEmpty  (  AssertionInfo info ,   Iterable  <  ? > actual )  {   assertNotNull  ( info , actual ) ;  if  (  isNullOrEmpty  ( actual ) )  throw  failures . failure  ( info ,  shouldNotBeEmpty  ( ) ) ; }   public void assertHasSize  (  AssertionInfo info ,   Iterable  <  ? > actual ,   int expectedSize )  {   assertNotNull  ( info , actual ) ;   checkSizes  ( actual ,  sizeOf  ( actual ) , expectedSize , info ) ; }   public  <  T > void assertHasOnlyOneElementSatisfying  (  AssertionInfo info ,   Iterable  <  ? extends T > actual ,   Consumer  <  ? super T > consumer )  {   assertHasSize  ( info , actual , 1 ) ;   consumer . accept  (   actual . iterator  ( ) . next  ( ) ) ; }   public void assertHasSizeGreaterThan  (  AssertionInfo info ,   Iterable  <  ? > actual ,   int boundary )  {   assertNotNull  ( info , actual ) ;   checkSizeGreaterThan  ( actual , boundary ,  sizeOf  ( actual ) , info ) ; }   public void assertHasSizeGreaterThanOrEqualTo  (  AssertionInfo info ,   Iterable  <  ? > actual ,   int boundary )  {   assertNotNull  ( info , actual ) ;   checkSizeGreaterThanOrEqualTo  ( actual , boundary ,  sizeOf  ( actual ) , info ) ; }   public void assertHasSizeLessThan  (  AssertionInfo info ,   Iterable  <  ? > actual ,   int boundary )  {   assertNotNull  ( info , actual ) ;   checkSizeLessThan  ( actual , boundary ,  sizeOf  ( actual ) , info ) ; }   public void assertHasSizeLessThanOrEqualTo  (  AssertionInfo info ,   Iterable  <  ? > actual ,   int boundary )  {   assertNotNull  ( info , actual ) ;   checkSizeLessThanOrEqualTo  ( actual , boundary ,  sizeOf  ( actual ) , info ) ; }   public void assertHasSizeBetween  (  AssertionInfo info ,   Iterable  <  ? > actual ,   int lowerBoundary ,   int higherBoundary )  {   assertNotNull  ( info , actual ) ;   checkSizeBetween  ( actual , lowerBoundary , higherBoundary ,  sizeOf  ( actual ) , info ) ; }   public void assertHasSameSizeAs  (  AssertionInfo info ,   Iterable  <  ? > actual ,  Object other )  {   assertNotNull  ( info , actual ) ;   assertIsArray  ( info , other ) ;   hasSameSizeAsCheck  ( info , actual , other ,  sizeOf  ( actual ) ) ; }   public void assertHasSameSizeAs  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Iterable  <  ? > other )  {   assertNotNull  ( info , actual ) ;   hasSameSizeAsCheck  ( info , actual , other ,  sizeOf  ( actual ) ) ; }   public void assertContains  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] values )  {   final  List  <  ? >  actualAsList =  newArrayList  ( actual ) ;  if  (  commonCheckThatIterableAssertionSucceeds  ( info , actualAsList , values ) )  return ;   assertIterableContainsGivenValues  ( actualAsList , values , info ) ; }   private void assertIterableContainsGivenValues  (   Iterable  <  ? > actual ,   Object  [ ] values ,  AssertionInfo info )  {   Set  < Object >  notFound =    stream  ( values ) . filter  (  value ->  !  iterableContains  ( actual , value ) ) . collect  (  toCollection  (  LinkedHashSet :: new ) ) ;  if  (  notFound . isEmpty  ( ) )  return ;  throw  failures . failure  ( info ,  shouldContain  ( actual , values , notFound , comparisonStrategy ) ) ; }   private boolean iterableContains  (   Iterable  <  ? > actual ,  Object value )  {  return  comparisonStrategy . iterableContains  ( actual , value ) ; }   private void iterablesRemoveFirst  (   Iterable  <  ? > actual ,  Object value )  {   comparisonStrategy . iterablesRemoveFirst  ( actual , value ) ; }   private void iterablesRemove  (   Iterable  <  ? > actual ,  Object value )  {   comparisonStrategy . iterableRemoves  ( actual , value ) ; }   public void assertContainsOnly  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] expectedValues )  {   final  List  <  ? >  actualAsList =  newArrayList  ( actual ) ;  if  (  commonCheckThatIterableAssertionSucceeds  ( info , actualAsList , expectedValues ) )  return ;   List  < Object >  unexpectedValues =  newArrayList  ( actualAsList ) ;   List  < Object >  missingValues =  newArrayList  ( expectedValues ) ;  for ( Object expected : expectedValues )  {  if  (  iterableContains  ( actualAsList , expected ) )  {   iterablesRemove  ( missingValues , expected ) ;   iterablesRemove  ( unexpectedValues , expected ) ; } }  if  (   !  unexpectedValues . isEmpty  ( ) ||  !  missingValues . isEmpty  ( ) )  {  throw  failures . failure  ( info ,  shouldContainOnly  ( actualAsList , expectedValues , missingValues , unexpectedValues , comparisonStrategy ) ) ; } }   public void assertContainsOnlyOnce  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] values )  {  if  (  commonCheckThatIterableAssertionSucceeds  ( info , actual , values ) )  return ;   Set  < Object >  notFound =  new  LinkedHashSet  < >  ( ) ;   Set  < Object >  notOnlyOnce =  new  LinkedHashSet  < >  ( ) ;   Iterable  <  ? >  actualDuplicates =  comparisonStrategy . duplicatesFrom  ( actual ) ;  for ( Object expectedOnlyOnce : values )  {  if  (  !  iterableContains  ( actual , expectedOnlyOnce ) )  {   notFound . add  ( expectedOnlyOnce ) ; } else  if  (  iterableContains  ( actualDuplicates , expectedOnlyOnce ) )  {   notOnlyOnce . add  ( expectedOnlyOnce ) ; } }  if  (   !  notFound . isEmpty  ( ) ||  !  notOnlyOnce . isEmpty  ( ) )  throw  failures . failure  ( info ,  shouldContainsOnlyOnce  ( actual , values , notFound , notOnlyOnce , comparisonStrategy ) ) ; }   public void assertContainsOnlyNulls  (  AssertionInfo info ,   Iterable  <  ? > actual )  {   assertNotNull  ( info , actual ) ;  if  (   sizeOf  ( actual ) == 0 )  throw  failures . failure  ( info ,  shouldContainOnlyNulls  ( actual ) ) ;   List  < Object >  nonNullElements =    stream  ( actual ) . filter  (    java . util . Objects :: nonNull ) . collect  (  toList  ( ) ) ;  if  (   nonNullElements . size  ( ) > 0 )  throw  failures . failure  ( info ,  shouldContainOnlyNulls  ( actual , nonNullElements ) ) ; }   public void assertContainsSequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] sequence )  {   checkNotNullIterables  ( info , actual , sequence ) ;   final  Iterator  <  ? >  actualIterator =  actual . iterator  ( ) ;  if  (   !  actualIterator . hasNext  ( ) &&   sequence . length == 0 )  return ;   failIfEmptySinceActualIsNotEmpty  ( sequence ) ;  Lifo  lifo =  new Lifo  (  sequence . length ) ;  while  (  actualIterator . hasNext  ( ) )  {   lifo . add  (  actualIterator . next  ( ) ) ;  if  (  lifo . matchesExactly  ( sequence ) )  return ; }  throw  actualDoesNotContainSequence  ( info , actual , sequence ) ; }   private class Lifo  {   private  int  maxSize ;   private  LinkedList  < Object >  stack ;  Lifo  (   int maxSize )  {    this . maxSize = maxSize ;   stack =  new  LinkedList  < >  ( ) ; }  void add  (   final Object element )  {  if  (   stack . size  ( ) == maxSize )   stack . removeFirst  ( ) ;   stack . addLast  ( element ) ; }  boolean matchesExactly  (   Object  [ ] sequence )  {  if  (   stack . size  ( ) !=  sequence . length )  return false ;  for (   int  i = 0 ;  i <  sequence . length ;  i ++ )  {  if  (  !  areEqual  (  stack . get  ( i ) ,  sequence [ i ] ) )  return false ; }  return true ; } }   public void assertDoesNotContainSequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] sequence )  {   requireNonNull  ( sequence ,  nullSequence  ( ) ) ;   checkIsNotEmptySequence  ( sequence ) ;   assertNotNull  ( info , actual ) ;   List  <  ? >  actualAsList =  newArrayList  ( actual ) ;  for (   int  index = 0 ;  index <  actualAsList . size  ( ) ;  index ++ )  {  if  (  containsSequenceAtGivenIndex  ( actualAsList , sequence , index ) )  {  throw  actualDoesContainSequence  ( info , actual , sequence , index ) ; } } }   public void assertContainsSubsequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] subsequence )  {  if  (  commonCheckThatIterableAssertionSucceeds  ( info , actual , subsequence ) )  return ;   Iterator  <  ? >  actualIterator =  actual . iterator  ( ) ;   int  subsequenceIndex = 0 ;  while  (   actualIterator . hasNext  ( ) &&  subsequenceIndex <  subsequence . length )  {  Object  actualNext =  actualIterator . next  ( ) ;  Object  subsequenceNext =  subsequence [ subsequenceIndex ] ;  if  (  areEqual  ( actualNext , subsequenceNext ) )   subsequenceIndex ++ ; }  if  (  subsequenceIndex <  subsequence . length )  throw  actualDoesNotContainSubsequence  ( info , actual , subsequence ) ; }   public void assertContainsSubsequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   List  <  ? > subsequence )  {   checkIsNotNull  ( subsequence ) ;   assertContainsSubsequence  ( info , actual ,  subsequence . toArray  ( ) ) ; }   public void assertDoesNotContainSubsequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] subsequence )  {   requireNonNull  ( subsequence ,  nullSubsequence  ( ) ) ;   checkIsNotEmptySubsequence  ( subsequence ) ;   assertNotNull  ( info , actual ) ;   int  subsequenceIndex = 0 ;   int  subsequenceStartIndex = 0 ;   List  <  ? >  actualAsList =  newArrayList  ( actual ) ;  for (   int  index = 0 ;  index <  actualAsList . size  ( ) ;  index ++ )  {  Object  actualNext =  actualAsList . get  ( index ) ;  Object  subsequenceNext =  subsequence [ subsequenceIndex ] ;  if  (  areEqual  ( actualNext , subsequenceNext ) )  {  if  (  subsequenceIndex == 0 )   subsequenceStartIndex = index ;   subsequenceIndex ++ ; }  if  (  subsequenceIndex ==  subsequence . length )  {  throw  actualContainsSubsequence  ( info , actual , subsequence , subsequenceStartIndex ) ; } } }   public void assertIsSubsetOf  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Iterable  <  ? > values )  {   assertNotNull  ( info , actual ) ;   checkIterableIsNotNull  ( values ) ;   List  < Object >  extra =    stream  ( actual ) . filter  (  actualElement ->  !  iterableContains  ( values , actualElement ) ) . collect  (  toList  ( ) ) ;  if  (   extra . size  ( ) > 0 )  throw  failures . failure  ( info ,  shouldBeSubsetOf  ( actual , values , extra , comparisonStrategy ) ) ; }   private boolean containsSequenceAtGivenIndex  (   List  <  ? > actualAsList ,   Object  [ ] sequence ,   int startingIndex )  {  if  (    actualAsList . size  ( ) - startingIndex <  sequence . length )  return false ;  for (   int  i = 0 ;  i <  sequence . length ;  i ++ )  {  if  (  !  areEqual  (  actualAsList . get  (  startingIndex + i ) ,  sequence [ i ] ) )  return false ; }  return true ; }   private boolean areEqual  (  Object actual ,  Object other )  {  return  comparisonStrategy . areEqual  ( actual , other ) ; }   private AssertionError actualDoesNotContainSequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] sequence )  {  return  failures . failure  ( info ,  shouldContainSequence  ( actual , sequence , comparisonStrategy ) ) ; }   private AssertionError actualDoesContainSequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] sequence ,   int index )  {  return  failures . failure  ( info ,  shouldNotContainSequence  ( actual , sequence , index , comparisonStrategy ) ) ; }   private AssertionError actualDoesNotContainSubsequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] subsequence )  {  return  failures . failure  ( info ,  shouldContainSubsequence  ( actual , subsequence , comparisonStrategy ) ) ; }   private AssertionError actualContainsSubsequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] subsequence ,   int index )  {  return  failures . failure  ( info ,  shouldNotContainSubsequence  ( actual , subsequence , comparisonStrategy , index ) ) ; }   public void assertDoesNotContain  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] values )  {   checkIsNotNullAndNotEmpty  ( values ) ;   assertNotNull  ( info , actual ) ;   Set  < Object >  found =  new  LinkedHashSet  < >  ( ) ;  for ( Object o : values )  {  if  (  iterableContains  ( actual , o ) )   found . add  ( o ) ; }  if  (  !  found . isEmpty  ( ) )  throw  failures . failure  ( info ,  shouldNotContain  ( actual , values , found , comparisonStrategy ) ) ; }   public  <  T > void assertDoesNotContainAnyElementsOf  (  AssertionInfo info ,   Iterable  <  ? extends T > actual ,   Iterable  <  ? extends T > iterable )  {   checkIsNotNullAndNotEmpty  ( iterable ) ;   List  < T >  values =  newArrayList  ( iterable ) ;   assertDoesNotContain  ( info , actual ,  values . toArray  ( ) ) ; }   public void assertDoesNotHaveDuplicates  (  AssertionInfo info ,   Iterable  <  ? > actual )  {   assertNotNull  ( info , actual ) ;   Iterable  <  ? >  duplicates =  comparisonStrategy . duplicatesFrom  ( actual ) ;  if  (  !  isNullOrEmpty  ( duplicates ) )  throw  failures . failure  ( info ,  shouldNotHaveDuplicates  ( actual , duplicates , comparisonStrategy ) ) ; }   public void assertStartsWith  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] sequence )  {  if  (  commonCheckThatIterableAssertionSucceeds  ( info , actual , sequence ) )  return ;   int  i = 0 ;  for ( Object actualCurrentElement : actual )  {  if  (  i >=  sequence . length )  break ;  if  (  areEqual  ( actualCurrentElement ,  sequence [  i ++ ] ) )  continue ;  throw  actualDoesNotStartWithSequence  ( info , actual , sequence ) ; }  if  (   sequence . length > i )  {  throw  actualDoesNotStartWithSequence  ( info , actual , sequence ) ; } }   private AssertionError actualDoesNotStartWithSequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] sequence )  {  return  failures . failure  ( info ,  shouldStartWith  ( actual , sequence , comparisonStrategy ) ) ; }   public void assertEndsWith  (  AssertionInfo info ,   Iterable  <  ? > actual ,  Object first ,   Object  [ ] rest )  {   Object  [ ]  sequence =  prepend  ( first , rest ) ;   assertEndsWith  ( info , actual , sequence ) ; }   public void assertEndsWith  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] sequence )  {   checkNotNullIterables  ( info , actual , sequence ) ;   int  sizeOfActual =  sizeOf  ( actual ) ;  if  (  sizeOfActual <  sequence . length )  throw  actualDoesNotEndWithSequence  ( info , actual , sequence ) ;   int  start =  sizeOfActual -  sequence . length ;   int  sequenceIndex = 0 ,  indexOfActual = 0 ;  for ( Object actualElement : actual )  {  if  (   indexOfActual ++ < start )  continue ;  if  (  areEqual  ( actualElement ,  sequence [  sequenceIndex ++ ] ) )  continue ;  throw  actualDoesNotEndWithSequence  ( info , actual , sequence ) ; } }   private boolean commonCheckThatIterableAssertionSucceeds  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] sequence )  {   checkNotNullIterables  ( info , actual , sequence ) ;  if  (   !   actual . iterator  ( ) . hasNext  ( ) &&   sequence . length == 0 )  return true ;   failIfEmptySinceActualIsNotEmpty  ( sequence ) ;  return false ; }   private void checkNotNullIterables  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] sequence )  {   checkIsNotNull  ( sequence ) ;   assertNotNull  ( info , actual ) ; }   public void assertContainsNull  (  AssertionInfo info ,   Iterable  <  ? > actual )  {   assertNotNull  ( info , actual ) ;  if  (  !  iterableContains  ( actual , null ) )  throw  failures . failure  ( info ,  shouldContainNull  ( actual ) ) ; }   public void assertDoesNotContainNull  (  AssertionInfo info ,   Iterable  <  ? > actual )  {   assertNotNull  ( info , actual ) ;  if  (  iterableContains  ( actual , null ) )  throw  failures . failure  ( info ,  shouldNotContainNull  ( actual ) ) ; }   public  <  T > void assertAre  (  AssertionInfo info ,   Iterable  <  ? extends T > actual ,   Condition  <  ? super T > condition )  {   assertNotNull  ( info , actual ) ;   conditions . assertIsNotNull  ( condition ) ;  try  {   List  < T >  notSatisfiesCondition =  notSatisfyingCondition  ( actual , condition ) ;  if  (  !  notSatisfiesCondition . isEmpty  ( ) )  throw  failures . failure  ( info ,  elementsShouldBe  ( actual , notSatisfiesCondition , condition ) ) ; }  catch (   ClassCastException e )  {  throw  failures . failure  ( info ,  shouldBeSameGenericBetweenIterableAndCondition  ( actual , condition ) ) ; } }   public  <  E > void assertAreNot  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   Condition  <  ? super E > condition )  {   assertNotNull  ( info , actual ) ;   conditions . assertIsNotNull  ( condition ) ;  try  {   List  < E >  satisfiesCondition =  satisfiesCondition  ( actual , condition ) ;  if  (  !  satisfiesCondition . isEmpty  ( ) )  throw  failures . failure  ( info ,  elementsShouldNotBe  ( actual , satisfiesCondition , condition ) ) ; }  catch (   ClassCastException e )  {  throw  failures . failure  ( info ,  shouldBeSameGenericBetweenIterableAndCondition  ( actual , condition ) ) ; } }   public  <  E > void assertHave  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   Condition  <  ? super E > condition )  {   assertNotNull  ( info , actual ) ;   conditions . assertIsNotNull  ( condition ) ;  try  {   List  < E >  notSatisfiesCondition =  notSatisfyingCondition  ( actual , condition ) ;  if  (  !  notSatisfiesCondition . isEmpty  ( ) )  throw  failures . failure  ( info ,  elementsShouldHave  ( actual , notSatisfiesCondition , condition ) ) ; }  catch (   ClassCastException e )  {  throw  failures . failure  ( info ,  shouldBeSameGenericBetweenIterableAndCondition  ( actual , condition ) ) ; } }   public  <  E > void assertDoNotHave  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   Condition  <  ? super E > condition )  {   assertNotNull  ( info , actual ) ;   conditions . assertIsNotNull  ( condition ) ;  try  {   List  < E >  satisfiesCondition =  satisfiesCondition  ( actual , condition ) ;  if  (  !  satisfiesCondition . isEmpty  ( ) )  throw  failures . failure  ( info ,  elementsShouldNotHave  ( actual , satisfiesCondition , condition ) ) ; }  catch (   ClassCastException e )  {  throw  failures . failure  ( info ,  shouldBeSameGenericBetweenIterableAndCondition  ( actual , condition ) ) ; } }   public  <  E > void assertAreAtLeast  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   int times ,   Condition  <  ? super E > condition )  {   assertNotNull  ( info , actual ) ;   conditions . assertIsNotNull  ( condition ) ;  try  {  if  (  !  conditionIsSatisfiedAtLeastNTimes  ( actual , times , condition ) )  throw  failures . failure  ( info ,  elementsShouldBeAtLeast  ( actual , times , condition ) ) ; }  catch (   ClassCastException e )  {  throw  failures . failure  ( info ,  shouldBeSameGenericBetweenIterableAndCondition  ( actual , condition ) ) ; } }   private  <  E > boolean conditionIsSatisfiedAtLeastNTimes  (   Iterable  <  ? extends E > actual ,   int n ,   Condition  <  ? super E > condition )  {   List  < E >  satisfiesCondition =  satisfiesCondition  ( actual , condition ) ;  return   satisfiesCondition . size  ( ) >= n ; }   public  <  E > void assertAreAtMost  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   int n ,   Condition  <  ? super E > condition )  {   assertNotNull  ( info , actual ) ;   conditions . assertIsNotNull  ( condition ) ;  try  {  if  (  !  conditionIsSatisfiedAtMostNTimes  ( actual , condition , n ) )  throw  failures . failure  ( info ,  elementsShouldBeAtMost  ( actual , n , condition ) ) ; }  catch (   ClassCastException e )  {  throw  failures . failure  ( info ,  shouldBeSameGenericBetweenIterableAndCondition  ( actual , condition ) ) ; } }   private  <  E > boolean conditionIsSatisfiedAtMostNTimes  (   Iterable  <  ? extends E > actual ,   Condition  <  ? super E > condition ,   int n )  {   List  < E >  satisfiesCondition =  satisfiesCondition  ( actual , condition ) ;  return   satisfiesCondition . size  ( ) <= n ; }   public  <  E > void assertAreExactly  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   int times ,   Condition  <  ? super E > condition )  {   assertNotNull  ( info , actual ) ;   conditions . assertIsNotNull  ( condition ) ;  try  {  if  (  !  conditionIsSatisfiedNTimes  ( actual , condition , times ) )  throw  failures . failure  ( info ,  elementsShouldBeExactly  ( actual , times , condition ) ) ; }  catch (   ClassCastException e )  {  throw  failures . failure  ( info ,  shouldBeSameGenericBetweenIterableAndCondition  ( actual , condition ) ) ; } }   private  <  E > boolean conditionIsSatisfiedNTimes  (   Iterable  <  ? extends E > actual ,   Condition  <  ? super E > condition ,   int times )  {   List  < E >  satisfiesCondition =  satisfiesCondition  ( actual , condition ) ;  return   satisfiesCondition . size  ( ) == times ; }   public  <  E > void assertHaveAtLeast  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   int times ,   Condition  <  ? super E > condition )  {   assertNotNull  ( info , actual ) ;   conditions . assertIsNotNull  ( condition ) ;  try  {  if  (  !  conditionIsSatisfiedAtLeastNTimes  ( actual , times , condition ) )  throw  failures . failure  ( info ,  elementsShouldHaveAtLeast  ( actual , times , condition ) ) ; }  catch (   ClassCastException e )  {  throw  failures . failure  ( info ,  shouldBeSameGenericBetweenIterableAndCondition  ( actual , condition ) ) ; } }   public  <  E > void assertHaveAtMost  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   int times ,   Condition  <  ? super E > condition )  {   assertNotNull  ( info , actual ) ;   conditions . assertIsNotNull  ( condition ) ;  try  {  if  (  !  conditionIsSatisfiedAtMostNTimes  ( actual , condition , times ) )  throw  failures . failure  ( info ,  elementsShouldHaveAtMost  ( actual , times , condition ) ) ; }  catch (   ClassCastException e )  {  throw  failures . failure  ( info ,  shouldBeSameGenericBetweenIterableAndCondition  ( actual , condition ) ) ; } }   public  <  E > void assertHaveExactly  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   int times ,   Condition  <  ? super E > condition )  {   assertNotNull  ( info , actual ) ;   conditions . assertIsNotNull  ( condition ) ;  try  {  if  (  !  conditionIsSatisfiedNTimes  ( actual , condition , times ) )  throw  failures . failure  ( info ,  elementsShouldHaveExactly  ( actual , times , condition ) ) ; }  catch (   ClassCastException e )  {  throw  failures . failure  ( info ,  shouldBeSameGenericBetweenIterableAndCondition  ( actual , condition ) ) ; } }   public void assertContainsAll  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Iterable  <  ? > other )  {   checkIterableIsNotNull  ( other ) ;   assertNotNull  ( info , actual ) ;   Object  [ ]  values =   newArrayList  ( other ) . toArray  ( ) ;   assertIterableContainsGivenValues  ( actual , values , info ) ; }   public void assertContainsExactly  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] values )  {   checkIsNotNull  ( values ) ;   assertNotNull  ( info , actual ) ;   List  < Object >  actualAsList =  newArrayList  ( actual ) ;  IterableDiff  diff =  diff  ( actualAsList ,  asList  ( values ) , comparisonStrategy ) ;  if  (  !  diff . differencesFound  ( ) )  {   int  i = 0 ;  for ( Object elementFromActual : actualAsList )  {  if  (  !  areEqual  ( elementFromActual ,  values [ i ] ) )  {  throw  failures . failure  ( info ,  elementsDifferAtIndex  ( elementFromActual ,  values [ i ] , i , comparisonStrategy ) ) ; }   i ++ ; }  return ; }  throw  failures . failure  ( info ,  shouldContainExactly  ( actual ,  asList  ( values ) ,  diff . missing ,  diff . unexpected , comparisonStrategy ) ) ; }   public  <  E > void assertAllSatisfy  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   Consumer  <  ? super E > requirements )  {   assertNotNull  ( info , actual ) ;   requireNonNull  ( requirements , "The Consumer<T> expressing the assertions requirements must not be null" ) ;   List  < UnsatisfiedRequirement >  unsatisfiedRequirements =      stream  ( actual ) . map  (  element ->  failsRequirements  ( requirements , element ) ) . filter  (  Optional :: isPresent ) . map  (  Optional :: get ) . collect  (  toList  ( ) ) ;  if  (  !  unsatisfiedRequirements . isEmpty  ( ) )  throw  failures . failure  ( info ,  elementsShouldSatisfy  ( actual , unsatisfiedRequirements , info ) ) ; }   private static  <  E >  Optional  < UnsatisfiedRequirement > failsRequirements  (   Consumer  <  ? super E > requirements ,  E element )  {  try  {   requirements . accept  ( element ) ; }  catch (   AssertionError ex )  {  return  Optional . of  (  new UnsatisfiedRequirement  ( element ,  ex . getMessage  ( ) ) ) ; }  return  Optional . empty  ( ) ; }   public  <  ACTUAL_ELEMENT ,  OTHER_ELEMENT > void assertZipSatisfy  (  AssertionInfo info ,   Iterable  <  ? extends ACTUAL_ELEMENT > actual ,   Iterable  < OTHER_ELEMENT > other ,   BiConsumer  <  ? super ACTUAL_ELEMENT , OTHER_ELEMENT > zipRequirements )  {   assertNotNull  ( info , actual ) ;   requireNonNull  ( zipRequirements , "The BiConsumer expressing the assertions requirements must not be null" ) ;   requireNonNull  ( other , "The iterable to zip actual with must not be null" ) ;   assertHasSameSizeAs  ( info , actual , other ) ;   Iterator  < OTHER_ELEMENT >  otherIterator =  other . iterator  ( ) ;   List  < ZipSatisfyError >  errors =      stream  ( actual ) . map  (  actualElement ->  failsZipRequirements  ( actualElement ,  otherIterator . next  ( ) , zipRequirements ) ) . filter  (  Optional :: isPresent ) . map  (  Optional :: get ) . collect  (  toList  ( ) ) ;  if  (  !  errors . isEmpty  ( ) )  throw  failures . failure  ( info ,  zippedElementsShouldSatisfy  ( info , actual , other , errors ) ) ; }   private  <  ACTUAL_ELEMENT ,  OTHER_ELEMENT >  Optional  < ZipSatisfyError > failsZipRequirements  (  ACTUAL_ELEMENT actualElement ,  OTHER_ELEMENT otherElement ,   BiConsumer  < ACTUAL_ELEMENT , OTHER_ELEMENT > zipRequirements )  {  try  {   zipRequirements . accept  ( actualElement , otherElement ) ;  return  Optional . empty  ( ) ; }  catch (   AssertionError ex )  {  return  Optional . of  (  new ZipSatisfyError  ( actualElement , otherElement ,  ex . getMessage  ( ) ) ) ; } }   public  <  E > void assertAnySatisfy  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   Consumer  <  ? super E > requirements )  {   assertNotNull  ( info , actual ) ;   requireNonNull  ( requirements , "The Consumer<T> expressing the assertions requirements must not be null" ) ;   List  < UnsatisfiedRequirement >  unsatisfiedRequirements =  new  ArrayList  < >  ( ) ;  for ( E element : actual )  {   Optional  < UnsatisfiedRequirement >  result =  failsRequirements  ( requirements , element ) ;  if  (  !  result . isPresent  ( ) )  return ;   unsatisfiedRequirements . add  (  result . get  ( ) ) ; }  throw  failures . failure  ( info ,  elementsShouldSatisfyAny  ( actual , unsatisfiedRequirements , info ) ) ; }   public  <  E > void assertAllMatch  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   Predicate  <  ? super E > predicate ,  PredicateDescription predicateDescription )  {   assertNotNull  ( info , actual ) ;   predicates . assertIsNotNull  ( predicate ) ;   List  <  ? extends E >  nonMatches =    stream  ( actual ) . filter  (  predicate . negate  ( ) ) . collect  (  toList  ( ) ) ;  if  (  !  nonMatches . isEmpty  ( ) )  {  throw  failures . failure  ( info ,  elementsShouldMatch  ( actual ,    nonMatches . size  ( ) == 1 ?  nonMatches . get  ( 0 ) : nonMatches , predicateDescription ) ) ; } }   public  <  E > void assertNoneSatisfy  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   Consumer  <  ? super E > restrictions )  {   assertNotNull  ( info , actual ) ;   requireNonNull  ( restrictions , "The Consumer<T> expressing the restrictions must not be null" ) ;   List  < E >  erroneousElements =      stream  ( actual ) . map  (  element ->  failsRestrictions  ( element , restrictions ) ) . filter  (  Optional :: isPresent ) . map  (  Optional :: get ) . collect  (  toList  ( ) ) ;  if  (   erroneousElements . size  ( ) > 0 )  throw  failures . failure  ( info ,  noElementsShouldSatisfy  ( actual , erroneousElements ) ) ; }   private  <  E >  Optional  < E > failsRestrictions  (  E element ,   Consumer  <  ? super E > restrictions )  {  try  {   restrictions . accept  ( element ) ; }  catch (   AssertionError e )  {  return  Optional . empty  ( ) ; }  return  Optional . of  ( element ) ; }   public  <  E > void assertAnyMatch  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   Predicate  <  ? super E > predicate ,  PredicateDescription predicateDescription )  {   assertNotNull  ( info , actual ) ;   predicates . assertIsNotNull  ( predicate ) ;      stream  ( actual ) . filter  ( predicate ) . findFirst  ( ) . orElseThrow  (   ( ) ->  failures . failure  ( info ,  anyElementShouldMatch  ( actual , predicateDescription ) ) ) ; }   public  <  E > void assertNoneMatch  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   Predicate  <  ? super E > predicate ,  PredicateDescription predicateDescription )  {   assertNotNull  ( info , actual ) ;   predicates . assertIsNotNull  ( predicate ) ;      stream  ( actual ) . filter  ( predicate ) . findFirst  ( ) . ifPresent  (  e ->  {  throw  failures . failure  ( info ,  noElementsShouldMatch  ( actual , e , predicateDescription ) ) ; } ) ; }   public void assertContainsAnyOf  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] values )  {  if  (  commonCheckThatIterableAssertionSucceeds  ( info , actual , values ) )  return ;   Iterable  < Object >  valuesToSearchFor =  newArrayList  ( values ) ;  for ( Object element : actual )  {  if  (  iterableContains  ( valuesToSearchFor , element ) )  return ; }  throw  failures . failure  ( info ,  shouldContainAnyOf  ( actual , values , comparisonStrategy ) ) ; }   public void assertContainsExactlyInAnyOrder  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] values )  {   checkIsNotNull  ( values ) ;   assertNotNull  ( info , actual ) ;   List  < Object >  notExpected =  newArrayList  ( actual ) ;   List  < Object >  notFound =  newArrayList  ( values ) ;  for ( Object value : values )  {  if  (  iterableContains  ( notExpected , value ) )  {   iterablesRemoveFirst  ( notExpected , value ) ;   iterablesRemoveFirst  ( notFound , value ) ; } }  if  (   notExpected . isEmpty  ( ) &&  notFound . isEmpty  ( ) )  return ;  throw  failures . failure  ( info ,  shouldContainExactlyInAnyOrder  ( actual , values , notFound , notExpected , comparisonStrategy ) ) ; }  void assertNotNull  (  AssertionInfo info ,   Iterable  <  ? > actual )  {    Objects . instance  ( ) . assertNotNull  ( info , actual ) ; }   private AssertionError actualDoesNotEndWithSequence  (  AssertionInfo info ,   Iterable  <  ? > actual ,   Object  [ ] sequence )  {  return  failures . failure  ( info ,  shouldEndWith  ( actual , sequence , comparisonStrategy ) ) ; }   private  <  E >  List  < E > notSatisfyingCondition  (   Iterable  <  ? extends E > actual ,   Condition  <  ? super E > condition )  {  return    stream  ( actual ) . filter  (  o ->  !  condition . matches  ( o ) ) . collect  (  toList  ( ) ) ; }   private  <  E >  List  < E > satisfiesCondition  (   Iterable  <  ? extends E > actual ,   Condition  <  ? super E > condition )  {  return    stream  ( actual ) . filter  (  o ->  condition . matches  ( o ) ) . collect  (  toList  ( ) ) ; }   public static  <  T >  Predicate  < T > byPassingAssertions  (   Consumer  <  ? super T > assertions )  {  return  objectToTest ->  {  try  {   assertions . accept  ( objectToTest ) ;  return true ; }  catch (   AssertionError e )  {  return false ; } } ; }   private static void checkIsNotEmptySequence  (   Object  [ ] sequence )  {  if  (   sequence . length == 0 )  throw  new IllegalArgumentException  (  emptySequence  ( ) ) ; }   private static void checkIsNotEmptySubsequence  (   Object  [ ] subsequence )  {  if  (   subsequence . length == 0 )  throw  new IllegalArgumentException  (  emptySubsequence  ( ) ) ; }    @ SafeVarargs public final  <  E > void assertSatisfy  (  AssertionInfo info ,   Iterable  <  ? extends E > actual ,   Consumer  <  ? super E > ...  consumers )  {   assertNotNull  ( info , actual ) ;   requireNonNull  ( consumers , "The Consumer<? super E>... expressing the assertions consumers must not be null" ) ;  for (  Consumer  <  ? super E > consumer : consumers )   requireNonNull  ( consumer , "The element in consumers must not be null" ) ;    List  < E >  [ ]  satisfiedElementsLists =    stream  ( consumers ) . map  (  listFilteredBySatisfiedElements  ( actual ) ) .  <  List  < E > > toArray  (   List  [ ] :: new ) ;  if  (  !  isSatisfied  ( satisfiedElementsLists , 0 ) )  throw  failures . failure  ( info ,  shouldSatisfy  ( actual ) ) ; }   private  <  E >  Function  <  ? super  Consumer  <  ? super E > ,  List  < E > > listFilteredBySatisfiedElements  (   Iterable  <  ? extends E > actual )  {  return  consumer ->    stream  ( actual ) . filter  (  byPassingAssertions  ( consumer ) ) . collect  (  toList  ( ) ) ; }   private static  <  E > boolean isSatisfied  (    List  < E >  [ ] satisfiedElementsLists ,   int begin )  {  if  (  begin ==  satisfiedElementsLists . length )  return true ;  if  (   satisfiedElementsLists [ begin ] . isEmpty  ( ) )  return false ;  for ( E element :  satisfiedElementsLists [ begin ] )  {   List  < Integer >  removedElementRowIndices =  newArrayList  ( ) ;  for (   int  i =  begin + 1 ;  i <  satisfiedElementsLists . length ;  i ++ )  {  if  (   satisfiedElementsLists [ i ] . remove  ( element ) )  {   removedElementRowIndices . add  ( i ) ; } }  if  (  isSatisfied  ( satisfiedElementsLists ,  begin + 1 ) )  return true ;  for (  int i : removedElementRowIndices )  {    satisfiedElementsLists [ i ] . add  ( element ) ; } }  return false ; } }