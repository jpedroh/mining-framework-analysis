  package    org . assertj . core . api ;   import static    java . util . Objects . requireNonNull ;  import static     java . util . stream . Collectors . toList ;  import static     java . util . stream . StreamSupport . stream ;  import static      org . assertj . core . api . Assertions . assertThat ;  import static       org . assertj . core . api . filter . Filters . filter ;  import static      org . assertj . core . description . Description . mostRelevantDescription ;  import static      org . assertj . core . extractor . Extractors . byName ;  import static      org . assertj . core . extractor . Extractors . extractedDescriptionOf ;  import static      org . assertj . core . extractor . Extractors . extractedDescriptionOfMethod ;  import static      org . assertj . core . extractor . Extractors . resultOf ;  import static      org . assertj . core . internal . CommonValidations . checkSequenceIsNotNull ;  import static      org . assertj . core . internal . CommonValidations . checkSubsequenceIsNotNull ;  import static      org . assertj . core . internal . Iterables . byPassingAssertions ;  import static      org . assertj . core . internal . TypeComparators . defaultTypeComparators ;  import static      org . assertj . core . util . Arrays . isArray ;  import static      org . assertj . core . util . IterableUtil . toArray ;  import static      org . assertj . core . util . Lists . newArrayList ;  import static      org . assertj . core . util . Preconditions . checkArgument ;  import static      org . assertj . core . util . Preconditions . checkNotNull ;  import    java . lang . reflect . Array ;  import   java . util . Arrays ;  import   java . util . Collection ;  import   java . util . Comparator ;  import   java . util . HashSet ;  import   java . util . Iterator ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . SortedSet ;  import   java . util . TreeMap ;  import    java . util . function . BiConsumer ;  import    java . util . function . Consumer ;  import    java . util . function . Function ;  import    java . util . function . Predicate ;  import    java . util . stream . Stream ;  import     org . assertj . core . annotations . Beta ;  import      org . assertj . core . api . filter . FilterOperator ;  import      org . assertj . core . api . filter . Filters ;  import      org . assertj . core . api . iterable . ThrowingExtractor ;  import       org . assertj . core . api . recursive . comparison . RecursiveComparisonConfiguration ;  import     org . assertj . core . condition . Not ;  import     org . assertj . core . description . Description ;  import     org . assertj . core . groups . FieldsOrPropertiesExtractor ;  import     org . assertj . core . groups . Tuple ;  import     org . assertj . core . internal . CommonErrors ;  import     org . assertj . core . internal . ComparatorBasedComparisonStrategy ;  import     org . assertj . core . internal . ComparisonStrategy ;  import     org . assertj . core . internal . ConfigurableRecursiveFieldByFieldComparator ;  import     org . assertj . core . internal . ExtendedByTypesComparator ;  import     org . assertj . core . internal . FieldByFieldComparator ;  import     org . assertj . core . internal . IgnoringFieldsComparator ;  import     org . assertj . core . internal . IterableElementComparisonStrategy ;  import     org . assertj . core . internal . Iterables ;  import     org . assertj . core . internal . ObjectArrays ;  import     org . assertj . core . internal . Objects ;  import     org . assertj . core . internal . OnFieldsComparator ;  import     org . assertj . core . internal . RecursiveFieldByFieldComparator ;  import     org . assertj . core . internal . TypeComparators ;  import     org . assertj . core . presentation . PredicateDescription ;  import     org . assertj . core . util . CheckReturnValue ;  import     org . assertj . core . util . IterableUtil ;  import     org . assertj . core . util . Strings ;  import      org . assertj . core . util . introspection . IntrospectionError ;   public abstract class AbstractIterableAssert  <  SELF  extends  AbstractIterableAssert  < SELF , ACTUAL , ELEMENT , ELEMENT_ASSERT > ,  ACTUAL  extends  Iterable  <  ? extends ELEMENT > ,  ELEMENT ,  ELEMENT_ASSERT  extends  AbstractAssert  < ELEMENT_ASSERT , ELEMENT > >  extends  AbstractAssert  < SELF , ACTUAL >  implements   ObjectEnumerableAssert  < SELF , ELEMENT >  {   private static final String  ASSERT = "Assert" ;   private TypeComparators  comparatorsByType ;   private  Map  < String ,  Comparator  <  ? > >  comparatorsForElementPropertyOrFieldNames =  new  TreeMap  < >  ( ) ;   private TypeComparators  comparatorsForElementPropertyOrFieldTypes ;   protected Iterables  iterables =  Iterables . instance  ( ) ;   public AbstractIterableAssert  (  ACTUAL actual ,   Class  <  ? > selfType )  {  super  ( actual , selfType ) ; }    @ Override public void isNullOrEmpty  ( )  {   iterables . assertNullOrEmpty  ( info , actual ) ; }    @ Override public void isEmpty  ( )  {   iterables . assertEmpty  ( info , actual ) ; }    @ Override public SELF isNotEmpty  ( )  {   iterables . assertNotEmpty  ( info , actual ) ;  return myself ; }    @ Override public SELF hasSize  (   int expected )  {   iterables . assertHasSize  ( info , actual , expected ) ;  return myself ; }    @ Override public SELF hasSizeGreaterThan  (   int boundary )  {   iterables . assertHasSizeGreaterThan  ( info , actual , boundary ) ;  return myself ; }    @ Override public SELF hasSizeGreaterThanOrEqualTo  (   int boundary )  {   iterables . assertHasSizeGreaterThanOrEqualTo  ( info , actual , boundary ) ;  return myself ; }    @ Override public SELF hasSizeLessThan  (   int boundary )  {   iterables . assertHasSizeLessThan  ( info , actual , boundary ) ;  return myself ; }    @ Override public SELF hasSizeLessThanOrEqualTo  (   int boundary )  {   iterables . assertHasSizeLessThanOrEqualTo  ( info , actual , boundary ) ;  return myself ; }    @ Override public SELF hasSizeBetween  (   int lowerBoundary ,   int higherBoundary )  {   iterables . assertHasSizeBetween  ( info , actual , lowerBoundary , higherBoundary ) ;  return myself ; }    @ Deprecated  @ Override public SELF hasOnlyOneElementSatisfying  (   Consumer  <  ? super ELEMENT > elementAssertions )  {   iterables . assertHasSize  ( info , actual , 1 ) ;   elementAssertions . accept  (   actual . iterator  ( ) . next  ( ) ) ;  return myself ; }    @ Override public SELF hasSameSizeAs  (  Object other )  {   iterables . assertHasSameSizeAs  ( info , actual , other ) ;  return myself ; }    @ Override public SELF hasSameSizeAs  (   Iterable  <  ? > other )  {   iterables . assertHasSameSizeAs  ( info , actual , other ) ;  return myself ; }    @ Override public SELF contains  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  values )  {   iterables . assertContains  ( info , actual , values ) ;  return myself ; }    @ Override public SELF containsOnly  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  values )  {   iterables . assertContainsOnly  ( info , actual , values ) ;  return myself ; }    @ Override public SELF containsOnlyOnce  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  values )  {   iterables . assertContainsOnlyOnce  ( info , actual , values ) ;  return myself ; }    @ Override public SELF containsOnlyNulls  ( )  {   iterables . assertContainsOnlyNulls  ( info , actual ) ;  return myself ; }    @ Override public SELF containsExactly  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  values )  {   iterables . assertContainsExactly  ( info , actual , values ) ;  return myself ; }    @ Override public SELF containsExactlyInAnyOrder  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  values )  {   iterables . assertContainsExactlyInAnyOrder  ( info , actual , values ) ;  return myself ; }    @ Override public SELF containsExactlyInAnyOrderElementsOf  (   Iterable  <  ? extends ELEMENT > values )  {  return  containsExactlyInAnyOrder  (  toArray  ( values ) ) ; }    @ Override public SELF isSubsetOf  (   Iterable  <  ? extends ELEMENT > values )  {   iterables . assertIsSubsetOf  ( info , actual , values ) ;  return myself ; }    @ Override public SELF isSubsetOf  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  values )  {   iterables . assertIsSubsetOf  ( info , actual ,  Arrays . asList  ( values ) ) ;  return myself ; }    @ Override public SELF containsSequence  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  sequence )  {   iterables . assertContainsSequence  ( info , actual , sequence ) ;  return myself ; }    @ Override public SELF containsSequence  (   Iterable  <  ? extends ELEMENT > sequence )  {   checkSequenceIsNotNull  ( sequence ) ;   iterables . assertContainsSequence  ( info , actual ,  toArray  ( sequence ) ) ;  return myself ; }    @ Override public SELF doesNotContainSequence  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  sequence )  {   iterables . assertDoesNotContainSequence  ( info , actual , sequence ) ;  return myself ; }    @ Override public SELF doesNotContainSequence  (   Iterable  <  ? extends ELEMENT > sequence )  {   checkSequenceIsNotNull  ( sequence ) ;   iterables . assertDoesNotContainSequence  ( info , actual ,  toArray  ( sequence ) ) ;  return myself ; }    @ Override public SELF containsSubsequence  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  subsequence )  {   iterables . assertContainsSubsequence  ( info , actual , subsequence ) ;  return myself ; }    @ Override public SELF containsSubsequence  (   Iterable  <  ? extends ELEMENT > subsequence )  {   checkSubsequenceIsNotNull  ( subsequence ) ;   iterables . assertContainsSubsequence  ( info , actual ,  toArray  ( subsequence ) ) ;  return myself ; }    @ Override public SELF doesNotContainSubsequence  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  subsequence )  {   iterables . assertDoesNotContainSubsequence  ( info , actual , subsequence ) ;  return myself ; }    @ Override public SELF doesNotContainSubsequence  (   Iterable  <  ? extends ELEMENT > subsequence )  {   checkSubsequenceIsNotNull  ( subsequence ) ;   iterables . assertDoesNotContainSubsequence  ( info , actual ,  toArray  ( subsequence ) ) ;  return myself ; }    @ Override public SELF doesNotContain  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  values )  {   iterables . assertDoesNotContain  ( info , actual , values ) ;  return myself ; }    @ Override public SELF doesNotContainAnyElementsOf  (   Iterable  <  ? extends ELEMENT > iterable )  {   iterables . assertDoesNotContainAnyElementsOf  ( info , actual , iterable ) ;  return myself ; }    @ Override public SELF doesNotHaveDuplicates  ( )  {   iterables . assertDoesNotHaveDuplicates  ( info , actual ) ;  return myself ; }    @ Override public SELF startsWith  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  sequence )  {   iterables . assertStartsWith  ( info , actual , sequence ) ;  return myself ; }    @ Override public SELF endsWith  (  ELEMENT first ,    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  rest )  {   iterables . assertEndsWith  ( info , actual , first , rest ) ;  return myself ; }    @ Override public SELF endsWith  (   ELEMENT  [ ] sequence )  {   iterables . assertEndsWith  ( info , actual , sequence ) ;  return myself ; }    @ Override public SELF containsNull  ( )  {   iterables . assertContainsNull  ( info , actual ) ;  return myself ; }    @ Override public SELF doesNotContainNull  ( )  {   iterables . assertDoesNotContainNull  ( info , actual ) ;  return myself ; }    @ Override public SELF are  (   Condition  <  ? super ELEMENT > condition )  {   iterables . assertAre  ( info , actual , condition ) ;  return myself ; }    @ Override public SELF areNot  (   Condition  <  ? super ELEMENT > condition )  {   iterables . assertAreNot  ( info , actual , condition ) ;  return myself ; }    @ Override public SELF have  (   Condition  <  ? super ELEMENT > condition )  {   iterables . assertHave  ( info , actual , condition ) ;  return myself ; }    @ Override public SELF doNotHave  (   Condition  <  ? super ELEMENT > condition )  {   iterables . assertDoNotHave  ( info , actual , condition ) ;  return myself ; }    @ Override public SELF areAtLeastOne  (   Condition  <  ? super ELEMENT > condition )  {   areAtLeast  ( 1 , condition ) ;  return myself ; }    @ Override public SELF areAtLeast  (   int times ,   Condition  <  ? super ELEMENT > condition )  {   iterables . assertAreAtLeast  ( info , actual , times , condition ) ;  return myself ; }    @ Override public SELF areAtMost  (   int times ,   Condition  <  ? super ELEMENT > condition )  {   iterables . assertAreAtMost  ( info , actual , times , condition ) ;  return myself ; }    @ Override public SELF areExactly  (   int times ,   Condition  <  ? super ELEMENT > condition )  {   iterables . assertAreExactly  ( info , actual , times , condition ) ;  return myself ; }    @ Override public SELF haveAtLeastOne  (   Condition  <  ? super ELEMENT > condition )  {  return  haveAtLeast  ( 1 , condition ) ; }    @ Override public SELF haveAtLeast  (   int times ,   Condition  <  ? super ELEMENT > condition )  {   iterables . assertHaveAtLeast  ( info , actual , times , condition ) ;  return myself ; }    @ Override public SELF haveAtMost  (   int times ,   Condition  <  ? super ELEMENT > condition )  {   iterables . assertHaveAtMost  ( info , actual , times , condition ) ;  return myself ; }    @ Override public SELF haveExactly  (   int times ,   Condition  <  ? super ELEMENT > condition )  {   iterables . assertHaveExactly  ( info , actual , times , condition ) ;  return myself ; }    @ Override public SELF hasAtLeastOneElementOfType  (   Class  <  ? > expectedType )  {    ObjectArrays . instance  ( ) . assertHasAtLeastOneElementOfType  ( info ,  toArray  ( actual ) , expectedType ) ;  return myself ; }    @ Override public SELF hasOnlyElementsOfType  (   Class  <  ? > expectedType )  {    ObjectArrays . instance  ( ) . assertHasOnlyElementsOfType  ( info ,  toArray  ( actual ) , expectedType ) ;  return myself ; }    @ Override public SELF doesNotHaveAnyElementsOfTypes  (   Class  <  ? > ...  unexpectedTypes )  {    ObjectArrays . instance  ( ) . assertDoesNotHaveAnyElementsOfTypes  ( info ,  toArray  ( actual ) , unexpectedTypes ) ;  return myself ; }    @ Override public SELF hasOnlyElementsOfTypes  (   Class  <  ? > ...  types )  {    ObjectArrays . instance  ( ) . assertHasOnlyElementsOfTypes  ( info ,  toArray  ( actual ) , types ) ;  return myself ; }    @ Override public SELF containsAll  (   Iterable  <  ? extends ELEMENT > iterable )  {   iterables . assertContainsAll  ( info , actual , iterable ) ;  return myself ; }    @ Override  @ CheckReturnValue public SELF usingElementComparator  (   Comparator  <  ? super ELEMENT > elementComparator )  {    this . iterables =  new Iterables  (  new ComparatorBasedComparisonStrategy  ( elementComparator ) ) ;   objects =  new Objects  (  new  IterableElementComparisonStrategy  < >  ( elementComparator ) ) ;  return myself ; }    @ CheckReturnValue private SELF usingExtendedByTypesElementComparator  (   Comparator  < Object > elementComparator )  {  return  usingElementComparator  (  new ExtendedByTypesComparator  ( elementComparator ,  getComparatorsByType  ( ) ) ) ; }    @ Override  @ CheckReturnValue public SELF usingDefaultElementComparator  ( )  {    this . iterables =  Iterables . instance  ( ) ;  return  usingDefaultComparator  ( ) ; }    @ Override public SELF containsAnyOf  (    @ SuppressWarnings  ( "unchecked" ) ELEMENT ...  values )  {   iterables . assertContainsAnyOf  ( info , actual , values ) ;  return myself ; }    @ Override public SELF containsAnyElementsOf  (   Iterable  <  ? extends ELEMENT > iterable )  {  return  containsAnyOf  (  toArray  ( iterable ) ) ; }    @ CheckReturnValue public  AbstractListAssert  <  ? ,  List  <  ? extends Object > , Object ,  ObjectAssert  < Object > > extracting  (  String propertyOrField )  {   List  < Object >  values =  FieldsOrPropertiesExtractor . extract  ( actual ,  byName  ( propertyOrField ) ) ;  String  extractedDescription =  extractedDescriptionOf  ( propertyOrField ) ;  String  description =  mostRelevantDescription  (  info . description  ( ) , extractedDescription ) ;  return   newListAssertInstanceForMethodsChangingElementType  ( values ) . as  ( description ) ; }    @ CheckReturnValue public  AbstractListAssert  <  ? ,  List  <  ? extends Object > , Object ,  ObjectAssert  < Object > > extractingResultOf  (  String method )  {   List  < Object >  values =  FieldsOrPropertiesExtractor . extract  ( actual ,  resultOf  ( method ) ) ;  String  extractedDescription =  extractedDescriptionOfMethod  ( method ) ;  String  description =  mostRelevantDescription  (  info . description  ( ) , extractedDescription ) ;  return   newListAssertInstanceForMethodsChangingElementType  ( values ) . as  ( description ) ; }    @ CheckReturnValue public  <  P >  AbstractListAssert  <  ? ,  List  <  ? extends P > , P ,  ObjectAssert  < P > > extractingResultOf  (  String method ,   Class  < P > extractedType )  {    @ SuppressWarnings  ( "unchecked" )  List  < P >  values =  (  List  < P > )  FieldsOrPropertiesExtractor . extract  ( actual ,  resultOf  ( method ) ) ;  String  extractedDescription =  extractedDescriptionOfMethod  ( method ) ;  String  description =  mostRelevantDescription  (  info . description  ( ) , extractedDescription ) ;  return   newListAssertInstanceForMethodsChangingElementType  ( values ) . as  ( description ) ; }    @ CheckReturnValue public  <  P >  AbstractListAssert  <  ? ,  List  <  ? extends P > , P ,  ObjectAssert  < P > > extracting  (  String propertyOrField ,   Class  < P > extractingType )  {    @ SuppressWarnings  ( "unchecked" )  List  < P >  values =  (  List  < P > )  FieldsOrPropertiesExtractor . extract  ( actual ,  byName  ( propertyOrField ) ) ;  String  extractedDescription =  extractedDescriptionOf  ( propertyOrField ) ;  String  description =  mostRelevantDescription  (  info . description  ( ) , extractedDescription ) ;  return   newListAssertInstanceForMethodsChangingElementType  ( values ) . as  ( description ) ; }    @ CheckReturnValue public  AbstractListAssert  <  ? ,  List  <  ? extends Tuple > , Tuple ,  ObjectAssert  < Tuple > > extracting  (  String ...  propertiesOrFields )  {   List  < Tuple >  values =  FieldsOrPropertiesExtractor . extract  ( actual ,  byName  ( propertiesOrFields ) ) ;  String  extractedDescription =  extractedDescriptionOf  ( propertiesOrFields ) ;  String  description =  mostRelevantDescription  (  info . description  ( ) , extractedDescription ) ;  return   newListAssertInstanceForMethodsChangingElementType  ( values ) . as  ( description ) ; }    @ CheckReturnValue public  <  V >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > extracting  (   Function  <  ? super ELEMENT , V > extractor )  {  return  internalExtracting  ( extractor ) ; }   private  <  V >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > internalExtracting  (   Function  <  ? super ELEMENT , V > extractor )  {   List  < V >  values =  FieldsOrPropertiesExtractor . extract  ( actual , extractor ) ;  return  newListAssertInstanceForMethodsChangingElementType  ( values ) ; }   public  <  V >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > map  (   Function  <  ? super ELEMENT , V > mapper )  {  return  internalExtracting  ( mapper ) ; }    @ CheckReturnValue public  <  V ,  EXCEPTION  extends Exception >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > extracting  (   ThrowingExtractor  <  ? super ELEMENT , V , EXCEPTION > extractor )  {  return  internalExtracting  ( extractor ) ; }    @ CheckReturnValue public  <  V ,  EXCEPTION  extends Exception >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > map  (   ThrowingExtractor  <  ? super ELEMENT , V , EXCEPTION > mapper )  {  return  internalExtracting  ( mapper ) ; }   private  <  V >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > newListAssertInstanceForMethodsChangingElementType  (   List  < V > values )  {  if  (  actual instanceof SortedSet )  {   usingDefaultElementComparator  ( ) ; }  return   newListAssertInstance  ( values ) . withAssertionState  ( myself ) ; }    @ CheckReturnValue public  <  V >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > flatExtracting  (   Function  <  ? super ELEMENT ,  ? extends  Collection  < V > > extractor )  {  return  doFlatExtracting  ( extractor ) ; }    @ CheckReturnValue public  <  V >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > flatMap  (   Function  <  ? super ELEMENT ,  ? extends  Collection  < V > > mapper )  {  return  doFlatExtracting  ( mapper ) ; }    @ CheckReturnValue public  <  V ,  EXCEPTION  extends Exception >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > flatExtracting  (   ThrowingExtractor  <  ? super ELEMENT ,  ? extends  Collection  < V > , EXCEPTION > extractor )  {  return  doFlatExtracting  ( extractor ) ; }    @ CheckReturnValue public  <  V ,  EXCEPTION  extends Exception >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > flatMap  (   ThrowingExtractor  <  ? super ELEMENT ,  ? extends  Collection  < V > , EXCEPTION > mapper )  {  return  doFlatExtracting  ( mapper ) ; }   private  <  V >  AbstractListAssert  <  ? ,  List  <  ? extends V > , V ,  ObjectAssert  < V > > doFlatExtracting  (   Function  <  ? super ELEMENT ,  ? extends  Collection  < V > > extractor )  {   List  < V >  result =     FieldsOrPropertiesExtractor . extract  ( actual , extractor ) . stream  ( ) . flatMap  (  Collection :: stream ) . collect  (  toList  ( ) ) ;  return  newListAssertInstanceForMethodsChangingElementType  ( result ) ; }    @ CheckReturnValue public  @ CheckReturnValue public  AbstractListAssert  <  ? ,  List  <  ? extends Object > , Object ,  ObjectAssert  < Object > > flatExtracting  (    @ SuppressWarnings  ( "unchecked" )  @ SuppressWarnings  ( "unchecked" )  Function  <  ? super ELEMENT ,  ? > ...  extractors )  {  return  doFlaExtracting  ( extractors ) ; }    @ CheckReturnValue public  AbstractListAssert  <  ? ,  List  <  ? extends Object > , Object ,  ObjectAssert  < Object > > flatMap  (    @ SuppressWarnings  ( "unchecked" )  Function  <  ? super ELEMENT ,  ? > ...  mappers )  {  return  doFlaExtracting  ( mappers ) ; }    @ SafeVarargs private final  AbstractListAssert  <  ? ,  List  <  ? extends Object > , Object ,  ObjectAssert  < Object > > doFlaExtracting  (   Function  <  ? super ELEMENT ,  ? > ...  extractors )  {   Stream  <  ? extends ELEMENT >  actualStream =  stream  (  actual . spliterator  ( ) , false ) ;   List  < Object >  result =   actualStream . flatMap  (  element ->   Stream . of  ( extractors ) . map  (  extractor ->  extractor . apply  ( element ) ) ) . collect  (  toList  ( ) ) ;  return  newListAssertInstanceForMethodsChangingElementType  ( result ) ; }    @ CheckReturnValue public  @ CheckReturnValue  <  EXCEPTION  extends Exception >  AbstractListAssert  <  ? ,  List  <  ? extends Object > , Object ,  ObjectAssert  < Object > > flatExtracting  (    @ SuppressWarnings  ( "unchecked" )  ThrowingExtractor  <  ? super ELEMENT ,  ? , EXCEPTION > ...  extractors )  {  return  doFlatExtracting  ( extractors ) ; }    @ CheckReturnValue public  <  EXCEPTION  extends Exception >  AbstractListAssert  <  ? ,  List  <  ? extends Object > , Object ,  ObjectAssert  < Object > > flatMap  (    @ SuppressWarnings  ( "unchecked" )  ThrowingExtractor  <  ? super ELEMENT ,  ? , EXCEPTION > ...  mappers )  {  return  doFlatExtracting  ( mappers ) ; }    @ SafeVarargs private final  <  EXCEPTION  extends Exception >  AbstractListAssert  <  ? ,  List  <  ? extends Object > , Object ,  ObjectAssert  < Object > > doFlatExtracting  (   ThrowingExtractor  <  ? super ELEMENT ,  ? , EXCEPTION > ...  mappers )  {   Stream  <  ? extends ELEMENT >  actualStream =  stream  (  actual . spliterator  ( ) , false ) ;   List  < Object >  result =   actualStream . flatMap  (  element ->   Stream . of  ( mappers ) . map  (  extractor ->  extractor . apply  ( element ) ) ) . collect  (  toList  ( ) ) ;  return  newListAssertInstanceForMethodsChangingElementType  ( result ) ; }    @ CheckReturnValue public  AbstractListAssert  <  ? ,  List  <  ? extends Object > , Object ,  ObjectAssert  < Object > > flatExtracting  (  String fieldOrPropertyName )  {   List  < Object >  extractedValues =  newArrayList  ( ) ;   List  <  ? >  extractedGroups =  FieldsOrPropertiesExtractor . extract  ( actual ,  byName  ( fieldOrPropertyName ) ) ;  for ( Object group : extractedGroups )  {  if  (  isArray  ( group ) )  {   int  size =  Array . getLength  ( group ) ;  for (   int  i = 0 ;  i < size ;  i ++ )  {   extractedValues . add  (  Array . get  ( group , i ) ) ; } } else  if  (  group instanceof Iterable )  {   Iterable  <  ? >  iterable =  (  Iterable  <  ? > ) group ;  for ( Object value : iterable )  {   extractedValues . add  ( value ) ; } } else  {   CommonErrors . wrongElementTypeForFlatExtracting  ( group ) ; } }  return  newListAssertInstanceForMethodsChangingElementType  ( extractedValues ) ; }    @ CheckReturnValue public  AbstractListAssert  <  ? ,  List  <  ? extends Tuple > , Tuple ,  ObjectAssert  < Tuple > > extracting  (    @ SuppressWarnings  ( "unchecked" )  Function  <  ? super ELEMENT ,  ? > ...  extractors )  {  return  doExtracting  ( extractors ) ; }    @ SafeVarargs private final  AbstractListAssert  <  ? ,  List  <  ? extends Tuple > , Tuple ,  ObjectAssert  < Tuple > > doExtracting  (   Function  <  ? super ELEMENT ,  ? > ...  extractors )  {   Function  < ELEMENT , Tuple >  tupleExtractor =  objectToExtractValueFrom ->  new Tuple  (    Stream . of  ( extractors ) . map  (  extractor ->  extractor . apply  ( objectToExtractValueFrom ) ) . toArray  ( ) ) ;   List  < Tuple >  tuples =    stream  (  actual . spliterator  ( ) , false ) . map  ( tupleExtractor ) . collect  (  toList  ( ) ) ;  return  newListAssertInstanceForMethodsChangingElementType  ( tuples ) ; }    @ CheckReturnValue public  AbstractListAssert  <  ? ,  List  <  ? extends Tuple > , Tuple ,  ObjectAssert  < Tuple > > map  (    @ SuppressWarnings  ( "unchecked" )  Function  <  ? super ELEMENT ,  ? > ...  mappers )  {  return  doExtracting  ( mappers ) ; }    @ CheckReturnValue public  AbstractListAssert  <  ? ,  List  <  ? extends Object > , Object ,  ObjectAssert  < Object > > flatExtracting  (  String ...  fieldOrPropertyNames )  {   List  < Object >  extractedValues =     FieldsOrPropertiesExtractor . extract  ( actual ,  byName  ( fieldOrPropertyNames ) ) . stream  ( ) . flatMap  (  tuple ->   tuple . toList  ( ) . stream  ( ) ) . collect  (  toList  ( ) ) ;  return  newListAssertInstanceForMethodsChangingElementType  ( extractedValues ) ; }    @ Override public SELF containsExactlyElementsOf  (   Iterable  <  ? extends ELEMENT > iterable )  {  return  containsExactly  (  toArray  ( iterable ) ) ; }    @ Deprecated  @ Override public SELF containsOnlyElementsOf  (   Iterable  <  ? extends ELEMENT > iterable )  {  return  containsOnly  (  toArray  ( iterable ) ) ; }    @ Override public SELF containsOnlyOnceElementsOf  (   Iterable  <  ? extends ELEMENT > iterable )  {  return  containsOnlyOnce  (  toArray  ( iterable ) ) ; }    @ Override public SELF hasSameElementsAs  (   Iterable  <  ? extends ELEMENT > iterable )  {  return  containsOnly  (  toArray  ( iterable ) ) ; }    @ CheckReturnValue public  <  T > SELF usingComparatorForElementFieldsWithNames  (   Comparator  < T > comparator ,  String ...  elementPropertyOrFieldNames )  {  for ( String elementPropertyOrField : elementPropertyOrFieldNames )  {   comparatorsForElementPropertyOrFieldNames . put  ( elementPropertyOrField , comparator ) ; }  return myself ; }    @ CheckReturnValue public  <  T > SELF usingComparatorForElementFieldsWithType  (   Comparator  < T > comparator ,   Class  < T > type )  {    getComparatorsForElementPropertyOrFieldTypes  ( ) . put  ( type , comparator ) ;  return myself ; }    @ CheckReturnValue public  <  T > SELF usingComparatorForType  (   Comparator  < T > comparator ,   Class  < T > type )  {  if  (   iterables . getComparator  ( ) == null )  {   usingElementComparator  (  new ExtendedByTypesComparator  (  getComparatorsByType  ( ) ) ) ; }    getComparatorsForElementPropertyOrFieldTypes  ( ) . put  ( type , comparator ) ;    getComparatorsByType  ( ) . put  ( type , comparator ) ;  return myself ; }    @ CheckReturnValue public SELF usingFieldByFieldElementComparator  ( )  {  return  usingExtendedByTypesElementComparator  (  new FieldByFieldComparator  ( comparatorsForElementPropertyOrFieldNames ,  getComparatorsForElementPropertyOrFieldTypes  ( ) ) ) ; }    @ CheckReturnValue public SELF usingRecursiveFieldByFieldElementComparator  ( )  {  return  usingExtendedByTypesElementComparator  (  new RecursiveFieldByFieldComparator  ( comparatorsForElementPropertyOrFieldNames ,  getComparatorsForElementPropertyOrFieldTypes  ( ) ) ) ; }   public SELF usingRecursiveFieldByFieldElementComparator  (  RecursiveComparisonConfiguration configuration )  {  return  usingElementComparator  (  new ConfigurableRecursiveFieldByFieldComparator  ( configuration ) ) ; }    @ Override  @ Beta public  RecursiveComparisonAssert  <  ? > usingRecursiveComparison  ( )  {  return  super . usingRecursiveComparison  ( ) ; }    @ Override public  RecursiveComparisonAssert  <  ? > usingRecursiveComparison  (  RecursiveComparisonConfiguration recursiveComparisonConfiguration )  {  return   super . usingRecursiveComparison  ( recursiveComparisonConfiguration ) . withTypeComparators  ( comparatorsByType ) ; }    @ CheckReturnValue public SELF usingElementComparatorOnFields  (  String ...  fields )  {  return  usingExtendedByTypesElementComparator  (  new OnFieldsComparator  ( comparatorsForElementPropertyOrFieldNames ,  getComparatorsForElementPropertyOrFieldTypes  ( ) , fields ) ) ; }   protected SELF usingComparisonStrategy  (  ComparisonStrategy comparisonStrategy )  {   iterables =  new Iterables  ( comparisonStrategy ) ;  return myself ; }    @ CheckReturnValue public SELF usingElementComparatorIgnoringFields  (  String ...  fields )  {  return  usingExtendedByTypesElementComparator  (  new IgnoringFieldsComparator  ( comparatorsForElementPropertyOrFieldNames ,  getComparatorsForElementPropertyOrFieldTypes  ( ) , fields ) ) ; }    @ Override  @ CheckReturnValue public SELF inHexadecimal  ( )  {  return  super . inHexadecimal  ( ) ; }    @ Override  @ CheckReturnValue public SELF inBinary  ( )  {  return  super . inBinary  ( ) ; }    @ CheckReturnValue public SELF filteredOn  (  String propertyOrFieldName ,  Object expectedValue )  {   Filters  <  ? extends ELEMENT >  filter =  filter  (  (  Iterable  <  ? extends ELEMENT > ) actual ) ;   Iterable  <  ? extends ELEMENT >  filteredIterable =   filter . with  ( propertyOrFieldName , expectedValue ) . get  ( ) ;  return   newAbstractIterableAssert  ( filteredIterable ) . withAssertionState  ( myself ) ; }    @ CheckReturnValue public SELF filteredOnNull  (  String propertyOrFieldName )  {   Filters  <  ? extends ELEMENT >  filter =  filter  (  (  Iterable  <  ? extends ELEMENT > ) actual ) ;   Iterable  <  ? extends ELEMENT >  filteredIterable =   filter . with  ( propertyOrFieldName , null ) . get  ( ) ;  return   newAbstractIterableAssert  ( filteredIterable ) . withAssertionState  ( myself ) ; }    @ CheckReturnValue public SELF filteredOn  (  String propertyOrFieldName ,   FilterOperator  <  ? > filterOperator )  {   checkNotNull  ( filterOperator ) ;   Filters  <  ? extends ELEMENT >  filter =   filter  (  (  Iterable  <  ? extends ELEMENT > ) actual ) . with  ( propertyOrFieldName ) ;   filterOperator . applyOn  ( filter ) ;  return   newAbstractIterableAssert  (  filter . get  ( ) ) . withAssertionState  ( myself ) ; }    @ CheckReturnValue public SELF filteredOn  (   Condition  <  ? super ELEMENT > condition )  {   Filters  <  ? extends ELEMENT >  filter =  filter  (  (  Iterable  <  ? extends ELEMENT > ) actual ) ;   Iterable  <  ? extends ELEMENT >  filteredIterable =   filter . being  ( condition ) . get  ( ) ;  return   newAbstractIterableAssert  ( filteredIterable ) . withAssertionState  ( myself ) ; }    @ CheckReturnValue public  <  T > SELF filteredOn  (   Function  <  ? super ELEMENT , T > function ,  T expectedValue )  {   checkArgument  (  function != null , "The filter function should not be null" ) ;  return  internalFilteredOn  (  element ->    java . util . Objects . equals  (  function . apply  ( element ) , expectedValue ) ) ; }   public SELF filteredOnAssertions  (   Consumer  <  ? super ELEMENT > elementAssertions )  {   checkArgument  (  elementAssertions != null , "The element assertions should not be null" ) ;   List  <  ? extends ELEMENT >  filteredIterable =    stream  (  actual . spliterator  ( ) , false ) . filter  (  byPassingAssertions  ( elementAssertions ) ) . collect  (  toList  ( ) ) ;  return   newAbstractIterableAssert  ( filteredIterable ) . withAssertionState  ( myself ) ; }    @ CheckReturnValue public ELEMENT_ASSERT first  ( )  {  return  internalFirst  ( ) ; }    @ CheckReturnValue public  <  ASSERT  extends  AbstractAssert  <  ? ,  ? > > ASSERT first  (   InstanceOfAssertFactory  <  ? , ASSERT > assertFactory )  {  return   internalFirst  ( ) . asInstanceOf  ( assertFactory ) ; }   private ELEMENT_ASSERT internalFirst  ( )  {   isNotEmpty  ( ) ;  return  toAssert  (   actual . iterator  ( ) . next  ( ) ,  navigationDescription  ( "check first element" ) ) ; }    @ CheckReturnValue public ELEMENT_ASSERT last  ( )  {  return  internalLast  ( ) ; }    @ CheckReturnValue public  <  ASSERT  extends  AbstractAssert  <  ? ,  ? > > ASSERT last  (   InstanceOfAssertFactory  <  ? , ASSERT > assertFactory )  {  return   internalLast  ( ) . asInstanceOf  ( assertFactory ) ; }   private ELEMENT_ASSERT internalLast  ( )  {   isNotEmpty  ( ) ;  return  toAssert  (  lastElement  ( ) ,  navigationDescription  ( "check last element" ) ) ; }   private ELEMENT lastElement  ( )  {  if  (  actual instanceof List )  {    @ SuppressWarnings  ( "unchecked" )  List  <  ? extends ELEMENT >  list =  (  List  <  ? extends ELEMENT > ) actual ;  return  list . get  (   list . size  ( ) - 1 ) ; }   Iterator  <  ? extends ELEMENT >  actualIterator =  actual . iterator  ( ) ;  ELEMENT  last =  actualIterator . next  ( ) ;  while  (  actualIterator . hasNext  ( ) )  {   last =  actualIterator . next  ( ) ; }  return last ; }    @ CheckReturnValue public ELEMENT_ASSERT element  (   int index )  {  return  internalElement  ( index ) ; }    @ CheckReturnValue public  <  ASSERT  extends  AbstractAssert  <  ? ,  ? > > ASSERT element  (   int index ,   InstanceOfAssertFactory  <  ? , ASSERT > assertFactory )  {  return   internalElement  ( index ) . asInstanceOf  ( assertFactory ) ; }   private ELEMENT_ASSERT internalElement  (   int index )  {   isNotEmpty  ( ) ;     assertThat  ( index ) . describedAs  (  navigationDescription  ( "check index validity" ) ) . isBetween  ( 0 ,   IterableUtil . sizeOf  ( actual ) - 1 ) ;  ELEMENT  elementAtIndex = null ;  if  (  actual instanceof List )  {    @ SuppressWarnings  ( "unchecked" )  List  <  ? extends ELEMENT >  list =  (  List  <  ? extends ELEMENT > ) actual ;   elementAtIndex =  list . get  ( index ) ; } else  {   Iterator  <  ? extends ELEMENT >  actualIterator =  actual . iterator  ( ) ;  for (   int  i = 0 ;  i < index ;  i ++ )  {   actualIterator . next  ( ) ; }   elementAtIndex =  actualIterator . next  ( ) ; }  return  toAssert  ( elementAtIndex ,  navigationDescription  (  "element at index " + index ) ) ; }    @ CheckReturnValue public ELEMENT_ASSERT singleElement  ( )  {  return  internalSingleElement  ( ) ; }    @ CheckReturnValue public  <  ASSERT  extends  AbstractAssert  <  ? ,  ? > > ASSERT singleElement  (   InstanceOfAssertFactory  <  ? , ASSERT > assertFactory )  {  return   internalSingleElement  ( ) . asInstanceOf  ( assertFactory ) ; }   private ELEMENT_ASSERT internalSingleElement  ( )  {   iterables . assertHasSize  ( info , actual , 1 ) ;  return  internalFirst  ( ) ; }   protected abstract ELEMENT_ASSERT toAssert  (  ELEMENT value ,  String description ) ;   protected String navigationDescription  (  String propertyName )  {  String  text =  descriptionText  ( ) ;  if  (  Strings . isNullOrEmpty  ( text ) )  {   text =  removeAssert  (   this . getClass  ( ) . getSimpleName  ( ) ) ; }  return   text + " " + propertyName ; }   private static String removeAssert  (  String text )  {  return   text . endsWith  ( ASSERT ) ?  text . substring  ( 0 ,   text . length  ( ) -  ASSERT . length  ( ) ) : text ; }   public SELF filteredOn  (   Predicate  <  ? super ELEMENT > predicate )  {  return  internalFilteredOn  ( predicate ) ; }    @ Override public SELF allMatch  (   Predicate  <  ? super ELEMENT > predicate )  {   iterables . assertAllMatch  ( info , actual , predicate ,  PredicateDescription . GIVEN ) ;  return myself ; }    @ Override public SELF allMatch  (   Predicate  <  ? super ELEMENT > predicate ,  String predicateDescription )  {   iterables . assertAllMatch  ( info , actual , predicate ,  new PredicateDescription  ( predicateDescription ) ) ;  return myself ; }    @ Override public SELF allSatisfy  (   Consumer  <  ? super ELEMENT > requirements )  {   iterables . assertAllSatisfy  ( info , actual , requirements ) ;  return myself ; }    @ Override public SELF anyMatch  (   Predicate  <  ? super ELEMENT > predicate )  {   iterables . assertAnyMatch  ( info , actual , predicate ,  PredicateDescription . GIVEN ) ;  return myself ; }   public  <  OTHER_ELEMENT > SELF zipSatisfy  (   Iterable  < OTHER_ELEMENT > other ,   BiConsumer  <  ? super ELEMENT , OTHER_ELEMENT > zipRequirements )  {   iterables . assertZipSatisfy  ( info , actual , other , zipRequirements ) ;  return myself ; }    @ Override public SELF anySatisfy  (   Consumer  <  ? super ELEMENT > requirements )  {   iterables . assertAnySatisfy  ( info , actual , requirements ) ;  return myself ; }    @ Override public SELF noneSatisfy  (   Consumer  <  ? super ELEMENT > restrictions )  {   iterables . assertNoneSatisfy  ( info , actual , restrictions ) ;  return myself ; }    @ Override  @ CheckReturnValue public SELF as  (  String description ,  Object ...  args )  {  return  super . as  ( description , args ) ; }    @ Override  @ CheckReturnValue public SELF as  (  Description description )  {  return  super . as  ( description ) ; }    @ Override  @ CheckReturnValue public SELF describedAs  (  Description description )  {  return  super . describedAs  ( description ) ; }    @ Override  @ CheckReturnValue public SELF describedAs  (  String description ,  Object ...  args )  {  return  super . describedAs  ( description , args ) ; }    @ Override public SELF doesNotHave  (   Condition  <  ? super ACTUAL > condition )  {  return  super . doesNotHave  ( condition ) ; }    @ Override public SELF doesNotHaveSameClassAs  (  Object other )  {  return  super . doesNotHaveSameClassAs  ( other ) ; }    @ Override public SELF has  (   Condition  <  ? super ACTUAL > condition )  {  return  super . has  ( condition ) ; }    @ Override public SELF hasSameClassAs  (  Object other )  {  return  super . hasSameClassAs  ( other ) ; }    @ Override public SELF hasToString  (  String expectedToString )  {  return  super . hasToString  ( expectedToString ) ; }    @ Override public SELF is  (   Condition  <  ? super ACTUAL > condition )  {  return  super . is  ( condition ) ; }    @ Override public SELF isEqualTo  (  Object expected )  {  return  super . isEqualTo  ( expected ) ; }    @ Override public SELF isExactlyInstanceOf  (   Class  <  ? > type )  {  return  super . isExactlyInstanceOf  ( type ) ; }    @ Override public SELF isIn  (   Iterable  <  ? > values )  {  return  super . isIn  ( values ) ; }    @ Override public SELF isIn  (  Object ...  values )  {  return  super . isIn  ( values ) ; }    @ Override public SELF isInstanceOf  (   Class  <  ? > type )  {  return  super . isInstanceOf  ( type ) ; }    @ Override public SELF isInstanceOfAny  (   Class  <  ? > ...  types )  {  return  super . isInstanceOfAny  ( types ) ; }    @ Override public SELF isNot  (   Condition  <  ? super ACTUAL > condition )  {  return  super . isNot  ( condition ) ; }    @ Override public SELF isNotEqualTo  (  Object other )  {  return  super . isNotEqualTo  ( other ) ; }    @ Override public SELF isNotExactlyInstanceOf  (   Class  <  ? > type )  {  return  super . isNotExactlyInstanceOf  ( type ) ; }    @ Override public SELF isNotIn  (   Iterable  <  ? > values )  {  return  super . isNotIn  ( values ) ; }    @ Override public SELF isNotIn  (  Object ...  values )  {  return  super . isNotIn  ( values ) ; }    @ Override public SELF isNotInstanceOf  (   Class  <  ? > type )  {  return  super . isNotInstanceOf  ( type ) ; }    @ Override public SELF isNotInstanceOfAny  (   Class  <  ? > ...  types )  {  return  super . isNotInstanceOfAny  ( types ) ; }    @ Override public SELF isNotOfAnyClassIn  (   Class  <  ? > ...  types )  {  return  super . isNotOfAnyClassIn  ( types ) ; }    @ Override public SELF isNotNull  ( )  {  return  super . isNotNull  ( ) ; }    @ Override public SELF isNotSameAs  (  Object other )  {  return  super . isNotSameAs  ( other ) ; }    @ Override public SELF isOfAnyClassIn  (   Class  <  ? > ...  types )  {  return  super . isOfAnyClassIn  ( types ) ; }    @ Override public SELF isSameAs  (  Object expected )  {  return  super . isSameAs  ( expected ) ; }    @ Override public SELF noneMatch  (   Predicate  <  ? super ELEMENT > predicate )  {   iterables . assertNoneMatch  ( info , actual , predicate ,  PredicateDescription . GIVEN ) ;  return myself ; }    @ Override  @ CheckReturnValue public SELF overridingErrorMessage  (  String newErrorMessage ,  Object ...  args )  {  return  super . overridingErrorMessage  ( newErrorMessage , args ) ; }    @ Override  @ CheckReturnValue public SELF usingDefaultComparator  ( )  {  return  super . usingDefaultComparator  ( ) ; }    @ Override  @ CheckReturnValue public SELF usingComparator  (   Comparator  <  ? super ACTUAL > customComparator )  {  return  usingComparator  ( customComparator , null ) ; }    @ Override  @ CheckReturnValue public SELF usingComparator  (   Comparator  <  ? super ACTUAL > customComparator ,  String customComparatorDescription )  {  return  super . usingComparator  ( customComparator , customComparatorDescription ) ; }    @ Override  @ CheckReturnValue public SELF withFailMessage  (  String newErrorMessage ,  Object ...  args )  {  return  super . withFailMessage  ( newErrorMessage , args ) ; }    @ Override  @ CheckReturnValue public SELF withThreadDumpOnError  ( )  {  return  super . withThreadDumpOnError  ( ) ; }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } )  @ CheckReturnValue public  AbstractIterableSizeAssert  < SELF , ACTUAL , ELEMENT , ELEMENT_ASSERT > size  ( )  {   requireNonNull  ( actual , "Can not perform assertions on the size of a null iterable." ) ;  return  new IterableSizeAssert  ( this ,  IterableUtil . sizeOf  ( actual ) ) ; }   protected TypeComparators getComparatorsByType  ( )  {  if  (  comparatorsByType == null )   comparatorsByType =  defaultTypeComparators  ( ) ;  return comparatorsByType ; }   protected TypeComparators getComparatorsForElementPropertyOrFieldTypes  ( )  {  if  (  comparatorsForElementPropertyOrFieldTypes == null )   comparatorsForElementPropertyOrFieldTypes =  defaultTypeComparators  ( ) ;  return comparatorsForElementPropertyOrFieldTypes ; }   protected abstract SELF newAbstractIterableAssert  (   Iterable  <  ? extends ELEMENT > iterable ) ;    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } )  @ Override SELF withAssertionState  (  AbstractAssert assertInstance )  {  if  (  assertInstance instanceof AbstractIterableAssert )  {  AbstractIterableAssert  iterableAssert =  ( AbstractIterableAssert ) assertInstance ;  return  ( SELF )      super . withAssertionState  ( assertInstance ) . withIterables  (  iterableAssert . iterables ) . withTypeComparators  (  iterableAssert . comparatorsByType ) . withComparatorsForElementPropertyOrFieldNames  (  iterableAssert . comparatorsForElementPropertyOrFieldNames ) . withComparatorsForElementPropertyOrFieldTypes  (  iterableAssert . comparatorsForElementPropertyOrFieldTypes ) ; }  if  (  assertInstance instanceof AbstractObjectArrayAssert )  {  AbstractObjectArrayAssert  objectArrayAssert =  ( AbstractObjectArrayAssert ) assertInstance ;  return  ( SELF )      super . withAssertionState  ( assertInstance ) . withIterables  (  objectArrayAssert . iterables ) . withTypeComparators  (  objectArrayAssert . comparatorsByType ) . withComparatorsForElementPropertyOrFieldNames  (  objectArrayAssert . comparatorsForElementPropertyOrFieldNames ) . withComparatorsForElementPropertyOrFieldTypes  (  objectArrayAssert . comparatorsForElementPropertyOrFieldTypes ) ; }  return  super . withAssertionState  ( assertInstance ) ; }  SELF withIterables  (  Iterables iterables )  {    this . iterables = iterables ;  return myself ; }  SELF withTypeComparators  (  TypeComparators comparatorsByType )  {    this . comparatorsByType = comparatorsByType ;  return myself ; }  SELF withComparatorsForElementPropertyOrFieldNames  (   Map  < String ,  Comparator  <  ? > > comparatorsForElementPropertyOrFieldNames )  {    this . comparatorsForElementPropertyOrFieldNames = comparatorsForElementPropertyOrFieldNames ;  return myself ; }  SELF withComparatorsForElementPropertyOrFieldTypes  (  TypeComparators comparatorsForElementPropertyOrFieldTypes )  {    this . comparatorsForElementPropertyOrFieldTypes = comparatorsForElementPropertyOrFieldTypes ;  return myself ; }   private SELF internalFilteredOn  (   Predicate  <  ? super ELEMENT > predicate )  {   checkArgument  (  predicate != null , "The filter predicate should not be null" ) ;   List  <  ? extends ELEMENT >  filteredIterable =    stream  (  actual . spliterator  ( ) , false ) . filter  ( predicate ) . collect  (  toList  ( ) ) ;  return   newAbstractIterableAssert  ( filteredIterable ) . withAssertionState  ( myself ) ; }    @ SafeVarargs public final SELF satisfy  (   Consumer  <  ? super ELEMENT > ...  consumers )  {   iterables . assertSatisfy  ( info , actual , consumers ) ;  return myself ; } }