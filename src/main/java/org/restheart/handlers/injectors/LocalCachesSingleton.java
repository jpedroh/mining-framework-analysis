  package    org . restheart . handlers . injectors ;   import   com . mongodb . DBObject ;  import   com . mongodb . MongoException ;  import   org . restheart . Configuration ;  import    org . restheart . db . CollectionDAO ;  import   java . util . Optional ;  import    org . restheart . cache . Cache ;  import    org . restheart . cache . LoadingCache ;  import    org . restheart . cache . CacheFactory ;  import    org . restheart . db . DbsDAO ;   public class LocalCachesSingleton  {   private static final String  SEPARATOR = "_@_@_" ;   private static boolean  initialized = false ;   private  LoadingCache  < String , DBObject >  dbPropsCache = null ;   private  LoadingCache  < String , DBObject >  collectionPropsCache = null ;   private static  long  ttl = 1000 ;   private static boolean  enabled = false ;   private static final  long  maxCacheSize = 1000 ;   private LocalCachesSingleton  ( )  {   setup  ( ) ; }   public static void init  (  Configuration conf )  {   ttl =  conf . getLocalCacheTtl  ( ) ;   enabled =  conf . isLocalCacheEnabled  ( ) ;   initialized = true ; }   private void setup  ( )  {  if  (  ! initialized )  {  throw  new IllegalStateException  ( "not initialized" ) ; }  if  ( enabled )  {    this . dbPropsCache =  CacheFactory . createLocalLoadingCache  ( 
<<<<<<<
maxCacheSize
=======
 new  CacheLoader  < String ,  Optional  < DBObject > >  ( )  {   final DbsDAO  dbsDAO =  new DbsDAO  ( ) ;    @ Override public  Optional  < DBObject > load  (  String key )  throws Exception  {  return  Optional . ofNullable  (  dbsDAO . getDbProps  ( key ) ) ; } }
>>>>>>>
 ,   Cache . EXPIRE_POLICY . AFTER_WRITE , ttl ,  DBDAO :: getDbProps ) ;    this . collectionPropsCache =  CacheFactory . createLocalLoadingCache  ( 
<<<<<<<
maxCacheSize
=======
 new  CacheLoader  < String ,  Optional  < DBObject > >  ( )  {   final CollectionDAO  collectionDAO =  new CollectionDAO  ( ) ;    @ Override public  Optional  < DBObject > load  (  String key )  throws Exception  {   String  [ ]  dbNameAndCollectionName =  key . split  ( SEPARATOR ) ;  return  Optional . ofNullable  (  collectionDAO . getCollectionProps  (  dbNameAndCollectionName [ 0 ] ,  dbNameAndCollectionName [ 1 ] ) ) ; } }
>>>>>>>
 ,   Cache . EXPIRE_POLICY . AFTER_WRITE , ttl ,   (  String key ) ->  {   String  [ ]  dbNameAndCollectionName =  key . split  ( SEPARATOR ) ;  return  CollectionDAO . getCollectionProps  (  dbNameAndCollectionName [ 0 ] ,  dbNameAndCollectionName [ 1 ] ) ; } ) ; } }   public static LocalCachesSingleton getInstance  ( )  {  return  LocalCachesSingletonHolder . INSTANCE ; }   private static class LocalCachesSingletonHolder  {   private static final LocalCachesSingleton  INSTANCE =  new LocalCachesSingleton  ( ) ; }   public DBObject getDBProps  (  String dbName )  {  if  (  ! enabled )  {  throw  new IllegalStateException  ( "tried to use disabled cache" ) ; }  DBObject  dbProps ;   Optional  < DBObject >  _dbProps =  dbPropsCache . get  ( dbName ) ;  if  (  _dbProps != null )  {  if  (  _dbProps . isPresent  ( ) )  {   dbProps =  _dbProps . get  ( ) ;   dbProps . put  ( "_db-props-cached" , true ) ; } else  {   dbProps = null ; } } else  {  try  {   _dbProps =  dbPropsCache . getLoading  ( dbName ) ; }  catch (   Throwable uex )  {  if  (   uex . getCause  ( ) instanceof MongoException )  {  throw  ( MongoException )  uex . getCause  ( ) ; } else  {  throw uex ; } }  if  (   _dbProps != null &&  _dbProps . isPresent  ( ) )  {   dbProps =  _dbProps . get  ( ) ;   dbProps . put  ( "_db-props-cached" , false ) ; } else  {   dbProps = null ; } }  return dbProps ; }   public DBObject getCollectionProps  (  String dbName ,  String collName )  {  if  (  ! enabled )  {  throw  new IllegalStateException  ( "tried to use disabled cache" ) ; }  DBObject  collProps ;   Optional  < DBObject >  _collProps =  collectionPropsCache . get  (   dbName + SEPARATOR + collName ) ;  if  (  _collProps != null )  {  if  (  _collProps . isPresent  ( ) )  {   collProps =  _collProps . get  ( ) ;   collProps . put  ( "_collection-props-cached" , true ) ; } else  {   collProps = null ; } } else  {  try  {   _collProps =  collectionPropsCache . getLoading  (   dbName + SEPARATOR + collName ) ; }  catch (   Throwable uex )  {  if  (   uex . getCause  ( ) instanceof MongoException )  {  throw  ( MongoException )  uex . getCause  ( ) ; } else  {  throw uex ; } }  if  (  _collProps . isPresent  ( ) )  {   collProps =  _collProps . get  ( ) ;   collProps . put  ( "_collection-props-cached" , false ) ; } else  {   collProps = null ; } }  return collProps ; }   public void invalidateDb  (  String dbName )  {  if  (  enabled &&  dbPropsCache != null )  {   dbPropsCache . invalidate  ( dbName ) ; } }   public void invalidateCollection  (  String dbName ,  String collName )  {  if  (  enabled &&  collectionPropsCache != null )  {   collectionPropsCache . invalidate  (   dbName + SEPARATOR + collName ) ; } }   public static boolean isEnabled  ( )  {  return enabled ; } }