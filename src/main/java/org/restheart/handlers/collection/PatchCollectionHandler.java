  package    org . restheart . handlers . collection ;   import   com . mongodb . BasicDBList ;  import   com . mongodb . DBObject ;  import    org . restheart . db . CollectionDAO ;  import     org . restheart . hal . metadata . InvalidMetadataException ;  import     org . restheart . hal . metadata . Relationship ;  import    org . restheart . handlers . PipedHttpHandler ;  import    org . restheart . utils . HttpStatus ;  import    org . restheart . handlers . RequestContext ;  import     org . restheart . handlers . injectors . LocalCachesSingleton ;  import    org . restheart . utils . RequestHelper ;  import    org . restheart . utils . ResponseHelper ;  import    io . undertow . server . HttpServerExchange ;  import    org . bson . types . ObjectId ;   public class PatchCollectionHandler  extends PipedHttpHandler  {   public PatchCollectionHandler  ( )  {  super  ( null ) ; }    @ Override public void handleRequest  (  HttpServerExchange exchange ,  RequestContext context )  throws Exception  {  if  (   context . getDBName  ( ) . isEmpty  ( ) )  {   ResponseHelper . endExchangeWithMessage  ( exchange ,  HttpStatus . SC_NOT_ACCEPTABLE , "wrong request, db name cannot be empty" ) ;  return ; }  if  (    context . getCollectionName  ( ) . isEmpty  ( ) ||   context . getCollectionName  ( ) . startsWith  ( "_" ) )  {   ResponseHelper . endExchangeWithMessage  ( exchange ,  HttpStatus . SC_NOT_ACCEPTABLE , "wrong request, collection name cannot be empty or start with _" ) ;  return ; }  DBObject  content =  context . getContent  ( ) ;  if  (  content == null )  {   ResponseHelper . endExchangeWithMessage  ( exchange ,  HttpStatus . SC_NOT_ACCEPTABLE , "no data provided" ) ;  return ; }  if  (  content instanceof BasicDBList )  {   ResponseHelper . endExchangeWithMessage  ( exchange ,  HttpStatus . SC_NOT_ACCEPTABLE , "data cannot be an array" ) ;  return ; }  if  (  content . containsField  (  Relationship . RELATIONSHIPS_ELEMENT_NAME ) )  {  try  {   Relationship . getFromJson  ( content ) ; }  catch (   InvalidMetadataException ex )  {   ResponseHelper . endExchangeWithMessage  ( exchange ,  HttpStatus . SC_NOT_ACCEPTABLE ,  "wrong relationships definition. " +  ex . getMessage  ( ) , ex ) ;  return ; } }  ObjectId  etag =  RequestHelper . getWriteEtag  ( exchange ) ;  if  (  etag == null )  {   ResponseHelper . endExchange  ( exchange ,  HttpStatus . SC_CONFLICT ) ;  return ; }   final CollectionDAO  collectionDAO =  new CollectionDAO  ( ) ;   int  httpCode =  collectionDAO . upsertCollection  (  context . getDBName  ( ) ,  context . getCollectionName  ( ) , content , etag , true , true ) ;  if  (    context . getWarnings  ( ) != null &&  !   context . getWarnings  ( ) . isEmpty  ( ) )  {   sendWarnings  ( httpCode , exchange , context ) ; } else  {   exchange . setResponseCode  ( httpCode ) ; }   exchange . endExchange  ( ) ;    LocalCachesSingleton . getInstance  ( ) . invalidateCollection  (  context . getDBName  ( ) ,  context . getCollectionName  ( ) ) ; } }