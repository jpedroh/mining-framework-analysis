  package   org . restheart . handlers ;   import   com . mongodb . DBObject ;  import     org . restheart . db . DBCursorPool . EAGER_CURSOR_ALLOCATION_POLICY ;  import    org . restheart . utils . URLUtilis ;  import    io . undertow . server . HttpServerExchange ;  import    io . undertow . util . HttpString ;  import    io . undertow . util . Methods ;  import   java . net . URI ;  import   java . net . URISyntaxException ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Deque ;   public class RequestContext  {   public enum TYPE  {  ERROR ,  ROOT ,  DB ,  COLLECTION ,  DOCUMENT ,  COLLECTION_INDEXES ,  INDEX ,  FILE } ;   public enum METHOD  {  GET ,  POST ,  PUT ,  DELETE ,  PATCH ,  OPTIONS ,  OTHER } ;   public static final String  PAGE_QPARAM_KEY = "page" ;   public static final String  PAGESIZE_QPARAM_KEY = "pagesize" ;   public static final String  COUNT_QPARAM_KEY = "count" ;   public static final String  SORT_BY_QPARAM_KEY = "sort_by" ;   public static final String  FILTER_QPARAM_KEY = "filter" ;   public static final String  EAGER_CURSOR_ALLOCATION_POLICY_QPARAM_KEY = "eager" ;   private final String  whereUri ;   private final String  whatUri ;   private final TYPE  type ;   private final METHOD  method ;   private final  String  [ ]  pathTokens ;   private DBObject  dbProps ;   private DBObject  collectionProps ;   private DBObject  content ;   private final  ArrayList  < String >  warnings =  new  ArrayList  < >  ( ) ;   private  int  page = 1 ;   private  int  pagesize = 100 ;   private boolean  count = false ;   private EAGER_CURSOR_ALLOCATION_POLICY  cursorAllocationPolicy ;   private  Deque  < String >  filter = null ;   private  Deque  < String >  sortBy = null ;   private String  unmappedRequestUri = null ;   private String  mappedRequestUri = null ;   public RequestContext  (  HttpServerExchange exchange ,  String whereUri ,  String whatUri )  {    this . whereUri =  URLUtilis . removeTrailingSlashes  ( whereUri ) ;    this . whatUri = whatUri ;    this . unmappedRequestUri =  exchange . getRequestPath  ( ) ;    this . mappedRequestUri =  unmapUri  (  exchange . getRequestPath  ( ) ) ;   pathTokens =  mappedRequestUri . split  ( SLASH ) ;    this . type =  selectRequestType  ( pathTokens ) ;    this . method =  selectRequestMethod  (  exchange . getRequestMethod  ( ) ) ; }   public final String unmapUri  (  String mappedUri )  {  String  ret =  URLUtilis . removeTrailingSlashes  ( mappedUri ) ;  if  (  whatUri . equals  ( "*" ) )  {  if  (  !   this . whereUri . equals  ( SLASH ) )  {   ret =  ret . replaceFirst  (  "^" +  this . whereUri , "" ) ; } } else  {   ret =  URLUtilis . removeTrailingSlashes  (  ret . replaceFirst  (  "^" +  this . whereUri ,  this . whatUri ) ) ; }  if  (  ret . isEmpty  ( ) )  {   ret = SLASH ; }  return ret ; }   public final String mapUri  (  String unmappedUri )  {  String  ret =  URLUtilis . removeTrailingSlashes  ( unmappedUri ) ;  if  (  whatUri . equals  ( "*" ) )  {  if  (  !   this . whereUri . equals  ( SLASH ) )  {  return   this . whereUri + unmappedUri ; } } else  {   ret =  URLUtilis . removeTrailingSlashes  (  ret . replaceFirst  (  "^" +  this . whatUri ,  this . whereUri ) ) ; }  if  (  ret . isEmpty  ( ) )  {   ret = SLASH ; }  return ret ; }   public final boolean isParentAccessible  ( )  {  return   type ==  TYPE . DB ?    unmappedRequestUri . split  ( SLASH ) . length > 1 :    unmappedRequestUri . split  ( SLASH ) . length > 2 ; }   public TYPE getType  ( )  {  return type ; }   public String getDBName  ( )  {  return  getPathTokenAt  ( 1 ) ; }   public String getCollectionName  ( )  {  return  getPathTokenAt  ( 2 ) ; }   public String getDocumentId  ( )  {  return  getPathTokenAt  ( 3 ) ; }   public String getIndexId  ( )  {  return  getPathTokenAt  ( 4 ) ; }   public URI getUri  ( )  throws URISyntaxException  {  return  new URI  (    Arrays . asList  ( pathTokens ) . stream  ( ) . reduce  ( SLASH ,   ( t1 , t2 ) ->   t1 + SLASH + t2 ) ) ; }   public METHOD getMethod  ( )  {  return method ; }   public static boolean isReservedResourceDb  (  String dbName )  {  return     dbName . equals  ( ADMIN ) ||  dbName . equals  ( LOCAL ) ||  dbName . startsWith  ( SYSTEM ) ||  dbName . startsWith  ( UNDERSCORE ) ; }   public static boolean isReservedResourceCollection  (  String collectionName )  {  return   collectionName != null &&  (   collectionName . startsWith  ( SYSTEM ) ||  collectionName . startsWith  ( UNDERSCORE ) ) ; }   public static boolean isReservedResourceDocument  (  String documentId )  {  return    documentId != null &&  documentId . startsWith  ( UNDERSCORE ) &&  !  documentId . equals  ( _INDEXES ) ; }   public boolean isReservedResource  ( )  {  if  (  type ==  TYPE . ROOT )  {  return false ; }  return    isReservedResourceDb  (  getDBName  ( ) ) ||  isReservedResourceCollection  (  getCollectionName  ( ) ) ||  isReservedResourceDocument  (  getDocumentId  ( ) ) ; }   public String getUriPrefix  ( )  {  return whereUri ; }   public String getMappingUri  ( )  {  return whatUri ; }   public  int getPage  ( )  {  return page ; }   public void setPage  (   int page )  {    this . page = page ; }   public  int getPagesize  ( )  {  return pagesize ; }   public void setPagesize  (   int pagesize )  {    this . pagesize = pagesize ; }   public boolean isCount  ( )  {  return count ; }   public void setCount  (  boolean count )  {    this . count = count ; }   public  Deque  < String > getFilter  ( )  {  return filter ; }   public void setFilter  (   Deque  < String > filter )  {    this . filter = filter ; }   public  Deque  < String > getSortBy  ( )  {  return sortBy ; }   public void setSortBy  (   Deque  < String > sortBy )  {    this . sortBy = sortBy ; }   public DBObject getCollectionProps  ( )  {  return collectionProps ; }   public void setCollectionProps  (  DBObject collectionProps )  {    this . collectionProps = collectionProps ; }   public DBObject getDbProps  ( )  {  return dbProps ; }   public void setDbProps  (  DBObject dbProps )  {    this . dbProps = dbProps ; }   public DBObject getContent  ( )  {  return content ; }   public void setContent  (  DBObject content )  {    this . content = content ; }   public  ArrayList  < String > getWarnings  ( )  {  return warnings ; }   public void addWarning  (  String warning )  {   warnings . add  ( warning ) ; }   public String getMappedRequestUri  ( )  {  return mappedRequestUri ; }   public String getUnmappedRequestUri  ( )  {  return unmappedRequestUri ; }   private String getPathTokenAt  (   int index )  {  return    pathTokens . length > index ?  pathTokens [ index ] : null ; }   public EAGER_CURSOR_ALLOCATION_POLICY getCursorAllocationPolicy  ( )  {  return cursorAllocationPolicy ; }   public void setCursorAllocationPolicy  (  EAGER_CURSOR_ALLOCATION_POLICY cursorAllocationPolicy )  {    this . cursorAllocationPolicy = cursorAllocationPolicy ; }   public static final String  SLASH = "/" ;   public static final String  PATCH = "PATCH" ;   public static final String  UNDERSCORE = "_" ;   public static final String  SYSTEM = "system." ;   public static final String  LOCAL = "local" ;   public static final String  ADMIN = "admin" ;   public static final String  _INDEXES = "_indexes" ;   public static final String  _FILES = "_files" ;   protected static METHOD selectRequestMethod  (  HttpString _method )  {  METHOD  method ;  if  (   Methods . GET . equals  ( _method ) )  {   method =  METHOD . GET ; } else  if  (   Methods . POST . equals  ( _method ) )  {   method =  METHOD . POST ; } else  if  (   Methods . PUT . equals  ( _method ) )  {   method =  METHOD . PUT ; } else  if  (   Methods . DELETE . equals  ( _method ) )  {   method =  METHOD . DELETE ; } else  if  (  PATCH . equals  (  _method . toString  ( ) ) )  {   method =  METHOD . PATCH ; } else  if  (   Methods . OPTIONS . equals  ( _method ) )  {   method =  METHOD . OPTIONS ; } else  {   method =  METHOD . OTHER ; }  return method ; }   protected static TYPE selectRequestType  (   String  [ ] pathTokens )  {  TYPE  type ;  if  (   pathTokens . length < 2 )  {   type =  TYPE . ROOT ; } else  if  (   pathTokens . length < 3 )  {   type =  TYPE . DB ; } else  if  (   pathTokens . length < 4 )  {   type =  TYPE . COLLECTION ; } else  if  (    pathTokens . length == 4 &&   pathTokens [ 3 ] . equals  ( _INDEXES ) )  {   type =  TYPE . COLLECTION_INDEXES ; } else  if  (    pathTokens . length > 4 &&   pathTokens [ 3 ] . equals  ( _INDEXES ) )  {   type =  TYPE . INDEX ; } else  {   type =  TYPE . DOCUMENT ; }  return type ; } }