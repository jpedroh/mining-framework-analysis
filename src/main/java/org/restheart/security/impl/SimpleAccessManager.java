  package    org . restheart . security . impl ;   import    org . restheart . handlers . RequestContext ;  import    org . restheart . security . AccessManager ;  import    io . undertow . predicate . Predicate ;  import    io . undertow . predicate . PredicateParser ;  import     io . undertow . security . idm . Account ;  import    io . undertow . server . HttpServerExchange ;  import   java . io . FileNotFoundException ;  import   java . security . Principal ;  import   java . util . HashMap ;  import   java . util . Map ;  import   java . util . Set ;  import    java . util . stream . Stream ;  import static      com . google . common . collect . Sets . newHashSet ;  import    java . util . function . Consumer ;  import    org . restheart . utils . RequestHelper ;   public final class SimpleAccessManager  extends AbstractSecurityManager  implements  AccessManager  {   private final  HashMap  < String ,  Set  < Predicate > >  acl =  new  HashMap  < >  ( ) ;   public SimpleAccessManager  (   Map  < String , Object > arguments )  throws FileNotFoundException  {   init  ( arguments , "permissions" ) ; }    @ Override  Consumer  <  ? super  Map  < String , Object > > consumeConfiguration  ( )  {  return  u ->  {  Object  _role =  u . get  ( "role" ) ;  Object  _predicate =  u . get  ( "predicate" ) ;  if  (   _role == null ||  !  (  _role instanceof String ) )  {  throw  new IllegalArgumentException  ( "wrong configuration file format. a permission entry is missing the role" ) ; }  String  role =  ( String ) _role ;  if  (   _predicate == null ||  !  (  _predicate instanceof String ) )  {  throw  new IllegalArgumentException  ( "wrong configuration file format. a permission entry is missing the predicate" ) ; }  Predicate  predicate = null ;  try  {   predicate =  PredicateParser . parse  (  ( String ) _predicate ,   this . getClass  ( ) . getClassLoader  ( ) ) ; }  catch (   Throwable t )  {  throw  new IllegalArgumentException  (  "wrong configuration file format. wrong predictate" +  ( String ) _predicate , t ) ; }    aclForRole  ( role ) . add  ( predicate ) ; } ; }    @ Override public boolean isAllowed  (  HttpServerExchange exchange ,  RequestContext context )  {  if  (  noAclDefined  ( ) )  {  return false ; }   RequestHelper . fixExchangeForUndertowBug  ( exchange ) ;  return   roles  ( exchange ) . anyMatch  (  role ->    aclForRole  ( role ) . stream  ( ) . anyMatch  (  p ->  p . resolve  ( exchange ) ) ) ; }   private  Stream  < String > roles  (  HttpServerExchange exchange )  {  return    account  ( exchange ) . getRoles  ( ) . stream  ( ) ; }   private boolean noAclDefined  ( )  {  return   getAcl  ( ) == null ; }   private  Set  < Predicate > aclForRole  (  String role )  {   Set  < Predicate >  predicates =   getAcl  ( ) . get  ( role ) ;  if  (  predicates == null )  {   predicates =  newHashSet  ( ) ;    getAcl  ( ) . put  ( role , predicates ) ; }  return predicates ; }   private Account account  (  HttpServerExchange exchange )  {   final Account  account =   exchange . getSecurityContext  ( ) . getAuthenticatedAccount  ( ) ;  return   isAuthenticated  ( account ) ? account :  new NotAuthenticatedAccount  ( ) ; }   private boolean isAuthenticated  (  Account authenticatedAccount )  {  return  authenticatedAccount != null ; }    @ Override public  HashMap  < String ,  Set  < Predicate > > getAcl  ( )  {  return acl ; }   private static class NotAuthenticatedAccount  implements  Account  {    @ Override public Principal getPrincipal  ( )  {  return null ; }    @ Override public  Set  < String > getRoles  ( )  {  return  newHashSet  ( "$unauthenticated" ) ; } } }