  package   org . restheart . db ;   import   com . mongodb . BasicDBObject ;  import   com . mongodb . DB ;  import   com . mongodb . DBCollection ;  import   com . mongodb . DBCursor ;  import   com . mongodb . DBObject ;  import   com . mongodb . MongoClient ;  import    com . mongodb . util . JSON ;  import    com . mongodb . util . JSONParseException ;  import    org . restheart . utils . HttpStatus ;  import   java . time . Instant ;  import   java . util . ArrayList ;  import   java . util . Deque ;  import   java . util . Iterator ;  import   org . bson . BSONObject ;  import    org . bson . types . ObjectId ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  class CollectionDAO  {   private final MongoClient  client ;   private static final Logger  LOGGER =  LoggerFactory . getLogger  (  CollectionDAO . class ) ;  CollectionDAO  (  MongoClient client )  {    this . client = client ; }  static  {   FIELDS_TO_RETURN =  new BasicDBObject  ( ) ;   FIELDS_TO_RETURN . put  ( "_id" , 1 ) ;   FIELDS_TO_RETURN . put  ( "_etag" , 1 ) ;   FIELDS_TO_RETURN . put  ( "_created_on" , 1 ) ; }  boolean doesCollectionExist  (   final String dbName ,   final String collName )  {  if  (    dbName == null ||  dbName . isEmpty  ( ) ||  dbName . contains  ( " " ) )  {  return false ; }  BasicDBObject  query =  new BasicDBObject  ( "name" ,   dbName + "." + collName ) ;  return     client . getDB  ( dbName ) . getCollection  ( "system.namespaces" ) . findOne  ( query ) != null ; }  DBCollection getCollection  (   final String dbName ,   final String collName )  {  return   client . getDB  ( dbName ) . getCollection  ( collName ) ; }   public boolean isCollectionEmpty  (   final DBCollection coll )  {  return   coll . count  ( ) == 0 ; }   public  long getCollectionSize  (   final DBCollection coll ,   final  Deque  < String > filters )  {   final BasicDBObject  query =  new BasicDBObject  ( ) ;  if  (  filters != null )  {  try  {    filters . stream  ( ) . forEach  (  f ->  {   query . putAll  (  ( BSONObject )  JSON . parse  ( f ) ) ; } ) ; }  catch (   JSONParseException jpe )  {   LOGGER . warn  ( "****** error parsing filter expression {}" , filters , jpe ) ; } }  return  coll . count  ( query ) ; }  DBCursor getCollectionDBCursor  (   final DBCollection coll ,   final  Deque  < String > sortBy ,   final  Deque  < String > filters ,   final  Deque  < String > keys )  throws JSONParseException  {  DBObject  sort =  new BasicDBObject  ( ) ;  if  (   sortBy == null ||  sortBy . isEmpty  ( ) )  {   sort . put  ( "_id" ,  - 1 ) ; } else  {    sortBy . stream  ( ) . forEach  (   ( s ) ->  {  String  _s =  s . trim  ( ) ;  if  (  _s . startsWith  ( "-" ) )  {   sort . put  (  _s . substring  ( 1 ) ,  - 1 ) ; } else  if  (  _s . startsWith  ( "+" ) )  {   sort . put  (  _s . substring  ( 1 ) , 1 ) ; } else  {   sort . put  ( _s , 1 ) ; } } ) ; }   final BasicDBObject  query =  new BasicDBObject  ( ) ;  if  (  filters != null )  {    filters . stream  ( ) . forEach  (   (  String f ) ->  {  BSONObject  filterQuery =  ( BSONObject )  JSON . parse  ( f ) ;   query . putAll  ( filterQuery ) ; } ) ; }   final BasicDBObject  fields =  new BasicDBObject  ( ) ;  if  (  keys != null )  {    keys . stream  ( ) . forEach  (   (  String f ) ->  {  BSONObject  keyQuery =  ( BSONObject )  JSON . parse  ( f ) ;   fields . putAll  ( keyQuery ) ; } ) ; }  return   coll . find  ( query , fields ) . sort  ( sort ) ; }   ArrayList  < DBObject > getCollectionData  (   final DBCollection coll ,   final  int page ,   final  int pagesize ,   final  Deque  < String > sortBy ,   final  Deque  < String > filters ,   final  Deque  < String > keys ,   DBCursorPool . EAGER_CURSOR_ALLOCATION_POLICY eager )  throws JSONParseException  {   ArrayList  < DBObject >  ret =  new  ArrayList  < >  ( ) ;   int  toskip =  pagesize *  (  page - 1 ) ;  SkippedDBCursor  _cursor = null ;  if  (  eager !=   DBCursorPool . EAGER_CURSOR_ALLOCATION_POLICY . NONE )  {   _cursor =   DBCursorPool . getInstance  ( ) . get  (  new DBCursorPoolEntryKey  ( coll , sortBy , filters , keys , toskip , 0 ) , eager ) ; }  DBCursor  cursor ;  if  (  _cursor == null )  {   cursor =  getCollectionDBCursor  ( coll , sortBy , filters , keys ) ;   cursor . skip  ( toskip ) ;  while  (   pagesize > 0 &&  cursor . hasNext  ( ) )  {   ret . add  (  cursor . next  ( ) ) ;   pagesize -- ; } } else  {   int  alreadySkipped ;   cursor =  _cursor . getCursor  ( ) ;   alreadySkipped =  _cursor . getAlreadySkipped  ( ) ;  while  (   toskip > alreadySkipped &&  cursor . hasNext  ( ) )  {   cursor . next  ( ) ;   alreadySkipped ++ ; }  while  (   pagesize > 0 &&  cursor . hasNext  ( ) )  {   ret . add  (  cursor . next  ( ) ) ;   pagesize -- ; } }   int  _pagesize = pagesize ; 
<<<<<<<
=======
 while  (   _pagesize > 0 &&  cursor . hasNext  ( ) )  {   ret . add  (  cursor . next  ( ) ) ;   _pagesize -- ; }
>>>>>>>
   ret . forEach  (  row ->  {  Object  etag =  row . get  ( "_etag" ) ;  if  (     row . get  ( "_lastupdated_on" ) == null &&  etag != null &&  etag instanceof ObjectId )  {   row . put  ( "_lastupdated_on" ,   Instant . ofEpochSecond  (   (  ( ObjectId ) etag ) . getTimestamp  ( ) ) . toString  ( ) ) ; }  Object  id =  row . get  ( "_id" ) ;  if  (     row . get  ( "_created_on" ) == null &&  id != null &&  id instanceof ObjectId )  {   row . put  ( "_created_on" ,   Instant . ofEpochSecond  (   (  ( ObjectId ) id ) . getTimestamp  ( ) ) . toString  ( ) ) ; } } ) ;    DBCursorPool . getInstance  ( ) . populateCache  (  new DBCursorPoolEntryKey  ( coll , sortBy , filters , keys , toskip , 0 ) , eager ) ;  return ret ; }   public DBObject getCollectionProps  (   final String dbName ,   final String collName ,   final boolean fixMissingProperties )  {  DBCollection  propsColl =  getCollection  ( dbName , "_properties" ) ;  DBObject  properties =  propsColl . findOne  (  new BasicDBObject  ( "_id" ,  "_properties." . concat  ( collName ) ) ) ;  if  (  properties != null )  {   properties . put  ( "_id" , collName ) ;  Object  etag =  properties . get  ( "_etag" ) ;  if  (   etag != null &&  etag instanceof ObjectId )  {   properties . put  ( "_lastupdated_on" ,   Instant . ofEpochSecond  (   (  ( ObjectId ) etag ) . getTimestamp  ( ) ) . toString  ( ) ) ; } } else  if  ( fixMissingProperties )  {    new PropsFixer  ( ) . addCollectionProps  ( dbName , collName ) ;  return  getCollectionProps  ( dbName , collName , false ) ; }  return properties ; }  OperationResult upsertCollection  (   final String dbName ,   final String collName ,   final DBObject properties ,   final ObjectId requestEtag ,   final boolean updating ,   final boolean patching )  {  DB  db =  client . getDB  ( dbName ) ;  if  (  patching &&  ! updating )  {  return  new OperationResult  (  HttpStatus . SC_NOT_FOUND ) ; }   final DBCollection  propsColl =  db . getCollection  ( "_properties" ) ;   final DBObject  exists =  propsColl . findOne  (  new BasicDBObject  ( "_id" ,  "_properties." . concat  ( collName ) ) , FIELDS_TO_RETURN ) ;  if  (   exists == null && updating )  {   LOGGER . error  ( "updating but cannot find collection _properties.{} for {}/{}" , collName , dbName , collName ) ;  return  new OperationResult  (  HttpStatus . SC_NOT_FOUND ) ; } else  if  (  exists != null )  {  Object  oldEtag =  exists . get  ( "_etag" ) ;  if  (  oldEtag != null )  {  if  (  requestEtag == null )  {  return  new OperationResult  (  HttpStatus . SC_CONFLICT , oldEtag ) ; }  if  (  !  oldEtag . equals  ( requestEtag ) )  {  return  new OperationResult  (  HttpStatus . SC_PRECONDITION_FAILED , oldEtag ) ; } } }  ObjectId  newEtag =  new ObjectId  ( ) ;  Instant  now =  Instant . ofEpochSecond  (  newEtag . getTimestamp  ( ) ) ;   final DBObject  content =  DAOUtils . validContent  ( properties ) ;   content . removeField  ( "_id" ) ;  if  ( updating )  {   content . removeField  ( "_crated_on" ) ;   content . put  ( "_etag" , newEtag ) ; } else  {   content . put  ( "_id" ,  "_properties." . concat  ( collName ) ) ;   content . put  ( "_created_on" ,  now . toString  ( ) ) ;   content . put  ( "_etag" , newEtag ) ; }  if  ( patching )  {   propsColl . update  (  new BasicDBObject  ( "_id" ,  "_properties." . concat  ( collName ) ) ,  new BasicDBObject  ( "$set" , content ) , true , false ) ;  return  new OperationResult  (  HttpStatus . SC_OK , newEtag ) ; } else  {  DBObject  old =  propsColl . findAndModify  (  new BasicDBObject  ( "_id" ,  "_properties." . concat  ( collName ) ) , FIELDS_TO_RETURN , null , false , content , false , true ) ;  if  (  old != null )  {  Object  oldTimestamp =  old . get  ( "_created_on" ) ;  if  (  oldTimestamp == null )  {   oldTimestamp =  now . toString  ( ) ;   LOGGER . warn  ( "properties of collection {} had no @created_on field. set it to now" ,   dbName + "." + collName ) ; }  BasicDBObject  createdContent =  new BasicDBObject  ( "_created_on" ,  "" + oldTimestamp ) ;   createdContent . markAsPartialObject  ( ) ;   propsColl . update  (  new BasicDBObject  ( "_id" ,  "_properties." . concat  ( collName ) ) ,  new BasicDBObject  ( "$set" , createdContent ) , true , false ) ;  return  new OperationResult  (  HttpStatus . SC_OK , newEtag ) ; } else  {  BasicDBObject  createdContent =  new BasicDBObject  ( "_created_on" ,  now . toString  ( ) ) ;   createdContent . markAsPartialObject  ( ) ;   propsColl . update  (  new BasicDBObject  ( "_id" ,  "_properties." . concat  ( collName ) ) ,  new BasicDBObject  ( "$set" , createdContent ) , true , false ) ;   initDefaultIndexes  (  db . getCollection  ( collName ) ) ;  return  new OperationResult  (  HttpStatus . SC_CREATED , newEtag ) ; } } }  OperationResult deleteCollection  (   final String dbName ,   final String collName ,   final ObjectId requestEtag )  {  DBCollection  coll =  getCollection  ( dbName , collName ) ;  DBCollection  propsColl =  getCollection  ( dbName , "_properties" ) ;   final BasicDBObject  checkEtag =  new BasicDBObject  ( "_id" ,  "_properties." . concat  ( collName ) ) ;   final DBObject  exists =  propsColl . findOne  ( checkEtag , FIELDS_TO_RETURN ) ;  if  (  exists != null )  {  Object  oldEtag =  exists . get  ( "_etag" ) ;  if  (   oldEtag != null &&  requestEtag == null )  {  return  new OperationResult  (  HttpStatus . SC_CONFLICT , oldEtag ) ; }  if  (  requestEtag . equals  ( oldEtag ) )  {   propsColl . remove  (  new BasicDBObject  ( "_id" ,  "_properties." . concat  ( collName ) ) ) ;   coll . drop  ( ) ;  return  new OperationResult  (  HttpStatus . SC_NO_CONTENT ) ; } else  {  return  new OperationResult  (  HttpStatus . SC_PRECONDITION_FAILED , oldEtag ) ; } } else  {   LOGGER . error  ( "cannot find collection _properties.{} for {}/{}" , collName , dbName , collName ) ;  return  new OperationResult  (  HttpStatus . SC_NOT_FOUND ) ; } }   private void initDefaultIndexes  (   final DBCollection coll )  {   coll . createIndex  (   new BasicDBObject  ( "_id" , 1 ) . append  ( "_etag" , 1 ) ,  new BasicDBObject  ( "name" , "_id_etag_idx" ) ) ;   coll . createIndex  (  new BasicDBObject  ( "_etag" , 1 ) ,  new BasicDBObject  ( "name" , "_etag_idx" ) ) ; }   private static final BasicDBObject  FIELDS_TO_RETURN ; }