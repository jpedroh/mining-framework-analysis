  package   org . kohsuke . file_leak_detector ;   import     org . kohsuke . file_leak_detector . transform . ClassTransformSpec ;  import     org . kohsuke . file_leak_detector . transform . CodeGenerator ;  import     org . kohsuke . file_leak_detector . transform . MethodAppender ;  import     org . kohsuke . file_leak_detector . transform . TransformerImpl ;  import  java . io .  * ;  import    java . lang . instrument . Instrumentation ;  import   java . net . InetSocketAddress ;  import   java . net . ServerSocket ;  import   java . net . Socket ;  import   java . net . SocketImpl ;  import     java . nio . channels . spi . AbstractInterruptibleChannel ;  import     java . nio . channels . spi . AbstractSelectableChannel ;  import    java . nio . channels . SocketChannel ;  import   java . util . Arrays ;  import   java . util . List ;  import    java . util . concurrent . Callable ;  import    java . util . concurrent . ExecutorService ;  import    java . util . concurrent . Executors ;  import    java . util . concurrent . ThreadFactory ;  import    java . util . zip . ZipFile ;  import    org . kohsuke . asm6 . Label ;  import    org . kohsuke . asm6 . MethodVisitor ;  import    org . kohsuke . asm6 . Type ;  import     org . kohsuke . asm6 . commons . LocalVariablesSorter ;  import static    org . kohsuke . asm6 . Opcodes .  * ;    @ SuppressWarnings  ( "Since15" ) public class AgentMain  {   public static void agentmain  (  String agentArguments ,  Instrumentation instrumentation )  throws Exception  {   premain  ( agentArguments , instrumentation ) ; }   public static void premain  (  String agentArguments ,  Instrumentation instrumentation )  throws Exception  {   int  serverPort =  - 1 ;  if  (  agentArguments != null )  {  for ( String t :  agentArguments . split  ( "," ) )  {  if  (  t . equals  ( "help" ) )  {   usageAndQuit  ( ) ; } else  if  (  t . startsWith  ( "threshold=" ) )  {    Listener . THRESHOLD =  Integer . parseInt  (  t . substring  (   t . indexOf  ( '=' ) + 1 ) ) ; } else  if  (  t . equals  ( "trace" ) )  {    Listener . TRACE =  new PrintWriter  (  System . err ) ; } else  if  (  t . equals  ( "strong" ) )  {   Listener . makeStrong  ( ) ; } else  if  (  t . startsWith  ( "http=" ) )  {   serverPort =  Integer . parseInt  (  t . substring  (   t . indexOf  ( '=' ) + 1 ) ) ; } else  if  (  t . startsWith  ( "trace=" ) )  {    Listener . TRACE =  new PrintWriter  (  new FileOutputStream  (  t . substring  ( 6 ) ) ) ; } else  if  (  t . startsWith  ( "error=" ) )  {    Listener . ERROR =  new PrintWriter  (  new FileOutputStream  (  t . substring  ( 6 ) ) ) ; } else  if  (  t . startsWith  ( "listener=" ) )  {    ActivityListener . LIST . add  (  ( ActivityListener )     AgentMain . class . getClassLoader  ( ) . loadClass  (  t . substring  ( 9 ) ) . newInstance  ( ) ) ; } else  if  (  t . equals  ( "dumpatshutdown" ) )  {    Runtime . getRuntime  ( ) . addShutdownHook  (  new Thread  ( "File handles dumping shutdown hook" )  {    @ Override public void run  ( )  {   Listener . dump  (  System . err ) ; } } ) ; } else  if  (  t . startsWith  ( "excludes=" ) )  {  BufferedReader  reader =  new BufferedReader  (  new FileReader  (  t . substring  ( 9 ) ) ) ;  try  {  while  ( true )  {  String  line =  reader . readLine  ( ) ;  if  (  line == null )  {  break ; }  String  str =  line . trim  ( ) ;  if  (   !  str . isEmpty  ( ) &&  !  str . startsWith  ( "#" ) )  {    Listener . EXCLUDES . add  ( str ) ; } } }  finally  {   reader . close  ( ) ; } } else  {    System . err . println  (  "Unknown option: " + t ) ;   usageAndQuit  ( ) ; } } }    Listener . EXCLUDES . add  ( "sun.nio.ch.PipeImpl$Initializer$LoopbackConnector.run" ) ;    System . err . println  ( "File leak detector installed" ) ;    ActivityListener . LIST . size  ( ) ;    Listener . AGENT_INSTALLED = true ;   instrumentation . addTransformer  (  new TransformerImpl  (  createSpec  ( ) ) , true ) ;   instrumentation . retransformClasses  (  FileInputStream . class ,  FileOutputStream . class ,  RandomAccessFile . class ,  Class . forName  ( "java.net.PlainSocketImpl" ) ,  ZipFile . class ,  AbstractSelectableChannel . class ,  AbstractInterruptibleChannel . class ) ;  if  (  serverPort >= 0 )   runHttpServer  ( serverPort ) ; }   private static void runHttpServer  (   int port )  throws IOException  {   final ServerSocket  ss =  new ServerSocket  ( ) ;   ss . bind  (  new InetSocketAddress  ( "localhost" , port ) ) ;    System . err . println  (   "Serving file leak stats on http://localhost:" +  ss . getLocalPort  ( ) + "/ for stats" ) ;   final ExecutorService  es =  Executors . newCachedThreadPool  (  new ThreadFactory  ( )  {   public Thread newThread  (  Runnable r )  {  Thread  t =  new Thread  ( r ) ;   t . setDaemon  ( true ) ;  return t ; } } ) ;   es . submit  (  new  Callable  < Object >  ( )  {   public Object call  ( )  throws Exception  {  while  ( true )  {   final Socket  s =  ss . accept  ( ) ;   es . submit  (  new  Callable  < Void >  ( )  {   public Void call  ( )  throws Exception  {  try  {  BufferedReader  in =  new BufferedReader  (  new InputStreamReader  (  s . getInputStream  ( ) ) ) ;   in . readLine  ( ) ;  PrintWriter  w =  new PrintWriter  (  new OutputStreamWriter  (  s . getOutputStream  ( ) , "UTF-8" ) ) ;   w . print  ( "HTTP/1.0 200 OK\r\nContent-Type: text/plain;charset=UTF-8\r\n\r\n" ) ;   Listener . dump  ( w ) ; }  finally  {   s . close  ( ) ; }  return null ; } } ) ; } } } ) ; }   private static void usageAndQuit  ( )  {    System . err . println  ( "File leak detector arguments (to specify multiple values, separate them by ',':" ) ;   printOptions  ( ) ;   System . exit  (  - 1 ) ; }   static void printOptions  ( )  {    System . err . println  ( "  help          - show the help screen." ) ;    System . err . println  ( "  trace         - log every open/close operation to stderr." ) ;    System . err . println  ( "  trace=FILE    - log every open/close operation to the given file." ) ;    System . err . println  ( "  error=FILE    - if 'too many open files' error is detected, send the dump here." ) ;    System . err . println  ( "                  by default it goes to stderr." ) ;    System . err . println  ( "  threshold=N   - instead of waiting until 'too many open files', dump once" ) ;    System . err . println  ( "                  we have N descriptors open." ) ;    System . err . println  ( "  http=PORT     - Run a mini HTTP server that you can access to get stats on demand" ) ;    System . err . println  ( "                  Specify 0 to choose random available port, -1 to disable, which is default." ) ;    System . err . println  ( "  strong        - Don't let GC auto-close leaking file descriptors" ) ;    System . err . println  ( "  listener=S    - Specify the fully qualified name of ActivityListener class to activate from beginning" ) ;    System . err . println  ( "  dumpatshutdown- Dump open file handles at shutdown" ) ;    System . err . println  ( "  excludes=FILE - Ignore files opened directly/indirectly in specific methods." ) ;    System . err . println  ( "                  File lists 'some.pkg.ClassName.methodName' patterns." ) ; }   static  List  < ClassTransformSpec > createSpec  ( )  {  return  Arrays . asList  (  newSpec  (  FileOutputStream . class , "(Ljava/io/File;Z)V" ) ,  newSpec  (  FileInputStream . class , "(Ljava/io/File;)V" ) ,  newSpec  (  RandomAccessFile . class , "(Ljava/io/File;Ljava/lang/String;)V" ) ,  newSpec  (  ZipFile . class , "(Ljava/io/File;I)V" ) ,  newFdSpec  ( "java/nio/channels/spi/AbstractInterruptibleChannel" , "close" , "()V" , "close" ) ,  newFdSpec  ( "java/nio/channels/spi/AbstractSelectableChannel" , "<init>" , "(Ljava/nio/channels/spi/SelectorProvider;)V" , "ch_open" ) ,  new ClassTransformSpec  ( "java/net/PlainSocketImpl" ,  new OpenSocketInterceptor  ( "create" , "(Z)V" ) ,  new AcceptInterceptor  ( "accept" , "(Ljava/net/SocketImpl;)V" ) ,  new CloseInterceptor  ( "socketClose" ) ) ,  new ClassTransformSpec  ( "java/net/AbstractPlainSocketImpl" ,  new OpenSocketInterceptor  ( "create" , "(Z)V" ) ,  new AcceptInterceptor  ( "accept" , "(Ljava/net/SocketImpl;)V" ) ,  new CloseInterceptor  ( "socketClose" ) ) ,  new ClassTransformSpec  ( "sun/nio/ch/SocketChannelImpl" ,  new OpenSocketInterceptor  ( "<init>" , "(Ljava/nio/channels/spi/SelectorProvider;Ljava/io/FileDescriptor;Ljava/net/InetSocketAddress;)V" ) ,  new OpenSocketInterceptor  ( "<init>" , "(Ljava/nio/channels/spi/SelectorProvider;)V" ) ,  new CloseInterceptor  ( "kill" ) ) ) ; }   private static ClassTransformSpec newSpec  (   final Class c ,  String constructorDesc )  {   final String  binName =   c . getName  ( ) . replace  ( '.' , '/' ) ;  return  new ClassTransformSpec  ( binName ,  new CloseInterceptor  ( ) ) ; }   private static ClassTransformSpec newFdSpec  (  String binName ,  String methodName ,  String constructorDesc ,  String listenermethod )  {  return  new ClassTransformSpec  ( binName ,  new GenericInterceptor  ( methodName , constructorDesc , listenermethod ) ) ; }   private static class CloseInterceptor  extends MethodAppender  {   public CloseInterceptor  ( )  {  this  ( "close" ) ; }   public CloseInterceptor  (  String methodName )  {  super  ( methodName , "()V" ) ; }   protected void append  (  CodeGenerator g )  {   g . invokeAppStatic  (  Listener . class , "close" ,  new Class  [ ]  {  Object . class } ,  new  int  [ ]  { 0 } ) ; } }   private static class OpenSocketInterceptor  extends MethodAppender  {   public OpenSocketInterceptor  (  String name ,  String desc )  {  super  ( name , desc ) ; }    @ Override public MethodVisitor newAdapter  (  MethodVisitor base ,   int access ,  String name ,  String desc ,  String signature ,   String  [ ] exceptions )  {   final MethodVisitor  b =  super . newAdapter  ( base , access , name , desc , signature , exceptions ) ;  return  new OpenInterceptionAdapter  ( b , access , desc )  {    @ Override protected boolean toIntercept  (  String owner ,  String name )  {  return  name . equals  ( "socketCreate" ) ; } } ; }   protected void append  (  CodeGenerator g )  {   g . invokeAppStatic  (  Listener . class , "openSocket" ,  new Class  [ ]  {  Object . class } ,  new  int  [ ]  { 0 } ) ; } }   private static class AcceptInterceptor  extends MethodAppender  {   public AcceptInterceptor  (  String name ,  String desc )  {  super  ( name , desc ) ; }    @ Override public MethodVisitor newAdapter  (  MethodVisitor base ,   int access ,  String name ,  String desc ,  String signature ,   String  [ ] exceptions )  {   final MethodVisitor  b =  super . newAdapter  ( base , access , name , desc , signature , exceptions ) ;  return  new OpenInterceptionAdapter  ( b , access , desc )  {    @ Override protected boolean toIntercept  (  String owner ,  String name )  {  return  name . equals  ( "socketAccept" ) ; } } ; }   protected void append  (  CodeGenerator g )  {   g . invokeAppStatic  (  Listener . class , "openSocket" ,  new Class  [ ]  {  Object . class } ,  new  int  [ ]  { 1 } ) ; } }   private static abstract class OpenInterceptionAdapter  extends MethodVisitor  {   private final LocalVariablesSorter  lvs ;   private final MethodVisitor  base ;   private OpenInterceptionAdapter  (  MethodVisitor base ,   int access ,  String desc )  {  super  ( ASM5 ) ;   lvs =  new LocalVariablesSorter  ( access , desc , base ) ;   mv = lvs ;    this . base = base ; }   protected abstract boolean toIntercept  (  String owner ,  String name ) ;   protected  Class  <  ? extends Exception > getExpectedException  ( )  {  return  IOException . class ; }    @ Override public void visitMethodInsn  (   int opcode ,  String owner ,  String name ,  String desc ,  boolean itf )  {  if  (  toIntercept  ( owner , name ) )  {  Type  exceptionType =  Type . getType  (  getExpectedException  ( ) ) ;  CodeGenerator  g =  new CodeGenerator  ( mv ) ;  Label  s =  new Label  ( ) ;  Label  e =  new Label  ( ) ;  Label  h =  new Label  ( ) ;  Label  tail =  new Label  ( ) ;   g . visitTryCatchBlock  ( s , e , h ,  exceptionType . getInternalName  ( ) ) ;   g . visitLabel  ( s ) ;   super . visitMethodInsn  ( opcode , owner , name , desc , itf ) ;   g . _goto  ( tail ) ;   g . visitLabel  ( e ) ;   g . visitLabel  ( h ) ;   int  ex =  lvs . newLocal  ( exceptionType ) ;   g . dup  ( ) ;   base . visitVarInsn  ( ASTORE , ex ) ;   g . invokeVirtual  (  exceptionType . getInternalName  ( ) , "getMessage" , "()Ljava/lang/String;" ) ;   g . ldc  ( "Too many open files" ) ;   g . invokeVirtual  ( "java/lang/String" , "contains" , "(Ljava/lang/CharSequence;)Z" ) ;  Label  rethrow =  new Label  ( ) ;   g . ifFalse  ( rethrow ) ;   g . invokeAppStatic  (  Listener . class , "outOfDescriptors" ,  new Class  [ 0 ] ,  new  int  [ 0 ] ) ;   g . visitLabel  ( rethrow ) ;   base . visitVarInsn  ( ALOAD , ex ) ;   g . athrow  ( ) ;   g . visitLabel  ( tail ) ; } else   super . visitMethodInsn  ( opcode , owner , name , desc , itf ) ; } }   private static class ConstructorOpenInterceptor  extends MethodAppender  {   private final String  binName ;   public ConstructorOpenInterceptor  (  String constructorDesc ,  String binName )  {  super  ( "<init>" , constructorDesc ) ;    this . binName = binName ; }    @ Override public MethodVisitor newAdapter  (  MethodVisitor base ,   int access ,  String name ,  String desc ,  String signature ,   String  [ ] exceptions )  {   final MethodVisitor  b =  super . newAdapter  ( base , access , name , desc , signature , exceptions ) ;  return  new OpenInterceptionAdapter  ( b , access , desc )  {    @ Override protected boolean toIntercept  (  String owner ,  String name )  {  return   owner . equals  ( binName ) &&  name . startsWith  ( "open" ) ; }    @ Override protected  Class  <  ? extends Exception > getExpectedException  ( )  {  return  FileNotFoundException . class ; } } ; }   protected void append  (  CodeGenerator g )  {   g . invokeAppStatic  (  Listener . class , "open" ,  new Class  [ ]  {  Object . class ,  File . class } ,  new  int  [ ]  { 0 , 1 } ) ; } }   private static class GenericInterceptor  extends MethodAppender  {   private final String  listenerMethod ;   public GenericInterceptor  (  String methodName ,  String constructorDesc ,  String listenerMethod )  {  super  ( methodName , constructorDesc ) ;    this . listenerMethod = listenerMethod ; }   protected void append  (  CodeGenerator g )  {   g . invokeAppStatic  (  Listener . class , listenerMethod ,  new Class  [ ]  {  Object . class } ,  new  int  [ ]  { 0 } ) ; } } }