  package    org . fluttercode . datafactory . impl ;   import   java . math . BigInteger ;  import   java . util . Calendar ;  import   java . util . Date ;  import   java . util . List ;  import   java . util . Properties ;  import   java . util . Random ;  import    org . fluttercode . datafactory . AddressDataValues ;  import    org . fluttercode . datafactory . ContentDataValues ;  import    org . fluttercode . datafactory . NameDataValues ;   public final class DataFactory  {   private static Random  random =  new Random  ( 93285 ) ;   private NameDataValues  nameDataValues =  new DefaultNameDataValues  ( ) ;   private AddressDataValues  addressDataValues =  new DefaultAddressDataValues  ( ) ;   private ContentDataValues  contentDataValues =  new DefaultContentDataValues  ( ) ;   public  <  T > T getItem  (   List  < T > items )  {  return  getItem  ( items , 100 , null ) ; }   public  <  T > T getItem  (   List  < T > items ,   int probability )  {  return  getItem  ( items , probability , null ) ; }   public  <  T > T getItem  (   List  < T > items ,   int probability ,  T defaultItem )  {  if  (  items == null )  {  throw  new IllegalArgumentException  ( "Item list cannot be null" ) ; }  if  (  items . isEmpty  ( ) )  {  throw  new IllegalArgumentException  ( "Item list cannot be empty" ) ; }  return   chance  ( probability ) ?  items . get  (  random . nextInt  (  items . size  ( ) ) ) : defaultItem ; }   public  <  T > T getItem  (   T  [ ] items )  {  return  getItem  ( items , 100 , null ) ; }   public  <  T > T getItem  (   T  [ ] items ,   int probability )  {  return  getItem  ( items , probability , null ) ; }   public  <  T > T getItem  (   T  [ ] items ,   int probability ,  T defaultItem )  {  if  (  items == null )  {  throw  new IllegalArgumentException  ( "Item array cannot be null" ) ; }  if  (   items . length == 0 )  {  throw  new IllegalArgumentException  ( "Item array cannot be empty" ) ; }  return   chance  ( probability ) ?  items [  random . nextInt  (  items . length ) ] : defaultItem ; }   public String getFirstName  ( )  {  return  getItem  (  nameDataValues . getFirstNames  ( ) ) ; }   public String getName  ( )  {  return    getItem  (  nameDataValues . getFirstNames  ( ) ) + " " +  getItem  (  nameDataValues . getLastNames  ( ) ) ; }   public String getLastName  ( )  {  return  getItem  (  nameDataValues . getLastNames  ( ) ) ; }   public String getStreetName  ( )  {  return  getItem  (  addressDataValues . getStreetNames  ( ) ) ; }   public String getStreetSuffix  ( )  {  return  getItem  (  addressDataValues . getAddressSuffixes  ( ) ) ; }   public String getCity  ( )  {  return  getItem  (  addressDataValues . getCities  ( ) ) ; }   public String getAddress  ( )  {   int  num =  404 +  random . nextInt  ( 1400 ) ;  return     num + " " +  getStreetName  ( ) + " " +  getStreetSuffix  ( ) ; }   public String getAddressLine2  (   int probability )  {  return  getAddressLine2  ( probability , null ) ; }   public String getAddressLine2  (   int probability ,  String defaultValue )  {  return   chance  ( probability ) ?  getAddressLine2  ( ) : defaultValue ; }   public String getAddressLine2  ( )  {   int  test =  random . nextInt  ( 100 ) ;  if  (  test < 50 )  {  return   "Apt #" + 100 +  random . nextInt  ( 1000 ) ; } else  {  return   "Suite #" + 100 +  random . nextInt  ( 1000 ) ; } }   public Date getBirthDate  ( )  {  Date  base =  new Date  ( 0 ) ;  return  getDate  ( base ,   - 365 * 15 ,  365 * 15 ) ; }   public  int getNumber  ( )  {  return  getNumberBetween  (  Integer . MIN_VALUE ,  Integer . MAX_VALUE ) ; }   public  int getNumberUpTo  (   int max )  {  return  getNumberBetween  ( 0 , max ) ; }   public  int getNumberBetween  (   int min ,   int max )  {  if  (  max < min )  {  throw  new IllegalArgumentException  (  String . format  ( "Minimum must be less than minimum (min=%d, max=%d)" , min , max ) ) ; }   int  average =  avg  ( min , max ) ;   int  base =  abs  (  min - average ) ;   int  randomNumber ;  if  (  base != 0 )  {   randomNumber =  random . nextInt  ( base ) ; } else  {   randomNumber = 0 ; }  if  (  random . nextBoolean  ( ) )  {  return  average + randomNumber ; } else  {  return  average - randomNumber ; } }   private  int abs  (   int number )  {  if  (  number ==  Integer . MIN_VALUE )  {  return  Integer . MAX_VALUE ; } else  {  return  Math . abs  ( number ) ; } }   private  int avg  (   int first ,   int second )  {  BigInteger  firstInt =  BigInteger . valueOf  ( first ) ;  BigInteger  secondInt =  BigInteger . valueOf  ( second ) ;  return    firstInt . add  ( secondInt ) . divide  (  BigInteger . valueOf  ( 2 ) ) . intValue  ( ) ; }   public Date getDate  (   int year ,   int month ,   int day )  {  Calendar  cal =  Calendar . getInstance  ( ) ;   cal . clear  ( ) ;   cal . set  ( year ,  month - 1 , day , 0 , 0 , 0 ) ;  return  cal . getTime  ( ) ; }   public Date getDate  (  Date baseDate ,   int minDaysFromDate ,   int maxDaysFromDate )  {  Calendar  cal =  Calendar . getInstance  ( ) ;   cal . setTime  ( baseDate ) ;   int  diff =  minDaysFromDate +  (  random . nextInt  (  maxDaysFromDate - minDaysFromDate ) ) ;   cal . add  (  Calendar . DATE , diff ) ;  return  cal . getTime  ( ) ; }   public Date getDateBetween  (  Date minDate ,  Date maxDate )  {   long  seconds =   (   maxDate . getTime  ( ) -  minDate . getTime  ( ) ) / 1000 ;   seconds =  (  long )  (   random . nextDouble  ( ) * seconds ) ;  Date  result =  new Date  ( ) ;   result . setTime  (   minDate . getTime  ( ) +  (  seconds * 1000 ) ) ;  return result ; }   public String getRandomText  (   int length )  {  return  getRandomText  ( length , length ) ; }   public String getRandomText  (   int minLength ,   int maxLength )  {   validateMinMaxParams  ( minLength , maxLength ) ;  StringBuilder  sb =  new StringBuilder  ( maxLength ) ;   int  length = minLength ;  if  (  maxLength != minLength )  {   length =  length +  random . nextInt  (  maxLength - minLength ) ; }  while  (  length > 0 )  {  if  (   sb . length  ( ) != 0 )  {   sb . append  ( " " ) ;   length -- ; }   final  double  desiredWordLengthNormalDistributed =  1.0 +   Math . abs  (  random . nextGaussian  ( ) ) * 6 ;   int  usedWordLength =  (  int )  (  Math . min  ( length , desiredWordLengthNormalDistributed ) ) ;  String  word =  getRandomWord  ( 
<<<<<<<
0
=======
usedWordLength
>>>>>>>
 , ) ;   sb . append  ( word ) ;   length =  length -  word . length  ( ) ; }  return  sb . toString  ( ) ; }   private void validateMinMaxParams  (   int minLength ,   int maxLength )  {  if  (  minLength < 0 )  {  throw  new IllegalArgumentException  ( "Minimum length must be a non-negative number" ) ; }  if  (  maxLength < 0 )  {  throw  new IllegalArgumentException  ( "Maximum length must be a non-negative number" ) ; }  if  (  maxLength < minLength )  {  throw  new IllegalArgumentException  (  String . format  ( "Minimum length must be less than maximum length (min=%d, max=%d)" , minLength , maxLength ) ) ; } }   public  char getRandomChar  ( )  {  return  (  char )  (   random . nextInt  ( 26 ) + 'a' ) ; }   public String getRandomChars  (   int length )  {  return  getRandomChars  ( length , length ) ; }   public String getRandomChars  (   int minLength ,   int maxLength )  {   validateMinMaxParams  ( minLength , maxLength ) ;  StringBuilder  sb =  new StringBuilder  ( maxLength ) ;   int  length = minLength ;  if  (  maxLength != minLength )  {   length =  length +  random . nextInt  (  maxLength - minLength ) ; }  while  (  length > 0 )  {   sb . append  (  getRandomChar  ( ) ) ;   length -- ; }  return  sb . toString  ( ) ; }   public String getRandomWord  ( )  {  return  getItem  (  contentDataValues . getWords  ( ) ) ; }   public String getRandomWord  (   int length )  {  return  getRandomWord  ( length , length ) ; }   public String getRandomWord  (   int length ,  boolean exactLength )  {  if  ( exactLength )  {  return  getRandomWord  ( length , length ) ; }  return  getRandomWord  ( 0 , length ) ; }   public String getRandomWord  (   int minLength ,   int maxLength )  {   validateMinMaxParams  ( minLength , maxLength ) ;  if  (  maxLength == 1 )  {  if  (  chance  ( 50 ) )  {  return "a" ; }  return "I" ; }  String  value = null ;   String  [ ]  words =  contentDataValues . getWords  ( ) ;   int  pos =  random . nextInt  (  words . length ) ;  for (   int  i = 0 ;  i <  words . length ;  i ++ )  {   int  idx =   (  i + pos ) %  words . length ;  String  test =  words [ idx ] ;  if  (    test . length  ( ) >= minLength &&   test . length  ( ) <= maxLength )  {  return test ; } }  return  getRandomChars  ( minLength , maxLength ) ; }   public String getSuffix  (   int chance )  {  return  getItem  (  nameDataValues . getSuffixes  ( ) , chance ) ; }   public String getPrefix  (   int chance )  {  return  getItem  (  nameDataValues . getPrefixes  ( ) , chance ) ; }   public String getNumberText  (   int digits )  {  String  result = "" ;  for (   int  i = 0 ;  i < digits ;  i ++ )  {   result =  result +  random . nextInt  ( 10 ) ; }  return result ; }   public String getBusinessName  ( )  {  return    getCity  ( ) + " " +  getItem  (  contentDataValues . getBusinessTypes  ( ) ) ; }   public String getEmailAddress  ( )  {   int  test =  random . nextInt  ( 100 ) ;  String  email = "" ;  if  (  test < 50 )  {   email =    getFirstName  ( ) . charAt  ( 0 ) +  getLastName  ( ) ; } else  {   email =   getItem  (  contentDataValues . getWords  ( ) ) +  getItem  (  contentDataValues . getWords  ( ) ) ; }  if  (   random . nextInt  ( 100 ) > 80 )  {   email =  email +  random . nextInt  ( 100 ) ; }   email =     email + "@" +  getItem  (  contentDataValues . getEmailHosts  ( ) ) + "." +  getItem  (  contentDataValues . getTlds  ( ) ) ;  return  email . toLowerCase  ( ) ; }   public boolean chance  (   int chance )  {  return   random . nextInt  ( 100 ) < chance ; }   public NameDataValues getNameDataValues  ( )  {  return nameDataValues ; }   public void randomize  (   int seed )  {   random =  new Random  ( seed ) ; }   public void setNameDataValues  (  NameDataValues nameDataValues )  {    this . nameDataValues = nameDataValues ; }   public void setAddressDataValues  (  AddressDataValues addressDataValues )  {    this . addressDataValues = addressDataValues ; }   public void setContentDataValues  (  ContentDataValues contentDataValues )  {    this . contentDataValues = contentDataValues ; } }