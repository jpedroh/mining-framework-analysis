  package   org . codehaus . jparsec ;   import     org . codehaus . jparsec . annotations . Private ;  import     org . codehaus . jparsec . error . ParserException ;  import     org . codehaus . jparsec . functors . Map ;  import     org . codehaus . jparsec . functors . Map2 ;  import     org . codehaus . jparsec . functors . Maps ;  import     org . codehaus . jparsec . util . Checks ;  import   java . io . IOException ;  import   java . nio . CharBuffer ;  import   java . util . Collection ;  import   java . util . List ;  import     java . util . concurrent . atomic . AtomicReference ;  import static      org . codehaus . jparsec . util . Checks . checkArgument ;   public abstract class Parser  <  T >  {   public static final class Reference  <  T >  extends  AtomicReference  <  Parser  < T > >  {   private static final  long  serialVersionUID =  - 8778697271614979497L ;   private final  Parser  < T >  lazy =  new  LazyParser  < T >  ( this ) ;   public  Parser  < T > lazy  ( )  {  return lazy ; } }  Parser  ( )  { }   public static  <  T >  Reference  < T > newReference  ( )  {  return  new  Reference  < T >  ( ) ; }   public final  <  R >  Parser  < R > retn  (  R value )  {  return  next  (  Parsers . constant  ( value ) ) ; }   public final  <  R >  Parser  < R > next  (   Parser  < R > parser )  {  return  Parsers . sequence  ( this , parser ) ; }   public final  <  To >  Parser  < To > next  (   Map  <  ? super T ,  ? extends  Parser  <  ? extends To > > map )  {  return  new  BindNextParser  < T , To >  ( this , map ) ; }   public final  Parser  < T > followedBy  (   Parser  <  ? > parser )  {  return  Parsers . sequence  ( this , parser ,  InternalFunctors .  < T , Object > firstOfTwo  ( ) ) ; }   public final  Parser  < T > notFollowedBy  (   Parser  <  ? > parser )  {  return  followedBy  (  parser . not  ( ) ) ; }   public final  Parser  <  List  < T > > many  ( )  {  return  atLeast  ( 0 ) ; }   public final  Parser  < Void > skipMany  ( )  {  return  skipAtLeast  ( 0 ) ; }   public final  Parser  <  List  < T > > many1  ( )  {  return  atLeast  ( 1 ) ; }   public final  Parser  < Void > skipMany1  ( )  {  return  skipAtLeast  ( 1 ) ; }   public final  Parser  <  List  < T > > atLeast  (   int min )  {  return  new  RepeatAtLeastParser  < T >  ( this ,  Checks . checkMin  ( min ) ) ; }   public final  Parser  < Void > skipAtLeast  (   int min )  {  return  new SkipAtLeastParser  ( this ,  Checks . checkMin  ( min ) ) ; }   public final  Parser  < Void > skipTimes  (   int n )  {  return  skipTimes  ( n , n ) ; }   public final  Parser  <  List  < T > > times  (   int n )  {  return  times  ( n , n ) ; }   public final  Parser  <  List  < T > > times  (   int min ,   int max )  {   Checks . checkMinMax  ( min , max ) ;  return  new  RepeatTimesParser  < T >  ( this , min , max ) ; }   public final  Parser  < Void > skipTimes  (   int min ,   int max )  {   Checks . checkMinMax  ( min , max ) ;  return  new SkipTimesParser  ( this , min , max ) ; }   public final  <  R >  Parser  < R > map  (   Map  <  ? super T ,  ? extends R > map )  {  return  new  MapParser  < T , R >  ( this , map ) ; }    @ SuppressWarnings  ( "unchecked" ) public final  Parser  < T > or  (   Parser  <  ? extends T > alternative )  {  return  Parsers . or  ( this , alternative ) ; }   public final  Parser  < T > optional  ( )  {  return  Parsers . plus  ( this ,  Parsers .  < T > always  ( ) ) ; }   public final  Parser  < T > optional  (  T defaultValue )  {  return  Parsers . plus  ( this ,  Parsers . constant  ( defaultValue ) ) ; }   public final  Parser  <  ? > not  ( )  {  return  not  (  toString  ( ) ) ; }   public final  Parser  <  ? > not  (  String unexpected )  {  return   peek  ( ) . ifelse  (  Parsers . unexpected  ( unexpected ) ,  Parsers . always  ( ) ) ; }   public final  Parser  < T > peek  ( )  {  return  new  PeekParser  < T >  ( this ) ; }   public final  Parser  < T > atomic  ( )  {  return  new  AtomicParser  < T >  ( this ) ; }   public final  Parser  < Boolean > succeeds  ( )  {  return  ifelse  (  Parsers . TRUE ,  Parsers . FALSE ) ; }   public final  Parser  < Boolean > fails  ( )  {  return  ifelse  (  Parsers . FALSE ,  Parsers . TRUE ) ; }   public final  <  R >  Parser  < R > ifelse  (   Parser  <  ? extends R > consequence ,   Parser  <  ? extends R > alternative )  {  return  ifelse  (  Maps . constant  ( consequence ) , alternative ) ; }   public final  <  R >  Parser  < R > ifelse  (   Map  <  ? super T ,  ? extends  Parser  <  ? extends R > > consequence ,   Parser  <  ? extends R > alternative )  {  return  new  IfElseParser  < R , T >  ( this , consequence , alternative ) ; }   public final  Parser  < T > label  (  String name )  {  return  Parsers . plus  ( this ,  Parsers .  < T > expect  ( name ) ) ; }    @ SuppressWarnings  ( "unchecked" ) public final  <  R >  Parser  < R > cast  ( )  {  return  (  Parser  < R > ) this ; }   public final  Parser  < T > between  (   Parser  <  ? > before ,   Parser  <  ? > after )  {  return  before . next  (  followedBy  ( after ) ) ; }   public final  Parser  <  List  < T > > sepBy1  (   Parser  <  ? > delim )  {   final  Parser  < T >  afterFirst =   delim . step  ( 0 ) . next  ( this ) ;   Map  < T ,  Parser  <  List  < T > > >  binder =  new  Map  < T ,  Parser  <  List  < T > > >  ( )  {   public  Parser  <  List  < T > > map  (  T firstValue )  {  return  new  RepeatAtLeastParser  < T >  ( afterFirst , 0 ,  ListFactories . arrayListFactoryWithFirstElement  ( firstValue ) ) ; } } ;  return  next  ( binder ) ; }   public final  Parser  <  List  < T > > sepBy  (   Parser  <  ? > delim )  {  return  Parsers . plus  (  sepBy1  ( delim ) ,  EmptyListParser .  < T > instance  ( ) ) ; }   public final  Parser  <  List  < T > > endBy  (   Parser  <  ? > delim )  {  return   followedBy  ( delim ) . many  ( ) ; }   public final  Parser  <  List  < T > > endBy1  (   Parser  <  ? > delim )  {  return   followedBy  ( delim ) . many1  ( ) ; }   public final  Parser  <  List  < T > > sepEndBy1  (   final  Parser  <  ? > delim )  {  return  next  (  new  Map  < T ,  Parser  <  List  < T > > >  ( )  {   public  Parser  <  List  < T > > map  (  T first )  {  return  new  DelimitedListParser  < T >  (  Parser . this , delim ,  ListFactories . arrayListFactoryWithFirstElement  ( first ) ) ; } } ) ; }   public final  Parser  <  List  < T > > sepEndBy  (   Parser  <  ? > delim )  {  return  Parsers . plus  (  sepEndBy1  ( delim ) ,  EmptyListParser .  < T > instance  ( ) ) ; }    @ SuppressWarnings  ( "unchecked" ) public final  Parser  < T > prefix  (   Parser  <  ? extends  Map  <  ? super T ,  ? extends T > > op )  {  return  Parsers . sequence  (  op . many  ( ) , this ,  Parsers . PREFIX_OPERATOR_MAP2 ) ; }    @ SuppressWarnings  ( "unchecked" ) public final  Parser  < T > postfix  (   Parser  <  ? extends  Map  <  ? super T ,  ? extends T > > op )  {  return  Parsers . sequence  ( this ,  op . many  ( ) ,  Parsers . POSTFIX_OPERATOR_MAP2 ) ; }   public final  Parser  < T > infixn  (   Parser  <  ? extends  Map2  <  ? super T ,  ? super T ,  ? extends T > > op )  {  return  Parsers . infixn  ( this , op ) ; }   public final  Parser  < T > infixl  (   Parser  <  ? extends  Map2  <  ? super T ,  ? super T ,  ? extends T > > op )  {  return  Parsers . infixl  ( this , op ) ; }   public final  Parser  < T > infixr  (   Parser  <  ? extends  Map2  <  ? super T ,  ? super T ,  ? extends T > > op )  {  return  Parsers . infixr  ( this , op ) ; }   public final  Parser  < Token > token  ( )  {  return  new ToTokenParser  ( this ) ; }   public final  Parser  < String > source  ( )  {  return  new ReturnSourceParser  ( this ) ; }   public final  Parser  < T > from  (   Parser  <  ? extends  Collection  < Token > > lexer )  {  return  Parsers . nested  (  Parsers . tokens  ( lexer ) ,  followedBy  (  Parsers . EOF ) ) ; }   public final  Parser  < T > from  (   Parser  <  ? > tokenizer ,   Parser  < Void > delim )  {  return  from  (  tokenizer . lexer  ( delim ) ) ; }   public  Parser  <  List  < Token > > lexer  (   Parser  <  ? > delim )  {  return   delim . optional  ( ) . next  (   token  ( ) . sepEndBy  ( delim ) ) ; }   public final T parse  (  CharSequence source ,  String moduleName )  {  return  parse  ( source , moduleName ,  new DefaultSourceLocator  ( source ) ) ; }   public final T parse  (  CharSequence source )  {  return  parse  ( source , null ) ; }   public final T parse  (  Readable readable )  throws IOException  {  return  parse  ( readable , null ) ; }   public final T parse  (  Readable readable ,  String moduleName )  throws IOException  {  StringBuilder  builder =  new StringBuilder  ( ) ;   copy  ( readable , builder ) ;  return  parse  ( builder , moduleName ) ; }   abstract boolean apply  (  ParseContext ctxt ) ;    @ Private static void copy  (  Readable from ,  Appendable to )  throws IOException  {  CharBuffer  buf =  CharBuffer . allocate  ( 2048 ) ;  for ( ; ; )  {   int  r =  from . read  ( buf ) ;  if  (  r ==  - 1 )  break ;   buf . flip  ( ) ;   to . append  ( buf , 0 , r ) ; } }   final  Parser  < T > step  (   int n )  {   checkArgument  (  n >= 0 , "step < 0" ) ;  return  new  StepParser  < T >  ( this , n ) ; }   final T parse  (  CharSequence source ,  String moduleName ,  SourceLocator sourceLocator )  {  return  Parsers . parse  ( source ,  followedBy  (  Parsers . EOF ) , sourceLocator , moduleName ) ; }    @ SuppressWarnings  ( "unchecked" ) final T getReturn  (  ParseContext ctxt )  {  return  ( T )  ctxt . result ; }   final boolean run  (  ParseContext ctxt )  {  try  {  return  apply  ( ctxt ) ; }  catch (   RuntimeException e )  {  throw  asParserException  ( e , ctxt ) ; } }   private ParserException asParserException  (  Throwable e ,  ParseContext ctxt )  {  if  (  e instanceof ParserException )  return  ( ParserException ) e ;  return  new ParserException  ( e , null ,  ctxt . module ,   ctxt . locator . locate  (  ctxt . getIndex  ( ) ) ) ; } 
<<<<<<<
=======
  public final  Parser  < T > locate  ( )  {  return  new  LocatableParser  < T >  ( this ) ; }
>>>>>>>
   public final  <  U >  Parser  < T > locate  (   LocatableHandler  < U > handler )  {  return  new  LocatableParser2  < T , U >  ( this , handler ) ; } }