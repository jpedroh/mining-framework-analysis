  package     org . movsim . simulator . roadSection . impl ;   import   java . io . PrintWriter ;  import   java . util . List ;  import      org . movsim . input . model . simulation . UpstreamBoundaryData ;  import    org . movsim . simulator . Constants ;  import     org . movsim . simulator . roadSection . InflowTimeSeries ;  import     org . movsim . simulator . roadSection . UpstreamBoundary ;  import     org . movsim . simulator . vehicles . Vehicle ;  import     org . movsim . simulator . vehicles . VehicleContainer ;  import     org . movsim . simulator . vehicles . VehicleGenerator ;  import     org . movsim . simulator . vehicles . VehiclePrototype ;  import     org . movsim . utilities . impl . FileUtils ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     org . movsim . output . fileoutput . FileUpstreamBoundaryData ;   public class UpstreamBoundaryImpl  implements  UpstreamBoundary  { 
<<<<<<<
  private static final String  outputHeading =   Constants . COMMENT_CHAR + "     t[s], lane,  xEnter[m],    v[km/h],   total qBC[1/h],    count,      queue\n" ;
=======
>>>>>>>
   final static Logger  logger =  LoggerFactory . getLogger  (  UpstreamBoundaryImpl . class ) ;   private  double  nWait ;   private final VehicleGenerator  vehGenerator ;   private final  List  < VehicleContainer >  vehContainers ;   private final InflowTimeSeries  inflowTimeSeries ;   private  int  enteringVehCounter ;   private  double  xEnterLast ;   private  double  vEnterLast ;   private  int  laneEnterLast ;   public UpstreamBoundaryImpl  (  VehicleGenerator vehGenerator ,   List  < VehicleContainer > vehContainers ,  UpstreamBoundaryData upstreamBoundaryData ,  String projectName )  {    this . vehGenerator = vehGenerator ;    this . vehContainers = vehContainers ;   nWait = 0 ;   enteringVehCounter = 1 ;   inflowTimeSeries =  new InflowTimeSeriesImpl  (  upstreamBoundaryData . getInflowTimeSeries  ( ) ) ;  if  (  upstreamBoundaryData . withLogging  ( ) )  {   fileUpstreamBoundary =  new FileUpstreamBoundaryData  ( projectName ) ; } }   private  int getNewLaneIndex  (   int iLane )  {  return  (   iLane ==   vehContainers . size  ( ) - 1 ? 0 :  iLane + 1 ) ; }   public  double getTotalInflow  (   double time )  {   final  double  qBC =  inflowTimeSeries . getFlowPerLane  ( time ) ;   final  int  nLanes =  vehContainers . size  ( ) ;  return  nLanes * qBC ; }    @ Override public void update  (   int itime ,   double dt ,   double time )  {   final  double  totalInflow =  getTotalInflow  ( time ) ;   nWait +=  totalInflow * dt ;  if  (  nWait >= 1 )  {   int  iLane = laneEnterLast ;  for (   int  i = 0 ,  N =  vehContainers . size  ( ) ;  i < N ;  i ++ )  {   iLane =  getNewLaneIndex  ( iLane ) ;   final VehicleContainer  vehContainerLane =  vehContainers . get  ( iLane ) ;   final boolean  isEntered =  tryEnteringNewVehicle  ( vehContainerLane , iLane , time , totalInflow ) ;  if  ( isEntered )  {   nWait -- ;  if  (  fileUpstreamBoundary != null )  {   fileUpstreamBoundary . update  ( time , laneEnterLast , xEnterLast ,  3.6 * vEnterLast ,  3600 * totalInflow , enteringVehCounter , nWait ) ; }  return ; } } } }   private boolean tryEnteringNewVehicle  (   final VehicleContainer vehContainer ,   int lane ,   double time ,   double qBC )  {   final VehiclePrototype  vehPrototype =  vehGenerator . getVehiclePrototype  ( ) ;   final Vehicle  leader =  vehContainer . getMostUpstream  ( ) ;  if  (  leader == null )  {   enterVehicleOnEmptyRoad  ( vehContainer , lane , time , vehPrototype ) ;  return true ; }   final  double  netGapToLeader =   leader . getPosition  ( ) -  leader . getLength  ( ) ;   double  gapAtQMax =  1. /  vehPrototype . getRhoQMax  ( ) ;  if  (    vehPrototype . getLongModel  ( ) . modelName  ( ) . equalsIgnoreCase  ( "" ) )  {   final  double  tau = 1 ;   gapAtQMax =   leader . getSpeed  ( ) * tau ; }   double  minRequiredGap =  0.8 * gapAtQMax ;  if  (   vehPrototype . getLongModel  ( ) . isCA  ( ) )  {   final  double  tau = 1 ;   minRequiredGap =   leader . getSpeed  ( ) * tau ; }  if  (  netGapToLeader > minRequiredGap )  {   enterVehicle  ( vehContainer , lane , time , minRequiredGap , vehPrototype , leader ) ;  return true ; }  return false ; }   private void enterVehicleOnEmptyRoad  (   final VehicleContainer vehContainer ,   int lane ,   double time ,  VehiclePrototype vehPrototype )  {   final  double  xEnter = 0 ;   final  double  vEnter =  inflowTimeSeries . getSpeed  ( time ) ;   addVehicle  ( vehContainer , lane , vehPrototype , xEnter , vEnter ) ; }   private void enterVehicle  (   final VehicleContainer vehContainer ,   int lane ,   double time ,   double sFreeMin ,  VehiclePrototype vehPrototype ,  Vehicle leader )  {   final  double  sFree =   leader . getPosition  ( ) -  leader . getLength  ( ) ;   final  double  xLast =  leader . getPosition  ( ) ;   final  double  vLast =  leader . getSpeed  ( ) ;   final  double  aLast =  leader . getAcc  ( ) ;   final  double  speedDefault =  inflowTimeSeries . getSpeed  ( time ) ;   final  double  vEnterTest =  Math . min  ( speedDefault ,  1.5 * vLast ) ;   final  double  lengthLast =  leader . getLength  ( ) ;   final  double  qBC =  inflowTimeSeries . getFlowPerLane  ( time ) ;   final  double  xEnter =  Math . min  (   vEnterTest * nWait /  Math . max  ( qBC , 0.001 ) ,   xLast - sFreeMin - lengthLast ) ;   final  double  rhoEnter =  1. /  (  xLast - xEnter ) ;   final  double  vMaxEq =  vehPrototype . getEquilibriumSpeed  (  0.5 * rhoEnter ) ;   final  double  bMax = 4 ;   final  double  bEff =  Math . max  ( 0.1 ,  bMax + aLast ) ;   final  double  vMaxKin =  vLast +  Math . sqrt  (   2 * sFree * bEff ) ;   final  double  vEnter =  Math . min  (  Math . min  ( vEnterTest , vMaxEq ) , vMaxKin ) ;   addVehicle  ( vehContainer , lane , vehPrototype , xEnter , vEnter ) ; }   private void addVehicle  (   final VehicleContainer vehContainer ,   int laneEnter ,   final VehiclePrototype vehPrototype ,   double xEnter ,   double vEnter )  {   final Vehicle  veh =  vehGenerator . createVehicle  ( vehPrototype ) ;   vehContainer . add  ( veh , xEnter , vEnter , laneEnter ) ;   enteringVehCounter ++ ;   xEnterLast = xEnter ;   vEnterLast = vEnter ;   laneEnterLast = laneEnter ; }   private FileUpstreamBoundaryData  fileUpstreamBoundary ; }