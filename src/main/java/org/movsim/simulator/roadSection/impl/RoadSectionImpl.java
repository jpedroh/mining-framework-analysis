  package     org . movsim . simulator . roadSection . impl ;   import   java . util . ArrayList ;  import   java . util . List ;  import    org . movsim . input . InputData ;  import     org . movsim . input . model . RoadInput ;  import     org . movsim . input . model . SimulationInput ;  import      org . movsim . input . model . simulation . DetectorInput ;  import      org . movsim . input . model . simulation . ICMacroData ;  import      org . movsim . input . model . simulation . ICMicroData ;  import      org . movsim . input . model . simulation . RampData ;  import      org . movsim . input . model . simulation . SimpleRampData ;  import       org . movsim . input . model . simulation . impl . AbstractRoadSection ;  import    org . movsim . output . LoopDetector ;  import     org . movsim . output . impl . LoopDetectors ;  import    org . movsim . simulator . Constants ;  import     org . movsim . simulator . roadSection . FlowConservingBottlenecks ;  import     org . movsim . simulator . roadSection . InitialConditionsMacro ;  import     org . movsim . simulator . roadSection . Onramp ;  import     org . movsim . simulator . roadSection . RoadSection ;  import     org . movsim . simulator . roadSection . SpeedLimits ;  import     org . movsim . simulator . roadSection . TrafficLight ;  import     org . movsim . simulator . roadSection . UpstreamBoundary ;  import     org . movsim . simulator . vehicles . Moveable ;  import     org . movsim . simulator . vehicles . Vehicle ;  import     org . movsim . simulator . vehicles . VehicleContainer ;  import     org . movsim . simulator . vehicles . VehicleGenerator ;  import     org . movsim . simulator . vehicles . VehiclePrototype ;  import      org . movsim . simulator . vehicles . impl . VehicleContainerImpl ;  import      org . movsim . simulator . vehicles . impl . VehicleGeneratorImpl ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;   public class RoadSectionImpl  extends AbstractRoadSection  implements  RoadSection  {   final static Logger  logger =  LoggerFactory . getLogger  (  RoadSectionImpl . class ) ;   private TrafficLightsImpl  trafficLights ;   private SpeedLimits  speedlimits ;   private LoopDetectors  detectors = null ;   private  List  < Onramp >  simpleOnramps = null ;   public RoadSectionImpl  (  InputData inputData )  {  super  ( inputData ) ;   logger . info  ( "Cstr. RoadSectionImpl" ) ;   initialize  ( inputData ) ;  if  (   Math . abs  (  dt -  vehGenerator . requiredTimestep  ( ) ) >  Constants . SMALL_VALUE )  {    this . dt =  vehGenerator . requiredTimestep  ( ) ;   logger . info  ( "model requires specific integration timestep. sets to dt={}" , dt ) ; } }   private void initialize  (  InputData inputData )  {   vehContainers =  new  ArrayList  < VehicleContainer >  ( ) ;  for (   int  iLane = 0 ;  iLane < nLanes ;  iLane ++ )  {   vehContainers . add  (  new VehicleContainerImpl  ( ) ) ; }   vehGenerator =  new VehicleGeneratorImpl  ( inputData ) ;   final RoadInput  roadInput =   inputData . getSimulationInput  ( ) . getSingleRoadInput  ( ) ;   upstreamBoundary =  new UpstreamBoundaryImpl  ( vehGenerator , vehContainers ,  roadInput . getUpstreamBoundaryData  ( ) ,   inputData . getProjectMetaData  ( ) . getProjectName  ( ) ) ;   flowConsBottlenecks =  new FlowConservingBottlenecksImpl  (  roadInput . getFlowConsBottleneckInputData  ( ) ) ;   speedlimits =  new SpeedLimitsImpl  (  roadInput . getSpeedLimitInputData  ( ) ) ;   trafficLights =  new TrafficLightsImpl  (   inputData . getProjectMetaData  ( ) . getProjectName  ( ) ,  roadInput . getTrafficLightsInput  ( ) ) ;   final DetectorInput  detInput =  roadInput . getDetectorInput  ( ) ;  if  (  detInput . isWithDetectors  ( ) )  {   detectors =  new LoopDetectors  (   inputData . getProjectMetaData  ( ) . getProjectName  ( ) , detInput ) ; }   initialConditions  (  inputData . getSimulationInput  ( ) ) ;   initOnramps  ( inputData ) ; }    @ Override public  @ Deprecated void update  (   int iterationCount ,   double time )  {   checkForInconsistencies  ( iterationCount , time ) ;   updateRoadConditions  ( iterationCount , time ) ;   accelerate  ( iterationCount , dt , time ) ;   updatePositionAndSpeed  ( iterationCount , dt , time ) ;   updateDownstreamBoundary  ( ) ;   updateUpstreamBoundary  ( iterationCount , dt , time ) ;   updateOnramps  ( iterationCount , dt , time ) ;   detectors . update  ( iterationCount , time , dt , vehContainers ) ; }   private void initialConditions  (  SimulationInput simInput )  {   final  List  < ICMacroData >  icMacroData =   simInput . getSingleRoadInput  ( ) . getIcMacroData  ( ) ;  if  (  !  icMacroData . isEmpty  ( ) )  {   logger . debug  ( "choose macro initial conditions: generate vehicles from macro-density " ) ;   final InitialConditionsMacro  icMacro =  new InitialConditionsMacroImpl  ( icMacroData ) ;   final  double  xLocalMin = 0 ;   double  xLocal = roadLength ;  while  (  xLocal > xLocalMin )  {   final VehiclePrototype  vehPrototype =  vehGenerator . getVehiclePrototype  ( ) ;   final  double  rhoLocal =  icMacro . rho  ( xLocal ) ;   double  speedInit =  icMacro . vInit  ( xLocal ) ;  if  (  speedInit == 0 )  {   speedInit =  vehPrototype . getEquilibriumSpeed  ( rhoLocal ) ; }   final  int  laneEnter =  Constants . MOST_RIGHT_LANE ;   final Vehicle  veh =  vehGenerator . createVehicle  ( vehPrototype ) ;    vehContainers . get  (  Constants . MOST_RIGHT_LANE ) . add  ( veh , xLocal , speedInit , laneEnter ) ;   logger . debug  ( "init conditions macro: rhoLoc={}/km, xLoc={}" ,  1000 * rhoLocal , xLocal ) ;   xLocal -=  1 / rhoLocal ; } } else  {   logger . debug  (  ( "choose micro initial conditions" ) ) ;   final  List  < ICMicroData >  icSingle =   simInput . getSingleRoadInput  ( ) . getIcMicroData  ( ) ;  for (  final ICMicroData ic : icSingle )  {   final  double  posInit =  ic . getX  ( ) ;   final  double  speedInit =  ic . getSpeed  ( ) ;   final String  vehTypeFromFile =  ic . getLabel  ( ) ;   final  int  laneInit =  ic . getInitLane  ( ) ;   final Vehicle  veh =   (  vehTypeFromFile . isEmpty  ( ) ) ?  vehGenerator . createVehicle  ( ) :  vehGenerator . createVehicle  ( vehTypeFromFile ) ;    vehContainers . get  (  Constants . MOST_RIGHT_LANE ) . add  ( veh , posInit , speedInit , laneInit ) ;   logger . info  ( "set vehicle with label = {}" ,  veh . getLabel  ( ) ) ; } } }   private void initOnramps  (  InputData inputData )  {   simpleOnramps =  new  ArrayList  < Onramp >  ( ) ;   final String  projectName =   inputData . getProjectMetaData  ( ) . getProjectName  ( ) ;   final  List  < SimpleRampData >  simpleOnrampData =    inputData . getSimulationInput  ( ) . getSingleRoadInput  ( ) . getSimpleRamps  ( ) ;   int  rampIndex = 1 ;  for (  final SimpleRampData onrmp : simpleOnrampData )  {   simpleOnramps . add  (  new OnrampImpl  ( onrmp , vehGenerator ,  vehContainers . get  (  Constants . MOST_RIGHT_LANE ) , projectName , rampIndex ) ) ;   rampIndex ++ ; }   final  List  < RampData >  onrampData =    inputData . getSimulationInput  ( ) . getSingleRoadInput  ( ) . getRamps  ( ) ;  for (  final RampData onrmp : onrampData )  {   simpleOnramps . add  (  new OnrampMobilImpl  ( onrmp , vehGenerator ,  vehContainers . get  (  Constants . MOST_RIGHT_LANE ) , projectName , rampIndex ) ) ;   rampIndex ++ ; } }   public void updateDownstreamBoundary  ( )  {  for ( VehicleContainer vehContainerLane : vehContainers )  {   vehContainerLane . removeVehiclesDownstream  ( roadLength ) ; } }   public void updateUpstreamBoundary  (   int iterationCount ,   double dt ,   double time )  {   upstreamBoundary . update  ( iterationCount , dt , time ) ; }   public void updateRoadConditions  (   int iterationCount ,   double time )  {   trafficLights . update  ( iterationCount , time , vehContainers ) ;   updateSpeedLimits  ( vehContainers ) ; }   private void updateSpeedLimits  (   List  < VehicleContainer > vehContainers )  {  if  (  !  speedlimits . isEmpty  ( ) )  {  for ( VehicleContainer vehContainerLane : vehContainers )  {  for (  final Vehicle veh :  vehContainerLane . getVehicles  ( ) )  {   final  double  pos =  veh . getPosition  ( ) ;   veh . setSpeedlimit  (  speedlimits . calcSpeedLimit  ( pos ) ) ; } } } }   public void updateOnramps  (   int iterationCount ,   double dt ,   double time )  {  if  (  simpleOnramps . isEmpty  ( ) )  return ;  for (  final Onramp onramp : simpleOnramps )  {   onramp . update  ( iterationCount , dt , time ) ; } }    @ Override public  List  < TrafficLight > getTrafficLights  ( )  {  return  trafficLights . getTrafficLights  ( ) ; }    @ Override public  List  < LoopDetector > getLoopDetectors  ( )  {  return  detectors . getDetectors  ( ) ; } 
<<<<<<<
=======
  public void checkForInconsistencies  (   int iterationCount ,   double time )  {  for (   int  laneIndex = 0 ,  laneIndexMax =  vehContainers . size  ( ) ;  laneIndex < laneIndexMax ;  laneIndex ++ )  {   final VehicleContainer  vehContainerLane =  vehContainers . get  ( laneIndex ) ;   final  List  < Vehicle >  vehiclesOnLane =  vehContainerLane . getVehicles  ( ) ;  for (   int  i = 0 ,  N =  vehiclesOnLane . size  ( ) ;  i < N ;  i ++ )  {   final Moveable  egoVeh =  vehiclesOnLane . get  ( i ) ;   final Moveable  vehFront =  vehContainerLane . getLeader  ( egoVeh ) ;   final  double  netDistance =  egoVeh . getNetDistance  ( vehFront ) ;  if  (  netDistance < 0 )  {   logger . error  ( "#########################################################" ) ;   logger . error  ( "Crash of Vehicle i = {} at x = {}m" , i ,  egoVeh . getPosition  ( ) ) ;  if  (  vehFront != null )  {   logger . error  ( "with veh in front at x = {} on lane = {}" ,  vehFront . getPosition  ( ) ,  egoVeh . getLane  ( ) ) ; }   logger . error  ( "net distance  = {}" , netDistance ) ;   logger . error  ( "lane index    = {}" , laneIndex ) ;   logger . error  ( "container.size = {}" ,  vehiclesOnLane . size  ( ) ) ;   final StringBuilder  msg =  new StringBuilder  ( "\n" ) ;  for (   int  j =  Math . max  ( 0 ,  i - 8 ) ,  M =  vehiclesOnLane . size  ( ) ;  j <=  Math . min  (  i + 8 ,  M - 1 ) ;  j ++ )  {   final Moveable  veh =  vehiclesOnLane . get  ( j ) ;   msg . append  (  String . format  ( "veh=%d, pos=%6.2f, speed=%4.2f, accModel=%4.3f, length=%3.1f, lane=%d, id=%d%n" , j ,  veh . getPosition  ( ) ,  veh . getSpeed  ( ) ,  veh . accModel  ( ) ,  veh . getLength  ( ) ,  veh . getLane  ( ) ,  veh . getId  ( ) ) ) ; }   logger . error  (  msg . toString  ( ) ) ;  if  ( instantaneousFileOutput )  {  if  ( withCrashExit )  {   logger . error  ( " !!! exit after crash !!! " ) ;   System . exit  (  - 99 ) ; } } } } } }
>>>>>>>
 
<<<<<<<
=======
  public void accelerate  (   int iterationCount ,   double dt ,   double time )  {  for ( VehicleContainer vehContainerLane : vehContainers )  {   final  List  < Vehicle >  vehiclesOnLane =  vehContainerLane . getVehicles  ( ) ;  for (   int  i = 0 ,  N =  vehiclesOnLane . size  ( ) ;  i < N ;  i ++ )  {   final Vehicle  veh =  vehiclesOnLane . get  ( i ) ;   final  double  x =  veh . getPosition  ( ) ;   final  double  alphaT =  flowConsBottlenecks . alphaT  ( x ) ;   final  double  alphaV0 =  flowConsBottlenecks . alphaV0  ( x ) ;   veh . calcAcceleration  ( dt , vehContainerLane , alphaT , alphaV0 ) ; } } }
>>>>>>>
 
<<<<<<<
=======
  public void updatePositionAndSpeed  (   int iterationCount ,   double dt ,   double time )  {  for ( VehicleContainer vehContainerLane : vehContainers )  {  for (  final Vehicle veh :  vehContainerLane . getVehicles  ( ) )  {   veh . updatePostionAndSpeed  ( dt ) ; } } }
>>>>>>>
    @ Override public void updateDetectors  (   int iterationCount ,   double dt ,   double simulationTime )  {   detectors . update  ( iterationCount , simulationTime , dt , vehContainers ) ; } }