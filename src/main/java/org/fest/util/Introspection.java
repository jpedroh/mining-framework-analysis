  package   org . fest . util ;   import static    java . lang . String . format ;  import static    org . fest . util . Strings .  * ;  import  java . beans .  * ;  import   java . lang . reflect .  * ;   public final class Introspection  {   public static PropertyDescriptor descriptorForProperty  (  String propertyName ,  Object target )  {   validate  ( propertyName , target ) ;  BeanInfo  beanInfo = null ;   Class  <  ? >  type =  target . getClass  ( ) ;  try  {   beanInfo =  Introspector . getBeanInfo  ( type ) ; }  catch (   Exception e )  {  throw  new IntrospectionError  (  format  ( "Unable to get BeanInfo for type %s" ,  type . getName  ( ) ) , e ) ; }  for ( PropertyDescriptor d :  beanInfo . getPropertyDescriptors  ( ) )  if  (  propertyName . equals  (  d . getName  ( ) ) )  return d ;  throw 
<<<<<<<
 new IntrospectionError  (  format  ( "Unable to find property %s in %s" ,  quote  ( propertyName ) ,  type . getName  ( ) ) )
=======
 buildIntrospectionErrorForMissingProperty  ( propertyName , target )
>>>>>>>
 ; }   private static void validate  (  String propertyName ,  Object target )  {  if  (  propertyName == null )  throw  new NullPointerException  ( "The property name should not be null" ) ;  if  (  isEmpty  ( propertyName ) )  throw  new IllegalArgumentException  ( "The property name should not be empty" ) ;  if  (  target == null )  throw  new NullPointerException  ( "The target object should not be null" ) ; }   private Introspection  ( )  { }   private static IntrospectionError buildIntrospectionErrorForMissingProperty  (  String propertyName ,  Object target )  {  if  (  !  fieldHasGetter  ( propertyName , target ) )  return  new IntrospectionError  (  concat  ( "No getter for property " ,  quote  ( propertyName ) , " in " ,   target . getClass  ( ) . getName  ( ) ) ) ;  if  (  !  fieldHasPublicGetter  ( propertyName , target ) )  return  new IntrospectionError  (  concat  ( "No public getter for property " ,  quote  ( propertyName ) , " in " ,   target . getClass  ( ) . getName  ( ) ) ) ;  return  new IntrospectionError  (  concat  ( "Unable to find property " ,  quote  ( propertyName ) , " in " ,   target . getClass  ( ) . getName  ( ) ) ) ; }   private static boolean fieldHasGetter  (  String propertyName ,  Object target )  {  if  (   beanGetter  ( propertyName , target ) != null )  return true ;  return false ; }   private static boolean fieldHasPublicGetter  (  String propertyName ,  Object target )  {  if  (  !  fieldHasGetter  ( propertyName , target ) )  return false ;  return  Modifier . isPublic  (   beanGetter  ( propertyName , target ) . getModifiers  ( ) ) ; }   private static Method beanGetter  (  String propertyName ,  Object target )  {   validate  ( propertyName , target ) ;  Method  getterMethod = null ;  String  propertyWithFirstLetterUppercased =    propertyName . substring  ( 0 , 1 ) . toUpperCase  ( ) +  propertyName . substring  ( 1 ) ;  try  {   getterMethod =   target . getClass  ( ) . getDeclaredMethod  (  "get" + propertyWithFirstLetterUppercased ) ;  if  (  getterMethod != null )  return getterMethod ; }  catch (   SecurityException e )  { }  catch (   NoSuchMethodException e )  { }  try  {   getterMethod =   target . getClass  ( ) . getDeclaredMethod  (  "is" + propertyWithFirstLetterUppercased ) ; }  catch (   SecurityException e )  {  return null ; }  catch (   NoSuchMethodException e )  {  return null ; }  return getterMethod ; } }