  package     org . apache . commons . net . util ;   import    java . util . regex . Pattern ;   public class SubnetUtils  {   private static final String  IPV4_ADDRESS = "(\\d{1,3}\\.){3}\\d{1,3}/\\d{1,2}" ;   private static final String  IPV6_ADDRESS = "([0-9a-f]{1,4}\\:){7}[0-9a-f]{1,4}/\\d{1,3}" ;   private final SubnetInfo  subnetInfo ;   public SubnetUtils  (  String cidrNotation )  {   subnetInfo =  getByCIDRNortation  ( cidrNotation ) ; }   public SubnetUtils  (  String address ,  String mask )  {   subnetInfo =  new IP4Subnet  ( address , mask ) ; }   public boolean isInclusiveHostCount  ( )  {  return  subnetInfo . isInclusiveHostCount  ( ) ; }   public void setInclusiveHostCount  (  boolean inclusiveHostCount )  {   subnetInfo . setInclusiveHostCount  ( inclusiveHostCount ) ; }   public static SubnetInfo getByCIDRNortation  (  String cidrNotation )  {  if  (  Pattern . matches  ( IPV4_ADDRESS , cidrNotation ) )  {  return  new IP4Subnet  ( cidrNotation ) ; } else  if  (  Pattern . matches  ( IPV6_ADDRESS , cidrNotation ) )  {  return  new IP6Subnet  ( cidrNotation ) ; } else  {  throw  new IllegalArgumentException  (   "Could not parse [" + cidrNotation + "]" ) ; } }   public static IP4Subnet getByMask  (  String address ,  String mask )  {  return  new IP4Subnet  ( address , mask ) ; }   public static class SubnetInfo  {   static  int rangeCheck  (   int value ,   int begin ,   int end )  {  if  (   value < begin ||  value > end )  {  throw  new IllegalArgumentException  (       "Value [" + value + "] not in range [" + begin + "," + end + "]" ) ; }  return value ; }   static  int pop  (   int x )  {   x =  x -  (   (  x >>> 1 ) & 0x55555555 ) ;   x =   (  x & 0x33333333 ) +  (   (  x >>> 2 ) & 0x33333333 ) ;   x =   (  x +  (  x >>> 4 ) ) & 0x0F0F0F0F ;   x =  x +  (  x >>> 8 ) ;   x =  x +  (  x >>> 16 ) ;  return  x & 0x3F ; }   static String format  (    int  [ ] arry ,  String symbol )  {  StringBuilder  str =  new StringBuilder  ( ) ;   final  int  iMax =   arry . length - 1 ;  for (   int  i = 0 ;  i <= iMax ;  i ++ )  {   str . append  (  arry [ i ] ) ;  if  (  i != iMax )  {   str . append  ( symbol ) ; } }  return  str . toString  ( ) ; }   public  int asInteger  (  String address )  {  return 0 ; }   public boolean isInclusiveHostCount  ( )  {  return false ; }   public void setInclusiveHostCount  (  boolean inclusiveHostCount )  { }   public boolean isInRange  (  String address )  {  return false ; }   public boolean isInRange  (   int address )  {  if  (  address == 0 )  {  return false ; }  return false ; }   public boolean isInRange  (    int  [ ] address )  {  return false ; }   public String getAddress  ( )  {  return null ; }   public  int getCIDR  ( )  {  return 0 ; }   public String getNetmask  ( )  {  return null ; }   public String getNetworkAddress  ( )  {  return null ; }   public String getBroadcastAddress  ( )  {  return null ; }   public String getCIDRNotation  ( )  {  return null ; }   public String getCidrSignature  ( )  {  return  getCIDRNotation  ( ) ; }   public String getLowAddress  ( )  {  return null ; }   public String getHighAddress  ( )  {  return null ; }    @ Deprecated public  int getAddressCount  ( )  {   long  countLong =  getAddressCountLong  ( ) ;  if  (  countLong >  Integer . MAX_VALUE )  {  throw  new RuntimeException  (  "Count is larger than an integer: " + countLong ) ; }  return  (  int ) countLong ; }   public  long getAddressCountLong  ( )  {  return 0 ; }   public String getAddressCountString  ( )  {  return null ; }   public  String  [ ] getAllAddresses  ( )  {  return  new String  [ 0 ] ; } }   public final SubnetInfo getInfo  ( )  {  return subnetInfo ; } }