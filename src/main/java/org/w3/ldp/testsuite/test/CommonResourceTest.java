  package     org . w3 . ldp . testsuite . test ;   import static    org . hamcrest . Matchers . containsString ;  import static    org . hamcrest . Matchers . not ;  import static    org . hamcrest . Matchers . notNullValue ;  import static    org . testng . Assert . assertEquals ;  import static    org . testng . Assert . assertTrue ;  import static       org . w3 . ldp . testsuite . matcher . HeaderMatchers . isValidEntityTag ;  import static       org . w3 . ldp . testsuite . matcher . HttpStatusSuccessMatcher . isSuccessful ;  import   java . io . IOException ;  import   java . net . URISyntaxException ;  import   java . util . HashSet ;  import   java . util . Map ;  import   java . util . Set ;  import     org . apache . commons . lang3 . StringUtils ;  import    org . apache . http . HttpStatus ;  import   org . testng . SkipException ;  import    org . testng . annotations . BeforeClass ;  import    org . testng . annotations . Optional ;  import    org . testng . annotations . Parameters ;  import    org . testng . annotations . Test ;  import     org . w3 . ldp . testsuite . LdpTestSuite ;  import      org . w3 . ldp . testsuite . annotations . SpecTest ;  import       org . w3 . ldp . testsuite . annotations . SpecTest . METHOD ;  import       org . w3 . ldp . testsuite . annotations . SpecTest . STATUS ;  import      org . w3 . ldp . testsuite . exception . SkipMethodNotAllowedException ;  import      org . w3 . ldp . testsuite . exception . SkipNotTestableException ;  import      org . w3 . ldp . testsuite . http . HttpMethod ;  import      org . w3 . ldp . testsuite . vocab . LDP ;  import     com . google . common . collect . ImmutableMap ;  import    com . jayway . restassured . RestAssured ;  import     com . jayway . restassured . response . Response ;  import     com . jayway . restassured . specification . RequestSpecification ;  import     com . jayway . restassured . specification . ResponseSpecification ;   public abstract class CommonResourceTest  extends LdpTest  {   private  Set  < String >  options =  new  HashSet  < String >  ( ) ;   protected  Map  < String , String >  auth ;   protected abstract String getResourceUri  ( ) ;    @ BeforeClass  (  alwaysRun = true ) public void determineOptions  ( )  {  String  uri =  getResourceUri  ( ) ;  if  (  StringUtils . isNotBlank  ( uri ) )  {  Response  optionsResponse =   buildBaseRequestSpecification  ( ) . options  ( uri ) ;  String  allow =  optionsResponse . header  ( ALLOW ) ;  if  (  allow != null )  {   String  [ ]  methods =  allow . split  ( "\\s*,\\s*" ) ;  for ( String method : methods )  {   options . add  ( method ) ; } } } }    @ Parameters  ( "auth" ) public CommonResourceTest  (    @ Optional String auth )  throws IOException  {  if  (   StringUtils . isNotBlank  ( auth ) &&  auth . contains  ( ":" ) )  {   String  [ ]  split =  auth . split  ( ":" ) ;  if  (     split . length == 2 &&  StringUtils . isNotBlank  (  split [ 0 ] ) &&  StringUtils . isNotBlank  (  split [ 1 ] ) )  {    this . auth =  ImmutableMap . of  ( "username" ,  split [ 0 ] , "password" ,  split [ 1 ] ) ; } } else  {    this . auth = null ; } }    @ Override protected RequestSpecification buildBaseRequestSpecification  ( )  {  if  (  auth == null )  {  return  RestAssured . given  ( ) ; } else  {  return     RestAssured . given  ( ) . auth  ( ) . preemptive  ( ) . basic  (  auth . get  ( "username" ) ,  auth . get  ( "password" ) ) ; } } 
<<<<<<<
   @ Test  (  groups =  { MUST } ,  description =  "LDP servers MUST at least be" + " HTTP/1.1 conformant servers [HTTP11]." )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-gen-http" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_EXTENSION ,  comment =  "testIsHttp11Server covers only part of the specification requirement. " + "testIsHttp11Manual covers the rest." ) public void testIsHttp11Server  ( )  {       buildBaseRequestSpecification  ( ) . expect  ( ) . statusLine  (  containsString  ( "HTTP/1.1" ) ) . when  ( ) . head  (  getResourceUri  ( ) ) ; }
=======
>>>>>>>
    @ Test  (  groups =  { MUST , MANUAL } ,  description =  "LDP servers MUST at least be" + " HTTP/1.1 conformant servers [HTTP11]." )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-gen-http" ,  testMethod =  METHOD . MANUAL ,  approval =  STATUS . WG_APPROVED ,  comment =  "testIsHttp11Manual covers only part of the specification requirement. " + "testIsHttp11Server covers the rest." ) public void testIsHttp11Manual  ( )  throws URISyntaxException  {  throw  new SkipNotTestableException  ( ) ; }    @ Test  (  groups =  { MUST } ,  description =   "LDP server responses MUST use entity tags " + "(either weak or strong ones) as response " + "ETag header values." )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-gen-etags" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_PENDING ,  comment =  "testETagHeadersGet covers only part of the specification requirement. " + "testETagHeadersHead covers the rest." ) public void testETagHeadersGet  ( )  {        buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . header  ( ETAG ,  isValidEntityTag  ( ) ) . when  ( ) . get  (  getResourceUri  ( ) ) ; }    @ Test  (  groups =  { MUST } ,  description =   "LDP server responses MUST use entity tags " + "(either weak or strong ones) as response " + "ETag header values." )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-gen-etags" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ,  comment =  "testETagHeadersHead covers only part of the specification requirement. " + "testETagHeadersGet covers the rest." ) public void testETagHeadersHead  ( )  {        buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . header  ( ETAG ,  isValidEntityTag  ( ) ) . when  ( ) . head  (  getResourceUri  ( ) ) ; }    @ Test  (  groups =  { MUST } ,  description =      "LDP servers exposing LDPRs MUST advertise " + "their LDP support by exposing a HTTP Link header " + "with a target URI of http://www.w3.org/ns/ldp#Resource, " + "and a link relation type of type (that is, rel='type') " + "in all responses to requests made to the LDPR's " + "HTTP Request-URI." )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-gen-linktypehdr" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ) public void testLdpLinkHeader  ( )  {  Response  response =      buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . when  ( ) . get  (  getResourceUri  ( ) ) ;   assertTrue  (  containsLinkHeader  (   LDP . Resource . stringValue  ( ) , LINK_REL_TYPE , response ) ,    "4.2.1.4 LDP servers exposing LDPRs must advertise their LDP support by exposing a HTTP Link header " + "with a target URI of http://www.w3.org/ns/ldp#Resource, and a link relation type of type (that is, " + "rel='type') in all responses to requests made to the LDPR's HTTP Request-URI. Actual: " +  response . getHeader  ( LINK ) ) ; }    @ Test  (  groups =  { MUST } ,  description = "LDP servers MUST support the HTTP GET Method for LDPRs" )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-get-must" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ) public void testGetResource  ( )  {   assertTrue  (  supports  (  HttpMethod . GET ) ,   "HTTP GET is not listed in the Allow response header on HTTP OPTIONS requests for resource <" +  getResourceUri  ( ) + ">" ) ;       buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . when  ( ) . get  (  getResourceUri  ( ) ) ; }    @ Test  (  groups =  { MUST } ,  description =  "LDP servers MUST support the HTTP response headers " + "defined in section 4.2.8 HTTP OPTIONS. " )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-get-options" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ) public void testGetResponseHeaders  ( )  {  ResponseSpecification  expectResponse =   buildBaseRequestSpecification  ( ) . expect  ( ) ;   expectResponse . header  ( ALLOW ,  notNullValue  ( ) ) ;  if  (  supports  (  HttpMethod . PATCH ) )  {   expectResponse . header  ( ACCEPT_PATCH ,  notNullValue  ( ) ) ; }  if  (  supports  (  HttpMethod . POST ) )  {   expectResponse . header  ( ACCEPT_POST ,  notNullValue  ( ) ) ; }    expectResponse . when  ( ) . get  (  getResourceUri  ( ) ) ; }    @ Test  (  groups =  { SHOULD } ,  description =    "LDP clients SHOULD use the HTTP If-Match header and HTTP ETags " + "to ensure it isnâ€™t modifying a resource that has changed since the " + "client last retrieved its representation. LDP servers SHOULD require " + "the HTTP If-Match header and HTTP ETags to detect collisions." )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-put-precond" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ,  comment =   "testPutRequiresIfMatch covers only part of the specification requirement. " + "testConditionFailedStatusCode, testPreconditionRequiredStatusCode " + "and testPutBadETag covers the rest." ) public void testPutRequiresIfMatch  ( )  throws URISyntaxException  {   skipIfMethodNotAllowed  (  HttpMethod . PUT ) ;  String  resourceUri =  getResourceUri  ( ) ;  Response  response =       buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . header  ( ETAG ,  isValidEntityTag  ( ) ) . when  ( ) . get  ( resourceUri ) ;         buildBaseRequestSpecification  ( ) . contentType  (  response . getContentType  ( ) ) . body  (  response . asByteArray  ( ) ) . expect  ( ) . statusCode  (  not  (  isSuccessful  ( ) ) ) . when  ( ) . put  ( resourceUri ) ; }    @ Test  (  groups =  { MUST } ,  description =       "LDP servers MUST respond with status code 412 " + "(Condition Failed) if ETags fail to match when there " + "are no other errors with the request [HTTP11]. LDP " + "servers that require conditional requests MUST respond " + "with status code 428 (Precondition Required) when the " + "absence of a precondition is the only reason for rejecting " + "the request [RFC6585]." )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-put-precond" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ,  comment =   "testConditionFailedStatusCode covers only part of the specification requirement. " + "testPutBadETag, testPreconditionRequiredStatusCode " + "and testPutRequiresIfMatch covers the rest." ) public void testConditionFailedStatusCode  ( )  {   skipIfMethodNotAllowed  (  HttpMethod . PUT ) ;  String  resourceUri =  getResourceUri  ( ) ;  Response  response =       buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . header  ( ETAG ,  isValidEntityTag  ( ) ) . when  ( ) . get  ( resourceUri ) ;  String  contentType =  response . getContentType  ( ) ;          buildBaseRequestSpecification  ( ) . contentType  ( contentType ) . header  ( IF_MATCH , "These aren't the ETags you're looking for." ) . body  (  response . asByteArray  ( ) ) . expect  ( ) . statusCode  (  HttpStatus . SC_PRECONDITION_FAILED ) . when  ( ) . put  ( resourceUri ) ; }    @ Test  (  groups =  { MUST } ,  description =       "LDP servers MUST respond with status code 412 " + "(Condition Failed) if ETags fail to match when there " + "are no other errors with the request [HTTP11]. LDP " + "servers that require conditional requests MUST respond " + "with status code 428 (Precondition Required) when the " + "absence of a precondition is the only reason for rejecting " + "the request [RFC6585]." )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-put-precond" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ,  comment =   "testPreconditionRequiredStatusCode covers only part of the specification requirement. " + "testConditionFailedStatusCode,  testPutBadETag" + "and testPutRequiresIfMatch covers the rest." ) public void testPreconditionRequiredStatusCode  ( )  {   skipIfMethodNotAllowed  (  HttpMethod . PUT ) ;  String  resourceUri =  getResourceUri  ( ) ;  Response  getResponse =       buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . header  ( ETAG ,  isValidEntityTag  ( ) ) . when  ( ) . get  ( resourceUri ) ;  Response  ifMatchResponse =       buildBaseRequestSpecification  ( ) . header  ( IF_MATCH ,  getResponse . getHeader  ( ETAG ) ) . contentType  (  getResponse . contentType  ( ) ) . body  (  getResponse . asByteArray  ( ) ) . when  ( ) . put  ( resourceUri ) ;  if  (  !   isSuccessful  ( ) . matches  (  ifMatchResponse . getStatusCode  ( ) ) )  {  throw  new SkipException  ( "Skipping test because PUT request failed with valid If-Match header." ) ; }  Response  noIfMatchResponse =      buildBaseRequestSpecification  ( ) . contentType  (  getResponse . contentType  ( ) ) . body  (  getResponse . asByteArray  ( ) ) . when  ( ) . put  ( resourceUri ) ;  if  (   isSuccessful  ( ) . matches  (  noIfMatchResponse . getStatusCode  ( ) ) )  {  throw  new SkipException  ( "Server does not require If-Match header." ) ; }   assertEquals  ( 428 ,  noIfMatchResponse . getStatusCode  ( ) , "Expected 428 Precondition Required error on PUT request with no If-Match header" ) ; }    @ Test  (  groups =  { MUST } ,  description =       "LDP servers MUST respond with status code 412 " + "(Condition Failed) if ETags fail to match when there " + "are no other errors with the request [HTTP11]. LDP " + "servers that require conditional requests MUST respond " + "with status code 428 (Precondition Required) when the " + "absence of a precondition is the only reason for rejecting " + "the request [RFC6585]." )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-put-precond" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ,  comment =   "testPutBadETag covers only part of the specification requirement. " + "testConditionFailedStatusCode, testPreconditionRequiredStatusCode " + "and testPutRequiresIfMatch covers the rest." ) public void testPutBadETag  ( )  {   skipIfMethodNotAllowed  (  HttpMethod . PUT ) ;  String  resourceUri =  getResourceUri  ( ) ;  Response  response =       buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . header  ( ETAG ,  isValidEntityTag  ( ) ) . when  ( ) . get  ( resourceUri ) ;          buildBaseRequestSpecification  ( ) . contentType  (  response . getContentType  ( ) ) . header  ( IF_MATCH , "\"This is not the ETag you're looking for\"" ) . body  (  response . asByteArray  ( ) ) . expect  ( ) . statusCode  (  HttpStatus . SC_PRECONDITION_FAILED ) . when  ( ) . put  ( resourceUri ) ; }    @ Test  (  groups =  { MUST } ,  description = "LDP servers MUST support the HTTP HEAD method. " )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-head-must" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ) public void testHead  ( )  {   assertTrue  (  supports  (  HttpMethod . HEAD ) ,   "HTTP HEAD is not listed in the Allow response header on HTTP OPTIONS requests for resource <" +  getResourceUri  ( ) + ">" ) ;       buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . when  ( ) . head  (  getResourceUri  ( ) ) ; }    @ Test  (  groups =  { MUST } ,  description =    "LDP servers that support PATCH MUST include an " + "Accept-Patch HTTP response header [RFC5789] on HTTP " + "OPTIONS requests, listing patch document media type(s) " + "supported by the server. " )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-patch-acceptpatch" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ) public void testAcceptPatchHeader  ( )  {  if  (  supports  (  HttpMethod . PATCH ) )  {        buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . header  ( ACCEPT_PATCH ,  notNullValue  ( ) ) . when  ( ) . options  (  getResourceUri  ( ) ) ; } }    @ Test  (  groups =  { MUST } ,  description = "LDP servers MUST support the HTTP OPTIONS method. " )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-options-must" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ) public void testOptions  ( )  {       buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . when  ( ) . options  (  getResourceUri  ( ) ) ; }    @ Test  (  groups =  { MUST } ,  description =   "LDP servers MUST indicate their support for HTTP Methods " + "by responding to a HTTP OPTIONS request on the LDPRâ€™s URL " + "with the HTTP Method tokens in the HTTP response header Allow. " )  @ SpecTest  (  specRefUri =   LdpTestSuite . SPEC_URI + "#ldpr-options-allow" ,  testMethod =  METHOD . AUTOMATED ,  approval =  STATUS . WG_APPROVED ) public void testOptionsAllowHeader  ( )  {        buildBaseRequestSpecification  ( ) . expect  ( ) . statusCode  (  isSuccessful  ( ) ) . header  ( ALLOW ,  notNullValue  ( ) ) . when  ( ) . options  (  getResourceUri  ( ) ) ; }   protected boolean supports  (  HttpMethod method )  {  return  options . contains  (  method . getName  ( ) ) ; }   protected void skipIfMethodNotAllowed  (  HttpMethod method )  {  if  (  !  supports  ( method ) )  {  throw  new SkipMethodNotAllowedException  (  getResourceUri  ( ) , method ) ; } } }