  package     de . uni_koblenz . jgralab . utilities . rsa ;   import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . DEFAULT_MAX_MULTIPLICITY ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . DEFAULT_MIN_MULTIPLICITY ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ANNOTATED_ELEMENT ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ASSOCIATION ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ASSOCIATION_CLASS ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_AGGREGATION ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_ASSOCIATION ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_CLASSIFIER ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_CLIENT ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_CONSTRAINED_ELEMENT ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_GENERAL ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_HREF ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_ISDERIVED ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_IS_ABSRACT ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_KEY ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_NAME ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_SUPPLIER ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_TYPE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ATTRIBUTE_VALUE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_BODY ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_CLASS ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_COMPOSITE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_DEFAULT_VALUE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_DETAILS ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ENUMERATION ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_ENUMERATION_LITERAL ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_E_ANNOTATIONS ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_GENERALIZATION ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_INSTANCE_VALUE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_LANGUAGE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_LITERAL_BOOLEAN ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_LITERAL_INTEGER ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_LITERAL_STRING ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_LOWER_VALUE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_MEMBER_END ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_MODEL ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_OPAQUE_EXPRESSION ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_OWNEDEND ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_OWNEDRULE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_OWNED_ATTRIBUTE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_OWNED_COMMENT ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_OWNED_LITERAL ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_PACKAGE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_PACKAGED_ELEMENT ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_PRIMITIVE_TYPE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_PROPERTY ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_REALIZATION ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_SHARED ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_SPECIFICATION ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_TRUE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . UML_UPPER_VALUE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . XMI_EXTENSION ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . XMI_NAMESPACE_PREFIX ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . XMI_TYPE ;  import static       de . uni_koblenz . jgralab . utilities . rsa . XMIConstants . XMI_XMI ;  import   java . io . File ;  import   java . io . IOException ;  import   java . util . ArrayList ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . LinkedList ;  import   java . util . List ;  import   java . util . Map ;  import    java . util . Map . Entry ;  import   java . util . Queue ;  import   java . util . Set ;  import   java . util . Stack ;  import   java . util . TreeSet ;  import    java . util . logging . Level ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import    javax . xml . stream . XMLStreamException ;  import    javax . xml . stream . XMLStreamReader ;  import     org . apache . commons . cli . CommandLine ;  import     org . apache . commons . cli . Option ;  import   org . pcollections . PVector ;  import      de . uni_koblenz . ist . utilities . option_handler . OptionHandler ;  import      de . uni_koblenz . ist . utilities . xml . XmlProcessor ;  import    de . uni_koblenz . jgralab . AttributedElement ;  import    de . uni_koblenz . jgralab . Edge ;  import    de . uni_koblenz . jgralab . EdgeDirection ;  import    de . uni_koblenz . jgralab . GraphIOException ;  import    de . uni_koblenz . jgralab . ImplementationType ;  import    de . uni_koblenz . jgralab . JGraLab ;  import    de . uni_koblenz . jgralab . Vertex ;  import     de . uni_koblenz . jgralab . graphmarker . BooleanGraphMarker ;  import     de . uni_koblenz . jgralab . graphmarker . GraphMarker ;  import     de . uni_koblenz . jgralab . graphvalidator . ConstraintViolation ;  import     de . uni_koblenz . jgralab . graphvalidator . GraphValidator ;  import      de . uni_koblenz . jgralab . greql2 . evaluator . GreqlEvaluatorImpl ;  import     de . uni_koblenz . jgralab . grumlschema . GrumlSchema ;  import     de . uni_koblenz . jgralab . grumlschema . SchemaGraph ;  import      de . uni_koblenz . jgralab . grumlschema . domains . CollectionDomain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . Domain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . EnumDomain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . HasRecordDomainComponent ;  import      de . uni_koblenz . jgralab . grumlschema . domains . MapDomain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . RecordDomain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . StringDomain ;  import      de . uni_koblenz . jgralab . grumlschema . structure . AggregationKind ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Annotates ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Attribute ;  import      de . uni_koblenz . jgralab . grumlschema . structure . AttributedElementClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . ComesFrom ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Comment ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Constraint ;  import      de . uni_koblenz . jgralab . grumlschema . structure . ContainsGraphElementClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . EdgeClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . EndsAt ;  import      de . uni_koblenz . jgralab . grumlschema . structure . GoesTo ;  import      de . uni_koblenz . jgralab . grumlschema . structure . GraphClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . GraphElementClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . HasAttribute ;  import      de . uni_koblenz . jgralab . grumlschema . structure . HasDomain ;  import      de . uni_koblenz . jgralab . grumlschema . structure . IncidenceClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . IncidenceDirection ;  import      de . uni_koblenz . jgralab . grumlschema . structure . NamedElement ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Package ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Redefines ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Schema ;  import      de . uni_koblenz . jgralab . grumlschema . structure . SpecializesEdgeClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Subsets ;  import      de . uni_koblenz . jgralab . grumlschema . structure . VertexClass ;  import      de . uni_koblenz . jgralab . utilities . tg2dot . Tg2Dot ;   public class Rsa2Tg  extends XmlProcessor  {   private static final String  OPTION_FILENAME_VALIDATION = "r" ;   private static final String  OPTION_FILENAME_SCHEMA_GRAPH = "s" ;   private static final String  OPTION_FILENAME_DOT = "e" ;   private static final String  OPTION_FILENAME_SCHEMA = "o" ;   private static final String  OPTION_USE_NAVIGABILITY = "n" ;   private static final String  OPTION_REMOVE_UNUSED_DOMAINS = "u" ;   private static final String  OPTION_KEEP_EMPTY_PACKAGES = "k" ;   private static final String  OPTION_USE_ROLE_NAME = "f" ;   private  Stack  < String >  xmiIdStack ;   private SchemaGraph  sg ;   private Schema  schema ;   private GraphClass  graphClass ;   private  Stack  < Package >  packageStack ;   private  Map  < String , Vertex >  idMap ;   private String  currentClassId ;   private AttributedElementClass  currentClass ;   private RecordDomain  currentRecordDomain ;   private HasRecordDomainComponent  currentRecordDomainComponent ;   private Attribute  currentAttribute ;   private  GraphMarker  <  Set  < String > >  generalizations ;   private  Map  < String ,  Set  < String > >  realizations ;   private  GraphMarker  < String >  attributeType ;   private  GraphMarker  < String >  recordComponentType ;   private  Map  < String , Domain >  domainMap ;   private  Set  < Vertex >  preliminaryVertices ;   private IncidenceClass  currentAssociationEnd ;   private  Set  < IncidenceClass >  ownedEnds ;   private boolean  inConstraint ;   private String  constrainedElementId ;   private  Map  < String ,  List  < String > >  constraints ;   private  Map  < String ,  List  < String > >  comments ;   private  GraphMarker  <  Set  < String > >  redefines ;   private boolean  useFromRole ;   private boolean  removeUnusedDomains ;   private boolean  keepEmptyPackages ;   private boolean  useNavigability ;   private boolean  suppressOutput ;   private String  filenameSchema ;   private String  filenameSchemaGraph ;   private String  filenameDot ;   private String  filenameValidation ;   private String  annotatedElementId ;   private boolean  inComment ;   private boolean  inOwnedAttribute ;   private GreqlEvaluatorImpl  edgeClassAcyclicEvaluator ;   private GreqlEvaluatorImpl  vertexClassAcyclicEvaluator ;   private boolean  inDefaultValue ;   private  int  modelRootElementNestingDepth ;   private  Set  < Package >  ignoredPackages ;   private boolean  inSpecification ;   public static void main  (   String  [ ] args )  throws IOException  {    System . out . println  ( "RSA to TG" ) ;    System . out . println  ( "=========" ) ;   JGraLab . setLogLevel  (  Level . OFF ) ;  CommandLine  cli =  processCommandLineOptions  ( args ) ;  assert  cli != null : "No CommandLine object has been generated!" ;  File  input =  new File  (  cli . getOptionValue  ( 'i' ) ) ;  Rsa2Tg  r =  new Rsa2Tg  ( ) ;   r . setUseFromRole  (  cli . hasOption  ( OPTION_USE_ROLE_NAME ) ) ;   r . setRemoveUnusedDomains  (  cli . hasOption  ( OPTION_REMOVE_UNUSED_DOMAINS ) ) ;   r . setKeepEmptyPackages  (  cli . hasOption  ( OPTION_KEEP_EMPTY_PACKAGES ) ) ;   r . setUseNavigability  (  cli . hasOption  ( OPTION_USE_NAVIGABILITY ) ) ;   r . setFilenameSchema  (  cli . getOptionValue  ( OPTION_FILENAME_SCHEMA ) ) ;   r . setFilenameSchemaGraph  (  cli . getOptionValue  ( OPTION_FILENAME_SCHEMA_GRAPH ) ) ;   r . setFilenameDot  (  cli . getOptionValue  ( OPTION_FILENAME_DOT ) ) ;   r . setFilenameValidation  (  cli . getOptionValue  ( OPTION_FILENAME_VALIDATION ) ) ;  boolean  noOutputOptionSelected =     !  cli . hasOption  ( OPTION_FILENAME_SCHEMA ) &&  !  cli . hasOption  ( OPTION_FILENAME_SCHEMA_GRAPH ) &&  !  cli . hasOption  ( OPTION_FILENAME_DOT ) &&  !  cli . hasOption  ( OPTION_FILENAME_VALIDATION ) ;  if  ( noOutputOptionSelected )  {    System . out . println  (  "No output option has been selected. " + "A TG-file for the Schema will be written." ) ;   r . setFilenameSchema  (  createFilename  ( input ) ) ; }  try  {    System . out . println  (   "processing: " +  input . getPath  ( ) + "\n" ) ;   r . process  (  input . getPath  ( ) ) ; }  catch (   Exception e )  {    System . err . println  (   "An Exception occured while processing " + input + "." ) ;    System . err . println  (  e . getMessage  ( ) ) ;   e . printStackTrace  ( ) ; }    System . out . println  ( "Fini." ) ; }   public static CommandLine processCommandLineOptions  (   String  [ ] args )  {  String  toolString =  "java " +   Rsa2Tg . class . getName  ( ) ;  String  versionString =  JGraLab . getInfo  ( false ) ;  OptionHandler  oh =  new OptionHandler  ( toolString , versionString ) ;  Option  validate =  new Option  ( OPTION_FILENAME_VALIDATION , "report" , true ,  "(optional): writes a validation report to the given filename. " + "Free naming, but should look like this: '<filename>.html'" ) ;   validate . setRequired  ( false ) ;   validate . setArgName  ( "filename" ) ;   oh . addOption  ( validate ) ;  Option  export =  new Option  ( OPTION_FILENAME_DOT , "export" , true ,  "(optional): writes a GraphViz DOT file to the given filename. " + "Free naming, but should look like this: '<filename>.dot'" ) ;   export . setRequired  ( false ) ;   export . setArgName  ( "filename" ) ;   oh . addOption  ( export ) ;  Option  schemaGraph =  new Option  ( OPTION_FILENAME_SCHEMA_GRAPH , "schemaGraph" , true ,  "(optional): writes a TG-file of the Schema as graph instance to the given filename. " + "Free naming, but should look like this:  '<filename>.tg'" ) ;   schemaGraph . setRequired  ( false ) ;   schemaGraph . setArgName  ( "filename" ) ;   oh . addOption  ( schemaGraph ) ;  Option  input =  new Option  ( "i" , "input" , true , "(required): UML 2.1-XMI exchange model file of the Schema." ) ;   input . setRequired  ( true ) ;   input . setArgName  ( "filename" ) ;   oh . addOption  ( input ) ;  Option  output =  new Option  ( OPTION_FILENAME_SCHEMA , "output" , true ,  "(optional): writes a TG-file of the Schema to the given filename. " + "Free naming, but should look like this: '<filename>.rsa.tg.'" ) ;   output . setRequired  ( false ) ;   output . setArgName  ( "filename" ) ;   oh . addOption  ( output ) ;  Option  fromRole =  new Option  ( OPTION_USE_ROLE_NAME , "useFromRole" , false , "(optional): if this flag is set, the name of from roles will be used for creating undefined EdgeClass names." ) ;   fromRole . setRequired  ( false ) ;   oh . addOption  ( fromRole ) ;  Option  unusedDomains =  new Option  ( OPTION_REMOVE_UNUSED_DOMAINS , "removeUnusedDomains" , false , "(optional): if this flag is set, all unused domains be deleted." ) ;   unusedDomains . setRequired  ( false ) ;   oh . addOption  ( unusedDomains ) ;  Option  emptyPackages =  new Option  ( OPTION_KEEP_EMPTY_PACKAGES , "keepEmptyPackages" , false , "(optional): if this flag is set, empty packages will be retained." ) ;   unusedDomains . setRequired  ( false ) ;   oh . addOption  ( emptyPackages ) ;  Option  navigability =  new Option  ( OPTION_USE_NAVIGABILITY , "useNavigability" , false , "(optional): if this flag is set, navigability information will be interpreted as reading direction." ) ;   navigability . setRequired  ( false ) ;   oh . addOption  ( navigability ) ;  return  oh . parse  ( args ) ; }   public static String createFilename  (  File file )  {  StringBuilder  filenameBuilder =  new StringBuilder  ( ) ;   filenameBuilder . append  (  file . getParent  ( ) ) ;   filenameBuilder . append  (  File . separatorChar ) ;  String  filename =  file . getName  ( ) ;   int  periodePosition =  filename . lastIndexOf  ( '.' ) ;  if  (  periodePosition !=  - 1 )  {   filename =  filename . substring  ( 0 , periodePosition ) ; }   filenameBuilder . append  ( filename ) ;   filenameBuilder . append  ( ".rsa.tg" ) ;  return  filenameBuilder . toString  ( ) ; }   public Rsa2Tg  ( )  {   addIgnoredElements  ( "profileApplication" , "packageImport" , "Ecore:EReference" ) ; }    @ Override public void startDocument  ( )  {   sg =   GrumlSchema . instance  ( ) . createSchemaGraph  (  ImplementationType . STANDARD ) ;   xmiIdStack =  new  Stack  < String >  ( ) ;   idMap =  new  HashMap  < String , Vertex >  ( ) ;   packageStack =  new  Stack  < Package >  ( ) ;   generalizations =  new  GraphMarker  <  Set  < String > >  ( sg ) ;   realizations =  new  HashMap  < String ,  Set  < String > >  ( ) ;   attributeType =  new  GraphMarker  < String >  ( sg ) ;   recordComponentType =  new  GraphMarker  < String >  ( sg ) ;   domainMap =  new  HashMap  < String , Domain >  ( ) ;   preliminaryVertices =  new  HashSet  < Vertex >  ( ) ;   ownedEnds =  new  HashSet  < IncidenceClass >  ( ) ;   constraints =  new  HashMap  < String ,  List  < String > >  ( ) ;   comments =  new  HashMap  < String ,  List  < String > >  ( ) ;   redefines =  new  GraphMarker  <  Set  < String > >  ( sg ) ;   ignoredPackages =  new  HashSet  < Package >  ( ) ;   modelRootElementNestingDepth = 1 ; }    @ Override protected void startElement  (  String name )  throws XMLStreamException  {  if  (   (   getNestingDepth  ( ) == 1 ) &&  name . equals  ( XMI_XMI ) )  {   modelRootElementNestingDepth = 2 ;  return ; }  String  xmiId =  getAttribute  ( XMI_NAMESPACE_PREFIX , "id" ) ;   xmiIdStack . push  ( xmiId ) ;  Vertex  vertexId = null ;  if  (   getNestingDepth  ( ) == modelRootElementNestingDepth )  {   vertexId =  createDefaultElements  ( name ) ; } else  {   vertexId =  processXMIElements  ( name , xmiId ) ; }  if  (   (  xmiId != null ) &&  (  vertexId != null ) )  {   idMap . put  ( xmiId , vertexId ) ; } }   private Vertex createDefaultElements  (  String name )  throws XMLStreamException  {  if  (   name . equals  ( UML_MODEL ) ||  name . equals  ( UML_PACKAGE ) )  {   setSchemaQualifiedName  ( ) ;   createGraphClass  ( ) ;   createDefaultPackage  ( ) ; } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,      "Root element must be " + UML_MODEL + " or " + UML_PACKAGE + ", buf was " + name ) ; }  return schema ; }   private void setSchemaQualifiedName  ( )  throws XMLStreamException  {  String  nm =  getAttribute  ( UML_ATTRIBUTE_NAME ) ;   int  p =  nm . lastIndexOf  ( '.' ) ;   schema =  sg . createSchema  ( ) ;  if  (  p ==  - 1 )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  "A Schema must have a package prefix!\nProcessed qualified name: " + nm ) ; }   schema . set_packagePrefix  (  nm . substring  ( 0 , p ) ) ;   schema . set_name  (  nm . substring  (  p + 1 ) ) ; }   private void createGraphClass  ( )  {   graphClass =  sg . createGraphClass  ( ) ;   sg . createDefinesGraphClass  ( schema , graphClass ) ; }   private void createDefaultPackage  ( )  {  Package  defaultPackage =  sg . createPackage  ( ) ;   defaultPackage . set_qualifiedName  ( "" ) ;   sg . createContainsDefaultPackage  ( schema , defaultPackage ) ;   packageStack . push  ( defaultPackage ) ; }   private Vertex processXMIElements  (  String name ,  String xmiId )  throws XMLStreamException  {  String  type =  getAttribute  ( XMI_NAMESPACE_PREFIX , UML_ATTRIBUTE_TYPE ) ;  Vertex  vertexId = null ;  if  (  name . equals  ( UML_PACKAGED_ELEMENT ) )  {  if  (  type . equals  ( UML_PACKAGE ) )  {   vertexId =  handlePackage  ( ) ; } else  if  (  type . equals  ( UML_CLASS ) )  {   vertexId =  handleClass  ( xmiId ) ; } else  if  (   type . equals  ( UML_ASSOCIATION ) ||  type . equals  ( UML_ASSOCIATION_CLASS ) )  {   vertexId =  handleAssociation  ( xmiId ) ; } else  if  (  type . equals  ( UML_ENUMERATION ) )  {   vertexId =  handleEnumeration  ( ) ; } else  if  (  type . equals  ( UML_PRIMITIVE_TYPE ) )  {   vertexId =  handlePrimitiveType  ( xmiId ) ; } else  if  (  type . equals  ( UML_REALIZATION ) )  {   handleRealization  ( ) ; } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  createUnexpectedElementMessage  ( name , type ) ) ; } } else  if  (  name . equals  ( UML_OWNEDRULE ) )  {   inConstraint = true ;   constrainedElementId =  getAttribute  ( UML_ATTRIBUTE_CONSTRAINED_ELEMENT ) ;  if  (  constrainedElementId != null )  {   int  p =  constrainedElementId . indexOf  ( ' ' ) ;  if  (  p >= 0 )  {   constrainedElementId = null ; } } } else  if  (  name . equals  ( UML_BODY ) )  {  if  (     ! inConstraint &&  ! inComment &&  ! inDefaultValue &&  ! inSpecification )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  createUnexpectedElementMessage  ( name , null ) ) ; } } else  if  (  name . equals  ( UML_SPECIFICATION ) )  {   inSpecification = true ; } else  if  (  name . equals  ( UML_LANGUAGE ) )  {  if  (  ! inConstraint )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  createUnexpectedElementMessage  ( name , null ) ) ; } } else  if  (  name . equals  ( UML_OWNEDEND ) )  {  if  (   type . equals  ( UML_PROPERTY ) &&  (  currentClass instanceof EdgeClass ) )  {   handleAssociationEnd  ( xmiId ) ; } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  createUnexpectedElementMessage  ( name , type ) ) ; } } else  if  (  name . equals  ( UML_OWNED_ATTRIBUTE ) )  {   inOwnedAttribute = true ;  if  (  type . equals  ( UML_PROPERTY ) )  {   handleOwnedAttribute  ( xmiId ) ; } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  createUnexpectedElementMessage  ( name , type ) ) ; } } else  if  (  name . equals  ( UML_ATTRIBUTE_TYPE ) )  {  if  (  ! inDefaultValue )  {  if  (  type . equals  ( UML_PRIMITIVE_TYPE ) )  {   handleNestedTypeElement  ( xmiId ) ; } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  createUnexpectedElementMessage  ( name , type ) ) ; } } } else  if  (  name . equals  ( UML_OWNED_LITERAL ) )  {  if  (  type . equals  ( UML_ENUMERATION_LITERAL ) )  {   handleEnumerationLiteral  ( ) ; } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  createUnexpectedElementMessage  ( name , type ) ) ; } } else  if  (  name . equals  ( XMI_EXTENSION ) )  { } else  if  (  name . equals  ( UML_E_ANNOTATIONS ) )  { } else  if  (  name . equals  ( UML_GENERALIZATION ) )  {   handleGeneralization  ( ) ; } else  if  (  name . equals  ( UML_DETAILS ) )  {   handleStereotype  ( ) ; } else  if  (  name . equals  ( UML_LOWER_VALUE ) )  {   handleLowerValue  ( ) ; } else  if  (  name . equals  ( UML_UPPER_VALUE ) )  {   handleUpperValue  ( ) ; } else  if  (  name . equals  ( UML_OWNED_COMMENT ) )  {   annotatedElementId =  getAttribute  ( UML_ANNOTATED_ELEMENT ) ;   inComment = true ; } else  if  (  name . equals  ( UML_DEFAULT_VALUE ) )  {  String  xmiType =  getAttribute  ( XMI_NAMESPACE_PREFIX , XMI_TYPE ) ;  if  (  isPrimitiveDefaultValue  ( xmiType ) )  {   handlePrimitiveDefaultValue  ( xmiId , xmiType ) ; } else  if  (  !  xmiType . equals  ( UML_OPAQUE_EXPRESSION ) )  {    System . out . println  (            "Warning: Unexpected default value type '" + xmiType + "' for attribute '" +  currentAttribute . get_name  ( ) + "' of " +   currentClass . getSchemaClass  ( ) . getSimpleName  ( ) + " '" +  currentClass . get_qualifiedName  ( ) + "' in file '" +  getFileName  ( ) + "' at line " +    getParser  ( ) . getLocation  ( ) . getLineNumber  ( ) ) ; }   inDefaultValue = true ; } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  createUnexpectedElementMessage  ( name , type ) ) ; }  return vertexId ; }   private boolean isPrimitiveDefaultValue  (  String xmiType )  {  return     xmiType . equals  ( UML_LITERAL_STRING ) ||  xmiType . equals  ( UML_LITERAL_INTEGER ) ||  xmiType . equals  ( UML_LITERAL_BOOLEAN ) ||  xmiType . equals  ( UML_INSTANCE_VALUE ) ; }   private void handlePrimitiveDefaultValue  (  String xmiId ,  String xmiType )  throws XMLStreamException  {  if  (  xmiType . equals  ( UML_INSTANCE_VALUE ) )  {  String  value =  getAttribute  ( UML_ATTRIBUTE_NAME ) ;   handleDefaultValue  ( xmiId , value ) ;  return ; }  String  value =  getAttribute  ( UML_ATTRIBUTE_VALUE ) ;  if  (  xmiType . equals  ( UML_LITERAL_BOOLEAN ) )  {  if  (  value == null )  {   value = "f" ; } else  {  assert   value . equals  ( "true" ) ||  value . equals  ( "false" ) ;   value =  value . substring  ( 0 , 1 ) ; }   handleDefaultValue  ( xmiId , value ) ;  return ; } else  if  (  xmiType . equals  ( UML_LITERAL_INTEGER ) )  {  if  (  value == null )  {   value = "0" ; }   handleDefaultValue  ( xmiId , value ) ;  return ; }  if  (  value == null )  {    System . out . println  (          "Warning: Undefined default value for attribute '" +  currentAttribute . get_name  ( ) + "' of " +   currentClass . getSchemaClass  ( ) . getSimpleName  ( ) + " '" +  currentClass . get_qualifiedName  ( ) + "' in file '" +  getFileName  ( ) + "' at line " +    getParser  ( ) . getLocation  ( ) . getLineNumber  ( ) ) ;  return ; }  if  (  xmiType . equals  ( UML_LITERAL_STRING ) )  {   value =   "\"" + value + "\"" ;   handleDefaultValue  ( xmiId , value ) ; } else  {    System . out . println  (            "Warning: Undefined default value type '" + xmiType + "' for attribute '" +  currentAttribute . get_name  ( ) + "' of " +   currentClass . getSchemaClass  ( ) . getSimpleName  ( ) + " '" +  currentClass . get_qualifiedName  ( ) + "' in file '" +  getFileName  ( ) + "' at line " +    getParser  ( ) . getLocation  ( ) . getLineNumber  ( ) ) ; } }   private void handleDefaultValue  (  String xmiId ,  String value )  {  if  (  currentAttribute == null )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "Found a <defaultValue> tag (XMI id " + xmiId + ") outside an attribute definition (e.g. in a <<record>> class)" ) ; }   currentAttribute . set_defaultValue  ( value ) ; }    @ Override protected void endElement  (  String name ,  StringBuilder content )  throws XMLStreamException  {  if  (   getNestingDepth  ( ) < modelRootElementNestingDepth )  {  return ; }  String  xmiId =  xmiIdStack . pop  ( ) ;  if  (  name . equals  ( UML_BODY ) )  {  if  ( inConstraint )  {  assert   ! inComment &&  ! inDefaultValue ;   handleConstraint  (    content . toString  ( ) . trim  ( ) . replace  ( "\\s+" , " " ) ) ; } else  if  ( inComment )  {  assert  ! inDefaultValue ;   handleComment  (  content . toString  ( ) ) ; } else  if  ( inDefaultValue )  {   handleDefaultValue  ( xmiId ,   content . toString  ( ) . trim  ( ) ) ; } }   AttributedElement  <  ? ,  ? >  elem =  idMap . get  ( xmiId ) ;  if  (  elem != null )  {  if  (  elem instanceof Package )  {  if  (   packageStack . size  ( ) <= 1 )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) , "XMI file is malformed. There is probably one end element to much." ) ; }   packageStack . pop  ( ) ; } else  if  (  elem instanceof AttributedElementClass )  {   currentClassId = null ;   currentClass = null ;   currentAttribute = null ; } else  if  (  elem instanceof RecordDomain )  {   currentRecordDomain = null ;   currentAttribute = null ; } else  if  (  elem instanceof Attribute )  {   currentAttribute = null ; } }  if  (  name . equals  ( UML_PACKAGE ) )  {   packageStack . pop  ( ) ;  if  (   packageStack . size  ( ) != 0 )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) , "XMI file is malformed. There is probably one end element to much." ) ; } } else  if  (  name . equals  ( UML_OWNED_ATTRIBUTE ) )  {   currentRecordDomainComponent = null ;  if  (  currentAssociationEnd != null )  {   checkMultiplicities  ( currentAssociationEnd ) ;   currentAssociationEnd = null ; }   inOwnedAttribute = false ; } else  if  (  name . equals  ( UML_OWNEDEND ) )  {   checkMultiplicities  ( currentAssociationEnd ) ;   currentAssociationEnd = null ; } else  if  (  name . equals  ( UML_OWNEDRULE ) )  {   inConstraint = false ;   constrainedElementId = null ; } else  if  (  name . equals  ( UML_OWNED_COMMENT ) )  {   inComment = false ;   annotatedElementId = null ; } else  if  (  name . equals  ( UML_DEFAULT_VALUE ) )  {   inDefaultValue = false ; } else  if  (  name . equals  ( UML_SPECIFICATION ) )  {   inSpecification = false ; } }   private void checkMultiplicities  (  IncidenceClass inc )  {   int  min =  inc . get_min  ( ) ;   int  max =  inc . get_max  ( ) ;  assert  min >= 0 ;  assert  max > 0 ;  if  (  min ==  Integer . MAX_VALUE )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "Error in multiplicities: lower bound must not be *" + " at association end " + inc ) ; }  if  (  min > max )  {  throw  new ProcessingException  (  getFileName  ( ) ,      "Error in multiplicities: lower bound (" + min + ") must be <= upper bound (" + max + ") at association end " + inc ) ; } }   private void handleComment  (  String body )  {   body =  body . replaceAll  ( "\\s+" , " " ) ;   body =  body . replace  ( "<p>" , " " ) ;   body =  body . replace  ( "</p>" , "\n" ) ;   String  [ ]  lines =  body . split  ( "\n" ) ;  StringBuilder  text =  new StringBuilder  ( ) ;  for ( String line : lines )  {   line =   line . replaceAll  ( "\\s+" , " " ) . trim  ( ) ;  if  (   line . length  ( ) > 0 )  {  if  (   text . length  ( ) > 0 )  {   text . append  ( "\n" ) ; }   text . append  ( line ) ; } }  if  (   text . length  ( ) == 0 )  {  return ; }   List  < String >  commentList =  comments . get  ( annotatedElementId ) ;  if  (  commentList == null )  {   commentList =  new  LinkedList  < String >  ( ) ;   comments . put  ( annotatedElementId , commentList ) ; }   commentList . add  (  text . toString  ( ) ) ; }    @ Override public void endDocument  ( )  throws XMLStreamException  {  assert  schema != null ;  assert  graphClass != null ;  if  (   graphClass . get_qualifiedName  ( ) == null )  {  throw  new ProcessingException  (  getFileName  ( ) ,     "No <<graphclass>> defined in schema '" +  schema . get_packagePrefix  ( ) + "." +  schema . get_name  ( ) + "'" ) ; }   checkEnumDomains  ( ) ;   linkGeneralizations  ( ) ;   linkRecordDomainComponents  ( ) ;   linkAttributeDomains  ( ) ;   removeIgnoredPackages  ( ) ;  if  (  isUseNavigability  ( ) )  {   correctEdgeDirection  ( ) ; }   attachConstraints  ( ) ;   createSubsetsAndRedefinesRelations  ( ) ;   createEdgeClassNames  ( ) ;  if  (  isRemoveUnusedDomains  ( ) )  {   removeUnusedDomains  ( ) ; }   attachComments  ( ) ;  if  (  !  isKeepEmptyPackages  ( ) )  {   removeEmptyPackages  ( ) ; }  if  (  !  preliminaryVertices . isEmpty  ( ) )  {    System . err . println  (   "Remaining preliminary vertices (" +  preliminaryVertices . size  ( ) + "):" ) ;  for ( Vertex v : preliminaryVertices )  {    System . err . println  (  attributedElement2String  ( v ) ) ; }  throw  new ProcessingException  (  getFileName  ( ) , "There are still vertices left over. " ) ; }  if  (  ! suppressOutput )  {  try  {   writeOutput  ( ) ; }  catch (   GraphIOException e )  {  throw  new XMLStreamException  ( e ) ; } } }   private void removeIgnoredPackages  ( )  {    System . out . println  ( "Removing ignored packages..." ) ;   int  n = 0 ;  for ( Package pkg : ignoredPackages )  {   n +=  removePackage  ( pkg ) ; }    System . out . println  (     "\tRemoved " + n + " package" +  (   n == 1 ? "" : "s" ) + "." ) ; }   private  int removePackage  (  Package pkg )  {  if  (  !  pkg . isValid  ( ) )  {  return 0 ; }   int  n = 0 ;   List  < Package >  subPackages =  new  ArrayList  < Package >  ( ) ;  for ( Package sub :  pkg . get_subpackage  ( ) )  {   subPackages . add  ( sub ) ; }  for ( Package sub : subPackages )  {   n +=  removePackage  ( sub ) ; }  for (  ContainsGraphElementClass  c =  pkg . getFirstContainsGraphElementClassIncidence  (  EdgeDirection . OUT ) ;  c != null ;  c =  pkg . getFirstContainsGraphElementClassIncidence  (  EdgeDirection . OUT ) )  {  GraphElementClass  gec =  ( GraphElementClass )  c . getThat  ( ) ;  if  (  gec instanceof EdgeClass )  {  EdgeClass  ec =  ( EdgeClass ) gec ;    ec . get_to  ( ) . delete  ( ) ;    ec . get_from  ( ) . delete  ( ) ; } else  if  (  gec instanceof VertexClass )  {  VertexClass  vc =  ( VertexClass ) gec ;  for (  EndsAt  e =  vc . getFirstEndsAtIncidence  (  EdgeDirection . IN ) ;  e != null ;  e =  vc . getFirstEndsAtIncidence  (  EdgeDirection . IN ) )  {  EdgeClass  ec ;  ComesFrom  cf =   (  ( IncidenceClass )  e . getThat  ( ) ) . getFirstComesFromIncidence  ( ) ;  if  (  cf == null )  {  GoesTo  gt =   (  ( IncidenceClass )  e . getThat  ( ) ) . getFirstGoesToIncidence  ( ) ;   ec =  ( EdgeClass )  gt . getThat  ( ) ; } else  {   ec =  ( EdgeClass )  cf . getThat  ( ) ; }    ec . get_to  ( ) . delete  ( ) ;    ec . get_from  ( ) . delete  ( ) ;   removeAttributes  ( ec ) ;   ec . delete  ( ) ; } }   removeAttributes  ( gec ) ;   gec . delete  ( ) ; }  if  (   pkg . getDegree  ( ) == 1 )  {   ++ n ;    System . out . println  (  "\t- removing " +  pkg . get_qualifiedName  ( ) ) ;   pkg . delete  ( ) ; }  return n ; }   private void removeAttributes  (  AttributedElementClass aec )  {  for (  HasAttribute  ha =  aec . getFirstHasAttributeIncidence  (  EdgeDirection . OUT ) ;  ha != null ;  ha =  aec . getFirstHasAttributeIncidence  (  EdgeDirection . OUT ) )  {    ha . getThat  ( ) . delete  ( ) ; } }   private void checkEnumDomains  ( )  {    System . out . println  ( "Checking enumeration domains..." ) ;   ArrayList  < String >  faultyDomains =  new  ArrayList  < String >  ( ) ;  for ( EnumDomain ed :  sg . getEnumDomainVertices  ( ) )  {  if  (    ed . get_enumConstants  ( ) . size  ( ) < 1 )  {   faultyDomains . add  (  ed . get_qualifiedName  ( ) ) ; } }  if  (   faultyDomains . size  ( ) > 0 )  {  StringBuilder  sb =  new StringBuilder  ( ) ;     sb . append  ( "The following enumeration domain" ) . append  (    faultyDomains . size  ( ) == 1 ? " has" : "s have" ) . append  ( " no literals" ) ;  String  delim = ": " ;  for ( String name : faultyDomains )  {    sb . append  ( delim ) . append  ( name ) ;   delim = ", " ; }  throw  new ProcessingException  (  getFileName  ( ) ,  sb . toString  ( ) ) ; } }   private void attachComments  ( )  {    System . out . println  ( "Attaching comments to annotated elements..." ) ;  for ( String id :  comments . keySet  ( ) )  {  NamedElement  annotatedElement = null ;  if  (  domainMap . containsKey  ( id ) )  {   annotatedElement =  domainMap . get  ( id ) ; } else  if  (  idMap . containsKey  ( id ) )  {  Vertex  v =  idMap . get  ( id ) ;   annotatedElement =  ( NamedElement ) v ; }  if  (  annotatedElement == null )  {    System . out . println  (     "\t- Couldn't find annotated element for XMI id " + id + "\n\t  => attaching to GraphClass (Comment starts with '" +   comments . get  ( id ) . get  ( 0 ) + "'" ) ;   annotatedElement = graphClass ; }  assert  annotatedElement != null ;  if  (  annotatedElement . isValid  ( ) )  {   List  < String >  lines =  comments . get  ( id ) ;  for ( String line : lines )  {  Comment  c =  sg . createComment  ( ) ;   c . set_text  ( line ) ;   sg . createAnnotates  ( c , annotatedElement ) ; } } } }   private void createSubsetsAndRedefinesRelations  ( )  {    System . out . println  ( "Creating subsets and redefines relationships..." ) ;  SpecializesEdgeClass  spec =  sg . getFirstSpecializesEdgeClass  ( ) ;  while  (  spec != null )  {  EdgeClass  subClass =  spec . getAlpha  ( ) ;  EdgeClass  superClass =  spec . getOmega  ( ) ;  assert   subClass . getFirstComesFromIncidence  ( ) != null ;  assert   superClass . getFirstComesFromIncidence  ( ) != null ;   createSubsetsForIncidences  ( subClass , superClass ,  ( IncidenceClass )   subClass . getFirstComesFromIncidence  ( ) . getThat  ( ) ,  ( IncidenceClass )   superClass . getFirstComesFromIncidence  ( ) . getThat  ( ) ) ;  assert   subClass . getFirstGoesToIncidence  ( ) != null ;  assert   superClass . getFirstGoesToIncidence  ( ) != null ;   createSubsetsForIncidences  ( subClass , superClass ,  ( IncidenceClass )   subClass . getFirstGoesToIncidence  ( ) . getThat  ( ) ,  ( IncidenceClass )   superClass . getFirstGoesToIncidence  ( ) . getThat  ( ) ) ;   spec =  spec . getNextSpecializesEdgeClassInGraph  ( ) ; }  for (  AttributedElement  <  ? ,  ? > ae :  redefines . getMarkedElements  ( ) )  {  IncidenceClass  inc =  ( IncidenceClass ) ae ;   Set  < String >  redefinedRolenames =  redefines . getMark  ( inc ) ;  for ( String rolename : redefinedRolenames )  {  IncidenceClass  sup = null ;   Queue  < IncidenceClass >  q =  new  LinkedList  < IncidenceClass >  ( ) ;  BooleanGraphMarker  m =  new BooleanGraphMarker  ( sg ) ;   m . mark  ( inc ) ;   q . offer  ( inc ) ;  while  (  !  q . isEmpty  ( ) )  {  IncidenceClass  curr =  q . poll  ( ) ;   m . mark  ( curr ) ;  if  (   (  curr != inc ) &&  rolename . equals  (  curr . get_roleName  ( ) ) )  {   sup = curr ;  break ; }  for ( Subsets si :  curr . getSubsetsIncidences  (  EdgeDirection . OUT ) )  {  IncidenceClass  i =  si . getOmega  ( ) ;  if  (  !  m . isMarked  ( i ) )  {   m . mark  ( i ) ;   q . offer  ( i ) ; } } }  if  (  sup == null )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "Redefined rolename '" + rolename + "' not found" ) ; } else  {  for ( Subsets si :  inc . getSubsetsIncidences  (  EdgeDirection . OUT ) )  {  IncidenceClass  i =  si . getOmega  ( ) ;  if  (  i == sup )  {  assert  !  (  si instanceof Redefines ) ;   si . delete  ( ) ;  break ; } }   sg . createRedefines  ( inc , sup ) ; } } } }   private void createSubsetsForIncidences  (  EdgeClass subClass ,  EdgeClass superClass ,  IncidenceClass subInc ,  IncidenceClass superInc )  {  assert   getDirection  ( subInc ) != null ;  assert   getDirection  ( superInc ) != null ;  if  (   getDirection  ( subInc ) !=  getDirection  ( superInc ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,    "Incompatible incidence direction in specialisation " + subClass + " --> " + superClass ) ; }  if  (   subInc . get_max  ( ) >  superInc . get_max  ( ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,        "Subclass has higher upper bound (" +  subInc . get_max  ( ) + ") than superclass (" +  superInc . get_max  ( ) + ") in specialisation " + subClass + " --> " + superClass ) ; }  AggregationKind  subAgg =  subInc . get_aggregation  ( ) ;  AggregationKind  superAgg =  superInc . get_aggregation  ( ) ;  if  (   (   (  subAgg ==  AggregationKind . SHARED ) &&  (  superAgg ==  AggregationKind . COMPOSITE ) ) ||  (   (  subAgg ==  AggregationKind . NONE ) &&  (  superAgg !=  AggregationKind . NONE ) ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,        "Incompatible aggregation kinds (" + subAgg + " specialises " + superAgg + ") in generalisation " + subClass + " --> " + superClass ) ; }   sg . createSubsets  ( subInc , superInc ) ; }   private IncidenceDirection getDirection  (  IncidenceClass inc )  {  assert   (   inc . getFirstComesFromIncidence  ( ) == null ) ||  (   inc . getFirstGoesToIncidence  ( ) == null ) ;  if  (   inc . getFirstComesFromIncidence  ( ) != null )  {  return  IncidenceDirection . OUT ; } else  if  (   inc . getFirstGoesToIncidence  ( ) != null )  {  return  IncidenceDirection . IN ; } else  {  return null ; } }   public void writeOutput  ( )  throws XMLStreamException , GraphIOException  {  boolean  fileCreated = false ;  if  (  filenameDot != null )  {  try  {   printTypeAndFilename  ( "GraphvViz DOT file" , filenameDot ) ;   writeDotFile  ( filenameDot ) ;   fileCreated = true ; }  catch (   IOException e )  {    System . out . println  ( "Could not create DOT file." ) ;    System . out . println  (  "Exception was " + e ) ; } }  if  (  filenameSchemaGraph != null )  {   printTypeAndFilename  ( "schemagraph" , filenameSchemaGraph ) ;   writeSchemaGraph  ( filenameSchemaGraph ) ;   fileCreated = true ; }    System . out . println  ( "Validating schema graph..." ) ;   validateGraph  ( filenameValidation ) ;  if  (  filenameValidation != null )  {   fileCreated = true ; }  if  (  filenameSchema != null )  {   printTypeAndFilename  ( "schema" , filenameSchema ) ;   writeSchema  ( filenameSchema ) ;   fileCreated = true ; }  if  (  ! fileCreated )  {    System . out . println  ( "No files have been created." ) ; } }   private void printTypeAndFilename  (  String type ,  String filename )  {    System . out . println  (    "Writing " + type + " to: " + filename ) ; }   private void validateGraph  (  String filePath )  {  if  (  filePath != null )  {   printTypeAndFilename  ( "validation report" , filePath ) ; }  try  {  GraphValidator  validator =  new GraphValidator  ( sg ) ;   Set  < ConstraintViolation >  s ;  if  (  filePath != null )  {   s =  validator . createValidationReport  ( filePath ) ; } else  {   s =  validator . validate  ( ) ; }  if  (  !  s . isEmpty  ( ) )  {    System . err . println  ( "The schema graph is not valid:" ) ;  for ( ConstraintViolation currentViolation : s )  {    System . err . println  ( currentViolation ) ; } } }  catch (   IOException e )  {   e . printStackTrace  ( ) ; } }   private String createUnexpectedElementMessage  (  String name ,  String type )  {  String  typeInsertion =   type != null ?  " of type " + type : "" ;  return     "Unexpected element <" + name + ">" + typeInsertion + "." ; }   private Vertex handlePackage  ( )  throws XMLStreamException  {  Package  pkg =  sg . createPackage  ( ) ;   pkg . set_qualifiedName  (  getQualifiedName  (  getAttribute  ( UML_ATTRIBUTE_NAME ) ) ) ;   sg . createContainsSubPackage  (  packageStack . peek  ( ) , pkg ) ;   packageStack . push  ( pkg ) ;  return pkg ; }   private Vertex handleClass  (  String xmiId )  throws XMLStreamException  {   AttributedElement  <  ? ,  ? >  ae =  idMap . get  ( xmiId ) ;  VertexClass  vc = null ;  if  (  ae != null )  {  if  (  !  (  ae instanceof VertexClass ) )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "The element with ID '" + xmiId + "' is not a class. (VertexClass)" ) ; }  assert  preliminaryVertices . contains  ( ae ) ;   preliminaryVertices . remove  ( ae ) ;   vc =  ( VertexClass ) ae ; } else  {   vc =  sg . createVertexClass  ( ) ; }   currentClassId = xmiId ;   currentClass = vc ;  String  abs =  getAttribute  ( UML_ATTRIBUTE_IS_ABSRACT ) ;   vc . set_abstract  (   (  abs != null ) &&  abs . equals  ( UML_TRUE ) ) ;   vc . set_qualifiedName  (  getQualifiedName  (  getAttribute  ( UML_ATTRIBUTE_NAME ) ) ) ;   sg . createContainsGraphElementClass  (  packageStack . peek  ( ) , vc ) ;  return vc ; }   private Vertex handleAssociation  (  String xmiId )  throws XMLStreamException  {   AttributedElement  <  ? ,  ? >  ae =  idMap . get  ( xmiId ) ;  EdgeClass  ec = null ;  if  (  ae != null )  {  if  (  !  (  ae instanceof EdgeClass ) )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,    "The XMI id " + xmiId + " must denonte an EdgeClass, but is " +   ae . getAttributedElementClass  ( ) . getQualifiedName  ( ) ) ; }  assert  preliminaryVertices . contains  ( ae ) ;   preliminaryVertices . remove  ( ae ) ;   ec =  ( EdgeClass ) ae ; } else  {   ec =  sg . createEdgeClass  ( ) ; }   currentClassId = xmiId ;   currentClass = ec ;  String  abs =  getAttribute  ( UML_ATTRIBUTE_IS_ABSRACT ) ;   ec . set_abstract  (   (  abs != null ) &&  abs . equals  ( UML_TRUE ) ) ;  String  n =  getAttribute  ( UML_ATTRIBUTE_NAME ) ;   n =   n == null ? "" :  n . trim  ( ) ;  if  (   n . length  ( ) > 0 )  {   n =   Character . toUpperCase  (  n . charAt  ( 0 ) ) +  n . substring  ( 1 ) ; }   ec . set_qualifiedName  (  getQualifiedName  ( n ) ) ;   sg . createContainsGraphElementClass  (  packageStack . peek  ( ) , ec ) ;  String  memberEnd =  getAttribute  ( UML_MEMBER_END ) ;  if  (  memberEnd == null )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "The association with ID '" + xmiId + "' has no end member. (EdgeClass)" ) ; }   memberEnd =   memberEnd . trim  ( ) . replaceAll  ( "\\s+" , " " ) ;   int  p =  memberEnd . indexOf  ( ' ' ) ;  String  targetEnd =  memberEnd . substring  ( 0 , p ) ;  String  sourceEnd =  memberEnd . substring  (  p + 1 ) ;  IncidenceClass  inc =  ( IncidenceClass )  idMap . get  ( sourceEnd ) ;  if  (  inc == null )  {  VertexClass  vc =  sg . createVertexClass  ( ) ;   preliminaryVertices . add  ( vc ) ;   vc . set_qualifiedName  (  "preliminary for source end " + sourceEnd ) ;   inc =  sg . createIncidenceClass  ( ) ;   inc . set_aggregation  (  AggregationKind . NONE ) ;   inc . set_min  ( DEFAULT_MIN_MULTIPLICITY ) ;   inc . set_max  ( DEFAULT_MAX_MULTIPLICITY ) ;   sg . createComesFrom  ( ec , inc ) ;   sg . createEndsAt  ( inc , vc ) ;   idMap . put  ( sourceEnd , inc ) ; }   inc =  ( IncidenceClass )  idMap . get  ( targetEnd ) ;  if  (  inc != null )  {  assert  inc . isValid  ( ) ;  assert   getDirection  ( inc ) ==  IncidenceDirection . OUT ;  IncidenceClass  to =  sg . createIncidenceClass  ( ) ;  IncidenceClass  from = inc ;   sg . createGoesTo  ( ec , to ) ;   sg . createEndsAt  ( to ,  ( VertexClass )   from . getFirstEndsAtIncidence  ( ) . getThat  ( ) ) ;   to . set_aggregation  (  from . get_aggregation  ( ) ) ;   to . set_max  (  from . get_max  ( ) ) ;   to . set_min  (  from . get_min  ( ) ) ;   to . set_roleName  (  from . get_roleName  ( ) ) ;  if  (  ownedEnds . contains  ( from ) )  {   ownedEnds . remove  ( from ) ;   ownedEnds . add  ( to ) ; }   inc . delete  ( ) ;   idMap . put  ( targetEnd , to ) ; } else  {  VertexClass  vc =  sg . createVertexClass  ( ) ;   preliminaryVertices . add  ( vc ) ;   vc . set_qualifiedName  (  "preliminary for target end " + targetEnd ) ;   inc =  sg . createIncidenceClass  ( ) ;   inc . set_aggregation  (  AggregationKind . NONE ) ;   inc . set_min  ( DEFAULT_MIN_MULTIPLICITY ) ;   inc . set_max  ( DEFAULT_MAX_MULTIPLICITY ) ;   sg . createGoesTo  ( ec , inc ) ;   sg . createEndsAt  ( inc , vc ) ;   idMap . put  ( targetEnd , inc ) ; }  return ec ; }   private Vertex handleEnumeration  ( )  throws XMLStreamException  {  EnumDomain  ed =  sg . createEnumDomain  ( ) ;  Package  p =  packageStack . peek  ( ) ;   ed . set_qualifiedName  (  getQualifiedName  (  getAttribute  ( UML_ATTRIBUTE_NAME ) ) ) ;   sg . createContainsDomain  ( p , ed ) ;   PVector  < String >  empty =  JGraLab . vector  ( ) ;   ed . set_enumConstants  ( empty ) ;  Domain  dom =  domainMap . get  (  ed . get_qualifiedName  ( ) ) ;  if  (  dom != null )  {  assert  preliminaryVertices . contains  ( dom ) ;   reconnectEdges  ( dom , ed ) ;   dom . delete  ( ) ;   preliminaryVertices . remove  ( dom ) ; }   domainMap . put  (  ed . get_qualifiedName  ( ) , ed ) ;  return ed ; }   private Vertex handlePrimitiveType  (  String xmiId )  throws XMLStreamException  {  String  typeName =  getAttribute  ( UML_ATTRIBUTE_NAME ) ;  if  (  typeName == null )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  "No type name in primitive type. XMI ID: " + xmiId ) ; }   typeName =  typeName . replaceAll  ( "\\s" , "" ) ;  if  (   typeName . length  ( ) == 0 )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,  "Type name in primitive type is empty. XMI ID: " + xmiId ) ; }  Domain  dom =  createDomain  ( typeName ) ;  assert  dom != null ;  return dom ; }   private void handleRealization  ( )  throws XMLStreamException  {  String  supplier =  getAttribute  ( UML_ATTRIBUTE_SUPPLIER ) ;  String  client =  getAttribute  ( UML_ATTRIBUTE_CLIENT ) ;   Set  < String >  reals =  realizations . get  ( client ) ;  if  (  reals == null )  {   reals =  new  TreeSet  < String >  ( ) ;   realizations . put  ( client , reals ) ; }   reals . add  ( supplier ) ; }   private String attributedElement2String  (   AttributedElement  <  ? ,  ? > attributedElement )  {  StringBuilder  sb =  new StringBuilder  ( ) ;       de . uni_koblenz . jgralab . schema . AttributedElementClass  <  ? ,  ? >  aec =  attributedElement . getAttributedElementClass  ( ) ;   sb . append  ( attributedElement ) ;   sb . append  ( " { " ) ;  for (     de . uni_koblenz . jgralab . schema . Attribute attr :  aec . getAttributeList  ( ) )  {   sb . append  (  attr . getName  ( ) ) ;   sb . append  ( " = " ) ;   sb . append  (  attributedElement . getAttribute  (  attr . getName  ( ) ) ) ;   sb . append  ( "; " ) ; }   sb . append  ( "}\n" ) ;  return  sb . toString  ( ) ; }   private void handleEnumerationLiteral  ( )  throws XMLStreamException  {  String  s =  getAttribute  ( UML_ATTRIBUTE_NAME ) ;  if  (  s == null )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) , "No Literal declared." ) ; }   s =  s . trim  ( ) ;  if  (   s . length  ( ) <= 0 )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) , "Literal is empty." ) ; }  String  classifier =  getAttribute  ( UML_ATTRIBUTE_CLASSIFIER ) ;  if  (  classifier == null )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "No Enumeration found for Literal '" + s + "'." ) ; }  EnumDomain  ed =  ( EnumDomain )  idMap . get  ( classifier ) ;  if  (  !  s . equals  (  s . toUpperCase  ( ) ) )  {    System . out . println  (     "Warning: Enumeration literal '" + s + "' in enumeration + '" +  ed . get_qualifiedName  ( ) + "' should be all uppercase letters." ) ; }   ed . set_enumConstants  (   ed . get_enumConstants  ( ) . plus  ( s ) ) ; }   private void writeSchema  (  String schemaName )  {  try  {  SchemaGraph2Tg  sg2tg =  new SchemaGraph2Tg  ( sg , schemaName ) ;   sg2tg . process  ( ) ; }  catch (   IOException e )  {  throw  new RuntimeException  ( "SchemaGraph2Tg failed with an IOException!" , e ) ; } }   private void correctEdgeDirection  ( )  {  if  (  !  isUseNavigability  ( ) )  {  return ; }    System . out . println  ( "Correcting edge directions according to navigability..." ) ;  for ( EdgeClass e :  sg . getEdgeClassVertices  ( ) )  {  ComesFrom  cf =  e . getFirstComesFromIncidence  ( ) ;  if  (  cf == null )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "EdgeClass " +  e . get_qualifiedName  ( ) + " has no ComesFrom incidence" ) ; }  GoesTo  gt =  e . getFirstGoesToIncidence  ( ) ;  if  (  gt == null )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "EdgeClass " +  e . get_qualifiedName  ( ) + " has no GoesTo incidence" ) ; }  IncidenceClass  from =  ( IncidenceClass )  cf . getThat  ( ) ;  IncidenceClass  to =  ( IncidenceClass )  gt . getThat  ( ) ;  boolean  fromIsNavigable =  !  ownedEnds . contains  ( from ) ;  boolean  toIsNavigable =  !  ownedEnds . contains  ( to ) ;  if  (  fromIsNavigable == toIsNavigable )  {  continue ; }  if  ( toIsNavigable )  {  continue ; }  assert   getDirection  ( to ) ==  IncidenceDirection . IN ;  assert   getDirection  ( from ) ==  IncidenceDirection . OUT ;  IncidenceClass  inc =  ( IncidenceClass )  cf . getThat  ( ) ;   cf . setThat  (  gt . getThat  ( ) ) ;   gt . setThat  ( inc ) ; } }   private void attachConstraints  ( )  throws XMLStreamException  {    System . out . println  ( "Attaching constraints..." ) ;  for ( String constrainedElementId :  constraints . keySet  ( ) )  {   List  < String >  l =  constraints . get  ( constrainedElementId ) ;  if  (   l . size  ( ) == 0 )  {  continue ; }  Vertex  ae =  idMap . get  ( constrainedElementId ) ;  if  (  ae == null )  {   ae = graphClass ; }  if  (  !  ae . isValid  ( ) )  {  continue ; }  if  (   !  (  ae instanceof AttributedElementClass ) &&  !  (  ae instanceof IncidenceClass ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,      "Constraint can only be attached to GraphClass, " + "VertexClass, EdgeClass or association ends. Offending element is " + ae + " (XMI id " + constrainedElementId + ")" ) ; }  if  (  ae instanceof AttributedElementClass )  {  if  (   (  ( AttributedElementClass ) ae ) . isValid  ( ) )  {  for ( String text : l )  {   addGreqlConstraint  (  ( AttributedElementClass ) ae , text ) ; } } } else  if  (  ae instanceof IncidenceClass )  {  if  (   (  ( IncidenceClass ) ae ) . isValid  ( ) )  {  for ( String text : l )  {  if  (  !  text . startsWith  ( "redefines" ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,     "Only 'redefines' constraints are allowed at association ends. Offending element: " + ae + " (XMI id " + constrainedElementId + ")" ) ; }   addRedefinesConstraint  (  ( IncidenceClass ) ae , text ) ; } } } else  {  throw  new ProcessingException  (  getFileName  ( ) ,     "Don't know what to do with constraint(s) at element " + ae + " (XMI id " + constrainedElementId + ")" ) ; } } }   private static final Pattern  GENNAME_PATTERN =  Pattern . compile  ( "(.*)\\$\\p{Digit}+(:(\\w+))?\\$$" ) ;   private void createEdgeClassNames  ( )  {    System . out . println  ( "Creating missing edge class names..." ) ;  for ( EdgeClass ec :  sg . getEdgeClassVertices  ( ) )  {  String  name =   ec . get_qualifiedName  ( ) . trim  ( ) ;  String  ecName = null ;  Matcher  m =  GENNAME_PATTERN . matcher  ( name ) ;  if  (  m . matches  ( ) )  {   name =  m . group  ( 1 ) ;   ecName =  m . group  (  m . groupCount  ( ) ) ; }  if  (   !  name . equals  ( "" ) &&  !  name . endsWith  ( "." ) )  {  continue ; }  IncidenceClass  to =  ( IncidenceClass )   ec . getFirstGoesToIncidence  ( ) . getThat  ( ) ;  IncidenceClass  from =  ( IncidenceClass )   ec . getFirstComesFromIncidence  ( ) . getThat  ( ) ;  String  toRole =  to . get_roleName  ( ) ;  if  (   (  toRole == null ) ||  toRole . equals  ( "" ) )  {   toRole =   (  ( VertexClass )   to . getFirstEndsAtIncidence  ( ) . getThat  ( ) ) . get_qualifiedName  ( ) ;   int  p =  toRole . lastIndexOf  ( '.' ) ;  if  (  p >= 0 )  {   toRole =  toRole . substring  (  p + 1 ) ; } } else  {   toRole =   Character . toUpperCase  (  toRole . charAt  ( 0 ) ) +  toRole . substring  ( 1 ) ; }  if  (   (  toRole == null ) ||  (   toRole . length  ( ) <= 0 ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "There is no role name 'to' for the edge '" + name + "' defined." ) ; }  if  (  ecName == null )  {  if  (   (   from . get_aggregation  ( ) !=  AggregationKind . NONE ) ||  (   to . get_aggregation  ( ) !=  AggregationKind . NONE ) )  {  if  (   to . get_aggregation  ( ) !=  AggregationKind . NONE )  {   ecName =  "Contains" + toRole ; } else  {   ecName =  "IsPartOf" + toRole ; } } else  {   ecName =  "LinksTo" + toRole ; } } else  {   ecName += toRole ; }  if  (  isUseFromRole  ( ) )  {  String  fromRole =  from . get_roleName  ( ) ;  if  (   (  fromRole == null ) ||  fromRole . equals  ( "" ) )  {   fromRole =   (  ( VertexClass )   from . getFirstEndsAtIncidence  ( ) . getThat  ( ) ) . get_qualifiedName  ( ) ;   int  p =  fromRole . lastIndexOf  ( '.' ) ;  if  (  p >= 0 )  {   fromRole =  fromRole . substring  (  p + 1 ) ; } } else  {   fromRole =   Character . toUpperCase  (  fromRole . charAt  ( 0 ) ) +  fromRole . substring  ( 1 ) ; }  if  (   (  fromRole == null ) ||  (   fromRole . length  ( ) <= 0 ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "There is no role name of 'from' for the edge '" + name + "' defined." ) ; }   name += fromRole ; }  assert   (  ecName != null ) &&  (   ecName . length  ( ) > 0 ) ;   ec . set_qualifiedName  (  name + ecName ) ; } }   private void removeUnusedDomains  ( )  {    System . out . println  ( "Removing unused domains..." ) ;  Domain  d =  sg . getFirstDomain  ( ) ;  while  (  d != null )  {  Domain  n =  d . getNextDomain  ( ) ;  if  (   (   d . getDegree  (  EdgeDirection . IN ) -  d . getDegree  (  Annotates . class ,  EdgeDirection . IN ) ) <= 1 )  {   List  <  ? extends Comment >  comments =  d . remove_comment  ( ) ;  for ( Comment c : comments )  {   c . delete  ( ) ; }   d . delete  ( ) ;   d =  sg . getFirstDomain  ( ) ; } else  {   d = n ; } } }   private void linkRecordDomainComponents  ( )  {  for ( HasRecordDomainComponent comp :  sg . getHasRecordDomainComponentEdges  ( ) )  {  String  domainId =  recordComponentType . getMark  ( comp ) ;  if  (  domainId == null )  {   recordComponentType . removeMark  ( comp ) ;  continue ; }  Domain  dom =  ( Domain )  idMap . get  ( domainId ) ;  if  (  dom != null )  {  Domain  d =  comp . getOmega  ( ) ;  assert    (  d instanceof StringDomain ) &&   d . get_qualifiedName  ( ) . equals  ( domainId ) &&  preliminaryVertices . contains  ( d ) ;   comp . setOmega  ( dom ) ;   d . delete  ( ) ;   preliminaryVertices . remove  ( d ) ;   recordComponentType . removeMark  ( comp ) ; } else  {  throw  new ProcessingException  (  getFileName  ( ) ,   "Undefined Domain with ID '" + domainId + "' found." ) ; } }  if  (  !  recordComponentType . isEmpty  ( ) )  {  throw  new ProcessingException  (  getFileName  ( ) , "Some RecordDomains have unresolved component types." ) ; } }   private void linkAttributeDomains  ( )  {  for ( Attribute att :  sg . getAttributeVertices  ( ) )  {  String  domainId =  attributeType . getMark  ( att ) ;  if  (  domainId == null )  {  assert   att . getDegree  (  HasDomain . class ,  EdgeDirection . OUT ) == 1 :         "Attribute '" +  att . get_name  ( ) + "' of " +     att . getFirstHasAttributeIncidence  ( ) . getThat  ( ) . getSchemaClass  ( ) . getSimpleName  ( ) + " '" +   (  ( AttributedElementClass )   att . getFirstHasAttributeIncidence  ( ) . getThat  ( ) ) . get_qualifiedName  ( ) + "' has " +  att . getDegree  (  HasDomain . class ,  EdgeDirection . OUT ) + " domain(s)" ;  continue ; }  Domain  dom =  ( Domain )  idMap . get  ( domainId ) ;  if  (  dom != null )  {   sg . createHasDomain  ( att , dom ) ;   attributeType . removeMark  ( att ) ; } else  {  throw  new ProcessingException  (  getFileName  ( ) ,   "Undefined Domain with ID '" + domainId + "' found." ) ; }  assert   att . getDegree  (  HasDomain . class ,  EdgeDirection . OUT ) == 1 ; }  if  (  !  attributeType . isEmpty  ( ) )  {  throw  new ProcessingException  (  getFileName  ( ) , "There are some Attribute objects, whos domains are not resolved." ) ; } }   private void writeDotFile  (  String dotName )  throws IOException  {  Tg2Dot  tg2Dot =  new Tg2Dot  ( ) ;   tg2Dot . setGraph  ( sg ) ;   tg2Dot . setPrintEdgeAttributes  ( true ) ;   tg2Dot . setOutputFile  ( dotName ) ;   tg2Dot . convert  ( ) ; }   private void writeSchemaGraph  (  String schemaGraphName )  throws GraphIOException  {   sg . save  ( schemaGraphName ) ; }   private void linkGeneralizations  ( )  {  for ( String clientId :  realizations . keySet  ( ) )  {   Set  < String >  suppliers =  realizations . get  ( clientId ) ;  AttributedElementClass  client =  ( AttributedElementClass )  idMap . get  ( clientId ) ;  if  (   suppliers . size  ( ) > 0 )  {   Set  < String >  superClasses =  generalizations . getMark  ( client ) ;  if  (  superClasses == null )  {   superClasses =  new  TreeSet  < String >  ( ) ;   generalizations . mark  ( client , superClasses ) ; }   superClasses . addAll  ( suppliers ) ; } }  for (  AttributedElement  <  ? ,  ? > ae :  generalizations . getMarkedElements  ( ) )  {  AttributedElementClass  sub =  ( AttributedElementClass ) ae ;   Set  < String >  superclasses =  generalizations . getMark  ( sub ) ;  for ( String id : superclasses )  {  AttributedElementClass  sup =  ( AttributedElementClass )  idMap . get  ( id ) ;  if  (  sup == null )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "The superclass with XMI id '" + id + "' could not be found." ) ; }  if  (  sup instanceof VertexClass )  {  if  (  !  (  sub instanceof VertexClass ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,         "Different types in generalization: " +   sub . getSchemaClass  ( ) . getSimpleName  ( ) + " '" +  sub . get_qualifiedName  ( ) + "' can not be subclass of " +   sub . getSchemaClass  ( ) . getSimpleName  ( ) + " '" +  sup . get_qualifiedName  ( ) + "'" ) ; }   sg . createSpecializesVertexClass  (  ( VertexClass ) ae ,  ( VertexClass ) sup ) ;  if  (  !  vertexClassHierarchyIsAcyclic  ( ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,     "Cycle in vertex class hierarchy. Involved classes are '" +  sub . get_qualifiedName  ( ) + "' and '" +  sup . get_qualifiedName  ( ) + "'" ) ; } } else  if  (  sup instanceof EdgeClass )  {  if  (  !  (  sub instanceof EdgeClass ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,         "Different types in generalization: " +   sub . getSchemaClass  ( ) . getSimpleName  ( ) + " '" +  sub . get_qualifiedName  ( ) + "' can not be subclass of " +   sub . getSchemaClass  ( ) . getSimpleName  ( ) + " '" +  sup . get_qualifiedName  ( ) + "'" ) ; }   sg . createSpecializesEdgeClass  (  ( EdgeClass ) ae ,  ( EdgeClass ) sup ) ;  if  (  !  edgeClassHierarchyIsAcyclic  ( ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,     "Cycle in edge class hierarchy. Involved classes are '" +  sub . get_qualifiedName  ( ) + "' and '" +  sup . get_qualifiedName  ( ) + "'" ) ; } } else  {  throw  new RuntimeException  ( "FIXME: Unexpected super class type. Super class must be VertexClass or EdgeClass!" ) ; } } }   generalizations . clear  ( ) ; }   private boolean edgeClassHierarchyIsAcyclic  ( )  {  return true ; }   private boolean vertexClassHierarchyIsAcyclic  ( )  {  return true ; }   private void removeEmptyPackages  ( )  {    System . out . println  ( "Removing empty packages..." ) ;  Package  p =  sg . getFirstPackage  ( ) ;   int  removed = 0 ;  while  (  p != null )  {  Package  n =  p . getNextPackage  ( ) ;   int  commentCount =  p . getDegree  (  Annotates . class ) ;  if  (   (   (   p . getDegree  ( ) - commentCount ) == 1 ) &&  (    p . get_qualifiedName  ( ) . length  ( ) > 0 ) )  {    System . out . println  (    "\t- empty package '" +  p . get_qualifiedName  ( ) + "' removed" +  (   commentCount > 0 ?   commentCount == 1 ? " including 1 comment" :   " including " + commentCount + " comments" : "" ) ) ;  if  (  commentCount > 0 )  {  for (  Annotates  a =  p . getFirstAnnotatesIncidence  ( ) ;  a != null ;  a =  p . getFirstAnnotatesIncidence  ( ) )  {    a . getThat  ( ) . delete  ( ) ; } }   p . delete  ( ) ;   ++ removed ;   p =  sg . getFirstPackage  ( ) ; } else  {   p = n ; } }    System . out . println  (     "\tRemoved " + removed + " package" +  (   removed == 1 ? "" : "s" ) + "." ) ; }   private void handleConstraint  (  String text )  throws XMLStreamException  {  if  (   text . startsWith  ( "redefines" ) ||  text . startsWith  ( "\"" ) )  {   List  < String >  l =  constraints . get  ( constrainedElementId ) ;  if  (  l == null )  {   l =  new  LinkedList  < String >  ( ) ;   constraints . put  ( constrainedElementId , l ) ; }   l . add  ( text ) ; } else  if  (  text . startsWith  ( "subsets" ) )  {    System . err . println  (   "warning: {subsets ...} constraint at element " + constrainedElementId + " ignored (don't forget to model generalizations between associations)" ) ; } else  if  (  text . startsWith  ( "union" ) )  {    System . err . println  (   "warning: {union} constraint at element " + constrainedElementId + " ignored (don't forget to add an <<abstract>> stereotype to the association)" ) ; } else  if  (  text . startsWith  ( "ordered" ) )  {    System . err . println  (   "warning: {ordered} constraint at element " + constrainedElementId + " ignored (TGraphs are ordered by default)" ) ; } else  {  throw  new ProcessingException  (  getFileName  ( ) ,    getParser  ( ) . getLocation  ( ) . getLineNumber  ( ) ,  "Illegal constraint format: " + text ) ; } }   private void addRedefinesConstraint  (  IncidenceClass constrainedEnd ,  String text )  throws XMLStreamException  {   text =   text . trim  ( ) . replaceAll  ( "\\s+" , " " ) ;  if  (  !  text . startsWith  ( "redefines " ) )  {  throw  new ProcessingException  (  getFileName  ( ) , "Wrong redefines constraint format." ) ; }   String  [ ]  roles =   text . substring  ( 10 ) . split  ( "\\s*,\\s*" ) ;  if  (   roles . length < 1 )  {  throw  new ProcessingException  (  getFileName  ( ) , "Redefines constraint without rolenames" ) ; }   Set  < String >  redefinedRoles =  new  TreeSet  < String >  ( ) ;  for ( String role : roles )  {  if  (   role . length  ( ) < 1 )  {  throw  new ProcessingException  (  getFileName  ( ) , "Empty role name in redefines constraint" ) ; }   redefinedRoles . add  ( role ) ; }  if  (   redefinedRoles . size  ( ) < 1 )  {  throw  new ProcessingException  (  getFileName  ( ) , "Redefines constraint without rolenames" ) ; }   Set  < String >  oldRedefinesRoles =  redefines . getMark  ( constrainedEnd ) ;  if  (  oldRedefinesRoles == null )  {   redefines . mark  ( constrainedEnd , redefinedRoles ) ; } else  {   oldRedefinesRoles . addAll  ( redefinedRoles ) ; } }   private void addGreqlConstraint  (  AttributedElementClass constrainedClass ,  String text )  throws XMLStreamException  {  assert  constrainedClass != null ;  Constraint  constraint =  sg . createConstraint  ( ) ;   sg . createHasConstraint  ( constrainedClass , constraint ) ;   int  stringCount = 0 ;    char  [ ]  ch =  text . toCharArray  ( ) ;  boolean  inString = false ;  boolean  escape = false ;   int  beginIndex = 0 ;  for (   int  i = 0 ;  i <  ch . length ;  ++ i )  {   char  c =  ch [ i ] ;  if  ( inString )  {  if  (  c == '\\' )  {   escape = true ; } else  if  (   ! escape &&  (  c == '"' ) )  {   ++ stringCount ;  String  constraintText =    text . substring  (  beginIndex + 1 , i ) . trim  ( ) . replaceAll  ( "\\\\(.)" , "$1" ) ;  if  (  constraintText . isEmpty  ( ) )  {   constraintText = null ; }  switch  ( stringCount )  {   case 1 :   constraint . set_message  ( constraintText ) ;  break ;   case 2 :   constraint . set_predicateQuery  ( constraintText ) ;  break ;   case 3 :   constraint . set_offendingElementsQuery  ( constraintText ) ;  break ;   default :  throw  new ProcessingException  (  getFileName  ( ) ,   "Illegal constraint format. The constraint text was '" + text + "'." ) ; }   inString = false ; } else  if  (  escape &&  (  c == '"' ) )  {   escape = false ; } } else  {  if  (  Character . isWhitespace  ( c ) )  { } else  {  if  (  c == '"' )  {   inString = true ;   beginIndex = i ; } else  {  throw  new ProcessingException  (  getFileName  ( ) ,       "Illegal constraint format. The constraint text was '" + text + "'.  Expected '\"' but got '" + c + "'.  (position = " + i + ")." ) ; } } } }  if  (    inString || escape ||  (  stringCount < 2 ) ||  (  stringCount > 3 ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "Illegal constraint format.  The constraint text was '" + text + "'." ) ; } }   private void handleUpperValue  ( )  throws XMLStreamException  {  assert   (  currentAssociationEnd != null ) || inOwnedAttribute ;   int  n =  getValue  ( ) ;  if  (   (  currentAssociationEnd == null ) && inOwnedAttribute )  {  if  (  n != 1 )  {  throw  new ProcessingException  (  getFileName  ( ) , "grUML does not support attribute multiplicities other than 1..1" ) ; } } else  {  assert  currentAssociationEnd != null ;  assert  n >= 1 ;   currentAssociationEnd . set_max  ( n ) ; } }   private  int getValue  ( )  throws XMLStreamException  {  String  val =  getAttribute  ( UML_ATTRIBUTE_VALUE ) ;  return   val == null ? 0 :   val . equals  ( "*" ) ?  Integer . MAX_VALUE :  Integer . parseInt  ( val ) ; }   private void handleLowerValue  ( )  throws XMLStreamException  {  assert   (  currentAssociationEnd != null ) || inOwnedAttribute ;   int  n =  getValue  ( ) ;  if  (   (  currentAssociationEnd == null ) && inOwnedAttribute )  {  if  (  n != 1 )  {  throw  new ProcessingException  (  getFileName  ( ) , "grUML does not support attribute multiplicities other than 1..1" ) ; } } else  {  assert  currentAssociationEnd != null ;  assert  n >= 0 ;   currentAssociationEnd . set_min  ( n ) ; } }   private void handleStereotype  ( )  throws XMLStreamException  {  String  key =  getAttribute  ( UML_ATTRIBUTE_KEY ) ;  if  (       (  currentClass == null ) &&  (  currentClassId == null ) &&  (  currentAssociationEnd == null ) &&  (  currentAttribute == null ) &&  (  currentRecordDomain == null ) &&  (  currentRecordDomainComponent == null ) )  {  if  (  key . equals  ( "rsa2tg_ignore" ) )  {   ignoredPackages . add  (  packageStack . peek  ( ) ) ;  return ; } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "Unexpected stereotype <<" + key + ">>" ) ; } }  if  (  currentClass == null )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "Unexpected stereotype <<" + key + ">>" ) ; }  if  (  key . equals  ( "graphclass" ) )  {  if  (  !  (  currentClass instanceof VertexClass ) )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) , "The stereotype '<<graphclass>>' is only valid for a UML class." ) ; }  AttributedElementClass  aec =  ( AttributedElementClass )  idMap . get  ( currentClassId ) ;  assert  graphClass != null ;   graphClass . set_qualifiedName  (  aec . get_qualifiedName  ( ) ) ;  Edge  e =  aec . getFirstIncidence  ( ) ;  while  (  e != null )  {  Edge  n =  e . getNextIncidence  ( ) ;  if  (  e instanceof ContainsGraphElementClass )  {   e . delete  ( ) ; } else  {   e . setThis  ( graphClass ) ; }   e = n ; }   aec . delete  ( ) ;   idMap . put  ( currentClassId , graphClass ) ;   currentClass = graphClass ; } else  if  (  key . equals  ( "record" ) )  {  if  (  !  (  currentClass instanceof VertexClass ) )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) , "The stereotype '<<record>>' is only allow for UML-classes." ) ; }  RecordDomain  rd =  sg . createRecordDomain  ( ) ;   rd . set_qualifiedName  (  currentClass . get_qualifiedName  ( ) ) ;  Edge  e =  currentClass . getFirstIncidence  ( ) ;  while  (  e != null )  {  Edge  n =  e . getNextIncidence  ( ) ;  if  (  e instanceof ContainsGraphElementClass )  {   sg . createContainsDomain  (  ( Package )  e . getThat  ( ) , rd ) ;   e . delete  ( ) ; } else  if  (  e instanceof HasAttribute )  {  Attribute  att =  ( Attribute )  e . getThat  ( ) ;  Edge  d =  att . getFirstHasDomainIncidence  ( ) ;  if  (  d != null )  {  Domain  dom =  ( Domain )  e . getThat  ( ) ;  HasRecordDomainComponent  comp =  sg . createHasRecordDomainComponent  ( rd , dom ) ;   comp . set_name  (  att . get_name  ( ) ) ; } else  {  String  typeId =  attributeType . getMark  ( att ) ;  if  (  typeId == null )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) , "No type id has been defined." ) ; }  Domain  dom =  sg . createStringDomain  ( ) ;   dom . set_qualifiedName  ( typeId ) ;   preliminaryVertices . add  ( dom ) ;  HasRecordDomainComponent  comp =  sg . createHasRecordDomainComponent  ( rd , dom ) ;   recordComponentType . mark  ( comp , typeId ) ;   attributeType . removeMark  ( att ) ; }   att . delete  ( ) ; }   e = n ; }  if  (   currentClass . getDegree  ( ) != 0 )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "The <<record>> class '" +  currentClass . get_qualifiedName  ( ) + "' must not have any association." ) ; }   domainMap . put  (  rd . get_qualifiedName  ( ) , rd ) ;   idMap . put  ( currentClassId , rd ) ;   currentRecordDomain = rd ;   currentClass . delete  ( ) ;   currentClass = null ;   currentClassId = null ; } else  if  (  key . equals  ( "abstract" ) )  {  if  (  currentClass instanceof GraphElementClass )  {  GraphElementClass  gec =  ( GraphElementClass ) currentClass ;   gec . set_abstract  ( true ) ; } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "The stereotype <<abstract>> can only be specified for vertex and edge classes, but not for class '" +  currentClass . get_qualifiedName  ( ) + "'" ) ; } } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "Unexpected stereotype '<<" + key + ">>'." ) ; } }   private void handleGeneralization  ( )  throws XMLStreamException  {  String  general =  getAttribute  ( UML_ATTRIBUTE_GENERAL ) ;   Set  < String >  gens =  generalizations . getMark  ( currentClass ) ;  if  (  gens == null )  {   gens =  new  TreeSet  < String >  ( ) ;   generalizations . mark  ( currentClass , gens ) ; }   gens . add  ( general ) ; }   private void handleNestedTypeElement  (  String xmiId )  throws XMLStreamException  {  if  (   (  currentAttribute == null ) &&  (  currentRecordDomain == null ) )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "unexpected primitive type in element (XMI id " + xmiId + ")" ) ; }  String  href =  getAttribute  ( UML_ATTRIBUTE_HREF ) ;  if  (  href == null )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "No type name specified in primitive type href of attribute (XMI id " + xmiId + ")" ) ; }  Domain  dom = null ;  if  (  href . endsWith  ( "#String" ) )  {   dom =  createDomain  ( "String" ) ; } else  if  (  href . endsWith  ( "#Integer" ) )  {   dom =  createDomain  ( "Integer" ) ; } else  if  (  href . endsWith  ( "#Boolean" ) )  {   dom =  createDomain  ( "Boolean" ) ; } else  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,     "Unknown primitive type with href '" + href + "' in attribute (XMI id " + xmiId + ")" ) ; }  assert  dom != null ;  if  (  currentRecordDomain != null )  {  assert  currentRecordDomainComponent != null ;  Domain  d =  currentRecordDomainComponent . getOmega  ( ) ;  assert    (  d instanceof StringDomain ) &&  (   d . get_qualifiedName  ( ) == null ) &&  preliminaryVertices . contains  ( d ) ;   currentRecordDomainComponent . setOmega  ( dom ) ;   d . delete  ( ) ;   preliminaryVertices . remove  ( d ) ;   recordComponentType . removeMark  ( currentRecordDomainComponent ) ; } else  {  assert  currentAttribute != null ;   sg . createHasDomain  ( currentAttribute , dom ) ;   attributeType . removeMark  ( currentAttribute ) ; } }   private void handleOwnedAttribute  (  String xmiId )  throws XMLStreamException  {  String  association =  getAttribute  ( UML_ATTRIBUTE_ASSOCIATION ) ;  if  (  association == null )  {  String  attrName =  getAttribute  ( UML_ATTRIBUTE_NAME ) ;  if  (   (  currentClass == null ) &&  (  currentRecordDomain == null ) )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,     "Found an attribute '" + attrName + "' (XMI id " + xmiId + ") outside a class!" ) ; }  if  (  attrName == null )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "No attribute name in ownedAttribute (XMI id " + xmiId + ")" ) ; }   attrName =  attrName . trim  ( ) ;  if  (   attrName . length  ( ) == 0 )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "Empty attribute name in ownedAttribute (XMI id " + xmiId + ")" ) ; }  String  isDerived =  getAttribute  ( UML_ATTRIBUTE_ISDERIVED ) ;  boolean  derived =   (  isDerived != null ) &&  isDerived . equals  ( UML_TRUE ) ;  if  ( derived )  {  return ; }  String  typeId =  getAttribute  ( UML_ATTRIBUTE_TYPE ) ;  if  (  currentClass != null )  {  Attribute  att =  sg . createAttribute  ( ) ;   currentAttribute = att ;   att . set_name  ( attrName ) ;   sg . createHasAttribute  ( currentClass , att ) ;  if  (  typeId != null )  {   attributeType . mark  ( att , typeId ) ; } } else  {  assert  currentRecordDomain != null ;   currentAttribute = null ;   currentRecordDomainComponent = null ;  if  (  typeId != null )  {  Vertex  v =  idMap . get  ( typeId ) ;  if  (  v != null )  {  assert  v instanceof Domain :   "typeID says " + typeId + " which is no Domain!" ;   currentRecordDomainComponent =  sg . createHasRecordDomainComponent  ( currentRecordDomain ,  ( Domain ) v ) ; } else  {  Domain  dom =  sg . createStringDomain  ( ) ;   dom . set_qualifiedName  ( typeId ) ;   preliminaryVertices . add  ( dom ) ;   currentRecordDomainComponent =  sg . createHasRecordDomainComponent  ( currentRecordDomain , dom ) ;   recordComponentType . mark  ( currentRecordDomainComponent , typeId ) ; } } else  {  Domain  dom =  sg . createStringDomain  ( ) ;   preliminaryVertices . add  ( dom ) ;   currentRecordDomainComponent =  sg . createHasRecordDomainComponent  ( currentRecordDomain , dom ) ; }   currentRecordDomainComponent . set_name  ( attrName ) ; } } else  {   handleAssociationEnd  ( xmiId ) ; } }   private void handleAssociationEnd  (  String xmiId )  throws XMLStreamException  {  String  endName =  getAttribute  ( UML_ATTRIBUTE_NAME ) ;  if  (   (  currentClass == null ) ||  (  currentRecordDomain != null ) )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,     "Found an association end '" + endName + "' (XMI id " + xmiId + ") outside a class or in a record domain" ) ; }  String  agg =  getAttribute  ( UML_ATTRIBUTE_AGGREGATION ) ;  boolean  aggregation =   (  agg != null ) &&  agg . equals  ( UML_SHARED ) ;  boolean  composition =   (  agg != null ) &&  agg . equals  ( UML_COMPOSITE ) ;  String  typeId =  getAttribute  ( UML_ATTRIBUTE_TYPE ) ;  if  (  typeId == null )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "No type attribute in association end (XMI id" + xmiId + ")" ) ; }  IncidenceClass  inc =  ( IncidenceClass )  idMap . get  ( xmiId ) ;  if  (  inc == null )  {  VertexClass  vc = null ;   AttributedElement  <  ? ,  ? >  ae =  idMap . get  ( typeId ) ;  if  (  ae != null )  {  if  (  !  (  ae instanceof VertexClass ) )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,    "Type attribute of association end (XMI id " + xmiId + ") must denote a VertexClass, but is " +   ae . getAttributedElementClass  ( ) . getQualifiedName  ( ) ) ; }   vc =  ( VertexClass ) ae ; } else  {   vc =  sg . createVertexClass  ( ) ;   vc . set_qualifiedName  ( typeId ) ;   preliminaryVertices . add  ( vc ) ;   idMap . put  ( typeId , vc ) ; }  EdgeClass  ec = null ;  if  (  currentClass instanceof EdgeClass )  {   ec =  ( EdgeClass ) currentClass ;   idMap . put  ( currentClassId , currentClass ) ; } else  {  String  associationId =  getAttribute  ( UML_ATTRIBUTE_ASSOCIATION ) ;  if  (  associationId == null )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,   "No assiocation attribute in association end (XMI id " + xmiId + ")" ) ; }   ae =  idMap . get  ( associationId ) ;  if  (  ae != null )  {  if  (  !  (  ae instanceof EdgeClass ) )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,    "Assiocation attribute of association end (XMI id " + xmiId + ") must denote an EdgeClass, but is " +   ae . getAttributedElementClass  ( ) . getQualifiedName  ( ) ) ; }   ec =  ( EdgeClass ) ae ; } else  {   ec =  sg . createEdgeClass  ( ) ; }   preliminaryVertices . add  ( ec ) ;   idMap . put  ( associationId , ec ) ; }  assert   (  vc != null ) &&  (  ec != null ) ;   inc =  sg . createIncidenceClass  ( ) ;   inc . set_min  ( DEFAULT_MIN_MULTIPLICITY ) ;   inc . set_max  ( DEFAULT_MAX_MULTIPLICITY ) ;   sg . createComesFrom  ( ec , inc ) ;   sg . createEndsAt  ( inc , vc ) ; } else  {  EdgeClass  ec =  ( EdgeClass )   (    inc . getFirstComesFromIncidence  ( ) != null ?  inc . getFirstComesFromIncidence  ( ) :  inc . getFirstGoesToIncidence  ( ) ) . getThat  ( ) ;  String  id = null ;  for (  Entry  < String , Vertex > idEntry :  idMap . entrySet  ( ) )  {  if  (   idEntry . getValue  ( ) == ec )  {   id =  idEntry . getKey  ( ) ;  break ; } }  assert  id != null ;   idMap . put  ( id , ec ) ;  VertexClass  vc =  ( VertexClass )   inc . getFirstEndsAtIncidence  ( ) . getThat  ( ) ;  if  (  preliminaryVertices . contains  ( vc ) )  {   AttributedElement  <  ? ,  ? >  ae =  idMap . get  ( typeId ) ;  if  (   (  ae != null ) &&  !  vc . equals  ( ae ) )  {  if  (  !  (  ae instanceof VertexClass ) )  {  throw  new ProcessingException  (  getParser  ( ) ,  getFileName  ( ) ,    "Type attribute of association end (XMI id " + xmiId + ") must denote a VertexClass, but is " +   ae . getAttributedElementClass  ( ) . getQualifiedName  ( ) ) ; }    inc . getFirstEndsAtIncidence  ( ) . setOmega  (  ( VertexClass ) ae ) ;   Set  < String >  gens =  generalizations . getMark  ( vc ) ;  if  (  gens != null )  {   generalizations . removeMark  ( vc ) ;   generalizations . mark  ( ae , gens ) ; }   vc . delete  ( ) ;   preliminaryVertices . remove  ( vc ) ; } else  if  (  ae == null )  {   idMap . put  ( typeId , vc ) ; } else  {  throw  new RuntimeException  ( "FIXME: Unexpected type. You should not get here!" ) ; } } }  assert  inc != null ;   currentAssociationEnd = inc ;  if  (  currentClass instanceof EdgeClass )  {   ownedEnds . add  ( inc ) ; }   inc . set_aggregation  (  aggregation ?  AggregationKind . SHARED :  composition ?  AggregationKind . COMPOSITE :  AggregationKind . NONE ) ;   idMap . put  ( xmiId , inc ) ;   inc . set_roleName  ( endName ) ; }   private void reconnectEdges  (  Vertex oldVertex ,  Vertex newVertex )  {  Edge  curr =  oldVertex . getFirstIncidence  ( ) ;  while  (  curr != null )  {  Edge  next =  curr . getNextIncidence  ( ) ;   curr . setThis  ( newVertex ) ;   curr = next ; } }   private Domain createDomain  (  String typeName )  {  Domain  dom =  domainMap . get  ( typeName ) ;  if  (  dom != null )  {  return dom ; }  if  (  typeName . equals  ( "String" ) )  {   dom =  sg . createStringDomain  ( ) ; } else  if  (  typeName . equals  ( "Integer" ) )  {   dom =  sg . createIntegerDomain  ( ) ; } else  if  (  typeName . equals  ( "Double" ) )  {   dom =  sg . createDoubleDomain  ( ) ; } else  if  (  typeName . equals  ( "Long" ) )  {   dom =  sg . createLongDomain  ( ) ; } else  if  (  typeName . equals  ( "Boolean" ) )  {   dom =  sg . createBooleanDomain  ( ) ; } else  if  (   typeName . startsWith  ( "Map<" ) &&  typeName . endsWith  ( ">" ) )  {   dom =  sg . createMapDomain  ( ) ;  String  keyValueDomains =  typeName . substring  ( 4 ,   typeName . length  ( ) - 1 ) ;    char  [ ]  c =  keyValueDomains . toCharArray  ( ) ;   int  p = 0 ;  for (   int  i = 0 ;  i <  c . length ;  ++ i )  {  if  (   (   c [ i ] == ',' ) &&  (  p == 0 ) )  {   p = i ;  break ; }  if  (   c [ i ] == '<' )  {   ++ p ; } else  if  (   c [ i ] == '>' )  {   -- p ; }  if  (  p < 0 )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "Error in primitive type name: '" + typeName + "'" ) ; } }  if  (   (  p <= 0 ) ||  (  p >=  (   c . length - 1 ) ) )  {  throw  new ProcessingException  (  getFileName  ( ) ,   "Error in primitive type name: '" + typeName + "'" ) ; }  String  keyDomainName =  keyValueDomains . substring  ( 0 , p ) ;  Domain  keyDomain =  createDomain  ( keyDomainName ) ;  assert  keyDomain != null ;  String  valueDomainName =  keyValueDomains . substring  (  p + 1 ) ;  Domain  valueDomain =  createDomain  ( valueDomainName ) ;  assert  valueDomain != null ;   sg . createHasKeyDomain  (  ( MapDomain ) dom , keyDomain ) ;   sg . createHasValueDomain  (  ( MapDomain ) dom , valueDomain ) ;   typeName =     "Map<" + keyDomainName + ", " + valueDomainName + '>' ; } else  if  (   typeName . startsWith  ( "List<" ) &&  typeName . endsWith  ( ">" ) )  {   dom =  sg . createListDomain  ( ) ;  String  compTypeName =  typeName . substring  ( 5 ,   typeName . length  ( ) - 1 ) ;  Domain  compDomain =  createDomain  ( compTypeName ) ;  assert  compDomain != null ;   sg . createHasBaseDomain  (  ( CollectionDomain ) dom , compDomain ) ; } else  if  (   typeName . startsWith  ( "Set<" ) &&  typeName . endsWith  ( ">" ) )  {   dom =  sg . createSetDomain  ( ) ;  String  compTypeName =  typeName . substring  ( 4 ,   typeName . length  ( ) - 1 ) ;  Domain  compDomain =  createDomain  ( compTypeName ) ;  assert  compDomain != null ;   sg . createHasBaseDomain  (  ( CollectionDomain ) dom , compDomain ) ; }  if  (  dom != null )  {   sg . createContainsDomain  (  packageStack . get  ( 0 ) , dom ) ; } else  {   dom =  sg . createStringDomain  ( ) ;   preliminaryVertices . add  ( dom ) ; }  assert  dom != null ;   dom . set_qualifiedName  ( typeName ) ;   domainMap . put  ( typeName , dom ) ;  return dom ; }   private String getQualifiedName  (  String simpleName )  {  assert  simpleName != null ;   simpleName =  simpleName . trim  ( ) ;  Package  p =  packageStack . peek  ( ) ;  assert  p != null ;  if  (   p . get_qualifiedName  ( ) . equals  ( "" ) )  {  return simpleName ; } else  {  return    p . get_qualifiedName  ( ) + "." + simpleName ; } }   public void setUseFromRole  (  boolean useFromRole )  {    this . useFromRole = useFromRole ; }   public boolean isUseFromRole  ( )  {  return useFromRole ; }   public void setRemoveUnusedDomains  (  boolean removeUnusedDomains )  {    this . removeUnusedDomains = removeUnusedDomains ; }   public boolean isRemoveUnusedDomains  ( )  {  return removeUnusedDomains ; }   public void setUseNavigability  (  boolean useNavigability )  {    this . useNavigability = useNavigability ; }   public boolean isUseNavigability  ( )  {  return useNavigability ; }   public SchemaGraph getSchemaGraph  ( )  {  return sg ; }   public void setSuppressOutput  (  boolean suppressOutput )  {    this . suppressOutput = suppressOutput ; }   public String getFilenameSchema  ( )  {  return filenameSchema ; }   public void setFilenameSchema  (  String filenameSchema )  {    this . filenameSchema = filenameSchema ; }   public String getFilenameSchemaGraph  ( )  {  return filenameSchemaGraph ; }   public void setFilenameSchemaGraph  (  String filenameSchemaGraph )  {    this . filenameSchemaGraph = filenameSchemaGraph ; }   public String getFilenameDot  ( )  {  return filenameDot ; }   public void setFilenameDot  (  String filenameDot )  {    this . filenameDot = filenameDot ; }   public String getFilenameValidation  ( )  {  return filenameValidation ; }   public void setFilenameValidation  (  String filenameValidation )  {    this . filenameValidation = filenameValidation ; }   public boolean isKeepEmptyPackages  ( )  {  return keepEmptyPackages ; }   public void setKeepEmptyPackages  (  boolean removeEmptyPackages )  {   keepEmptyPackages = removeEmptyPackages ; } }