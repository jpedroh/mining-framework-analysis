  package    de . uni_koblenz . jgralab . eca ;   import   java . io . BufferedInputStream ;  import   java . io . BufferedOutputStream ;  import   java . io . Closeable ;  import   java . io . DataOutputStream ;  import   java . io . FileInputStream ;  import   java . io . FileOutputStream ;  import   java . io . IOException ;  import   java . util . ArrayList ;  import   java . util . List ;  import    de . uni_koblenz . jgralab . AttributedElement ;  import    de . uni_koblenz . jgralab . Graph ;  import      de . uni_koblenz . jgralab . eca . events . ChangeAttributeEventDescription ;  import      de . uni_koblenz . jgralab . eca . events . ChangeEdgeEventDescription ;  import       de . uni_koblenz . jgralab . eca . events . ChangeEdgeEventDescription . EdgeEnd ;  import      de . uni_koblenz . jgralab . eca . events . CreateEdgeEventDescription ;  import      de . uni_koblenz . jgralab . eca . events . CreateVertexEventDescription ;  import      de . uni_koblenz . jgralab . eca . events . DeleteEdgeEventDescription ;  import      de . uni_koblenz . jgralab . eca . events . DeleteVertexEventDescription ;  import      de . uni_koblenz . jgralab . eca . events . EventDescription ;  import       de . uni_koblenz . jgralab . eca . events . EventDescription . EventTime ;  import     de . uni_koblenz . jgralab . gretl . Transformation ;  import      de . uni_koblenz . jgralab . gretl . eca . GretlTransformAction ;  import     de . uni_koblenz . jgralab . schema . AttributedElementClass ;  import     de . uni_koblenz . jgralab . schema . Schema ;   public class ECAIO  {   public static  List  < ECARule > loadECArules  (  Schema schema ,  String filename )  throws ECAIOException  {  BufferedInputStream  inputStream = null ;  try  {   inputStream =  new BufferedInputStream  (  new FileInputStream  ( filename ) , BUFFER_SIZE ) ;  ECAIO  ecaLoader =  new ECAIO  ( ) ;    ecaLoader . inStream = inputStream ;    ecaLoader . schema = schema ;   ecaLoader . load  ( ) ;  return  ecaLoader . rules ; }  catch (   IOException e )  {  throw  new ECAIOException  (  "Error while reading file " + filename ) ; }  finally  {   close  ( inputStream ) ; } }   public static void saveECArules  (  Schema schema ,  String filename ,   List  < ECARule > rules )  throws ECAIOException  {  DataOutputStream  out = null ;  try  {   out =  new DataOutputStream  (  new BufferedOutputStream  (  new FileOutputStream  ( filename ) , BUFFER_SIZE ) ) ;  ECAIO  ecaSaver =  new ECAIO  ( ) ;    ecaSaver . rules = rules ;    ecaSaver . schema = schema ;    ecaSaver . outStream = out ;   ecaSaver . save  ( ) ; }  catch (   IOException ex )  {  throw  new ECAIOException  (  "Error while saving ECA rules to " + filename ) ; }  finally  {   close  ( out ) ; } }   private static final  int  BUFFER_SIZE = 65536 ;   private Schema  schema ;   private  List  < ECARule >  rules ;   private BufferedInputStream  inStream ;   private DataOutputStream  outStream ;   int  la ;   private ECAIO  ( )  {   rules =  new  ArrayList  < ECARule >  ( ) ; }   private void save  ( )  throws ECAIOException  {  for ( ECARule rule : rules )  {   saveRule  ( rule ) ; } }   private void saveRule  (  ECARule rule )  throws ECAIOException  {   saveEventDescriptionToStream  (  rule . getEventDescription  ( ) ) ;  if  (   rule . getCondition  ( ) != null )  {   saveConditionToStream  (  rule . getCondition  ( ) ) ; }   saveActionToStream  (  rule . getAction  ( ) ) ; }   private void saveEventDescriptionToStream  (  EventDescription ev )  throws ECAIOException  {  String  eventDescriptionString = "" ;  if  (   ev . getContext  ( ) . equals  (   EventDescription . Context . EXPRESSION ) )  {   eventDescriptionString +=  ev . getContextExpression  ( ) ;   eventDescriptionString += " : " ; }  if  (   ev . getTime  ( ) . equals  (  EventTime . AFTER ) )  {   eventDescriptionString += "after " ; } else  {   eventDescriptionString += "before " ; }   eventDescriptionString +=  getEventDescriptionType  ( ev ) ;   writeToStream  ( eventDescriptionString ) ; }   private String getEventDescriptionType  (  EventDescription ev )  {  if  (  ev instanceof CreateVertexEventDescription )  {  return   "createdVertex(" +  getEventElementTypeString  ( ev ) + ") " ; } else  if  (  ev instanceof DeleteVertexEventDescription )  {  return   "deletedVertex(" +  getEventElementTypeString  ( ev ) + ") " ; } else  if  (  ev instanceof ChangeAttributeEventDescription )  {  return     "updatedAttributeValue(" +  getEventElementTypeString  ( ev ) + ", " +   (  ( ChangeAttributeEventDescription ) ev ) . getConcernedAttribute  ( ) + ")" ; } else  if  (  ev instanceof ChangeEdgeEventDescription )  {  if  (    (  ( ChangeEdgeEventDescription ) ev ) . getEdgeEnd  ( ) . equals  (  EdgeEnd . ALPHA ) )  {  return   "updatedStartVertex(" +  getEventElementTypeString  ( ev ) + ") " ; } else  if  (    (  ( ChangeEdgeEventDescription ) ev ) . getEdgeEnd  ( ) . equals  (  EdgeEnd . OMEGA ) )  {  return   "updatedEndVertex(" +  getEventElementTypeString  ( ev ) + ") " ; } else  {  return   "updatedStartOrEndVertex(" +  getEventElementTypeString  ( ev ) + ") " ; } } else  if  (  ev instanceof CreateEdgeEventDescription )  {  return   "createdEdge(" +  getEventElementTypeString  ( ev ) + ") " ; } else  {  return   "deletedEdge(" +  getEventElementTypeString  ( ev ) + ") " ; } }   private String getEventElementTypeString  (  EventDescription ev )  {  String  nameOfGraphElementClass = "" ;  if  (   ev . getContext  ( ) . equals  (   EventDescription . Context . TYPE ) )  {   nameOfGraphElementClass +=    ev . getType  ( ) . getName  ( ) . replace  (   schema . getPackagePrefix  ( ) + "." , "" ) ; }  return nameOfGraphElementClass ; }   private void saveConditionToStream  (  Condition cond )  throws ECAIOException  {  if  (  cond instanceof GreqlCondition )  {   writeToStream  (   " with \"" +   (  ( GreqlCondition ) cond ) . getConditionExpression  ( ) + "\" " ) ; } else  {   writeToStream  (   " with class " +   cond . getClass  ( ) . getName  ( ) + " " ) ; } }   private void saveActionToStream  (  Action act )  throws ECAIOException  {  String  actionstring = "do " ;  if  (  act instanceof PrintAction )  {   actionstring += "print \"" ;   actionstring +=   (  ( PrintAction ) act ) . getMessage  ( ) ;   actionstring += "\"" ;   actionstring += "\n" ; } else  if  (  act instanceof GretlTransformAction )  {  GretlTransformAction  gta =  (  ( GretlTransformAction ) act ) ;   actionstring +=   gta . getTransformationClass  ( ) . getName  ( ) ; } else  {   actionstring +=   act . getClass  ( ) . getName  ( ) ; }   writeToStream  ( actionstring ) ; }   private void writeToStream  (  String text )  throws ECAIOException  {  try  {   outStream . writeChars  ( text ) ; }  catch (   IOException e )  {  throw  new ECAIOException  (   "Error while writing " + text + " to stream." ) ; } }   private void load  ( )  throws ECAIOException  {   la = 0 ;  while  (  la !=  - 1 )  {   parseRule  ( ) ;   skipWs  ( ) ; } }   private void parseRule  ( )  throws ECAIOException  {  EventDescription  ed =  parseEventDescription  ( ) ;  Condition  cond =  parseCondition  ( ) ;  Action  action =  parseAction  ( ) ;  if  (  cond == null )  {   rules . add  (  new ECARule  ( ed , action ) ) ; } else  {   rules . add  (  new ECARule  ( ed , cond , action ) ) ; } }   private EventDescription parseEventDescription  ( )  throws ECAIOException  {  String  context = null ;  String  currentToken =  nextToken  ( ) ;  String  lookAheadToken =  nextToken  ( ) ;  if  (  lookAheadToken . equals  ( ":" ) )  {   context = currentToken ;   currentToken =  nextToken  ( ) ;   lookAheadToken =  nextToken  ( ) ; }  EventTime  et =  getEventTime  ( currentToken ) ;  String  eventdestype = lookAheadToken ;  String  type = null ;   match  ( "(" ) ;  if  (  context == null )  {   type =  nextToken  ( ) ; }  if  (  eventdestype . equals  ( "updatedAttributeValue" ) )  {   match  ( "," ) ;  return  finishChangeAttributeEventDescription  ( context , et , type ) ; } else  {   match  ( ")" ) ;  if  (  eventdestype . equals  ( "createdVertex" ) )  {  return  finishCreateVertexEvent  ( context , et , type ) ; } else  if  (  eventdestype . equals  ( "createdEdge" ) )  {  return  finishCreateEdgeEventDescription  ( context , et , type ) ; } else  if  (  eventdestype . equals  ( "updatedStartVertex" ) )  {  return  finishChangeEdgeEventDescription  ( context , et , type ,  EdgeEnd . ALPHA ) ; } else  if  (  eventdestype . equals  ( "updatedEndVertex" ) )  {  return  finishChangeEdgeEventDescription  ( context , et , type ,  EdgeEnd . OMEGA ) ; } else  if  (  eventdestype . equals  ( "updatedStartOrEndVertex" ) )  {  return  finishChangeEdgeEventDescription  ( context , et , type ,  EdgeEnd . ANY ) ; } else  if  (  eventdestype . equals  ( "deletedVertex" ) )  {  return  finishDeleteVertexEventDescription  ( context , et , type ) ; } else  if  (  eventdestype . equals  ( "deletedEdge" ) )  {  return  finishDeleteEdgeEventDescription  ( context , et , type ) ; } else  {  throw  new ECAIOException  (       "Type of EventDescription not recognized. Found " + eventdestype + " Possible are \"createVertex\", \"deleteVertex\", " + "\"createEdge\", \"deleteEdge\", " + "\"updatedStartVertex\", \"updatedEndVertex\", " + "\"updatedStartOrEndVertex\"" + "\"changeAttributeValue" ) ; } } }   private EventTime getEventTime  (  String eventTimeString )  throws ECAIOException  {  EventTime  eventTime ;  if  (  eventTimeString . equals  ( "after" ) )  {   eventTime =  EventTime . AFTER ; } else  if  (  eventTimeString . equals  ( "before" ) )  {   eventTime =  EventTime . BEFORE ; } else  {  throw  new ECAIOException  (   "EventTime expected. Possible are \"before\" and \"after\". Found: \"" + eventTimeString + "\" " ) ; }  return eventTime ; }   private EventDescription finishDeleteEdgeEventDescription  (  String context ,  EventTime eventTime ,  String qualNameOfGraphElementToMonitor )  throws ECAIOException  {  if  (   context != null &&  qualNameOfGraphElementToMonitor == null )  {  return  new DeleteEdgeEventDescription  ( eventTime , context ) ; } else  if  (   context == null &&  qualNameOfGraphElementToMonitor != null )  {  return  new DeleteEdgeEventDescription  ( eventTime ,  getAttributedElement  ( qualNameOfGraphElementToMonitor ) ) ; } else  {  throw  new ECAIOException  (     "It's necessary to give a context OR a type. Its an XOR. Found: context: \"" + context + "\" and GraphElementType: \"" + qualNameOfGraphElementToMonitor + "\"" ) ; } }   private EventDescription finishDeleteVertexEventDescription  (  String context ,  EventTime eventTime ,  String qualNameOfGraphElementToMonitor )  throws ECAIOException  {  if  (   context != null &&  qualNameOfGraphElementToMonitor == null )  {  return  new DeleteVertexEventDescription  ( eventTime , context ) ; } else  if  (   context == null &&  qualNameOfGraphElementToMonitor != null )  {  return  new DeleteVertexEventDescription  ( eventTime ,  getAttributedElement  ( qualNameOfGraphElementToMonitor ) ) ; } else  {  throw  new ECAIOException  (     "It's necessary to give a context OR a type. Its an XOR. Found: context: \"" + context + "\" and type: \"" + qualNameOfGraphElementToMonitor + "\"" ) ; } }   private EventDescription finishChangeEdgeEventDescription  (  String context ,  EventTime eventTime ,  String qualNameOfGraphElementToMonitor ,  EdgeEnd edgeEnd )  throws ECAIOException  {  if  (   context != null &&  qualNameOfGraphElementToMonitor == null )  {  return  new ChangeEdgeEventDescription  ( eventTime , context ) ; } else  if  (   context == null &&  qualNameOfGraphElementToMonitor != null )  {  return  new ChangeEdgeEventDescription  ( eventTime ,  getAttributedElement  ( qualNameOfGraphElementToMonitor ) , edgeEnd ) ; } else  {  throw  new ECAIOException  (     "It's necessary to give a context OR a type. Its an XOR. Found: context: \"" + context + "\" and type: \"" + qualNameOfGraphElementToMonitor + "\"" ) ; } }   private EventDescription finishChangeAttributeEventDescription  (  String context ,  EventTime eventTime ,  String qualNameOfGraphElementToMonitor )  throws ECAIOException  {  String  name =  nextToken  ( ) ;   match  ( ")" ) ;  if  (   context != null &&  qualNameOfGraphElementToMonitor == null )  {  return  new ChangeAttributeEventDescription  ( eventTime , context , name ) ; } else  if  (   context == null &&  qualNameOfGraphElementToMonitor != null )  {  return  new ChangeAttributeEventDescription  ( eventTime ,  getAttributedElement  ( qualNameOfGraphElementToMonitor ) , name ) ; } else  {  throw  new ECAIOException  (     "It's necessary to give a context OR a type. Its an XOR. Found: context: \"" + context + "\" and type: \"" + qualNameOfGraphElementToMonitor + "\"" ) ; } }   private EventDescription finishCreateEdgeEventDescription  (  String context ,  EventTime eventTime ,  String qualNameOfGraphElementToMonitor )  throws ECAIOException  {  if  (   context != null &&  qualNameOfGraphElementToMonitor == null )  {  return  new CreateEdgeEventDescription  ( eventTime , context ) ; } else  if  (   context == null &&  qualNameOfGraphElementToMonitor != null )  {  return  new CreateEdgeEventDescription  ( eventTime ,  getAttributedElement  ( qualNameOfGraphElementToMonitor ) ) ; } else  {  throw  new ECAIOException  (     "It's necessary to give a context OR a type. Its an XOR. Found: context: \"" + context + "\" and type: \"" + qualNameOfGraphElementToMonitor + "\"" ) ; } }   private EventDescription finishCreateVertexEvent  (  String context ,  EventTime eventTime ,  String qualNameOfGraphElementToMonitor )  throws ECAIOException  {  if  (   context != null &&  qualNameOfGraphElementToMonitor == null )  {  return  new CreateVertexEventDescription  ( eventTime , context ) ; } else  if  (   context == null &&  qualNameOfGraphElementToMonitor != null )  {  return  new CreateVertexEventDescription  ( eventTime ,  getAttributedElement  ( qualNameOfGraphElementToMonitor ) ) ; } else  {  throw  new ECAIOException  (     "It's necessary to give a context OR a type. Its an XOR. Found: context: \"" + context + "\" and type: \"" + qualNameOfGraphElementToMonitor + "\"" ) ; } }   private  Class  <  ? extends AttributedElement > getAttributedElement  (  String name )  {   Class  <  ? extends AttributedElement >  aecl ;  AttributedElementClass  aeclo =  schema . getAttributedElementClass  ( name ) ;   aecl =  aeclo . getM1Class  ( ) ;  return aecl ; }   private Condition parseCondition  ( )  throws ECAIOException  {  String  currentToken =  nextToken  ( ) ;  if  (  isMatching  ( currentToken , "do" ) )  {  return null ; } else  if  (  isMatching  ( currentToken , "with" ) )  {  String  condexpr =  nextToken  ( ) ;  if  (  condexpr . equals  ( "class" ) )  {   condexpr =  nextToken  ( ) ;  Condition  cond ;  try  {    System . out . println  (  "classname: " + condexpr ) ;   Class  <  ? >  conditionclass =  Class . forName  ( condexpr ) ;   cond =  ( Condition )  conditionclass . newInstance  ( ) ; }  catch (   ClassNotFoundException e )  {  throw  new ECAIOException  (   "Specified Condition " + currentToken + " not found." ) ; }  catch (   InstantiationException e )  {  throw  new ECAIOException  (  "Error while instanciating Condition " + currentToken ) ; }  catch (   IllegalAccessException e )  {  throw  new ECAIOException  (  "Error while instanciating Condition " + currentToken ) ; }   match  ( "do" ) ;  return cond ; } else  {   match  ( "do" ) ;  return  new GreqlCondition  ( condexpr ) ; } } else  {  throw  new ECAIOException  (   "Parsing Error. Expected \"do\" or \"with\". Found: \"" + currentToken + "\"" ) ; } }    @ SuppressWarnings  ( "unchecked" ) private Action parseAction  ( )  throws ECAIOException  {  String  currentToken =  nextToken  ( ) ;  if  (  isMatching  ( "print" , currentToken ) )  {  String  message =  nextToken  ( ) ;  return  new PrintAction  ( message ) ; } else  {  try  {   Class  <  ? >  actionclass =  Class . forName  ( currentToken ) ;  if  (   actionclass . getSuperclass  ( ) . equals  (  Transformation . class ) )  {  return  new GretlTransformAction  (  (  Class  <  ? extends  Transformation  < Graph > > ) actionclass ) ; } else  {  return  ( Action )  actionclass . newInstance  ( ) ; } }  catch (   ClassNotFoundException e )  {  throw  new ECAIOException  (   "Specified Action " + currentToken + " not found." ) ; }  catch (   InstantiationException e )  {  throw  new ECAIOException  (  "Error while instanciating Action " + currentToken ) ; }  catch (   IllegalAccessException e )  {  throw  new ECAIOException  (  "Error while instanciating Action " + currentToken ) ; } } }   private boolean isMatching  (  String one ,  String two )  {  if  (  one . equals  ( two ) )  {  return true ; } else  {  return false ; } }   private void match  (  String expected )  throws ECAIOException  {  String  token =  nextToken  ( ) ;  if  (  !  token . equals  ( expected ) )  {  throw  new ECAIOException  (     "Parsing Error: Expected \"" + expected + "\" Found: \"" + token + "\"" ) ; } }   private String nextToken  ( )  throws ECAIOException  {  StringBuilder  out =  new StringBuilder  ( ) ;  try  {   skipWs  ( ) ;  if  (  la == '"' )  {   readUtfString  ( out ) ; } else  if  (  isUnitSymbol  ( la ) )  {   out . append  (  (  char ) la ) ;   la =  inStream . read  ( ) ; } else  {  if  (  la !=  - 1 )  {  do  {   out . append  (  (  char ) la ) ;   la =  inStream . read  ( ) ; } while  (    !  isWs  ( la ) &&  !  isUnitSymbol  ( la ) &&  (  la !=  - 1 ) ) ; } } }  catch (   IOException e )  {  throw  new ECAIOException  ( "Error while reading next token from stream." ) ; }  return  myTrim0  (  out . toString  ( ) ) ; }   private final void skipWs  ( )  throws ECAIOException  {  while  (   isWs  ( la ) ||  la == 0 )  {  try  {   la =  inStream . read  ( ) ; }  catch (   IOException e )  {  throw  new ECAIOException  ( "Error while reading from stream." ) ; } } }   private String myTrim0  (  String x )  {    char  [ ]  ar =  x . toCharArray  ( ) ;  String  ex = "" ;  for (   int  i = 0 ;  i <  ar . length ;  i ++ )  {  if  (   ar [ i ] != 0 )  {   ex +=  ar [ i ] ; } }  return ex ; }   private boolean isWs  (   int c )  {  return     (  c == ' ' ) ||  (  c == '\n' ) ||  (  c == '\t' ) ||  (  c == '\r' ) ; }   private boolean isUnitSymbol  (   int c )  {  return      (  c == '>' ) ||  (  c == '<' ) ||  (  c == '(' ) ||  (  c == ')' ) ||  (  c == ',' ) ; }   private final void readUtfString  (  StringBuilder out )  throws IOException  {   la =  inStream . read  ( ) ;  LOOP :  while  (   (  la !=  - 1 ) &&  (  la != '"' ) )  {  if  (  la == 0 )  {   la =  inStream . read  ( ) ;  continue ; }  if  (   (  la < 32 ) ||  (  la > 127 ) )  {  throw  new RuntimeException  (   "invalid character '" +  (  char ) la + "'" ) ; }  if  (  la == '\\' )  {   la =  inStream . read  ( ) ;  if  (  la ==  - 1 )  {  break LOOP ; }  switch  ( la )  {   case '\\' :   la = '\\' ;  break ;   case '"' :   la = '"' ;  break ;   case 'n' :   la = '\n' ;  break ;   case 'r' :   la = '\r' ;  break ;   case 't' :   la = '\t' ;  break ;   case 'u' :   la =  inStream . read  ( ) ;  if  (  la ==  - 1 )  {  break LOOP ; }  String  unicode =  "" +  (  char ) la ;   la =  inStream . read  ( ) ;  if  (  la ==  - 1 )  {  break LOOP ; }   unicode +=  (  char ) la ;   la =  inStream . read  ( ) ;  if  (  la ==  - 1 )  {  break LOOP ; }   unicode +=  (  char ) la ;   la =  inStream . read  ( ) ;  if  (  la ==  - 1 )  {  break LOOP ; }   unicode +=  (  char ) la ;  try  {   la =  Integer . parseInt  ( unicode , 16 ) ; }  catch (   NumberFormatException e )  {  throw  new RuntimeException  (  "invalid unicode escape sequence '\\u" + unicode ) ; }  break ;   default :  throw  new RuntimeException  ( "invalid escape sequence in string" ) ; } }   out . append  (  (  char ) la ) ;   la =  inStream . read  ( ) ; }   la =  inStream . read  ( ) ; }   private static void close  (  Closeable stream )  throws ECAIOException  {  try  {  if  (  stream != null )  {   stream . close  ( ) ; } }  catch (   IOException ex )  {  throw  new ECAIOException  ( "Exception while closing the stream." , ex ) ; } } }