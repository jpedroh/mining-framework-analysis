  package     de . uni_koblenz . jgralab . schema . impl ;   import   java . io . IOException ;  import   java . util . List ;  import   org . pcollections . PVector ;  import    de . uni_koblenz . jgralab . GraphIO ;  import    de . uni_koblenz . jgralab . GraphIOException ;  import    de . uni_koblenz . jgralab . JGraLab ;  import     de . uni_koblenz . jgralab . codegenerator . CodeBlock ;  import     de . uni_koblenz . jgralab . codegenerator . CodeGenerator ;  import     de . uni_koblenz . jgralab . codegenerator . CodeSnippet ;  import     de . uni_koblenz . jgralab . schema . EnumDomain ;  import     de . uni_koblenz . jgralab . schema . Package ;  import      de . uni_koblenz . jgralab . schema . exception . InvalidNameException ;  import      de . uni_koblenz . jgralab . schema . exception . SchemaClassAccessException ;  import       de . uni_koblenz . jgralab . schema . impl . compilation . SchemaClassManager ;  import      de . uni_koblenz . jgralab . schema . exception . SchemaException ;   public final class EnumDomainImpl  extends DomainImpl  implements  EnumDomain  {   private  PVector  < String >  constants =  JGraLab . vector  ( ) ;   private  Class  <  ? extends Object >  schemaClass ;  EnumDomainImpl  (  String sn ,  Package pkg ,   List  < String > constants )  {  super  ( sn , pkg ) ;  for ( String c : constants )  {   addConst  ( c ) ; } }    @ Override public void addConst  (  String aConst )  {  if  (   (  ( SchemaImpl )  getSchema  ( ) ) . isFinish  ( ) )  {  throw  new SchemaException  ( "No changes to finished schema!" ) ; }  if  (  constants . contains  ( aConst ) )  {  throw  new InvalidNameException  (    "Try to add duplicate constant '" + aConst + "' to EnumDomain" +  getQualifiedName  ( ) ) ; }  if  (  !   getSchema  ( ) . isValidEnumConstant  ( aConst ) )  {  throw  new InvalidNameException  (  aConst + " is not a valid enumeration constant." ) ; }   constants =  constants . plus  ( aConst ) ; }    @ Override public  PVector  < String > getConsts  ( )  {  return constants ; }    @ Override public String getJavaAttributeImplementationTypeName  (  String schemaRootPackagePrefix )  {  return   schemaRootPackagePrefix + "." +  getQualifiedName  ( ) ; }    @ Override public String getJavaClassName  (  String schemaRootPackagePrefix )  {  return  getJavaAttributeImplementationTypeName  ( schemaRootPackagePrefix ) ; }    @ Override public CodeBlock getReadMethod  (  String schemaPrefix ,  String variableName ,  String graphIoVariableName )  {  return  new CodeSnippet  (      variableName + " = " +  getJavaAttributeImplementationTypeName  ( schemaPrefix ) + ".valueOfPermitNull(" + graphIoVariableName + ".matchEnumConstant());" ) ; }    @ Override public String getTGTypeName  (  Package pkg )  {  return  getQualifiedName  ( pkg ) ; }    @ Override public CodeBlock getWriteMethod  (  String schemaRootPackagePrefix ,  String variableName ,  String graphIoVariableName )  {  CodeSnippet  code =  new CodeSnippet  ( ) ;   code . add  (   "if (" + variableName + " != null) {" ) ;   code . add  (     "\t" + graphIoVariableName + ".writeIdentifier(" + variableName + ".toString());" ) ;   code . add  ( "} else {" ) ;   code . add  (   "\t" + graphIoVariableName + ".writeIdentifier(GraphIO.NULL_LITERAL);" ) ;   code . add  ( "}" ) ;  return code ; }    @ Override public boolean isComposite  ( )  {  return false ; }    @ Override public String toString  ( )  {  StringBuilder  output =  new StringBuilder  (   "domain Enum " +  getQualifiedName  ( ) + " (" ) ;  String  delim = "" ;   int  count = 0 ;  for ( String s : constants )  {   output . append  (    delim +  count ++ + ": " + s ) ;   delim = ", " ; }   output . append  ( ")" ) ;  return  output . toString  ( ) ; }    @ Override public CodeBlock getTransactionReadMethod  (  String schemaPrefix ,  String variableName ,  String graphIoVariableName )  {  return  new CodeSnippet  (         getJavaAttributeImplementationTypeName  ( schemaPrefix ) + " " + variableName + " = " +  getJavaAttributeImplementationTypeName  ( schemaPrefix ) + ".valueOfPermitNull(" + graphIoVariableName + ".matchEnumConstant());" ) ; }    @ Override public CodeBlock getTransactionWriteMethod  (  String schemaRootPackagePrefix ,  String variableName ,  String graphIoVariableName )  {  return  getWriteMethod  ( schemaRootPackagePrefix ,   "get" +  CodeGenerator . camelCase  ( variableName ) + "()" , graphIoVariableName ) ; }    @ Override public String getTransactionJavaAttributeImplementationTypeName  (  String schemaRootPackagePrefix )  {  return  getJavaAttributeImplementationTypeName  ( schemaRootPackagePrefix ) ; }    @ Override public String getTransactionJavaClassName  (  String schemaRootPackagePrefix )  {  return  getJavaClassName  ( schemaRootPackagePrefix ) ; }    @ Override public String getVersionedClass  (  String schemaRootPackagePrefix )  {  return   "de.uni_koblenz.jgralab.impl.trans.VersionedReferenceImpl<" +  getTransactionJavaAttributeImplementationTypeName  ( schemaRootPackagePrefix ) + ">" ; }    @ Override public String getInitialValue  ( )  {  return "null" ; }    @ Override public boolean isPrimitive  ( )  {  return false ; }    @ Override public  Class  <  ? extends Object > getSchemaClass  ( )  {  if  (  schemaClass == null )  {  String  schemaClassName =     getSchema  ( ) . getPackagePrefix  ( ) + "." +  getQualifiedName  ( ) ;  try  {   schemaClass =  Class . forName  ( schemaClassName , true ,  SchemaClassManager . instance  (   getSchema  ( ) . getQualifiedName  ( ) ) ) ; }  catch (   ClassNotFoundException e )  {  throw  new SchemaClassAccessException  (   "Can't load (generated) schema class for EnumDomain '" +  getQualifiedName  ( ) + "'" , e ) ; } }  return schemaClass ; }    @ Override public Object parseGenericAttribute  (  GraphIO io )  throws GraphIOException  {  String  result =  io . matchEnumConstant  ( ) ;  return result ; }    @ Override public void serializeGenericAttribute  (  GraphIO io ,  Object data )  throws IOException  {  if  (  data != null )  {   io . writeIdentifier  (  ( String ) data ) ; } else  {   io . writeIdentifier  (  GraphIO . NULL_LITERAL ) ; } }    @ Override public boolean genericIsConform  (  Object value )  {  boolean  result = true ;  if  (  value == null )  {  return result ; }  return  result &=   value instanceof String &&   this . getConsts  ( ) . contains  ( value ) ; } }