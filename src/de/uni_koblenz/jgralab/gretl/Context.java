  package    de . uni_koblenz . jgralab . gretl ;   import    java . lang . reflect . Method ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . Map ;  import    java . util . Map . Entry ;  import   java . util . Random ;  import   java . util . Set ;  import   java . util . TreeSet ;  import    java . util . logging . Logger ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import   org . pcollections . Empty ;  import   org . pcollections . PMap ;  import    de . uni_koblenz . jgralab . AttributedElement ;  import    de . uni_koblenz . jgralab . Graph ;  import    de . uni_koblenz . jgralab . GraphElement ;  import    de . uni_koblenz . jgralab . ImplementationType ;  import    de . uni_koblenz . jgralab . JGraLab ;  import      de . uni_koblenz . jgralab . greql2 . evaluator . GreqlEvaluatorImpl ;  import      de . uni_koblenz . jgralab . greql2 . evaluator . QueryImpl ;  import     de . uni_koblenz . jgralab . schema . AttributedElementClass ;  import     de . uni_koblenz . jgralab . schema . GraphClass ;  import     de . uni_koblenz . jgralab . schema . GraphElementClass ;  import     de . uni_koblenz . jgralab . schema . Schema ;  import      de . uni_koblenz . jgralab . schema . exception . SchemaException ;  import      de . uni_koblenz . jgralab . schema . impl . NamedElementImpl ;  import      de . uni_koblenz . jgralab . schema . impl . SchemaImpl ;  import       de . uni_koblenz . jgralab . schema . impl . compilation . SchemaClassManager ;   public class Context  {   private static Logger  logger =  JGraLab . getLogger  (    Context . class . getPackage  ( ) . getName  ( ) ) ;   public static final String  DEFAULT_SOURCE_GRAPH_ALIAS = "default" ;   public static final String  DEFAULT_TARGET_GRAPH_ALIAS = "target" ;   private static final Pattern  QUERY_GRAPH_ALIAS_PATTERN =  Pattern . compile  ( "\\p{Space}*(#(\\p{Alnum}+)#\\p{Space}*).*" ,  Pattern . DOTALL ) ;   private final  Map  < String , Graph >  sourceGraphs =  new  HashMap  < String , Graph >  ( 1 ) ;  Schema  targetSchema = null ;   public final Schema getTargetSchema  ( )  {  return targetSchema ; }  Graph  targetGraph = null ;   public enum TransformationPhase  {  SCHEMA ,  GRAPH }  TransformationPhase  phase =  TransformationPhase . SCHEMA ;   public final TransformationPhase getPhase  ( )  {  return phase ; }   private String  targetSchemaName ;   private String  targetGraphClassName ;  boolean  outermost = true ;   private  Map  <  AttributedElementClass  <  ? ,  ? > ,  PMap  < Object ,  AttributedElement  <  ? ,  ? > > >  imgMap =  new  HashMap  <  AttributedElementClass  <  ? ,  ? > ,  PMap  < Object ,  AttributedElement  <  ? ,  ? > > >  ( ) ;   private  Map  <  AttributedElementClass  <  ? ,  ? > ,  PMap  <  AttributedElement  <  ? ,  ? > , Object > >  archMap =  new  HashMap  <  AttributedElementClass  <  ? ,  ? > ,  PMap  <  AttributedElement  <  ? ,  ? > , Object > >  ( ) ;   private final  Map  < String , Object >  greqlExtraVars =  new  HashMap  < String , Object >  ( ) ;   private final  Set  < String >  greqlImports =  new  HashSet  < String >  ( ) ;   final void setGReQLVariable  (  String name ,  Object val )  {   greqlExtraVars . put  ( name , val ) ; }   final void setGReQLVariable  (  String name ,  String greqlExpression )  {   greqlExtraVars . put  ( name ,  evaluateGReQLQuery  ( greqlExpression ) ) ; }   final void addGReQLImport  (  String qualifiedName )  {   greqlImports . add  ( qualifiedName ) ; }   private final String getGreqlImportString  (  Graph graph )  {  StringBuilder  sb =  new StringBuilder  ( ) ;  for ( String s : greqlImports )  {  if  (  s . endsWith  ( ".*" ) )  {  if  (    graph . getSchema  ( ) . getPackage  (  s . replace  ( ".*" , "" ) ) == null )  {  continue ; } } else  {  if  (    graph . getSchema  ( ) . getAttributedElementClass  ( s ) == null )  {  continue ; } }   sb . append  ( "import " ) ;   sb . append  ( s ) ;   sb . append  ( "; " ) ; }  return  sb . toString  ( ) ; }   public Context  (  String targetSchemaName ,  String targetGraphClassName )  {    this . targetSchemaName = targetSchemaName ;    this . targetGraphClassName = targetGraphClassName ;  try  {   Class  <  ? >  schemaClass =   SchemaClassManager . instance  ( targetSchemaName ) . loadClass  ( targetSchemaName ) ;  Method  schemaInstanceMethod =  schemaClass . getMethod  ( "instance" ) ;   targetSchema =  ( Schema )  schemaInstanceMethod . invoke  ( null ) ; }  catch (   Exception e )  { } }   public Context  (  Schema targetSchema )  {    this . targetSchema = targetSchema ;   targetSchemaName =  targetSchema . getQualifiedName  ( ) ; }   public Context  (  Graph g )  {   setTargetGraph  ( g ) ;   setSourceGraph  ( g ) ; }   public final  PMap  <  AttributedElement  <  ? ,  ? > , Object > getArch  (   AttributedElementClass  <  ? ,  ? > aec )  {   PMap  <  AttributedElement  <  ? ,  ? > , Object >  result =  archMap . get  ( aec ) ;  if  (  result == null )  {   result =  Empty . orderedMap  ( ) ;   archMap . put  ( aec , result ) ; }  return result ; }   public final  PMap  < Object ,  AttributedElement  <  ? ,  ? > > getImg  (   AttributedElementClass  <  ? ,  ? > aec )  {   PMap  < Object ,  AttributedElement  <  ? ,  ? > >  result =  imgMap . get  ( aec ) ;  if  (  result == null )  {   result =  Empty . orderedMap  ( ) ;   imgMap . put  ( aec , result ) ; }  return result ; }   final void ensureMappings  (   AttributedElementClass  <  ? ,  ? > aec )  {   getImg  ( aec ) ;   getArch  ( aec ) ; }   public final void ensureAllMappings  ( )  {   ensureMappings  (  targetSchema . getGraphClass  ( ) ) ;  for (  GraphElementClass  <  ? ,  ? > gec :   targetSchema . getGraphClass  ( ) . getGraphElementClasses  ( ) )  {   ensureMappings  ( gec ) ; } }   public final void printImgMappings  ( )  {    System . out . println  ( "Image Mappings:" ) ;  for (  Entry  <  AttributedElementClass  <  ? ,  ? > ,  PMap  < Object ,  AttributedElement  <  ? ,  ? > > > e :  imgMap . entrySet  ( ) )  {   AttributedElementClass  <  ? ,  ? >  aec =  e . getKey  ( ) ;   PMap  < Object ,  AttributedElement  <  ? ,  ? > >  img =  e . getValue  ( ) ;    System . out . println  (  "Mappings for: " +  aec . getQualifiedName  ( ) ) ;  for (  Entry  < Object ,  AttributedElement  <  ? ,  ? > > entry :  img . entrySet  ( ) )  {    System . out . println  (    "    " +  entry . getKey  ( ) + " ==> " +  entry . getValue  ( ) ) ; } } }   final void addMapping  (   AttributedElementClass  <  ? ,  ? > attrElemClass ,  Object archetype ,   AttributedElement  <  ? ,  ? > image )  {   addMappingToClass  ( attrElemClass , archetype , image ) ;  if  (  attrElemClass instanceof GraphElementClass )  {   addMappingsToSuperClasses  (  (  GraphElementClass  <  ? ,  ? > ) attrElemClass , archetype ,  (  GraphElement  <  ? ,  ? > ) image ) ; } }   private final void addMappingsToSuperClasses  (   final  GraphElementClass  <  ? ,  ? > subClass ,   final Object archetype ,   final  GraphElement  <  ? ,  ? > image )  {  for (  AttributedElementClass  <  ? ,  ? > superClass :  subClass . getAllSuperClasses  ( ) )  {   addMappingToClass  ( superClass , archetype , image ) ; } }   private final void addMappingToClass  (   AttributedElementClass  <  ? ,  ? > attrElemClass ,  Object archetype ,   AttributedElement  <  ? ,  ? > image )  {   addArchMapping  ( attrElemClass , image , archetype ) ;   addImgMapping  ( attrElemClass , archetype , image ) ; }   private void addArchMapping  (   AttributedElementClass  <  ? ,  ? > attrElemClass ,   AttributedElement  <  ? ,  ? > image ,  Object archetype )  {   PMap  <  AttributedElement  <  ? ,  ? > , Object >  map =  archMap . get  ( attrElemClass ) ;  if  (  map . containsKey  ( image ) )  {  throw  new GReTLBijectionViolationException  ( this ,           "'" + image + "' already maps to '" +  map . get  ( image ) + "' in " +  toGReTLVarNotation  (  attrElemClass . getQualifiedName  ( ) ,  GReTLVariableType . ARCH ) + "! You wanted to create an archMap mapping from '" + image + "' to '" + archetype + "'." ) ; }   archMap . remove  ( map ) ;   map =  map . plus  ( image , archetype ) ;   archMap . put  ( attrElemClass , map ) ; }   private void addImgMapping  (   AttributedElementClass  <  ? ,  ? > attrElemClass ,  Object archetype ,   AttributedElement  <  ? ,  ? > image )  {   PMap  < Object ,  AttributedElement  <  ? ,  ? > >  map =  imgMap . get  ( attrElemClass ) ;  if  (  map . containsKey  ( archetype ) )  {  throw  new GReTLBijectionViolationException  ( this ,           "'" + archetype + "' already maps to '" +  map . get  ( archetype ) + "' in " +  toGReTLVarNotation  (  attrElemClass . getQualifiedName  ( ) ,  GReTLVariableType . IMG ) + "! You wanted to create an imgMap mapping from '" + archetype + "' to '" + image + "'." ) ; }   imgMap . remove  ( map ) ;   map =  map . plus  ( archetype , image ) ;   imgMap . put  ( attrElemClass , map ) ; }   private Random  uniqueSeed =  new Random  ( ) ;   public String getUniqueString  ( )  {  StringBuilder  sb =  new StringBuilder  ( ) ;   sb . append  ( "<--[" ) ;   sb . append  (  uniqueSeed . nextInt  ( ) ) ;   sb . append  ( "]--[" ) ;   sb . append  (  System . currentTimeMillis  ( ) ) ;   sb . append  ( "]-->" ) ;  return  sb . toString  ( ) ; }   public final void validateMappings  ( )  {  if  (   imgMap . size  ( ) !=  archMap . size  ( ) )  {    @ SuppressWarnings  ( "rawtypes" ) Map  m = imgMap ;    @ SuppressWarnings  ( "rawtypes" ) Map  o = archMap ;  if  (   archMap . size  ( ) >  imgMap . size  ( ) )  {   m = archMap ;   o = imgMap ; }    @ SuppressWarnings  ( "unchecked" )  Set  <  AttributedElementClass  <  ? ,  ? > >  keySet =  m . keySet  ( ) ;  for (  AttributedElementClass  <  ? ,  ? > aec : keySet )  {  if  (  !  o . containsKey  ( aec ) )  {    System . err . println  (   toGReTLVarNotation  (  aec . getQualifiedName  ( ) ,   (  o == archMap ) ?  GReTLVariableType . ARCH :  GReTLVariableType . IMG ) + " is missing" ) ; } }  throw  new GReTLBijectionViolationException  ( this ,      "The imgMap and archMap mappings aren't valid! " + "The sizes of imgMap (" +  imgMap . size  ( ) + ") and archMap (" +  archMap . size  ( ) + ") don't match!" ) ; }  for (  AttributedElementClass  <  ? ,  ? > aec :  archMap . keySet  ( ) )  {  if  (  !  imgMap . containsKey  ( aec ) )  {  throw  new GReTLBijectionViolationException  ( this ,    "The imgMap and archMap mappings aren't valid! " + "imgMap contains no mappings for '" +  aec . getQualifiedName  ( ) + "'!" ) ; }    @ SuppressWarnings  ( "rawtypes" ) Map  arch =  archMap . get  ( aec ) ;    @ SuppressWarnings  ( "rawtypes" ) Map  img =  imgMap . get  ( aec ) ;  if  (   arch . size  ( ) !=  img . size  ( ) )  {  throw  new GReTLBijectionViolationException  ( this ,      "The imgMap and archMap mappings aren't valid! " + "The sizes of '" +  toGReTLVarNotation  (  aec . getQualifiedName  ( ) ,  GReTLVariableType . IMG ) + "' and '" +  toGReTLVarNotation  (  aec . getQualifiedName  ( ) ,  GReTLVariableType . ARCH ) + "' don't match!" ) ; }    @ SuppressWarnings  (  { "unchecked" , "rawtypes" } )  Set  <  Map . Entry >  entries =  arch . entrySet  ( ) ;  for (   @ SuppressWarnings  ( "rawtypes" ) Entry entry : entries )  {  if  (  !  img . containsKey  (  entry . getValue  ( ) ) )  {  throw  new GReTLBijectionViolationException  ( this ,    "The imgMap and archMap mappings aren't valid! " + "imgMap contains no mapping for '" +  entry . getValue  ( ) + "'!" ) ; }  if  (  !   img . get  (  entry . getValue  ( ) ) . equals  (  entry . getKey  ( ) ) )  {  throw  new GReTLBijectionViolationException  ( this ,            "The imgMap and archMap mappings aren't valid! " + "imgMap is not inverse to archMap for '" +  toGReTLVarNotation  (  aec . getQualifiedName  ( ) ,  GReTLVariableType . ARCH ) + "'! " + "archMap: " +  entry . getKey  ( ) + " --> " +  entry . getValue  ( ) + ", but imgMap: " +  entry . getValue  ( ) + " --> " +  img . get  (  entry . getValue  ( ) ) ) ; } } } }   public final Context swap  ( )  {   logger . info  ( "Swapping context..." ) ;   logger . info  (  "Old target schema name: " +  targetSchema . getQualifiedName  ( ) ) ;   sourceGraphs . clear  ( ) ;  Graph  oldTargetGraph = targetGraph ;  String  newSchemaPackagePrefix =  targetSchema . getPackagePrefix  ( ) ;  Pattern  stepSuffix =  Pattern . compile  ( ".*(_v(\\d+))$" ) ;  Matcher  matcher =  stepSuffix . matcher  ( newSchemaPackagePrefix ) ;   int  step = 1 ;  if  (  matcher . matches  ( ) )  {  String  matchGroup =  matcher . group  ( 2 ) ;   step =  Integer . parseInt  ( matchGroup ) ;   newSchemaPackagePrefix =  newSchemaPackagePrefix . substring  ( 0 ,   newSchemaPackagePrefix . length  ( ) -   matcher . group  ( 1 ) . length  ( ) ) ; }   step ++ ;   newSchemaPackagePrefix +=  "_v" + step ;   targetSchemaName =   newSchemaPackagePrefix + "." +  targetSchema . getName  ( ) ;   logger . info  (  "New target schema name: " + targetSchemaName ) ;   setSourceGraph  ( oldTargetGraph ) ;  return  reset  ( true ) ; }   public final Context reset  (  boolean forgetTargetSchema )  {   outermost = true ;   phase =  TransformationPhase . SCHEMA ;   targetGraph = null ;  if  ( forgetTargetSchema )  {   targetSchema = null ; }   archMap . clear  ( ) ;   imgMap . clear  ( ) ;   GreqlEvaluatorImpl . resetGraphIndizes  ( ) ;   greqlExtraVars . clear  ( ) ;   greqlImports . clear  ( ) ;  return this ; }   public final void setSourceGraph  (  Graph sourceGraph )  {   addSourceGraph  ( DEFAULT_SOURCE_GRAPH_ALIAS , sourceGraph ) ; }   public final void addSourceGraph  (  String alias ,  Graph sourceGraph )  {  if  (  sourceGraphs . containsKey  ( alias ) )  {  throw  new GReTLException  ( this ,   "There's already a source graph with name '" + alias + "'." ) ; }  if  (  !  alias . matches  ( "\\w+" ) )  {  throw  new GReTLException  ( this ,   "Invalid source graph name '" + alias + "'. Must be only word characters." ) ; }  if  (  alias . equals  ( DEFAULT_TARGET_GRAPH_ALIAS ) )  {  throw  new GReTLException  ( this ,   "Invalid source graph name '" + alias + "'. That's the default alias for the target graph." ) ; }  if  (     sourceGraph . getSchema  ( ) . getQualifiedName  ( ) . equals  ( targetSchemaName ) &&  (  targetSchema == null ) )  {  throw  new SchemaException  (    "The schema names of source and target have to be different. " + "Currently both are named '" + targetSchemaName + "'." ) ; }   sourceGraphs . put  ( alias , sourceGraph ) ; }   public final  Map  < String , Graph > getSourceGraphs  ( )  {  return sourceGraphs ; }   public final Graph getSourceGraph  ( )  {  return  getSourceGraph  ( DEFAULT_SOURCE_GRAPH_ALIAS ) ; }   public final Graph getSourceGraph  (  String alias )  {  return  sourceGraphs . get  ( alias ) ; }   public final Graph getTargetGraph  ( )  {  return targetGraph ; }   public final void setTargetGraph  (  Graph targetGraph )  {    this . targetGraph = targetGraph ;   targetSchema =  targetGraph . getSchema  ( ) ; }   final void createTargetSchema  ( )  {   String  [ ]  qn =  SchemaImpl . splitQualifiedName  ( targetSchemaName ) ;   targetSchema =  new SchemaImpl  (  qn [ 1 ] ,  qn [ 0 ] ) ;  GraphClass  gc =  targetSchema . createGraphClass  ( targetGraphClassName ) ;   ensureMappings  ( gc ) ; }   final void createTargetGraph  ( )  {   targetSchema . finish  ( ) ;  try  {    targetSchema . getGraphClass  ( ) . getSchemaClass  ( ) ;   logger . info  (   "Schema '" +  targetSchema . getQualifiedName  ( ) + "' is already compiled or in the CLASSPATH..." ) ;   targetSchema . finish  ( ) ;   targetGraph =  targetSchema . createGraph  (  ImplementationType . STANDARD ) ; }  catch (   Exception e )  {   logger . info  (   "Schema '" +  targetSchema . getQualifiedName  ( ) + "' is new, so instantiating a generic target graph..." ) ;   targetGraph =  targetSchema . createGraph  (  ImplementationType . GENERIC ) ; }  for (  Entry  < String , Graph > e :  sourceGraphs . entrySet  ( ) )  {  String  sourceGraphName =  e . getKey  ( ) ;  Graph  sourceGraph =  e . getValue  ( ) ;  if  (  sourceGraphName . equals  ( DEFAULT_SOURCE_GRAPH_ALIAS ) )  {   addMapping  (  targetGraph . getGraphClass  ( ) , sourceGraph , targetGraph ) ; } } }   public enum GReTLVariableType  {  ARCH ,  IMG }   public static String toGReTLVarNotation  (  String qualifiedName ,  GReTLVariableType type )  {  String  qName =  NamedElementImpl . toUniqueNameNotation  ( qualifiedName ) ;  return     type . toString  ( ) . toLowerCase  ( ) + "_" + qName ; }   public final  <  T > T evaluateGReQLQuery  (  String greqlExpression )  {  if  (  phase ==  TransformationPhase . SCHEMA )  {  return null ; }  String  name = DEFAULT_SOURCE_GRAPH_ALIAS ;  Matcher  m =  QUERY_GRAPH_ALIAS_PATTERN . matcher  ( greqlExpression ) ;  if  (  m . matches  ( ) )  {   greqlExpression =  greqlExpression . replace  (  m . group  ( 1 ) , "" ) ;   name =  m . group  ( 2 ) ;  if  (  name . equals  ( DEFAULT_TARGET_GRAPH_ALIAS ) )  {  return  evalGReQLQuery  ( greqlExpression , targetGraph ) ; }  if  (  !  sourceGraphs . containsKey  ( name ) )  {  throw  new GReTLException  ( this ,   "No source graph with name '" + name + "'." ) ; } }  return  this .  < T > evalGReQLQuery  ( greqlExpression ,  sourceGraphs . get  ( name ) ) ; }    @ SuppressWarnings  ( "unchecked" ) private final  <  T > T evalGReQLQuery  (  String semanticExpression ,  Graph graph )  {  if  (  phase ==  TransformationPhase . SCHEMA )  {  return null ; }  if  (  semanticExpression . isEmpty  ( ) )  {   logger . severe  ( "The given semantic expression is empty!  Fix that!" ) ;  return null ; }   PMap  < String , Object >  greqlMapping =  getGreqlVariablesNeededByQuery  ( semanticExpression ) ;  StringBuilder  sb =  new StringBuilder  ( ) ;  if  (   sourceGraphs . values  ( ) . contains  ( graph ) )  {   sb . append  (  getGreqlImportString  ( graph ) ) ; }   sb . append  (  getGreqlUsingString  ( greqlMapping ) ) ;   sb . append  ( semanticExpression ) ;  String  query =  sb . toString  ( ) ;   logger . finest  (  "GReQL: " + semanticExpression ) ;  GreqlEvaluatorImpl  eval =  new GreqlEvaluatorImpl  (  new QueryImpl  ( query ) , graph , greqlMapping , null ) ;   eval . startEvaluation  ( ) ;  return  ( T )  eval . getResult  ( ) ; }   private final  PMap  < String , Object > getGreqlVariablesNeededByQuery  (  String query )  {   PMap  < String , Object >  result =  Empty . orderedMap  ( ) ;  for ( String extraVar :  greqlExtraVars . keySet  ( ) )  {  if  (  query . contains  ( extraVar ) )  {   result =  result . plus  ( extraVar ,  greqlExtraVars . get  ( extraVar ) ) ; } }  for (  Entry  <  AttributedElementClass  <  ? ,  ? > ,  PMap  <  AttributedElement  <  ? ,  ? > , Object > > e :  archMap . entrySet  ( ) )  {  String  varName =  toGReTLVarNotation  (   e . getKey  ( ) . getQualifiedName  ( ) ,  GReTLVariableType . ARCH ) ;  if  (  query . contains  ( varName ) )  {   result =  result . plus  ( varName ,  e . getValue  ( ) ) ; } }  for (  Entry  <  AttributedElementClass  <  ? ,  ? > ,  PMap  < Object ,  AttributedElement  <  ? ,  ? > > > e :  imgMap . entrySet  ( ) )  {  String  varName =  toGReTLVarNotation  (   e . getKey  ( ) . getQualifiedName  ( ) ,  GReTLVariableType . IMG ) ;  if  (  query . contains  ( varName ) )  {   result =  result . plus  ( varName ,  e . getValue  ( ) ) ; } }  return result ; }   private final String getGreqlUsingString  (   Map  < String , Object > greqlMapping )  {  if  (   greqlMapping . size  ( ) == 0 )  {  return "" ; }  StringBuilder  sb =  new StringBuilder  ( ) ;   sb . append  ( "using " ) ;  boolean  first = true ;  for ( String name :  new  TreeSet  < String >  (  greqlMapping . keySet  ( ) ) )  {  if  ( first )  {   first = false ; } else  {   sb . append  ( ", " ) ; }   sb . append  ( name ) ; }   sb . append  ( ": " ) ;  return  sb . toString  ( ) ; }   public final void storeTrace  (  String fileName )  { }   public final void restoreTrace  (  String fileName )  { } }