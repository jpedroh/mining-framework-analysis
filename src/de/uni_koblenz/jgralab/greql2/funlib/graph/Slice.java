  package      de . uni_koblenz . jgralab . greql2 . funlib . graph ;   import   java . util . ArrayList ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . LinkedList ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Queue ;  import   java . util . Set ;  import   org . pcollections . PSet ;  import    de . uni_koblenz . jgralab . Edge ;  import    de . uni_koblenz . jgralab . Graph ;  import    de . uni_koblenz . jgralab . JGraLab ;  import    de . uni_koblenz . jgralab . Vertex ;  import     de . uni_koblenz . jgralab . graphmarker . GraphMarker ;  import      de . uni_koblenz . jgralab . greql2 . evaluator . InternalGreqlEvaluator ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . DFA ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . NFA ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . State ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . Transition ;  import      de . uni_koblenz . jgralab . greql2 . funlib . Function ;  import      de . uni_koblenz . jgralab . greql2 . funlib . NeedsEvaluatorArgument ;  import       de . uni_koblenz . jgralab . greql2 . types . pathsearch . PathSystemMarkerEntry ;  import       de . uni_koblenz . jgralab . greql2 . types . pathsearch . PathSystemQueueEntry ;  import      de . uni_koblenz . jgralab . greql2 . funlib . Description ;    @ NeedsEvaluatorArgument public class Slice  extends Function  {   public Slice  ( )  {  super  ( 1000 , 1 , 1.0 ) ; }   private Graph  graph ;   public      de . uni_koblenz . jgralab . greql2 . types . Slice evaluate  (  InternalGreqlEvaluator evaluator ,  Vertex v ,  NFA nfa )  {  return  evaluate  ( evaluator , v ,  nfa . getDFA  ( ) ) ; }   public      de . uni_koblenz . jgralab . greql2 . types . Slice evaluate  (  InternalGreqlEvaluator evaluator ,  Vertex v ,  DFA dfa )  {  return  evaluate  ( evaluator ,   JGraLab .  < Vertex > set  ( ) . plus  ( v ) , dfa ) ; }   public      de . uni_koblenz . jgralab . greql2 . types . Slice evaluate  (  InternalGreqlEvaluator evaluator ,   PSet  < Vertex > roots ,  NFA nfa )  {  return  evaluate  ( evaluator , roots ,  nfa . getDFA  ( ) ) ; }   public      de . uni_koblenz . jgralab . greql2 . types . Slice evaluate  (  InternalGreqlEvaluator evaluator ,   PSet  < Vertex > roots ,  DFA dfa )  {   Set  < Vertex >  sliCritVertices =  new  HashSet  < Vertex >  ( ) ;  for ( Vertex v : roots )  {  if  (  graph == null )  {   graph =  v . getGraph  ( ) ; }   sliCritVertices . add  ( v ) ; }   marker =  new  ArrayList  <  GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > > >  (   dfa . stateList . size  ( ) ) ;  for (   int  i = 0 ;  i <   dfa . stateList . size  ( ) ;  i ++ )  {   marker . add  (  new  GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > >  ( graph ) ) ; }   List  < Vertex >  leaves =  markVerticesOfSlice  ( evaluator , sliCritVertices , dfa ) ;  return  createSliceFromMarkings  ( graph , sliCritVertices , leaves ) ; }   private  List  <  GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > > >  marker ;   private  GraphMarker  <  Set  < State > >  stateMarker ;   protected boolean markVertex  (  Vertex v ,  State s ,  Vertex parentVertex ,  Edge e ,  State ps ,   int d )  {  PathSystemMarkerEntry  m =  new PathSystemMarkerEntry  ( v , parentVertex , e , s , ps , d ) ;   GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > >  currentMarker =  marker . get  (  s . number ) ;   Map  < Edge , PathSystemMarkerEntry >  map =  currentMarker . getMark  ( v ) ;  if  (  map == null )  {   map =  new  HashMap  < Edge , PathSystemMarkerEntry >  ( ) ;   currentMarker . mark  ( v , map ) ; }  PathSystemMarkerEntry  entry =  map . get  ( e ) ;  if  (  entry == null )  {   map . put  ( e , m ) ;  return true ; } else  {  return false ; } }   protected boolean isMarked  (  Vertex v ,  State s ,  Edge parentEdge )  {   GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > >  currentMarker =  marker . get  (  s . number ) ;   Map  < Edge , PathSystemMarkerEntry >  map =  currentMarker . getMark  ( v ) ;  if  (  map != null )  {  return  map . containsKey  ( parentEdge ) ; } else  {  return false ; } }   protected boolean isMarked  (  Vertex v ,  State s )  {   GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > >  currentMarker =  marker . get  (  s . number ) ;   Map  < Edge , PathSystemMarkerEntry >  map =  currentMarker . getMark  ( v ) ;  return  map != null ; }   private  List  < Vertex > markVerticesOfSlice  (  InternalGreqlEvaluator evaluator ,   Set  < Vertex > sliCritVertices ,  DFA dfa )  {   ArrayList  < Vertex >  finalVertices =  new  ArrayList  < Vertex >  ( ) ;   Queue  < PathSystemQueueEntry >  queue =  new  LinkedList  < PathSystemQueueEntry >  ( ) ;  PathSystemQueueEntry  currentEntry ;  for ( Vertex v : sliCritVertices )  {   currentEntry =  new PathSystemQueueEntry  ( v ,  dfa . initialState , null , null , 0 ) ;   queue . offer  ( currentEntry ) ;   markVertex  ( v ,  dfa . initialState , null , null , null , 0 ) ; }  while  (  !  queue . isEmpty  ( ) )  {   currentEntry =  queue . poll  ( ) ;  if  (   currentEntry . state . isFinal )  {   finalVertices . add  (  currentEntry . vertex ) ; }  for ( Edge inc :   currentEntry . vertex . incidences  ( ) )  {  for ( Transition currentTransition :   currentEntry . state . outTransitions )  {  Vertex  nextVertex =  currentTransition . getNextVertex  (  currentEntry . vertex , inc ) ;  if  (   !  isMarked  ( nextVertex ,  currentTransition . endState , inc ) &&  currentTransition . accepts  (  currentEntry . vertex , inc , evaluator ) )  {  Edge  traversedEdge =   currentTransition . consumesEdge  ( ) ? inc : null ;  if  (  !  isMarked  ( nextVertex ,  currentTransition . endState ) )  {   queue . add  (  new PathSystemQueueEntry  ( nextVertex ,  currentTransition . endState , traversedEdge ,  currentEntry . state , 0 ) ) ; }   markVertex  ( nextVertex ,  currentTransition . endState ,  currentEntry . vertex , traversedEdge ,  currentEntry . state , 0 ) ; } } } }  return finalVertices ; }   private      de . uni_koblenz . jgralab . greql2 . types . Slice createSliceFromMarkings  (  Graph graph ,   Set  < Vertex > sliCritVertices ,   List  < Vertex > leaves )  {       de . uni_koblenz . jgralab . greql2 . types . Slice  slice =  new      de . uni_koblenz . jgralab . greql2 . types . Slice  ( graph ) ;   Map  < Edge , PathSystemMarkerEntry >  sliCritVertexMarkerMap ;  PathSystemMarkerEntry  sliCritVertexMarker ;   GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > >  startStateMarker =  marker . get  ( 0 ) ;  for ( Vertex v : sliCritVertices )  {   sliCritVertexMarkerMap =  startStateMarker . getMark  ( v ) ;   sliCritVertexMarker =  sliCritVertexMarkerMap . get  ( null ) ;   slice . addSlicingCriterionVertex  ( v ,   sliCritVertexMarker . state . number ,   sliCritVertexMarker . state . isFinal ) ; }   Queue  < Vertex >  queue =  new  LinkedList  < Vertex >  ( ) ;  Vertex  currentVertex ,  parentVertex ;  State  parentState ;   stateMarker =  new  GraphMarker  <  Set  < State > >  ( graph ) ;   GraphMarker  < State >  currentStateMarker =  new  GraphMarker  < State >  ( graph ) ;  for ( Vertex leaf : leaves )  {  for (  GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > > currentGraphMarker : marker )  {  if  (   currentGraphMarker . getMark  ( leaf ) != null )  {  for ( PathSystemMarkerEntry currentMarker :   currentGraphMarker . getMark  ( leaf ) . values  ( ) )  {  if  (   !   currentMarker . state . isFinal ||  isVertexMarkedWithState  ( leaf ,  currentMarker . state ) )  {  continue ; }   markVertexWithState  ( leaf ,  currentMarker . state ) ;   currentStateMarker . mark  ( leaf ,  currentMarker . state ) ;   queue . add  ( leaf ) ;  while  (  !  queue . isEmpty  ( ) )  {   currentVertex =  queue . poll  ( ) ;  for ( PathSystemMarkerEntry marker :   getMarkersWithState  ( currentVertex ,  currentStateMarker . getMark  ( currentVertex ) ) . values  ( ) )  {   int  parentStateNumber = 0 ;   parentState =  marker . parentState ;  if  (  parentState != null )  {   parentStateNumber =  parentState . number ; }   slice . addVertex  ( currentVertex ,   marker . state . number ,  marker . edgeToParentVertex ,  marker . parentVertex , parentStateNumber ,   marker . state . isFinal ) ;   parentVertex =  marker . parentVertex ;  if  (   (  parentVertex != null ) &&  !  isVertexMarkedWithState  ( parentVertex , parentState ) )  {   markVertexWithState  ( parentVertex , parentState ) ;   currentStateMarker . mark  ( parentVertex , parentState ) ;   queue . add  ( parentVertex ) ; } } } } } } }  return slice ; }   private void markVertexWithState  (  Vertex v ,  State s )  {  if  (   stateMarker . getMark  ( v ) == null )  {   stateMarker . mark  ( v ,  new  HashSet  < State >  ( ) ) ; }    stateMarker . getMark  ( v ) . add  ( s ) ; }   private boolean isVertexMarkedWithState  (  Vertex v ,  State s )  {  if  (   stateMarker . getMark  ( v ) == null )  {  return false ; }  return   stateMarker . getMark  ( v ) . contains  ( s ) ; }   private  Map  < Edge , PathSystemMarkerEntry > getMarkersWithState  (  Vertex v ,  State s )  {  if  (  v == null )  {  return null ; }   GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > >  currentMarker =  marker . get  (  s . number ) ;  return  currentMarker . getMark  ( v ) ; }    @ Override public  long getEstimatedCosts  (   ArrayList  < Long > inElements )  {  return 1000 ; }    @ Override public  double getSelectivity  ( )  {  return 0.001f ; }    @ Override public  long getEstimatedCardinality  (   int inElements )  {  return 1 ; } 
<<<<<<<
=======
   @ Description  (  params =  { "v" , "nfa" } ,  description =  "Returns a slice, starting at the given root vertex and " + " being structured according to the given path description." ,  categories =  {  Category . GRAPH ,  Category . PATHS_AND_PATHSYSTEMS_AND_SLICES } ) public      de . uni_koblenz . jgralab . greql2 . types . Slice evaluate  (  Vertex v ,  NFA nfa )  {  return  evaluate  ( v ,  nfa . getDFA  ( ) ) ; }
>>>>>>>
 
<<<<<<<
=======
   @ Description  (  params =  { "v" , "dfa" } ,  description =  "Returns a slice, starting at the given root vertex and " + " being structured according to the given path description." ,  categories =  {  Category . GRAPH ,  Category . PATHS_AND_PATHSYSTEMS_AND_SLICES } ) public      de . uni_koblenz . jgralab . greql2 . types . Slice evaluate  (  Vertex v ,  DFA dfa )  {  return  evaluate  (   JGraLab .  < Vertex > set  ( ) . plus  ( v ) , dfa ) ; }
>>>>>>>
 
<<<<<<<
=======
   @ Description  (  params =  { "roots" , "nfa" } ,  description =  "Returns a slice, starting at the given root vertices and " + " being structured according to the given path description." ,  categories =  {  Category . GRAPH ,  Category . PATHS_AND_PATHSYSTEMS_AND_SLICES } ) public      de . uni_koblenz . jgralab . greql2 . types . Slice evaluate  (   PSet  < Vertex > roots ,  NFA nfa )  {  return  evaluate  ( roots ,  nfa . getDFA  ( ) ) ; }
>>>>>>>
 
<<<<<<<
=======
   @ Description  (  params =  { "roots" , "dfa" } ,  description =  "Returns a slice, starting at the given root vertices and " + " being structured according to the given path description." ,  categories =  {  Category . GRAPH ,  Category . PATHS_AND_PATHSYSTEMS_AND_SLICES } ) public      de . uni_koblenz . jgralab . greql2 . types . Slice evaluate  (   PSet  < Vertex > roots ,  DFA dfa )  {   Set  < Vertex >  sliCritVertices =  new  HashSet  < Vertex >  ( ) ;  for ( Vertex v : roots )  {  if  (  graph == null )  {   graph =  v . getGraph  ( ) ; }   sliCritVertices . add  ( v ) ; }   marker =  new  ArrayList  <  GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > > >  (   dfa . stateList . size  ( ) ) ;  for (   int  i = 0 ;  i <   dfa . stateList . size  ( ) ;  i ++ )  {   marker . add  (  new  GraphMarker  <  Map  < Edge , PathSystemMarkerEntry > >  ( graph ) ) ; }   List  < Vertex >  leaves =  markVerticesOfSlice  ( sliCritVertices , dfa ) ;  return  createSliceFromMarkings  ( graph , sliCritVertices , leaves ) ; }
>>>>>>>
 }