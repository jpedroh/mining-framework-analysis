  package      de . uni_koblenz . jgralab . greql2 . funlib . graph ;   import   java . util . ArrayList ;  import   java . util . HashSet ;  import   java . util . LinkedList ;  import   java . util . Queue ;  import   java . util . Set ;  import    de . uni_koblenz . jgralab . Edge ;  import    de . uni_koblenz . jgralab . Vertex ;  import     de . uni_koblenz . jgralab . graphmarker . GraphMarker ;  import      de . uni_koblenz . jgralab . greql2 . evaluator . InternalGreqlEvaluator ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . DFA ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . NFA ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . State ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . Transition ;  import      de . uni_koblenz . jgralab . greql2 . funlib . Function ;  import      de . uni_koblenz . jgralab . greql2 . funlib . NeedsEvaluatorArgument ;  import       de . uni_koblenz . jgralab . greql2 . types . pathsearch . PathSystemMarkerEntry ;  import      de . uni_koblenz . jgralab . greql2 . funlib . Description ;    @ NeedsEvaluatorArgument public class PathSystem  extends Function  {   public  @ Description  (  params =  { "startVertex" , "fa" } ,  description = "Returns a path system with the given root vertex, which is structured according to the given path description." ,  categories =  Category . PATHS_AND_PATHSYSTEMS_AND_SLICES ) PathSystem  ( )  {  super  ( 1000 , 1 , 1.0 ) ; }   public      de . uni_koblenz . jgralab . greql2 . types . PathSystem evaluate  (  InternalGreqlEvaluator evaluator ,  Vertex startVertex ,  NFA nfa )  {  return  evaluate  ( evaluator , startVertex ,  nfa . getDFA  ( ) ) ; }   public      de . uni_koblenz . jgralab . greql2 . types . PathSystem evaluate  (  InternalGreqlEvaluator evaluator ,  Vertex startVertex ,  DFA dfa )  {    @ SuppressWarnings  ( "unchecked" )   GraphMarker  < PathSystemMarkerEntry >  [ ]  marker =  new GraphMarker  [   dfa . stateList . size  ( ) ] ;  for (   int  i = 0 ;  i <   dfa . stateList . size  ( ) ;  i ++ )  {    marker [ i ] =  new  GraphMarker  < PathSystemMarkerEntry >  (  startVertex . getGraph  ( ) ) ; }   Set  < PathSystemMarkerEntry >  leaves =  markVerticesOfPathSystem  ( evaluator , marker , startVertex , dfa ) ;       de . uni_koblenz . jgralab . greql2 . types . PathSystem  resultPathSystem =  createPathSystemFromMarkings  ( marker , startVertex , leaves ) ;  return resultPathSystem ; }   protected PathSystemMarkerEntry markVertex  (    GraphMarker  < PathSystemMarkerEntry >  [ ] marker ,  Vertex v ,  State s ,  Vertex parentVertex ,  Edge e ,  State ps ,   int d )  {  PathSystemMarkerEntry  m =  new PathSystemMarkerEntry  ( v , parentVertex , e , s , ps , d ) ;   GraphMarker  < PathSystemMarkerEntry >  currentMarker =  marker [  s . number ] ;   currentMarker . mark  ( v , m ) ;  return m ; }   protected boolean isMarked  (    GraphMarker  < PathSystemMarkerEntry >  [ ] marker ,  Vertex v ,  State s )  {   GraphMarker  < PathSystemMarkerEntry >  currentMarker =  marker [  s . number ] ;  return  currentMarker . isMarked  ( v ) ; }   private  Set  < PathSystemMarkerEntry > markVerticesOfPathSystem  (  InternalGreqlEvaluator evaluator ,    GraphMarker  < PathSystemMarkerEntry >  [ ] marker ,  Vertex startVertex ,  DFA dfa )  {   Set  < PathSystemMarkerEntry >  finalEntries =  new  HashSet  < PathSystemMarkerEntry >  ( ) ;   Queue  < PathSystemMarkerEntry >  queue =  new  LinkedList  < PathSystemMarkerEntry >  ( ) ;  PathSystemMarkerEntry  currentEntry =  markVertex  ( marker , startVertex ,  dfa . initialState , null , null , null , 0 ) ;  if  (   dfa . initialState . isFinal )  {   finalEntries . add  ( currentEntry ) ; }   queue . add  ( currentEntry ) ;  while  (  !  queue . isEmpty  ( ) )  {   currentEntry =  queue . poll  ( ) ;  Vertex  currentVertex =  currentEntry . vertex ;  for ( Edge inc :  currentVertex . incidences  ( ) )  {  for ( Transition currentTransition :   currentEntry . state . outTransitions )  {  Vertex  nextVertex =  currentTransition . getNextVertex  ( currentVertex , inc ) ;  if  (  !  isMarked  ( marker , nextVertex ,  currentTransition . endState ) )  {  if  (  currentTransition . accepts  ( currentVertex , inc , evaluator ) )  {  Edge  traversedEdge =   currentTransition . consumesEdge  ( ) ? inc : null ;  PathSystemMarkerEntry  newEntry =  markVertex  ( marker , nextVertex ,  currentTransition . endState , currentVertex , traversedEdge ,  currentEntry . state ,   currentEntry . distanceToRoot + 1 ) ;  if  (   currentTransition . endState . isFinal )  {   finalEntries . add  ( newEntry ) ; }   queue . add  ( newEntry ) ; } } } } }  return finalEntries ; }   private      de . uni_koblenz . jgralab . greql2 . types . PathSystem createPathSystemFromMarkings  (    GraphMarker  < PathSystemMarkerEntry >  [ ] marker ,  Vertex rootVertex ,   Set  < PathSystemMarkerEntry > leafEntries )  {       de . uni_koblenz . jgralab . greql2 . types . PathSystem  pathSystem =  new      de . uni_koblenz . jgralab . greql2 . types . PathSystem  (  rootVertex . getGraph  ( ) ) ;  PathSystemMarkerEntry  rootMarker =   marker [ 0 ] . getMark  ( rootVertex ) ;   pathSystem . setRootVertex  ( rootVertex ,   rootMarker . state . number ,   rootMarker . state . isFinal ) ;  for ( PathSystemMarkerEntry currentMarker : leafEntries )  {  Vertex  currentVertex =  currentMarker . vertex ;  while  (  currentVertex != null )  {   int  parentStateNumber = 0 ;  if  (   currentMarker . parentState != null )  {   parentStateNumber =   currentMarker . parentState . number ; }   pathSystem . addVertex  ( currentVertex ,   currentMarker . state . number ,  currentMarker . edgeToParentVertex ,  currentMarker . parentVertex , parentStateNumber ,  currentMarker . distanceToRoot ,   currentMarker . state . isFinal ) ;   currentVertex =  currentMarker . parentVertex ;   currentMarker =  getMarkerWithState  ( marker , currentVertex ,  currentMarker . parentState ) ; } }   pathSystem . finish  ( ) ;  return pathSystem ; }   private PathSystemMarkerEntry getMarkerWithState  (    GraphMarker  < PathSystemMarkerEntry >  [ ] marker ,  Vertex v ,  State s )  {  if  (  v == null )  {  return null ; }   GraphMarker  < PathSystemMarkerEntry >  currentMarker =  marker [  s . number ] ;  PathSystemMarkerEntry  entry =  currentMarker . getMark  ( v ) ;  return entry ; }    @ Override public  long getEstimatedCosts  (   ArrayList  < Long > inElements )  {  return 1000 ; }    @ Override public  double getSelectivity  ( )  {  return 0.001f ; }    @ Override public  long getEstimatedCardinality  (   int inElements )  {  return 1 ; } }