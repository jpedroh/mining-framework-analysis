  package      de . uni_koblenz . jgralab . greql2 . funlib . graph ;   import   java . util . HashSet ;  import   org . pcollections . PSet ;  import    de . uni_koblenz . jgralab . Edge ;  import    de . uni_koblenz . jgralab . JGraLab ;  import    de . uni_koblenz . jgralab . Vertex ;  import      de . uni_koblenz . jgralab . greql2 . evaluator . InternalGreqlEvaluator ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . DFA ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . State ;  import       de . uni_koblenz . jgralab . greql2 . evaluator . fa . Transition ;  import      de . uni_koblenz . jgralab . greql2 . funlib . Function ;  import      de . uni_koblenz . jgralab . greql2 . funlib . NeedsEvaluatorArgument ;  import       de . uni_koblenz . jgralab . greql2 . types . pathsearch . VertexStateQueue ;  import      de . uni_koblenz . jgralab . greql2 . funlib . Description ;    @ NeedsEvaluatorArgument public class ReachableVertices  extends Function  {   public  @ Description  (  params =  { "v" , "dfa" } ,  description = "Returns all vertices that are reachable from the given vertex by a path matching the the given path description." ,  categories =  {  Category . GRAPH ,  Category . PATHS_AND_PATHSYSTEMS_AND_SLICES } ) ReachableVertices  ( )  {  super  ( 100 , 10 , 1.0 ) ; }   public  PSet  < Vertex > evaluate  (  InternalGreqlEvaluator evaluator ,  Vertex v ,  DFA dfa )  {  return  search  ( evaluator , v , dfa ) ; }   public static  PSet  < Vertex > search  (  InternalGreqlEvaluator evaluator ,  Vertex v ,  DFA dfa )  {   PSet  < Vertex >  resultSet =  JGraLab . set  ( ) ;    @ SuppressWarnings  ( "unchecked" )   HashSet  < Vertex >  [ ]  markedElements =  new HashSet  [   dfa . stateList . size  ( ) ] ;  for ( State s :  dfa . stateList )  {    markedElements [  s . number ] =  new  HashSet  < Vertex >  ( 100 ) ; }  VertexStateQueue  queue =  new VertexStateQueue  ( ) ;    markedElements [   dfa . initialState . number ] . add  ( v ) ;   queue . put  ( v ,  dfa . initialState ) ;  while  (  queue . hasNext  ( ) )  {  Vertex  vertex =  queue . currentVertex ;  State  state =  queue . currentState ;  if  (  state . isFinal )  {   resultSet =  resultSet . plus  ( vertex ) ; }  for (  Edge  inc =  vertex . getFirstIncidence  ( ) ;  inc != null ;  inc =  inc . getNextIncidence  ( ) )  {   int  size =   state . outTransitions . size  ( ) ;  for (   int  i = 0 ;  i < size ;  i ++ )  {  Transition  currentTransition =   state . outTransitions . get  ( i ) ;  Vertex  nextVertex =  currentTransition . getNextVertex  ( vertex , inc ) ;  if  (  !   markedElements [   currentTransition . endState . number ] . contains  ( nextVertex ) )  {  if  (  currentTransition . accepts  ( vertex , inc , evaluator ) )  {    markedElements [   currentTransition . endState . number ] . add  ( nextVertex ) ;   queue . put  ( nextVertex ,  currentTransition . endState ) ; } } } } }  return resultSet ; } }