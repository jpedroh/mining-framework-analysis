  package     de . uni_koblenz . jgralab . greql2 . evaluator ;   import   org . pcollections . PMap ;  import   org . pcollections . POrderedSet ;  import   org . pcollections . PVector ;  import    de . uni_koblenz . jgralab . Graph ;  import    de . uni_koblenz . jgralab . ProgressFunction ;  import   java . util . WeakHashMap ; 
<<<<<<<
  public interface GreqlEvaluator  {   public Object getResult  ( ) ;   public  <  T > T getSingleResult  ( ) ;   public  <  T >  PVector  < T > getResultList  ( ) ;   public  <  K ,  V >  PMap  < K , V > getResultMap  ( ) ;   public  <  T >  POrderedSet  < T > getResultSet  ( ) ;   public Object evaluate  (  QueryImpl query ,  Graph datagraph ,  GreqlEnvironment environment ,  ProgressFunction progressFunction ) ; }
=======
  public class GreqlEvaluator  {   public static void main  (   String  [ ] args )  throws FileNotFoundException , IOException , GraphIOException  {  if  (   (   args . length < 1 ) ||  (   args . length > 2 ) )  {    System . err . println  ( "Usage: java GreqlEvaluator <query> [<graphfile>]" ) ;   System . exit  ( 1 ) ; }   JGraLab . setLogLevel  (  Level . OFF ) ;  String  query =  args [ 0 ] ;  Graph  datagraph = null ;  if  (   args . length == 2 )  {   datagraph =  GraphIO . loadGraphFromFile  (  args [ 1 ] ,  new ConsoleProgressFunction  ( "Loading" ) ) ; }  GreqlEvaluator  eval =  new GreqlEvaluator  ( query , datagraph , null ) ;   eval . startEvaluation  ( ) ;  Object  result =  eval . getResult  ( ) ;    System . out . println  ( "Evaluation Result:" ) ;    System . out . println  ( "==================" ) ;  if  (  result instanceof PCollection )  {   PCollection  <  ? >  coll =  (  PCollection  <  ? > ) result ;  for ( Object jv : coll )  {    System . out . println  ( jv ) ; } } else  if  (  result instanceof Map )  {  for (  Entry  <  ? ,  ? > e :   (  (  Map  <  ? ,  ? > ) result ) . entrySet  ( ) )  {    System . out . println  (    e . getKey  ( ) + " --> " +  e . getValue  ( ) ) ; } } else  {    System . out . println  ( result ) ; } }   private static final  long  INDEX_TIME_BARRIER = 10 ;   public static boolean  DEBUG_DECLARATION_ITERATIONS = false ;   public static boolean  DEBUG_OPTIMIZATION =  Boolean . parseBoolean  (  System . getProperty  ( "greqlDebugOptimization" , "false" ) ) ;   public static final boolean  VERTEX_INDEXING = true ;   public static final  int  VERTEX_INDEX_SIZE = 50 ;   protected static  Map  < String ,  SoftReference  <  List  < SyntaxGraphEntry > > >  optimizedGraphs ;   public static synchronized void resetOptimizedSyntaxGraphs  ( )  {  if  (  optimizedGraphs == null )  {   optimizedGraphs =  new  HashMap  < String ,  SoftReference  <  List  < SyntaxGraphEntry > > >  ( ) ; } else  {   optimizedGraphs . clear  ( ) ; } }   protected static File  optimizedSyntaxGraphsDirectory =  getTmpDirectory  ( ) ;   protected static  WeakHashMap  < Graph ,  SoftReference  < GraphIndex > >  graphIndizes ;   public static synchronized void resetGraphIndizes  ( )  {  if  (  graphIndizes == null )  {   graphIndizes =  new  WeakHashMap  < Graph ,  SoftReference  < GraphIndex > >  ( ) ; } else  {   graphIndizes . clear  ( ) ; } }   protected  GraphMarker  < VertexEvaluator >  vertexEvalGraphMarker ;   protected  Map  < String ,  GraphElementClass  <  ? ,  ? > >  knownTypes =  new  HashMap  < String ,  GraphElementClass  <  ? ,  ? > >  ( ) ;   public final  GraphMarker  < VertexEvaluator > getVertexEvaluatorGraphMarker  ( )  {  return vertexEvalGraphMarker ; }  static  {   resetOptimizedSyntaxGraphs  ( ) ;   resetGraphIndizes  ( ) ; }   private static Logger  logger =  Logger . getLogger  (   GreqlEvaluator . class . getName  ( ) ) ;   public static synchronized  PSet  < Vertex > getVertexIndex  (  Graph graph ,  String queryPart )  {   SoftReference  < GraphIndex >  ref =  graphIndizes . get  ( graph ) ;  if  (  ref == null )  {  return null ; }  GraphIndex  index =  ref . get  ( ) ;  if  (  index == null )  {   graphIndizes . remove  ( ref ) ;  return null ; }  if  (  index . isValid  ( graph ) )  {  return  index . getVertexSet  ( queryPart ) ; }  return null ; }   public static synchronized void addVertexIndex  (  Graph graph ,  String queryPart ,   PSet  < Vertex > vertexSet )  {   SoftReference  < GraphIndex >  ref =  graphIndizes . get  ( graph ) ;  GraphIndex  index = null ;  if  (  ref != null )  {   index =  ref . get  ( ) ;  if  (  index == null )  {   graphIndizes . remove  ( ref ) ; } }  if  (  index == null )  {   index =  new GraphIndex  ( graph ) ;   graphIndizes . put  ( graph ,  new  SoftReference  < GraphIndex >  ( index ) ) ; }   index . addVertexSet  ( queryPart , vertexSet ) ; }   public  long getIndexTimeBarrier  ( )  {  return INDEX_TIME_BARRIER ; }   protected static synchronized void addOptimizedSyntaxGraph  (  String queryString ,  SyntaxGraphEntry entry )  {   SoftReference  <  List  < SyntaxGraphEntry > >  ref =  optimizedGraphs . get  ( queryString ) ;   List  < SyntaxGraphEntry >  entryList = null ;  if  (  ref != null )  {   entryList =  ref . get  ( ) ;  if  (  entryList == null )  {   optimizedGraphs . remove  ( ref ) ; } }  if  (  entryList == null )  {   entryList =  new  ArrayList  < SyntaxGraphEntry >  ( ) ; }  if  (  !  entryList . contains  ( entry ) )  {   entryList . add  ( entry ) ; }   optimizedGraphs . put  ( queryString ,  new  SoftReference  <  List  < SyntaxGraphEntry > >  ( entryList ) ) ; }   protected static synchronized SyntaxGraphEntry getOptimizedSyntaxGraph  (  String queryString ,  Optimizer optimizer ,  CostModel costModel )  {   SoftReference  <  List  < SyntaxGraphEntry > >  ref =  optimizedGraphs . get  ( queryString ) ;   List  < SyntaxGraphEntry >  entryList = null ;  if  (  ref != null )  {   entryList =  ref . get  ( ) ;  if  (  entryList == null )  {   optimizedGraphs . remove  ( ref ) ; } }  if  (  entryList == null )  {  return null ; }  for ( SyntaxGraphEntry entry : entryList )  {  if  (   entry . getCostModel  ( ) . isEquivalent  ( costModel ) )  {  Optimizer  opt =  entry . getOptimizer  ( ) ;  if  (   (   (  opt != null ) &&  opt . isEquivalent  ( optimizer ) ) ||  (   (  opt == null ) &&  (  optimizer == null ) ) )  {  if  (  entry . lock  ( ) )  {  return entry ; } } } }  return null ; }   public static synchronized void loadOptimizedSyntaxGraphs  ( )  throws GraphIOException  {  if  (  !  (    optimizedSyntaxGraphsDirectory . exists  ( ) &&  optimizedSyntaxGraphsDirectory . canRead  ( ) &&  optimizedSyntaxGraphsDirectory . canExecute  ( ) ) )  {  throw  new GraphIOException  (   optimizedSyntaxGraphsDirectory . getPath  ( ) + " is not accessible.  Does it really exist and are the permissions ok?" ) ; }  for ( File syntaxGraphFile :  optimizedSyntaxGraphsDirectory . listFiles  (  TGFilenameFilter . instance  ( ) ) )  {   logger . info  (   "Loading SyntaxGraphEntry \"" +  syntaxGraphFile . getPath  ( ) + "\"." ) ;  SyntaxGraphEntry  entry ;  try  {   entry =  new SyntaxGraphEntry  ( syntaxGraphFile ) ;   addOptimizedSyntaxGraph  (  entry . getQueryText  ( ) , entry ) ; }  catch (   GraphIOException e )  {   e . printStackTrace  ( ) ; } } }   public static synchronized void saveOptimizedSyntaxGraphs  ( )  {  for (  SoftReference  <  List  < SyntaxGraphEntry > > ref :  optimizedGraphs . values  ( ) )  {   List  < SyntaxGraphEntry >  entryList =  ref . get  ( ) ;  if  (  entryList == null )  {  continue ; }  for ( SyntaxGraphEntry entry : entryList )  {  try  {   entry . saveToDirectory  ( optimizedSyntaxGraphsDirectory ) ; }  catch (   GraphIOException e )  {   e . printStackTrace  ( ) ; } } } }   protected String  queryString = null ;   public void setQuery  (  String queryString )  {    this . queryString = queryString ;   reset  ( ) ; }   public String getQuery  ( )  {  return queryString ; }   public void setQueryFile  (  File query )  throws IOException  {  BufferedReader  reader = null ;  try  {   reader =  new BufferedReader  (  new FileReader  ( query ) ) ;  String  line = null ;  StringBuffer  sb =  new StringBuffer  ( ) ;  while  (   (  line =  reader . readLine  ( ) ) != null )  {   sb . append  ( line ) ;   sb . append  ( '\n' ) ; }    System . out . println  ( "Query read from file:" ) ;    System . out . println  (  sb . toString  ( ) ) ;   setQuery  (  sb . toString  ( ) ) ; }  finally  {  try  {   reader . close  ( ) ; }  catch (   IOException ex )  {  throw  new RuntimeException  ( "An exception occurred while closing the stream." , ex ) ; } } }   private void reset  ( )  {   queryGraph = null ;   result = null ;   started = false ;   vertexEvalGraphMarker = null ;   knownTypes . clear  ( ) ; }   protected Greql2  queryGraph = null ;   protected SyntaxGraphEntry  syntaxGraphEntry = null ;   private Optimizer  optimizer = null ;   private boolean  optimize = true ;   private boolean  useSavedOptimizedSyntaxGraph = true ;   protected Graph  datagraph = null ;   protected Object  result = null ;   protected CostModel  costModel = null ;   protected ProgressFunction  progressFunction = null ;   protected  long  progressStepsPassed = 0 ;   protected  long  overallEvaluationTime =  - 1 ;   protected  long  plainEvaluationTime =  - 1 ;   protected  long  optimizationTime =  - 1 ;   protected  long  parseTime =  - 1 ;   public  long getOverallEvaluationTime  ( )  {  return overallEvaluationTime ; }   protected boolean  started = false ;   protected  Map  < String , Object >  variableMap = null ;   protected  LinkedHashMap  < String , Greql2 >  subQueryMap = null ;   protected  long  estimatedInterpretationSteps = 0 ;   protected  long  passedInterpretationSteps = 0 ;   public final void progress  (   long value )  {   progressStepsPassed += value ;  if  (  progressFunction != null )  {  while  (  progressStepsPassed >  progressFunction . getUpdateInterval  ( ) )  {   progressFunction . progress  ( 1 ) ;   progressStepsPassed -=  progressFunction . getUpdateInterval  ( ) ; } }   passedInterpretationSteps += value ; }   public  Map  < String , Object > getVariables  ( )  {  return variableMap ; }   public Object getVariable  (  String name )  {  return   variableMap == null ? null :  variableMap . get  ( name ) ; }   public void setVariables  (   Map  < String , Object > varMap )  {   variableMap = varMap ; }   public void setVariable  (  String varName ,  Object value )  {  if  (  variableMap == null )  {   variableMap =  new  HashMap  < String , Object >  ( ) ; }   variableMap . put  ( varName , value ) ; }   public void setSubQuery  (  String name ,  String greqlQuery )  {  if  (  name == null )  {  throw  new GreqlException  ( "The name of a subquery must not be null!" ) ; }  if  (  !  name . matches  ( "^\\w+$" ) )  {  throw  new GreqlException  (   "Invalid subquery name '" + name + "'. Only word chars are allowed." ) ; }  if  (  FunLib . contains  ( name ) )  {  throw  new GreqlException  (   "The subquery '" + name + "' would shadow a GReQL function!" ) ; }   Set  < String >  definedSubQueries =  subQueryMap . keySet  ( ) ;   HashSet  < String >  subQueryNames =  new  HashSet  < String >  (   definedSubQueries . size  ( ) + 1 ) ;   subQueryNames . addAll  ( definedSubQueries ) ;   subQueryNames . add  ( name ) ;  GreqlParser  parser =  new GreqlParser  ( greqlQuery , subQueryNames ) ;   parser . parse  ( ) ;  Greql2  subQueryGraph =  parser . getGraph  ( ) ;    subQueryGraph . getFirstGreql2Expression  ( ) . set_queryText  ( name ) ;  if  (  isOptimize  ( ) )  {  Greql2  oldQueryGraph = queryGraph ;  String  oldQueryString = queryString ;   queryGraph = subQueryGraph ;   queryString = greqlQuery ;   createOptimizedSyntaxGraph  ( ) ;   queryGraph = oldQueryGraph ;   queryString = oldQueryString ; }  for ( FunctionApplication fa :  subQueryGraph . getFunctionApplicationVertices  ( ) )  {  if  (  name . equals  (   fa . get_functionId  ( ) . get_name  ( ) ) )  {  throw  new GreqlException  (   "The subquery '" + name + "' is recursive.  That's not allowed!" ) ; } }   subQueryMap . put  ( name , subQueryGraph ) ; }   public Greql2 getSubQuery  (  String name )  {  return  subQueryMap . get  ( name ) ; }   public Object getResult  ( )  {  return result ; }    @ SuppressWarnings  ( "unchecked" ) public  <  T > T getSingleResult  ( )  {  return  ( T ) result ; }    @ SuppressWarnings  ( "unchecked" ) public  <  T >  PVector  < T > getResultList  ( )  {  return  (  PVector  < T > ) result ; }    @ SuppressWarnings  ( "unchecked" ) public  <  K ,  V >  PMap  < K , V > getResultMap  ( )  {  return  (  PMap  < K , V > ) result ; }    @ SuppressWarnings  ( "unchecked" ) public  <  T >  POrderedSet  < T > getResultSet  ( )  {  return  (  POrderedSet  < T > ) result ; }   private static File getTmpDirectory  ( )  {  File  tmpFile = null ,  tmpDir = null ;  try  {   tmpFile =  File . createTempFile  ( "_tmp" , "xyz" ) ;   tmpDir =  tmpFile . getParentFile  ( ) ;   tmpFile . delete  ( ) ; }  catch (   IOException e )  {   e . printStackTrace  ( ) ;   tmpDir =  new File  ( "/tmp/" ) ; }  return tmpDir ; }   public CostModel getCostModel  ( )  {  return costModel ; }   public void setCostModel  (  CostModel m )  {   costModel = m ; }   public Greql2 getSyntaxGraph  ( )  {  return queryGraph ; }   public GreqlEvaluator  (  String query ,  Graph datagraph ,   Map  < String , Object > variables ,  ProgressFunction progressFunction )  {  this  ( datagraph , variables , progressFunction ) ;   setQuery  ( query ) ; }   private GreqlEvaluator  (  Graph datagraph ,   Map  < String , Object > variables ,  ProgressFunction progressFunction )  {    this . datagraph = datagraph ;   knownTypes =  new  HashMap  < String ,  GraphElementClass  <  ? ,  ? > >  ( ) ;   variableMap = variables ;   subQueryMap =  new  LinkedHashMap  < String , Greql2 >  ( ) ;    this . progressFunction = progressFunction ; }   public void addKnownType  (   GraphElementClass  <  ? ,  ? > knownType )  {   knownTypes . put  (  knownType . getSimpleName  ( ) , knownType ) ; }   public  GraphElementClass  <  ? ,  ? > getKnownType  (  String typeSimpleName )  {  return  knownTypes . get  ( typeSimpleName ) ; }   public GreqlEvaluator  (  String query ,  Graph datagraph ,   Map  < String , Object > variables )  {  this  ( query , datagraph , variables , null ) ; }   public GreqlEvaluator  (  File queryFile ,  Graph datagraph ,   Map  < String , Object > variables ,  ProgressFunction progressFunction )  throws FileNotFoundException , IOException  {  this  ( datagraph , variables , progressFunction ) ;   setQueryFile  ( queryFile ) ; }   public GreqlEvaluator  (  File queryFile ,  Graph datagraph ,   Map  < String , Object > variables )  throws FileNotFoundException , IOException  {  this  ( queryFile , datagraph , variables , null ) ; }   public Graph getDatagraph  ( )  {  return datagraph ; }   protected boolean parseQuery  (  String query )  {   long  parseStartTime =  System . currentTimeMillis  ( ) ;  GreqlParser  parser =  new GreqlParser  ( query ,  subQueryMap . keySet  ( ) ) ;   parser . parse  ( ) ;   queryGraph =  parser . getGraph  ( ) ;   weaveInSubQueries  ( ) ;   parseTime =   System . currentTimeMillis  ( ) - parseStartTime ;  return true ; }   private void weaveInSubQueries  ( )  {  if  (   (  subQueryMap == null ) ||  subQueryMap . isEmpty  ( ) )  {  return ; }  FunctionApplication  subqueryCall =  findSubQueryCall  ( ) ;  while  (  subqueryCall != null )  {  TGMerge  tgm =  new TGMerge  ( queryGraph ,  subQueryMap . get  (   subqueryCall . get_functionId  ( ) . get_name  ( ) ) ) ;   tgm . merge  ( ) ;   weaveInSubquery  ( subqueryCall ) ;   subqueryCall =  findSubQueryCall  ( ) ; } }   private FunctionApplication findSubQueryCall  ( )  {  for ( FunctionApplication fa :  queryGraph . getFunctionApplicationVertices  ( ) )  {  if  (  subQueryMap . containsKey  (   fa . get_functionId  ( ) . get_name  ( ) ) )  {  return fa ; } }  return null ; }   private void weaveInSubquery  (  FunctionApplication fa )  {  FunctionId  fid =  fa . get_functionId  ( ) ;  String  name =  fid . get_name  ( ) ;  Greql2Expression  g2exp = null ;  for ( Greql2Expression e :  queryGraph . getGreql2ExpressionVertices  ( ) )  {  if  (   (   e . get_queryText  ( ) != null ) &&   e . get_queryText  ( ) . equals  ( name ) )  {   g2exp = e ;  break ; } }  Expression  exp =  g2exp . get_queryExpr  ( ) ;   ArrayList  < Variable >  boundVars =  new  ArrayList  < Variable >  ( ) ;  for ( Variable bv :  g2exp . get_boundVar  ( ) )  {   boundVars . add  ( bv ) ; }   ArrayList  < Expression >  args =  new  ArrayList  < Expression >  ( ) ;  for ( Expression arg :  fa . get_argument  ( ) )  {   args . add  ( arg ) ; }  if  (   args . size  ( ) !=  boundVars . size  ( ) )  {  throw  new GreqlException  (       "Subquery call to '" + name + "' has " +  args . size  ( ) + " arguments, but the subquery definition has " +  boundVars . size  ( ) + " formal parameters!" ) ; }  for (   int  i = 0 ;  i <  boundVars . size  ( ) ;  i ++ )  {  Expression  arg =  args . get  ( i ) ;  Variable  bv =  boundVars . get  ( i ) ;  Edge  e =  bv . getFirstIncidence  ( ) ;  while  (  e != null )  {  if  (   e . getSchemaClass  ( ) ==  IsBoundVarOf . class )  {   e =  e . getNextIncidence  ( ) ;  continue ; }   e . setThis  ( arg ) ;   e =  bv . getFirstIncidence  ( ) ; } }  Edge  e =  fa . getFirstIncidence  (  EdgeDirection . OUT ) ;  while  (  e != null )  {  if  (   e . getSchemaClass  ( ) ==  IsFunctionIdOf . class )  {   e =  e . getNextIncidence  (  EdgeDirection . OUT ) ;  continue ; }   e . setThis  ( exp ) ;   e =  fa . getFirstIncidence  (  EdgeDirection . OUT ) ; }   fa . delete  ( ) ;  if  (   fid . getDegree  ( ) == 0 )  {   fid . delete  ( ) ; }   g2exp . delete  ( ) ;  for ( Variable bv : boundVars )  {   bv . delete  ( ) ; } }   public void createVertexEvaluators  ( )  {  if  (  queryGraph == null )  {  return ; }   vertexEvalGraphMarker =  new  GraphMarker  < VertexEvaluator >  ( queryGraph ) ;  Vertex  currentVertex =  queryGraph . getFirstVertex  ( ) ;  while  (  currentVertex != null )  {  VertexEvaluator  vertexEval =  VertexEvaluator . createVertexEvaluator  ( currentVertex , this ) ;  if  (  vertexEval != null )  {   vertexEvalGraphMarker . mark  ( currentVertex , vertexEval ) ; }   currentVertex =  currentVertex . getNextVertex  ( ) ; } }   private void resetVertexEvaluators  ( )  {  Vertex  currentVertex =  queryGraph . getFirstVertex  ( ) ;  while  (  currentVertex != null )  {  VertexEvaluator  vertexEval =  vertexEvalGraphMarker . getMark  ( currentVertex ) ;  if  (  vertexEval != null )  {   vertexEval . resetToInitialState  ( ) ; }   currentVertex =  currentVertex . getNextVertex  ( ) ; } }   public void createOptimizedSyntaxGraph  ( )  throws OptimizerException  {   long  optimizerStartTime =  System . currentTimeMillis  ( ) ;  if  (  optimizer == null )  {   optimizer =  new DefaultOptimizer  ( ) ; }  if  (  costModel == null )  {   costModel =  new DefaultCostModel  ( ) ; }  if  (  useSavedOptimizedSyntaxGraph &&  optimizedGraphs . containsKey  ( queryString ) )  {   syntaxGraphEntry =  getOptimizedSyntaxGraph  ( queryString , optimizer , costModel ) ;  if  (  syntaxGraphEntry != null )  {   queryGraph =  syntaxGraphEntry . getSyntaxGraph  ( ) ;   createVertexEvaluators  ( ) ;   logger . info  ( "Using stored optimized syntax graph." ) ;  return ; } }  if  (  queryGraph == null )  {   parseQuery  ( queryString ) ; }  if  ( DEBUG_OPTIMIZATION )  {    System . out . println  ( "#########################################################" ) ;    System . out . println  ( "################## Unoptimized Query ####################" ) ;    System . out . println  ( "#########################################################" ) ;  String  name = "__greql-query." ;  try  {   queryGraph . save  (  name + "tg" ,  new ConsoleProgressFunction  ( "Saving broken GReQL graph:" ) ) ;   printGraphAsDot  ( queryGraph , true ,  name + "dot" ) ; }  catch (   GraphIOException e )  {   e . printStackTrace  ( ) ; }    System . out . println  (   "Saved query graph to " + name + "tg/dot." ) ;    System . out . println  ( "#########################################################" ) ; }   createVertexEvaluators  ( ) ;   optimizer . optimize  ( this , queryGraph ) ;   syntaxGraphEntry =  new SyntaxGraphEntry  ( queryString , queryGraph , optimizer , costModel , true ) ;   addOptimizedSyntaxGraph  ( queryString , syntaxGraphEntry ) ;   createVertexEvaluators  ( ) ;   optimizationTime =   System . currentTimeMillis  ( ) - optimizerStartTime ; }   public boolean startEvaluation  ( )  throws OptimizerException  {  if  ( started )  {  return  result != null ; }   started = true ;   parseTime = 0 ;   optimizationTime = 0 ;   plainEvaluationTime = 0 ;   overallEvaluationTime = 0 ;   long  startTime =  System . currentTimeMillis  ( ) ;  if  (  costModel == null )  {   costModel =  new DefaultCostModel  ( ) ; }  if  ( optimize )  {   createOptimizedSyntaxGraph  ( ) ;  if  ( DEBUG_OPTIMIZATION )  {    System . out . println  ( "#########################################################" ) ;    System . out . println  ( "################### Optimized Query #####################" ) ;    System . out . println  ( "#########################################################" ) ;    System . out . println  (  GreqlSerializer . serializeGraph  ( queryGraph ) ) ;  String  name = "__optimized-greql-query." ;  try  {   queryGraph . save  (  name + "tg" ,  new ConsoleProgressFunction  ( "Saving" ) ) ;   printGraphAsDot  ( queryGraph , true ,  name + "dot" ) ; }  catch (   GraphIOException e )  {   e . printStackTrace  ( ) ; }    System . out . println  (   "Saved optimized query graph to " + name + "tg/dot." ) ;    System . out . println  ( "#########################################################" ) ; } } else  {   parseQuery  ( queryString ) ;   createVertexEvaluators  ( ) ; }  if  (  queryGraph == null )  {  throw  new GreqlException  ( "Query graph is null. Evaluation impossible." ) ; }  if  (   queryGraph . getVCount  ( ) <= 1 )  {   result =  Undefined . UNDEFINED ;  return true ; }  VertexEvaluator  greql2ExpEval =  vertexEvalGraphMarker . getMark  (  queryGraph . getFirstGreql2Expression  ( ) ) ;  if  (  progressFunction != null )  {   estimatedInterpretationSteps =  greql2ExpEval . getInitialSubtreeEvaluationCosts  (  new GraphSize  ( datagraph ) ) ;   progressFunction . init  ( estimatedInterpretationSteps ) ; }   long  plainEvaluationStartTime =  System . currentTimeMillis  ( ) ;   result =  greql2ExpEval . getResult  ( ) ;  if  (  progressFunction != null )  {   progressFunction . finished  ( ) ; }   plainEvaluationTime =   System . currentTimeMillis  ( ) - plainEvaluationStartTime ;   resetVertexEvaluators  ( ) ;  if  (  syntaxGraphEntry != null )  {   syntaxGraphEntry . release  ( ) ; }   overallEvaluationTime =   System . currentTimeMillis  ( ) - startTime ;   started = false ;  return true ; }   private void printGraphAsDot  (  Graph graph ,  boolean reversedEdges ,  String outputFilename )  {  try  {   Class  <  ? >  tg2DotClass =  Class . forName  ( "de.uni_koblenz.jgralab.utilities.tg2dot.Tg2Dot" ) ;  Method  printMethod =  tg2DotClass . getMethod  ( "convertGraph" ,  Graph . class ,  String . class ,  boolean . class ) ;   printMethod . invoke  ( tg2DotClass ,  new Object  [ ]  { graph , outputFilename , reversedEdges } ) ; }  catch (   ClassNotFoundException e )  {   e . printStackTrace  ( ) ; }  catch (   SecurityException e )  {   e . printStackTrace  ( ) ; }  catch (   NoSuchMethodException e )  {   e . printStackTrace  ( ) ; }  catch (   IllegalArgumentException e )  {   e . printStackTrace  ( ) ; }  catch (   IllegalAccessException e )  {   e . printStackTrace  ( ) ; }  catch (   InvocationTargetException e )  {   e . printStackTrace  ( ) ; } }   public void setOptimizer  (  Optimizer optimizer )  {    this . optimizer = optimizer ; }   public Optimizer getOptimizer  ( )  {  return optimizer ; }   public void setDatagraph  (  Graph datagraph )  {    this . datagraph = datagraph ; }   public boolean isOptimize  ( )  {  return optimize ; }   public void setOptimize  (  boolean optimize )  {    this . optimize = optimize ; }   public  long getOptimizationTime  ( )  {  return optimizationTime ; }   public  long getParseTime  ( )  {  return parseTime ; }   public  long getPlainEvaluationTime  ( )  {  return plainEvaluationTime ; }   public void printEvaluationTimes  ( )  {   logger . info  (           "Overall evaluation took " +  (  overallEvaluationTime / 1000d ) + " seconds.\n" + " --> parsing time         : " +  (  parseTime / 1000d ) + "\n --> optimization time    : " +  (  optimizationTime / 1000d ) + "\n --> plain evaluation time: " +  (  plainEvaluationTime / 1000d ) + "\n" +  (   progressFunction != null ?  "Estimated evaluation costs: " + estimatedInterpretationSteps : "" ) ) ; }   public static File getOptimizedSyntaxGraphsDirectory  ( )  {  return optimizedSyntaxGraphsDirectory ; }   public static void setOptimizedSyntaxGraphsDirectory  (  File optimizedSyntaxGraphsDirectory )  {    GreqlEvaluator . optimizedSyntaxGraphsDirectory = optimizedSyntaxGraphsDirectory ; }   public boolean isUseSavedOptimizedSyntaxGraph  ( )  {  return useSavedOptimizedSyntaxGraph ; }   public void setUseSavedOptimizedSyntaxGraph  (  boolean useSavedOptimizedSyntaxGraph )  {    this . useSavedOptimizedSyntaxGraph = useSavedOptimizedSyntaxGraph ; } }
>>>>>>>
