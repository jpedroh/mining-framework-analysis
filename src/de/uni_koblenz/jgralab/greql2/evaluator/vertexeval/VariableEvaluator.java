  package      de . uni_koblenz . jgralab . greql2 . evaluator . vertexeval ;   import   java . util . ArrayList ;  import   java . util . HashSet ;  import   java . util . LinkedList ;  import   java . util . List ;  import   java . util . Queue ;  import   java . util . Set ;  import    de . uni_koblenz . jgralab . EdgeDirection ;  import    de . uni_koblenz . jgralab . Vertex ;  import      de . uni_koblenz . jgralab . greql2 . evaluator . InternalGreqlEvaluator ;  import      de . uni_koblenz . jgralab . greql2 . evaluator . QueryImpl ;  import      de . uni_koblenz . jgralab . greql2 . schema . Declaration ;  import      de . uni_koblenz . jgralab . greql2 . schema . Definition ;  import      de . uni_koblenz . jgralab . greql2 . schema . Expression ;  import      de . uni_koblenz . jgralab . greql2 . schema . Greql2Aggregation ;  import      de . uni_koblenz . jgralab . greql2 . schema . Greql2Vertex ;  import      de . uni_koblenz . jgralab . greql2 . schema . SimpleDeclaration ;  import      de . uni_koblenz . jgralab . greql2 . schema . Variable ;   public class VariableEvaluator  <  V  extends Variable >  extends  VertexEvaluator  < V >  {   private  List  <  VertexEvaluator  <  ? extends Expression > >  dependingExpressions ;   private final  long  estimatedAssignments =  Long . MIN_VALUE ;   public void setValue  (  Object variableValue ,  InternalGreqlEvaluator evaluator )  {  if  (  dependingExpressions == null )  {   dependingExpressions =  calculateDependingExpressions  ( ) ; }   int  size =  dependingExpressions . size  ( ) ;  for (   int  i = 0 ;  i < size ;  i ++ )  {    dependingExpressions . get  ( i ) . clear  ( evaluator ) ; }   evaluator . setLocalEvaluationResult  ( vertex , variableValue ) ; }   public Object getValue  (  InternalGreqlEvaluator evaluator )  {  return  evaluator . getLocalEvaluationResult  ( vertex ) ; }   public VariableEvaluator  (  V vertex ,  QueryImpl query )  {  super  ( vertex , query ) ; }    @ Override public Object evaluate  (  InternalGreqlEvaluator evaluator )  {  return  getValue  ( evaluator ) ; }    @ Override public Object getResult  (  InternalGreqlEvaluator evaluator )  {  return  getValue  ( evaluator ) ; }    @ Override public  Set  < Variable > getNeededVariables  ( )  {  if  (  neededVariables == null )  {   neededVariables =  new  HashSet  < Variable >  ( ) ;   neededVariables . add  ( vertex ) ; }  return neededVariables ; }    @ Override public  Set  < Variable > getDefinedVariables  ( )  {  if  (  definedVariables == null )  {   definedVariables =  new  HashSet  < Variable >  ( ) ; }  return definedVariables ; }    @ SuppressWarnings  ( "unchecked" ) public  List  <  VertexEvaluator  <  ? extends Expression > > calculateDependingExpressions  ( )  {   Queue  < Greql2Vertex >  queue =  new  LinkedList  < Greql2Vertex >  ( ) ;   List  <  VertexEvaluator  <  ? extends Expression > >  dependingEvaluators =  new  ArrayList  <  VertexEvaluator  <  ? extends Expression > >  ( ) ;   List  < Vertex >  forbiddenVertices =  new  ArrayList  < Vertex >  ( ) ;  SimpleDeclaration  simpleDecl = null ;  if  (   vertex . getFirstIsDeclaredVarOfIncidence  (  EdgeDirection . OUT ) != null )  {   simpleDecl =  ( SimpleDeclaration )   vertex . getFirstIsDeclaredVarOfIncidence  (  EdgeDirection . OUT ) . getThat  ( ) ; }  if  (  simpleDecl != null )  {   forbiddenVertices . add  ( simpleDecl ) ;  Declaration  declaringVertex =  ( Declaration )   simpleDecl . getFirstIsSimpleDeclOfIncidence  ( ) . getThat  ( ) ;  if  (   declaringVertex . getFirstIsCompDeclOfIncidence  (  EdgeDirection . OUT ) != null )  {   forbiddenVertices . add  (   declaringVertex . getFirstIsCompDeclOfIncidence  (  EdgeDirection . OUT ) . getThat  ( ) ) ; } else  {   forbiddenVertices . add  (   declaringVertex . getFirstIsQuantifiedDeclOfIncidence  (  EdgeDirection . OUT ) . getThat  ( ) ) ; } } else  {  if  (   vertex . getFirstIsVarOfIncidence  (  EdgeDirection . OUT ) != null )  {  Definition  definingVertex =  ( Definition )   vertex . getFirstIsVarOfIncidence  (  EdgeDirection . OUT ) . getThat  ( ) ;   forbiddenVertices . add  ( definingVertex ) ;   forbiddenVertices . add  (   definingVertex . getFirstIsDefinitionOfIncidence  (  EdgeDirection . OUT ) . getThat  ( ) ) ; } else  { } }   queue . add  ( vertex ) ;  while  (  !  queue . isEmpty  ( ) )  {  Greql2Vertex  currentVertex =  queue . poll  ( ) ;   VertexEvaluator  <  ? >  eval =  query . getVertexEvaluator  ( currentVertex ) ;  if  (      (  eval != null ) &&  (  !  dependingEvaluators . contains  ( eval ) ) &&  (  !  (  eval instanceof PathDescriptionEvaluator ) ) &&  (  !  (  eval instanceof DeclarationEvaluator ) ) &&  (  !  (  eval instanceof SimpleDeclarationEvaluator ) ) )  {   dependingEvaluators . add  (  (  VertexEvaluator  <  ? extends Expression > ) eval ) ; }  Greql2Aggregation  currentEdge =  currentVertex . getFirstGreql2AggregationIncidence  (  EdgeDirection . OUT ) ;  while  (  currentEdge != null )  {  Greql2Vertex  nextVertex =  ( Greql2Vertex )  currentEdge . getThat  ( ) ;  if  (  !  forbiddenVertices . contains  ( nextVertex ) )  {   queue . add  ( nextVertex ) ; }   currentEdge =  currentEdge . getNextGreql2AggregationIncidence  (  EdgeDirection . OUT ) ; } }  return dependingEvaluators ; }    @ Override public void calculateNeededAndDefinedVariables  ( )  { } }