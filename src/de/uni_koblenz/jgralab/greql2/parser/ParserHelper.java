  package     de . uni_koblenz . jgralab . greql2 . parser ;   import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . HashSet ;  import   java . util . LinkedList ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Queue ;  import   java . util . Set ;  import   org . pcollections . PVector ;  import    de . uni_koblenz . jgralab . Edge ;  import    de . uni_koblenz . jgralab . EdgeDirection ;  import    de . uni_koblenz . jgralab . JGraLab ;  import    de . uni_koblenz . jgralab . Vertex ;  import      de . uni_koblenz . jgralab . greql2 . exception . DuplicateVariableException ;  import      de . uni_koblenz . jgralab . greql2 . exception . ParsingException ;  import      de . uni_koblenz . jgralab . greql2 . exception . UndefinedVariableException ;  import      de . uni_koblenz . jgralab . greql2 . schema . Comprehension ;  import      de . uni_koblenz . jgralab . greql2 . schema . Declaration ;  import      de . uni_koblenz . jgralab . greql2 . schema . Definition ;  import      de . uni_koblenz . jgralab . greql2 . schema . DefinitionExpression ;  import      de . uni_koblenz . jgralab . greql2 . schema . Expression ;  import      de . uni_koblenz . jgralab . greql2 . schema . FunctionApplication ;  import      de . uni_koblenz . jgralab . greql2 . schema . FunctionId ;  import      de . uni_koblenz . jgralab . greql2 . schema . Greql2Aggregation ;  import      de . uni_koblenz . jgralab . greql2 . schema . Greql2Expression ;  import      de . uni_koblenz . jgralab . greql2 . schema . Greql2Graph ;  import      de . uni_koblenz . jgralab . greql2 . schema . Greql2Vertex ;  import      de . uni_koblenz . jgralab . greql2 . schema . Identifier ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsArgumentOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsBooleanPredicateOfEdgeRestriction ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsBoundExprOfQuantifiedExpression ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsBoundVarOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsColumnHeaderExprOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsConstraintOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsDeclaredVarOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsDefinitionOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsExprOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsFunctionIdOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsGoalRestrOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsKeyExprOfComprehension ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsQuantifiedDeclOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsQueryExprOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsRowHeaderExprOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsSimpleDeclOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsStartRestrOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsTableHeaderOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsValueExprOfComprehension ;  import      de . uni_koblenz . jgralab . greql2 . schema . IsVarOf ;  import      de . uni_koblenz . jgralab . greql2 . schema . ListComprehension ;  import      de . uni_koblenz . jgralab . greql2 . schema . MapComprehension ;  import      de . uni_koblenz . jgralab . greql2 . schema . PathDescription ;  import      de . uni_koblenz . jgralab . greql2 . schema . QuantifiedExpression ;  import      de . uni_koblenz . jgralab . greql2 . schema . SimpleDeclaration ;  import      de . uni_koblenz . jgralab . greql2 . schema . SourcePosition ;  import      de . uni_koblenz . jgralab . greql2 . schema . TableComprehension ;  import      de . uni_koblenz . jgralab . greql2 . schema . ThisEdge ;  import      de . uni_koblenz . jgralab . greql2 . schema . ThisLiteral ;  import      de . uni_koblenz . jgralab . greql2 . schema . ThisVertex ;  import      de . uni_koblenz . jgralab . greql2 . schema . Variable ;  import      de . uni_koblenz . jgralab . greql2 . schema . WhereExpression ;  import     de . uni_koblenz . jgralab . schema . EdgeClass ;  import     de . uni_koblenz . jgralab . schema . VertexClass ;   public abstract class ParserHelper  {   protected String  query = null ;   protected Greql2Graph  graph ;   protected SymbolTable  afterParsingvariableSymbolTable = null ;   protected SimpleSymbolTable  duringParsingvariableSymbolTable = null ;   protected  Map  < String , FunctionId >  functionSymbolTable = null ;   protected boolean  graphCleaned = false ;   protected Token  lookAhead = null ;   protected abstract boolean inPredicateMode  ( ) ;   protected final  int getCurrentOffset  ( )  {  if  (  lookAhead != null )  {  return  lookAhead . getOffset  ( ) ; }  return  query . length  ( ) ; }   protected final  int getLength  (   int offset )  {  return   getCurrentOffset  ( ) - offset ; }   public PathDescription addPathElement  (  VertexClass vc ,  EdgeClass ec ,  PathDescription pathDescr ,  PathDescription part1 ,   int offsetPart1 ,   int lengthPart1 ,  PathDescription part2 ,   int offsetPart2 ,   int lengthPart2 )  {  Greql2Aggregation  edge = null ;  if  (  pathDescr == null )  {   pathDescr =  graph . createVertex  ( vc ) ;   edge =  ( Greql2Aggregation )  graph . createEdge  ( ec , part1 , pathDescr ) ;   edge . set_sourcePositions  (  createSourcePositionList  ( lengthPart1 , offsetPart1 ) ) ; }   edge =  ( Greql2Aggregation )  graph . createEdge  ( ec , part2 , pathDescr ) ;   edge . set_sourcePositions  (  createSourcePositionList  ( lengthPart2 , offsetPart2 ) ) ;  return pathDescr ; }   public Greql2Graph getGraph  ( )  {  if  (  graph == null )  {  return null ; }   cleanGraph  ( ) ;  return graph ; }   private void cleanGraph  ( )  {  if  (  ! graphCleaned )  {   Set  < Vertex >  reachableVertices =  new  HashSet  < Vertex >  ( ) ;   Queue  < Vertex >  queue =  new  LinkedList  < Vertex >  ( ) ;  Greql2Expression  root =  graph . getFirstGreql2Expression  ( ) ;   queue . add  ( root ) ;  while  (  !  queue . isEmpty  ( ) )  {  Vertex  current =  queue . poll  ( ) ;  if  (  current != null )  {  for ( Edge e :  current . incidences  ( ) )  {  if  (  !  reachableVertices . contains  (  e . getThat  ( ) ) )  {   queue . add  (  e . getThat  ( ) ) ;   reachableVertices . add  (  e . getThat  ( ) ) ; } } } }  Vertex  deleteCandidate =  graph . getFirstVertex  ( ) ;  while  (   (  deleteCandidate != null ) &&  (  !  reachableVertices . contains  ( deleteCandidate ) ) )  {   deleteCandidate . delete  ( ) ;   deleteCandidate =  graph . getFirstVertex  ( ) ; }  while  (  deleteCandidate != null )  {  if  (  !  reachableVertices . contains  ( deleteCandidate ) )  {  Vertex  v =  deleteCandidate . getNextVertex  ( ) ;   deleteCandidate . delete  ( ) ;   deleteCandidate = v ; } else  {   deleteCandidate =  deleteCandidate . getNextVertex  ( ) ; } }   replaceDefinitionExpressions  ( ) ;   eliminateUnusedNodes  ( ) ; } }   protected void replaceDefinitionExpressions  ( )  throws DuplicateVariableException , UndefinedVariableException  {   List  < DefinitionExpression >  list =  new  ArrayList  < DefinitionExpression >  ( ) ;  for ( DefinitionExpression exp :  graph . getDefinitionExpressionVertices  ( ) )  {   list . add  ( exp ) ; }  for ( DefinitionExpression exp : list )  {   List  < Definition >  defList =  new  ArrayList  < Definition >  ( ) ;  for ( IsDefinitionOf isDefOf :  exp . getIsDefinitionOfIncidences  (  EdgeDirection . IN ) )  {  Definition  definition =  ( Definition )  isDefOf . getAlpha  ( ) ;   defList . add  ( definition ) ; }  if  (  exp instanceof WhereExpression )  {   Collections . reverse  ( defList ) ; }  for ( Definition definition : defList )  {  IsExprOf  isExprOf =  definition . getFirstIsExprOfIncidence  (  EdgeDirection . IN ) ;  IsVarOf  isVarOf =  definition . getFirstIsVarOfIncidence  (  EdgeDirection . IN ) ;  Expression  expr =  ( Expression )  isExprOf . getAlpha  ( ) ;  Variable  variable =  ( Variable )  isVarOf . getAlpha  ( ) ;   isVarOf . delete  ( ) ;   isExprOf . delete  ( ) ;  Edge  e =  variable . getFirstIncidence  (  EdgeDirection . OUT ) ;  while  (  e != null )  {   e . setAlpha  ( expr ) ;   e =  variable . getFirstIncidence  (  EdgeDirection . OUT ) ; }   variable . delete  ( ) ; }  Expression  boundExpr =  ( Expression )   exp . getFirstIsBoundExprOfIncidence  (  EdgeDirection . IN ) . getAlpha  ( ) ;  Edge  e =  exp . getFirstIncidence  (  EdgeDirection . OUT ) ;  while  (  e != null )  {   e . setAlpha  ( boundExpr ) ;   e =  exp . getFirstIncidence  (  EdgeDirection . OUT ) ; }   exp . delete  ( ) ; } }   protected void eliminateUnusedNodes  ( )  {   List  < Vertex >  deleteList =  new  ArrayList  < Vertex >  ( ) ;  for ( Vertex v :  graph . vertices  ( ) )  {  if  (   v . getFirstIncidence  ( ) == null )  {   deleteList . add  ( v ) ; } }  for ( Vertex v : deleteList )  {   v . delete  ( ) ; } }   private void mergeVariables  (  Vertex v ,  boolean separateScope )  throws DuplicateVariableException , UndefinedVariableException  {  if  (  v instanceof DefinitionExpression )  {   mergeVariablesInDefinitionExpression  (  ( DefinitionExpression ) v , separateScope ) ; } else  if  (  v instanceof Comprehension )  {   mergeVariablesInComprehension  (  ( Comprehension ) v , separateScope ) ; } else  if  (  v instanceof QuantifiedExpression )  {   mergeVariablesInQuantifiedExpression  (  ( QuantifiedExpression ) v , separateScope ) ; } else  if  (  v instanceof Greql2Expression )  {   mergeVariablesInGreql2Expression  (  ( Greql2Expression ) v ) ; } else  if  (  v instanceof ThisLiteral )  {  return ; } else  if  (  v instanceof Variable )  {  Vertex  var =  afterParsingvariableSymbolTable . lookup  (   (  ( Variable ) v ) . get_name  ( ) ) ;  if  (  var != null )  {  if  (  var != v )  {  Edge  inc =  v . getFirstIncidence  (  EdgeDirection . OUT ) ;   inc . setAlpha  ( var ) ;  if  (   v . getDegree  ( ) <= 0 )  {   v . delete  ( ) ; } } } else  {  Greql2Aggregation  e =  ( Greql2Aggregation )  v . getFirstIncidence  (  EdgeDirection . OUT ) ;  throw  new UndefinedVariableException  (  ( Variable ) v ,  e . get_sourcePositions  ( ) ) ; } } else  {   ArrayList  < Edge >  incidenceList =  new  ArrayList  < Edge >  ( ) ;  for ( Edge inc :  v . incidences  (  EdgeDirection . IN ) )  {   incidenceList . add  ( inc ) ; }  for ( Edge e : incidenceList )  {   mergeVariables  (  e . getAlpha  ( ) , true ) ; } } }   protected final void mergeVariablesInGreql2Expression  (  Greql2Expression root )  throws DuplicateVariableException , UndefinedVariableException  {   afterParsingvariableSymbolTable . blockBegin  ( ) ;  for ( IsBoundVarOf isBoundVarOf :  root . getIsBoundVarOfIncidences  (  EdgeDirection . IN ) )  {   afterParsingvariableSymbolTable . insert  (   (  ( Identifier )  isBoundVarOf . getAlpha  ( ) ) . get_name  ( ) ,  isBoundVarOf . getAlpha  ( ) ) ; }  IsQueryExprOf  isQueryExprOf =  root . getFirstIsQueryExprOfIncidence  (  EdgeDirection . IN ) ;   mergeVariables  (  isQueryExprOf . getAlpha  ( ) , true ) ;   afterParsingvariableSymbolTable . blockEnd  ( ) ; }   private void mergeVariablesInDefinitionExpression  (  DefinitionExpression v ,  boolean separateScope )  throws DuplicateVariableException , UndefinedVariableException  {  if  ( separateScope )  {   afterParsingvariableSymbolTable . blockBegin  ( ) ; }  for ( IsDefinitionOf currentEdge :  v . getIsDefinitionOfIncidences  (  EdgeDirection . IN ) )  {  Definition  definition =  ( Definition )  currentEdge . getAlpha  ( ) ;  Variable  variable =  ( Variable )   definition . getFirstIsVarOfIncidence  (  EdgeDirection . IN ) . getAlpha  ( ) ;   afterParsingvariableSymbolTable . insert  (  variable . get_name  ( ) , variable ) ; }  Edge  isBoundExprOf =  v . getFirstIsBoundExprOfDefinitionIncidence  (  EdgeDirection . IN ) ;   mergeVariables  (  isBoundExprOf . getAlpha  ( ) , false ) ;  for ( IsDefinitionOf currentEdge :  v . getIsDefinitionOfIncidences  (  EdgeDirection . IN ) )  {  Definition  definition =  ( Definition )  currentEdge . getAlpha  ( ) ;  Expression  expr =  ( Expression )   definition . getFirstIsExprOfIncidence  (  EdgeDirection . IN ) . getAlpha  ( ) ;   mergeVariables  ( expr , true ) ; }  if  ( separateScope )  {   afterParsingvariableSymbolTable . blockEnd  ( ) ; } }   private void mergeVariablesInDeclaration  (  Declaration v )  throws DuplicateVariableException , UndefinedVariableException  {  for ( IsSimpleDeclOf currentEdge :  v . getIsSimpleDeclOfIncidences  (  EdgeDirection . IN ) )  {  SimpleDeclaration  simpleDecl =  ( SimpleDeclaration )  currentEdge . getAlpha  ( ) ;  for ( IsDeclaredVarOf isDeclaredVarOf :  simpleDecl . getIsDeclaredVarOfIncidences  (  EdgeDirection . IN ) )  {  Variable  variable =  ( Variable )  isDeclaredVarOf . getAlpha  ( ) ;   afterParsingvariableSymbolTable . insert  (  variable . get_name  ( ) , variable ) ; } }  for ( IsSimpleDeclOf currentEdge :  v . getIsSimpleDeclOfIncidences  (  EdgeDirection . IN ) )  {  SimpleDeclaration  simpleDecl =  ( SimpleDeclaration )  currentEdge . getAlpha  ( ) ;  Expression  expr =  ( Expression )   simpleDecl . getFirstIsTypeExprOfIncidence  (  EdgeDirection . IN ) . getAlpha  ( ) ;   mergeVariables  ( expr , true ) ; }  for ( IsConstraintOf isConstraintOf :  v . getIsConstraintOfIncidences  (  EdgeDirection . IN ) )  {   mergeVariables  (  isConstraintOf . getAlpha  ( ) , true ) ; } }   private void mergeVariablesInQuantifiedExpression  (  QuantifiedExpression v ,  boolean separateScope )  throws DuplicateVariableException , UndefinedVariableException  {  if  ( separateScope )  {   afterParsingvariableSymbolTable . blockBegin  ( ) ; }  IsQuantifiedDeclOf  isQuantifiedDeclOf =  v . getFirstIsQuantifiedDeclOfIncidence  (  EdgeDirection . IN ) ;   mergeVariablesInDeclaration  (  ( Declaration )  isQuantifiedDeclOf . getAlpha  ( ) ) ;  IsBoundExprOfQuantifiedExpression  isBoundExprOfQuantifier =  v . getFirstIsBoundExprOfQuantifiedExpressionIncidence  (  EdgeDirection . IN ) ;   mergeVariables  (  isBoundExprOfQuantifier . getAlpha  ( ) , true ) ;  if  ( separateScope )  {   afterParsingvariableSymbolTable . blockEnd  ( ) ; } }   private void mergeVariablesInComprehension  (  Comprehension v ,  boolean separateScope )  throws DuplicateVariableException , UndefinedVariableException  {  if  ( separateScope )  {   afterParsingvariableSymbolTable . blockBegin  ( ) ; }  Edge  IsCompDeclOf =  v . getFirstIsCompDeclOfIncidence  (  EdgeDirection . IN ) ;   mergeVariablesInDeclaration  (  ( Declaration )  IsCompDeclOf . getAlpha  ( ) ) ;  Edge  isCompResultDefOf =  v . getFirstIsCompResultDefOfIncidence  (  EdgeDirection . IN ) ;  if  (  isCompResultDefOf != null )  {   mergeVariables  (  isCompResultDefOf . getAlpha  ( ) , true ) ;  if  (  v instanceof ListComprehension )  {  IsTableHeaderOf  isTableHeaderOf =  v . getFirstIsTableHeaderOfIncidence  (  EdgeDirection . IN ) ;  while  (  isTableHeaderOf != null )  {   mergeVariables  (  isTableHeaderOf . getAlpha  ( ) , true ) ;   isTableHeaderOf =  isTableHeaderOf . getNextIsTableHeaderOfIncidence  (  EdgeDirection . IN ) ; } }  if  (  v instanceof TableComprehension )  {  TableComprehension  tc =  ( TableComprehension ) v ;  IsColumnHeaderExprOf  ch =  tc . getFirstIsColumnHeaderExprOfIncidence  (  EdgeDirection . IN ) ;   mergeVariables  (  ch . getAlpha  ( ) , true ) ;  IsRowHeaderExprOf  rh =  tc . getFirstIsRowHeaderExprOfIncidence  (  EdgeDirection . IN ) ;   mergeVariables  (  rh . getAlpha  ( ) , true ) ;  IsTableHeaderOf  th =  tc . getFirstIsTableHeaderOfIncidence  (  EdgeDirection . IN ) ;  if  (  th != null )  {   mergeVariables  (  th . getAlpha  ( ) , true ) ; } } }  if  (  v instanceof MapComprehension )  {  IsKeyExprOfComprehension  keyEdge =   (  ( MapComprehension ) v ) . getFirstIsKeyExprOfComprehensionIncidence  ( ) ;   mergeVariables  (  keyEdge . getAlpha  ( ) , true ) ;  IsValueExprOfComprehension  valueEdge =   (  ( MapComprehension ) v ) . getFirstIsValueExprOfComprehensionIncidence  ( ) ;   mergeVariables  (  valueEdge . getAlpha  ( ) , true ) ; }  if  ( separateScope )  {   afterParsingvariableSymbolTable . blockEnd  ( ) ; } }  class FunctionConstruct  {  String  operatorName = null ;  Expression  arg1 = null ;  Expression  arg2 = null ;  FunctionId  op = null ;   int  offsetArg1 = 0 ;   int  lengthArg1 = 0 ;   int  offsetOperator = 0 ;   int  offsetArg2 = 0 ;   int  lengthOperator = 0 ;   int  lengthArg2 = 0 ;  boolean  binary = true ;   public FunctionConstruct  (  FunctionConstruct leftPart )  {   offsetArg1 =  leftPart . offsetArg1 ; }   public FunctionConstruct  ( )  { }   public boolean isValidFunction  ( )  {  return  operatorName != null ; }   public void preUnaryOp  ( )  {   binary = false ;   offsetOperator =  getCurrentOffset  ( ) ; }   public void preArg1  ( )  {   offsetArg1 =  getCurrentOffset  ( ) ; }   public void preOp  (  Expression arg1 )  {   binary = true ;    this . arg1 = arg1 ;   lengthArg1 =  getLength  ( offsetArg1 ) ;   offsetOperator =  getCurrentOffset  ( ) ; }   public void postOp  (  String op )  {   lengthOperator =  getLength  ( offsetOperator ) ;   offsetArg2 =  getCurrentOffset  ( ) ;   operatorName = op ; }   public FunctionApplication postArg2  (  Expression arg2 )  {  if  (  inPredicateMode  ( ) )  {  return null ; }   lengthArg2 =  getLength  ( offsetArg2 ) ;   op =  getFunctionId  ( operatorName ) ;  return  createFunctionIdAndArgumentOf  ( op , offsetOperator , lengthOperator , arg1 , offsetArg1 , lengthArg1 , arg2 , offsetArg2 , lengthArg2 , binary ) ; } }   protected abstract void debug  (  String s ) ;   protected final FunctionId getFunctionId  (  String name )  {  FunctionId  functionId =  functionSymbolTable . get  ( name ) ;  if  (  functionId == null )  {   functionId =  graph . createFunctionId  ( ) ;   functionId . set_name  ( name ) ;   functionSymbolTable . put  ( name , functionId ) ; }  return functionId ; }   protected FunctionApplication createFunctionIdAndArgumentOf  (  FunctionId functionId ,   int offsetOperator ,   int lengthOperator ,  Expression arg1 ,   int offsetArg1 ,   int lengthArg1 ,  Expression arg2 ,   int offsetArg2 ,   int lengthArg2 ,  boolean binary )  {  FunctionApplication  fa =  graph . createFunctionApplication  ( ) ;  IsFunctionIdOf  functionIdOf =  graph . createIsFunctionIdOf  ( functionId , fa ) ;   functionIdOf . set_sourcePositions  (  (  createSourcePositionList  ( lengthOperator , offsetOperator ) ) ) ;  IsArgumentOf  arg1Of = null ;  if  ( binary )  {   arg1Of =  graph . createIsArgumentOf  ( arg1 , fa ) ;   arg1Of . set_sourcePositions  (  createSourcePositionList  ( lengthArg1 , offsetArg1 ) ) ; }  IsArgumentOf  arg2Of =  graph . createIsArgumentOf  ( arg2 , fa ) ;   arg2Of . set_sourcePositions  (  createSourcePositionList  ( lengthArg2 , offsetArg2 ) ) ;  return fa ; }   protected final  PVector  < SourcePosition > createSourcePositionList  (   int length ,   int offset )  {   PVector  < SourcePosition >  list =  JGraLab . vector  ( ) ;  return  list . plus  (  new SourcePosition  ( length , offset ) ) ; }   protected final void testIllegalThisLiterals  ( )  {   Set  <  Class  <  ? extends Greql2Aggregation > >  allowedEdgesForThisVertex =  new  HashSet  <  Class  <  ? extends Greql2Aggregation > >  ( ) ;   Set  <  Class  <  ? extends Greql2Aggregation > >  allowedEdgesForThisEdge =  new  HashSet  <  Class  <  ? extends Greql2Aggregation > >  ( ) ;   allowedEdgesForThisVertex . add  (  IsGoalRestrOf . class ) ;   allowedEdgesForThisVertex . add  (  IsStartRestrOf . class ) ;   allowedEdgesForThisEdge . add  (  IsBooleanPredicateOfEdgeRestriction . class ) ;  for ( ThisLiteral vertex :  graph . getThisVertexVertices  ( ) )  {  for ( Edge sourcePositionEdge :  vertex . incidences  (  EdgeDirection . OUT ) )  {   Queue  < Greql2Vertex >  queue =  new  LinkedList  < Greql2Vertex >  ( ) ;   queue . add  ( vertex ) ;  while  (  !  queue . isEmpty  ( ) )  {  Greql2Vertex  currentVertex =  queue . poll  ( ) ;  for ( Edge edge :  currentVertex . incidences  (  EdgeDirection . OUT ) )  {  if  (  allowedEdgesForThisVertex . contains  (  edge . getSchemaClass  ( ) ) )  {  continue ; }  Greql2Vertex  omega =  ( Greql2Vertex )  edge . getOmega  ( ) ;  if  (  omega instanceof Greql2Expression )  {  throw  new ParsingException  ( "This literals must not be used outside pathdescriptions" ,  vertex . get_name  ( ) ,     (  ( Greql2Aggregation ) sourcePositionEdge ) . get_sourcePositions  ( ) . get  ( 0 ) . get_offset  ( ) ,     (  ( Greql2Aggregation ) sourcePositionEdge ) . get_sourcePositions  ( ) . get  ( 0 ) . get_length  ( ) , query ) ; }   queue . add  ( omega ) ; } } } }  for ( ThisLiteral vertex :  graph . getThisEdgeVertices  ( ) )  {  for ( Edge sourcePositionEdge :  vertex . incidences  (  EdgeDirection . OUT ) )  {   Queue  < Greql2Vertex >  queue =  new  LinkedList  < Greql2Vertex >  ( ) ;   queue . add  ( vertex ) ;  while  (  !  queue . isEmpty  ( ) )  {  Greql2Vertex  currentVertex =  queue . poll  ( ) ;  for ( Edge edge :  currentVertex . incidences  (  EdgeDirection . OUT ) )  {  if  (  allowedEdgesForThisEdge . contains  (  edge . getSchemaClass  ( ) ) )  {  continue ; }  Greql2Vertex  omega =  ( Greql2Vertex )  edge . getOmega  ( ) ;  if  (  omega instanceof Greql2Expression )  {  throw  new ParsingException  ( "This literals must not be used outside pathdescriptions" ,  vertex . get_name  ( ) ,     (  ( Greql2Aggregation ) sourcePositionEdge ) . get_sourcePositions  ( ) . get  ( 0 ) . get_offset  ( ) ,     (  ( Greql2Aggregation ) sourcePositionEdge ) . get_sourcePositions  ( ) . get  ( 0 ) . get_length  ( ) , query ) ; }   queue . add  ( omega ) ; } } } }   LinkedList  < Vertex >  literalsToDelete =  new  LinkedList  < Vertex >  ( ) ;  ThisVertex  firstThisVertex = null ;  for ( ThisVertex thisVertex :  graph . getThisVertexVertices  ( ) )  {  if  (  firstThisVertex == null )  {   firstThisVertex = thisVertex ; } else  {  while  (   thisVertex . getFirstIncidence  ( ) != null )  {  Edge  e =  thisVertex . getFirstIncidence  ( ) ;   e . setThis  ( firstThisVertex ) ; }   literalsToDelete . add  ( thisVertex ) ; } }  ThisEdge  firstThisEdge = null ;  for ( ThisEdge thisEdge :  graph . getThisEdgeVertices  ( ) )  {  if  (  firstThisEdge == null )  {   firstThisEdge = thisEdge ; } else  {  while  (   thisEdge . getFirstIncidence  ( ) != null )  {  Edge  e =  thisEdge . getFirstIncidence  ( ) ;   e . setThis  ( firstThisEdge ) ; }   literalsToDelete . add  ( thisEdge ) ; } }  while  (  !  literalsToDelete . isEmpty  ( ) )  {    literalsToDelete . getFirst  ( ) . delete  ( ) ; } } }