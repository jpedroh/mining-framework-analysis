  package    de . uni_koblenz . jgralab . impl ;   import    de . uni_koblenz . jgralab . AttributedElement ;  import    de . uni_koblenz . jgralab . Edge ;  import    de . uni_koblenz . jgralab . Graph ;  import    de . uni_koblenz . jgralab . GraphException ;  import    de . uni_koblenz . jgralab . Vertex ;  import     de . uni_koblenz . jgralab . schema . AggregationKind ;  import     de . uni_koblenz . jgralab . schema . EdgeClass ;  import    de . uni_koblenz . jgralab . TraversalContext ;   public abstract class EdgeBaseImpl  extends IncidenceImpl  implements  Edge , EdgeBase  {   protected final ReversedEdgeBaseImpl  reversedEdge ;   protected EdgeBaseImpl  (   int anId ,  Graph graph )  {  super  ( graph ) ;   setId  ( anId ) ;   reversedEdge =  createReversedEdge  ( ) ; }    @ Override public  int compareTo  (  AttributedElement a )  {  assert  a != null ;  assert  a instanceof Edge ;  Edge  e =  ( Edge ) a ;  assert  isValid  ( ) ;  assert  e . isValid  ( ) ;  assert   getGraph  ( ) ==  e . getGraph  ( ) ;  if  (  e ==  getReversedEdge  ( ) )  {  return  - 1 ; } else  {  return   Math . abs  (  getId  ( ) ) -  Math . abs  (  e . getId  ( ) ) ; } }    @ Override public void delete  ( )  {  assert  isValid  ( ) ;   graph . deleteEdge  ( this ) ; }    @ Override public Vertex getAlpha  ( )  {  assert  isValid  ( ) ;  return  getIncidentVertex  ( ) ; }    @ Override public Edge getNextEdge  ( )  {  EdgeBase  nextEdge =  getNextBaseEdge  ( ) ;  TraversalContext  tc =  graph . getTraversalContext  ( ) ;  if  (  !  (    tc == null ||  nextEdge == null ||  tc . containsEdge  ( nextEdge ) ) )  {  while  (  !  (   nextEdge == null ||  tc . containsEdge  ( nextEdge ) ) )  {   nextEdge =  nextEdge . getNextBaseEdge  ( ) ; } }  return nextEdge ; }    @ Override public Edge getNextEdge  (   Class  <  ? extends Edge > anEdgeClass )  {  assert  anEdgeClass != null ;  assert  isValid  ( ) ;  Edge  currentEdge =  getNextEdge  ( ) ;  while  (  currentEdge != null )  {  if  (  anEdgeClass . isInstance  ( currentEdge ) )  {  return currentEdge ; }   currentEdge =  currentEdge . getNextEdge  ( ) ; }  return null ; }    @ Override public Edge getNextEdge  (  EdgeClass anEdgeClass )  {  assert  anEdgeClass != null ;  assert  isValid  ( ) ;  return  getNextEdge  (  anEdgeClass . getM1Class  ( ) ) ; }    @ Override public Edge getNormalEdge  ( )  {  return this ; }    @ Override public Vertex getOmega  ( )  {  assert  isValid  ( ) ;  return  reversedEdge . getIncidentVertex  ( ) ; }    @ Override public Edge getReversedEdge  ( )  {  return reversedEdge ; }    @ Override public Vertex getThat  ( )  {  assert  isValid  ( ) ;  return  getOmega  ( ) ; }    @ Override public String getThatRole  ( )  {  assert  isValid  ( ) ;  return    (  ( EdgeClass )  getAttributedElementClass  ( ) ) . getTo  ( ) . getRolename  ( ) ; }    @ Override public Vertex getThis  ( )  {  assert  isValid  ( ) ;  return  getAlpha  ( ) ; }    @ Override public String getThisRole  ( )  {  assert  isValid  ( ) ;  return    (  ( EdgeClass )  getAttributedElementClass  ( ) ) . getFrom  ( ) . getRolename  ( ) ; }    @ Override public boolean isAfterEdge  (  Edge e )  {  assert  e != null ;  assert  isValid  ( ) ;  assert  e . isValid  ( ) ;  assert   getGraph  ( ) ==  e . getGraph  ( ) ;   e =  e . getNormalEdge  ( ) ;  if  (  e == this )  {  return false ; }  EdgeBase  p =  getPrevBaseEdge  ( ) ;  while  (   (  p != null ) &&  (  p != e ) )  {   p =  p . getPrevBaseEdge  ( ) ; }  return  p != null ; }    @ Override public boolean isBeforeEdge  (  Edge e )  {  assert  e != null ;  assert  isValid  ( ) ;  assert  e . isValid  ( ) ;  assert   getGraph  ( ) ==  e . getGraph  ( ) ;   e =  e . getNormalEdge  ( ) ;  if  (  e == this )  {  return false ; }  EdgeBase  n =  getNextBaseEdge  ( ) ;  while  (   (  n != null ) &&  (  n != e ) )  {   n =  n . getNextBaseEdge  ( ) ; }  return  n != null ; }    @ Override public boolean isNormal  ( )  {  return true ; }    @ Override public void putAfterEdge  (  Edge e )  {  assert  e != null ;  assert  isValid  ( ) ;  assert  e . isValid  ( ) ;  assert   getGraph  ( ) ==  e . getGraph  ( ) ;  assert  e != this ;  assert  e != reversedEdge ;   graph . putEdgeAfterInGraph  (  ( EdgeBase )  e . getNormalEdge  ( ) , this ) ; }    @ Override public void putBeforeEdge  (  Edge e )  {  assert  e != null ;  assert  isValid  ( ) ;  assert  e . isValid  ( ) ;  assert   getGraph  ( ) ==  e . getGraph  ( ) ;  assert  e != this ;  assert  e != reversedEdge ;   graph . putEdgeBeforeInGraph  (  ( EdgeBase )  e . getNormalEdge  ( ) , this ) ; }    @ Override public void setAlpha  (  Vertex alpha )  {  VertexBase  alphaBase =  ( VertexBase ) alpha ;  assert  isValid  ( ) ;  assert  alphaBase != null ;  assert  alphaBase . isValid  ( ) ;  assert   getGraph  ( ) ==  alphaBase . getGraph  ( ) ;  VertexBase  oldAlpha =  getIncidentVertex  ( ) ;  if  ( 
<<<<<<<
  !   this . graph . isLoading  ( ) &&    this . graph . getECARuleManagerIfThere  ( ) != null
=======
 !  graph . isLoading  ( )
>>>>>>>
 )  {    graph . getECARuleManagerIfThere  ( ) . fireBeforeChangeAlphaOfEdgeEvents  ( this , oldAlpha , alphaBase ) ; }  if  (  alphaBase == oldAlpha )  {  return ; }  if  (  !  alphaBase . isValidAlpha  ( this ) )  {  throw  new GraphException  (    "Edges of class " +   getAttributedElementClass  ( ) . getUniqueName  ( ) + " may not start at vertices of class " +   alphaBase . getAttributedElementClass  ( ) . getUniqueName  ( ) ) ; }   oldAlpha . removeIncidenceFromLambdaSeq  ( this ) ;   oldAlpha . incidenceListModified  ( ) ;  VertexBase  newAlpha =  ( VertexBase ) alphaBase ;   newAlpha . appendIncidenceToLambdaSeq  ( this ) ;   newAlpha . incidenceListModified  ( ) ;   setIncidentVertex  ( newAlpha ) ;  if  (  !  graph . isLoading  ( ) )  {    graph . getECARuleManager  ( ) . fireAfterChangeAlphaOfEdgeEvents  ( this , oldAlpha , alphaBase ) ; } }    @ Override public void setOmega  (  Vertex omega )  {  VertexBase  omegaBase =  ( VertexBase ) omega ;  assert  isValid  ( ) ;  assert  omegaBase != null ;  assert  omegaBase . isValid  ( ) ;  assert   getGraph  ( ) ==  omegaBase . getGraph  ( ) ;  VertexBase  oldOmgea =  reversedEdge . getIncidentVertex  ( ) ;  if  ( 
<<<<<<<
  !   this . graph . isLoading  ( ) &&    this . graph . getECARuleManagerIfThere  ( ) != null
=======
 !  graph . isLoading  ( )
>>>>>>>
 )  {    graph . getECARuleManagerIfThere  ( ) . fireBeforeChangeOmegaOfEdgeEvents  ( this , oldOmgea , omegaBase ) ; }  if  (  omegaBase == oldOmgea )  {  return ; }  if  (  !  omegaBase . isValidOmega  ( this ) )  {  throw  new GraphException  (    "Edges of class " +   getAttributedElementClass  ( ) . getUniqueName  ( ) + " may not end at at vertices of class " +   omegaBase . getAttributedElementClass  ( ) . getUniqueName  ( ) ) ; }   oldOmgea . removeIncidenceFromLambdaSeq  ( reversedEdge ) ;   oldOmgea . incidenceListModified  ( ) ;  VertexBase  newOmega =  ( VertexBase ) omegaBase ;   newOmega . appendIncidenceToLambdaSeq  ( reversedEdge ) ;   newOmega . incidenceListModified  ( ) ;   reversedEdge . setIncidentVertex  ( newOmega ) ;  if  (  !  graph . isLoading  ( ) )  {    graph . getECARuleManager  ( ) . fireAfterChangeOmegaOfEdgeEvents  ( this , oldOmgea , omegaBase ) ; } }    @ Override public void setThat  (  Vertex v )  {  assert  isValid  ( ) ;  assert  v != null ;  assert  v . isValid  ( ) ;  assert   getGraph  ( ) ==  v . getGraph  ( ) ;   setOmega  ( v ) ; }    @ Override public void setThis  (  Vertex v )  {  assert  isValid  ( ) ;  assert  v != null ;  assert  v . isValid  ( ) ;  assert   getGraph  ( ) ==  v . getGraph  ( ) ;   setAlpha  ( v ) ; }    @ Override public String toString  ( )  {  assert  isValid  ( ) ;  return    "+e" + id + ": " +   getAttributedElementClass  ( ) . getQualifiedName  ( ) ; }    @ Override public boolean isValid  ( )  {  return  graph . containsEdge  ( this ) ; }   abstract protected ReversedEdgeBaseImpl createReversedEdge  ( ) ;    @ Override public Edge getPrevEdge  ( )  {  EdgeBase  prevEdge =  getPrevBaseEdge  ( ) ;  TraversalContext  tc =  graph . getTraversalContext  ( ) ;  if  (  !  (    tc == null ||  prevEdge == null ||  tc . containsEdge  ( prevEdge ) ) )  {  while  (  !  (   prevEdge == null ||  tc . containsEdge  ( prevEdge ) ) )  {   prevEdge =  prevEdge . getPrevBaseEdge  ( ) ; } }  return prevEdge ; }    @ Override public AggregationKind getThisAggregationKind  ( )  {  assert  isValid  ( ) ;  return  getAlphaAggregationKind  ( ) ; }    @ Override public AggregationKind getThatAggregationKind  ( )  {  assert  isValid  ( ) ;  return  getOmegaAggregationKind  ( ) ; } }