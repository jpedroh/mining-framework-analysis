  package     de . uni_koblenz . jgralab . impl . trans ;   import   java . util . Map ;  import    de . uni_koblenz . jgralab . Graph ;  import    de . uni_koblenz . jgralab . GraphException ;  import    de . uni_koblenz . jgralab . Vertex ;  import     de . uni_koblenz . jgralab . impl . InternalEdge ;  import     de . uni_koblenz . jgralab . impl . EdgeBaseImpl ;  import     de . uni_koblenz . jgralab . impl . IncidenceImpl ;  import     de . uni_koblenz . jgralab . impl . InternalVertex ;  import     de . uni_koblenz . jgralab . impl . VertexBaseImpl ;  import     de . uni_koblenz . jgralab . trans . ListPosition ;  import     de . uni_koblenz . jgralab . trans . TransactionState ;  import     de . uni_koblenz . jgralab . trans . VersionedIncidence ;   public abstract class ReversedEdgeImpl  extends     de . uni_koblenz . jgralab . impl . ReversedEdgeBaseImpl  implements  VersionedIncidence  {   protected  VersionedReferenceImpl  < VertexBaseImpl >  incidentVertex ;   protected  VersionedReferenceImpl  < IncidenceImpl >  nextIncidence ;   protected  VersionedReferenceImpl  < IncidenceImpl >  prevIncidence ;   protected ReversedEdgeImpl  (  EdgeBaseImpl normalEdge ,  Graph graph )  {  super  ( normalEdge , graph ) ; }    @ Override public InternalVertex getIncidentVertex  ( )  {  if  (  incidentVertex == null )  {  return null ; }  return  incidentVertex . getValidValue  (  graph . getCurrentTransaction  ( ) ) ; }    @ Override public IncidenceImpl getNextIncidenceInISeq  ( )  {  if  (  nextIncidence == null )  {  return null ; }  return  nextIncidence . getValidValue  (  graph . getCurrentTransaction  ( ) ) ; }    @ Override public IncidenceImpl getPrevIncidenceInISeq  ( )  {  if  (  prevIncidence == null )  {  return null ; }  return  prevIncidence . getValidValue  (  graph . getCurrentTransaction  ( ) ) ; }    @ Override public void setIncidentVertex  (  Vertex v )  {  if  (  graph . isLoading  ( ) )  {   incidentVertex =  new  VersionedReferenceImpl  < VertexBaseImpl >  ( normalEdge ,  ( VertexBaseImpl ) v ) ; } else  {  if  (  incidentVertex == null )  {   incidentVertex =  new  VersionedReferenceImpl  < VertexBaseImpl >  ( normalEdge ) ; }   incidentVertex . setValidValue  (  ( VertexBaseImpl ) v ,  graph . getCurrentTransaction  ( ) ) ; } }    @ Override public void setNextIncidenceInternal  (  InternalEdge nextIncidence )  {  if  (  graph . isLoading  ( ) )  {    this . nextIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( normalEdge ,  ( IncidenceImpl ) nextIncidence ) ; } else  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  boolean  explicitChange = false ;  if  (   transaction . getState  ( ) ==  TransactionState . WRITING )  {  if  (   transaction . changedIncidences != null )  {  InternalVertex  currentIncidentVertex =  incidentVertex . getTemporaryValue  ( transaction ) ;   Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > >  incidenceList =   transaction . changedIncidences . get  ( currentIncidentVertex ) ;   explicitChange = false ;  if  (  incidenceList != null )  {   explicitChange =   incidenceList . containsKey  ( this ) &&  (    incidenceList . get  ( this ) . keySet  ( ) . contains  (  ListPosition . NEXT ) ) ; } } }  if  (   this . nextIncidence == null )  {    this . nextIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( normalEdge ) ; }    this . nextIncidence . setValidValue  (  ( IncidenceImpl ) nextIncidence , transaction , explicitChange ) ; } }    @ Override public void setPrevIncidenceInternal  (  InternalEdge prevIncidence )  {  if  (  graph . isLoading  ( ) )  {    this . prevIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( normalEdge ,  ( IncidenceImpl ) prevIncidence ) ; } else  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  boolean  explicitChange = false ;  if  (   transaction . getState  ( ) ==  TransactionState . WRITING )  {  if  (   transaction . changedIncidences != null )  {  InternalVertex  currentIncidentVertex =  incidentVertex . getTemporaryValue  ( transaction ) ;   Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > >  incidenceList =   transaction . changedIncidences . get  ( currentIncidentVertex ) ;   explicitChange = false ;  if  (  incidenceList != null )  {   explicitChange =   incidenceList . containsKey  ( this ) &&  (    incidenceList . get  ( this ) . keySet  ( ) . contains  (  ListPosition . PREV ) ) ; } } }  if  (   this . prevIncidence == null )  {    this . prevIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( normalEdge ) ; }    this . prevIncidence . setValidValue  (  ( IncidenceImpl ) prevIncidence , transaction , explicitChange ) ; } }    @ Override public  VersionedReferenceImpl  < IncidenceImpl > getVersionedNextIncidence  ( )  {  return nextIncidence ; }    @ Override public  VersionedReferenceImpl  < IncidenceImpl > getVersionedPrevIncidence  ( )  {  return prevIncidence ; } 
<<<<<<<
=======
   @ Override protected void setIncidentVertex  (  VertexBaseImpl v )  {  if  (  graph . isLoading  ( ) )  {   incidentVertex =  new  VersionedReferenceImpl  < VertexBaseImpl >  ( normalEdge , v , "$normalEdge" ) ; } else  {  if  (  incidentVertex == null )  {   incidentVertex =  new  VersionedReferenceImpl  < VertexBaseImpl >  ( normalEdge , null , "$revIncidentVertex" ) ; }   incidentVertex . setValidValue  ( v ,  graph . getCurrentTransaction  ( ) ) ; } }
>>>>>>>
 
<<<<<<<
=======
   @ Override protected void setNextIncidenceInternal  (  IncidenceImpl nextIncidence )  {  if  (  graph . isLoading  ( ) )  {    this . nextIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( normalEdge , nextIncidence , "$revNextIncidence" ) ; } else  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  boolean  explicitChange = false ;  if  (   transaction . getState  ( ) ==  TransactionState . WRITING )  {  if  (   transaction . changedIncidences != null )  {  VertexBaseImpl  currentIncidentVertex =   this . incidentVertex . getTemporaryValue  ( transaction ) ;   Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > >  incidenceList =   transaction . changedIncidences . get  ( currentIncidentVertex ) ;   explicitChange = false ;  if  (  incidenceList != null )  {   explicitChange =   incidenceList . containsKey  ( this ) &&  (    incidenceList . get  ( this ) . keySet  ( ) . contains  (  ListPosition . NEXT ) ) ; } } }  if  (   this . nextIncidence == null )  {    this . nextIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( normalEdge , null , "$revNextIncidence" ) ; }    this . nextIncidence . setValidValue  ( nextIncidence , transaction , explicitChange ) ; } }
>>>>>>>
 
<<<<<<<
=======
   @ Override protected void setPrevIncidenceInternal  (  IncidenceImpl prevIncidence )  {  if  (  graph . isLoading  ( ) )  {    this . prevIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( normalEdge , prevIncidence , "$revPrevIncidence" ) ; } else  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  boolean  explicitChange = false ;  if  (   transaction . getState  ( ) ==  TransactionState . WRITING )  {  if  (   transaction . changedIncidences != null )  {  VertexBaseImpl  currentIncidentVertex =   this . incidentVertex . getTemporaryValue  ( transaction ) ;   Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > >  incidenceList =   transaction . changedIncidences . get  ( currentIncidentVertex ) ;   explicitChange = false ;  if  (  incidenceList != null )  {   explicitChange =   incidenceList . containsKey  ( this ) &&  (    incidenceList . get  ( this ) . keySet  ( ) . contains  (  ListPosition . PREV ) ) ; } } }  if  (   this . prevIncidence == null )  {    this . prevIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( normalEdge , null , "$revPrevIncidence" ) ; }    this . prevIncidence . setValidValue  ( prevIncidence , transaction , explicitChange ) ; } }
>>>>>>>
 }