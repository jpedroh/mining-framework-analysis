  package     de . uni_koblenz . jgralab . impl . trans ;   import   java . util . ArrayList ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Map ;  import    java . util . Map . Entry ;  import   java . util . Set ;  import   java . util . SortedMap ;  import    java . util . logging . Logger ;  import    de . uni_koblenz . jgralab . AttributedElement ;  import    de . uni_koblenz . jgralab . Graph ;  import    de . uni_koblenz . jgralab . GraphException ;  import    de . uni_koblenz . jgralab . JGraLab ;  import    de . uni_koblenz . jgralab . TraversalContext ;  import     de . uni_koblenz . jgralab . impl . IncidenceImpl ;  import     de . uni_koblenz . jgralab . trans . CommitFailedException ;  import     de . uni_koblenz . jgralab . trans . InvalidSavepointException ;  import     de . uni_koblenz . jgralab . trans . ListPosition ;  import     de . uni_koblenz . jgralab . trans . Savepoint ;  import     de . uni_koblenz . jgralab . trans . Transaction ;  import     de . uni_koblenz . jgralab . trans . TransactionState ;  import     de . uni_koblenz . jgralab . trans . VersionedDataObject ;  import     de . uni_koblenz . jgralab . trans . VertexPosition ;   public class TransactionImpl  implements  Transaction  {   private static Logger  logger =  JGraLab . getLogger  ( "de.uni_koblenz.jgralab.impl.trans" ) ;   protected  long  temporaryVersionCounter ;   protected  long  persistentVersionAtBot ;   protected  long  persistentVersionAtCommit ;   private TransactionManagerImpl  transactionManager ;   private GraphImpl  graph ;   private Thread  thread ;   private  int  id ;   private TransactionState  state ;   private boolean  readOnly ;   private  short  savepointIdCounter ;   protected  List  < VertexImpl >  addedVertices ;   protected  List  < EdgeImpl >  addedEdges ;   protected  List  < VertexImpl >  deletedVertices ;   protected  List  < EdgeImpl >  deletedEdges ;   protected  Map  < VertexImpl ,  Map  < ListPosition , Boolean > >  changedVseqVertices ;   protected  Map  < EdgeImpl ,  Map  < ListPosition , Boolean > >  changedEseqEdges ;   protected  Map  < VertexImpl ,  Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > > >  changedIncidences ;   protected  Map  < EdgeImpl , VertexPosition >  changedEdges ;   protected  Map  < AttributedElement ,  Set  <  VersionedDataObject  <  ? > > >  changedAttributes ;   protected  List  < VertexImpl >  deletedVerticesWhileWriting ;   protected  List  <     de . uni_koblenz . jgralab . impl . InternalVertex >  deleteVertexList ;   protected SavepointImpl  latestDefinedSavepoint ;   protected SavepointImpl  latestRestoredSavepoint ;   private  List  < Savepoint >  savepointList ;   private ValidationComponent  validationComponent ;   private WritingComponent  writingComponent ;   protected  Set  <  VersionedDataObjectImpl  <  ? > >  changedDuringCommit ;   private TraversalContext  tc ;   protected  Map  <  VersionedDataObject  <  ? > , Object >  temporaryValueMap ;   protected  Map  <  VersionedDataObject  <  ? > ,  SortedMap  < Long , Object > >  temporaryVersionMap ;   protected  long incrTemporaryVersionCounter  ( )  {   ++ temporaryVersionCounter ;  return temporaryVersionCounter ; }   public TransactionImpl  (  TransactionManagerImpl transactionManager ,  GraphImpl graph ,   int ID ,  boolean readOnly )  {    this . transactionManager = transactionManager ;    this . graph = graph ;   id = ID ;    this . readOnly = readOnly ;   temporaryVersionCounter = 0 ;   latestDefinedSavepoint = null ;   validationComponent = null ;   writingComponent = null ;   thread =  Thread . currentThread  ( ) ;   state =  TransactionState . NOTRUNNING ;   bot  ( ) ;   savepointIdCounter = 0 ; }    @ Override public void abort  ( )  {  if  (  logger != null )  {   logger . fine  (  "tx id=" + id ) ; }  if  (  thread !=  Thread . currentThread  ( ) )  {  throw  new GraphException  ( "Transaction is not active in current thread." ) ; }  if  (  ! readOnly )  {   removeAllTemporaryValues  ( ) ;   state =  TransactionState . ABORTING ;  if  (   addedVertices != null &&   addedVertices . size  ( ) > 0 )  {  synchronized  (  graph . getFreeVertexList  ( ) )  {  for ( VertexImpl vertex : addedVertices )  {   graph . freeVertexIndex  (  vertex . getId  ( ) ) ; }   addedVertices = null ; } }  if  (   addedEdges != null &&   addedEdges . size  ( ) > 0 )  {  synchronized  (  graph . getFreeEdgeList  ( ) )  {  for ( EdgeImpl edge : addedEdges )  {   graph . freeEdgeIndex  (  edge . getId  ( ) ) ; }   addedEdges = null ; } }   graph . freeStoredIndexes  ( ) ; }   state =  TransactionState . ABORTED ;   transactionManager . removeTransactionForThread  (  Thread . currentThread  ( ) ) ;   deletedVertices = null ;   deletedEdges = null ;   deleteVertexList = null ;   changedVseqVertices = null ;   changedEseqEdges = null ;   changedIncidences = null ;   changedEdges = null ;   changedAttributes = null ;   savepointList = null ;   changedDuringCommit = null ;   temporaryValueMap = null ; }    @ Override public void bot  ( )  {  if  (  logger != null )  {   logger . fine  (  "tx id=" + id ) ; }  if  (  thread !=  Thread . currentThread  ( ) )  {  throw  new GraphException  ( "Transaction is not active in current thread." ) ; }  if  (  state ==  TransactionState . NOTRUNNING )  {     transactionManager . botWritingSync . readLock  ( ) . lock  ( ) ;   persistentVersionAtBot =  graph . getPersistentVersionCounter  ( ) ;     transactionManager . botWritingSync . readLock  ( ) . unlock  ( ) ;   state =  TransactionState . RUNNING ; } }    @ Override public void commit  ( )  throws CommitFailedException  {  if  (  logger != null )  {   logger . fine  (  "tx id=" + id ) ; }  if  (  thread !=  Thread . currentThread  ( ) )  {  throw  new GraphException  ( "Transaction is not active in current thread." ) ; }  assert  state ==  TransactionState . RUNNING :   "Expected TransactionState RUNNING, but it's " + state + "." ;   state =  TransactionState . COMMITTING ;  if  (  ! readOnly )  {     transactionManager . commitSync . writeLock  ( ) . lock  ( ) ;  if  (  internalIsInConflict  ( ) )  {   state =  TransactionState . RUNNING ;     transactionManager . commitSync . writeLock  ( ) . unlock  ( ) ;  throw  new CommitFailedException  ( this ,  validationComponent . getConflictReason  ( ) ) ; }     transactionManager . commitValidatingSync . writeLock  ( ) . lock  ( ) ;     transactionManager . botWritingSync . writeLock  ( ) . lock  ( ) ;   persistentVersionAtCommit =  graph . getPersistentVersionCounter  ( ) ;  if  (  writingComponent == null )  {   writingComponent =  new WritingComponent  ( this ) ; }  try  {   state =  TransactionState . WRITING ;   writingComponent . write  ( ) ; }  catch (   Exception e )  {   e . printStackTrace  ( ) ;   state =  TransactionState . RUNNING ;     transactionManager . botWritingSync . writeLock  ( ) . unlock  ( ) ;     transactionManager . commitValidatingSync . writeLock  ( ) . unlock  ( ) ;     transactionManager . commitSync . writeLock  ( ) . unlock  ( ) ;  throw  new CommitFailedException  ( this ,  e . getMessage  ( ) ) ; }   state =  TransactionState . COMMITTING ;  if  (   deletedVertices != null &&   deletedVertices . size  ( ) > 0 )  {  synchronized  (  graph . getFreeVertexList  ( ) )  {  for ( VertexImpl vertex : deletedVertices )  {   int  id =  vertex . getId  ( ) ;  assert  id > 0 ;   graph . freeVertexIndex  (  vertex . getId  ( ) ) ; }   deletedVertices = null ; } }  if  (   deletedEdges != null &&   deletedEdges . size  ( ) > 0 )  {  synchronized  (  graph . getFreeEdgeList  ( ) )  {  for ( EdgeImpl edge : deletedEdges )  {   int  id =  edge . getId  ( ) ;  assert  id > 0 ;   graph . freeEdgeIndex  (  edge . getId  ( ) ) ; }   deletedEdges = null ; } }   graph . freeStoredIndexes  ( ) ;   removeAllTemporaryValues  ( ) ;   state =  TransactionState . COMMITTED ;   transactionManager . removeTransactionForThread  (  Thread . currentThread  ( ) ) ;   transactionManager . removeTransaction  ( this ) ;     transactionManager . botWritingSync . writeLock  ( ) . unlock  ( ) ;     transactionManager . commitValidatingSync . writeLock  ( ) . unlock  ( ) ;     transactionManager . commitSync . writeLock  ( ) . unlock  ( ) ; } else  {   state =  TransactionState . COMMITTED ;   transactionManager . removeTransactionForThread  (  Thread . currentThread  ( ) ) ;   transactionManager . removeTransaction  ( this ) ; }   addedVertices = null ;   addedEdges = null ;   deletedVertices = null ;   deletedEdges = null ;   deleteVertexList = null ;   changedVseqVertices = null ;   changedEseqEdges = null ;   changedIncidences = null ;   changedEdges = null ;   changedAttributes = null ;   savepointList = null ;   changedDuringCommit = null ;   temporaryValueMap = null ; }   protected void removeNonReferencedPersistentValues  ( )  {  if  (  logger != null )  {   logger . finest  (  "tx id=" + id ) ; }   long  maxVersionNumber = 0 ;  TransactionImpl  oldestTransaction =  ( TransactionImpl )  transactionManager . getOldestTransaction  ( ) ;  if  (   oldestTransaction == this &&    transactionManager . getTransactions  ( ) . size  ( ) > 1 )  {   oldestTransaction =  ( TransactionImpl )   transactionManager . getTransactions  ( ) . get  ( 1 ) ; }   maxVersionNumber =  oldestTransaction . persistentVersionAtBot ;  if  (  changedDuringCommit != null )  {  for (  VersionedDataObjectImpl  <  ? > versionedDataObject : changedDuringCommit )  {  if  (   oldestTransaction == this &&    transactionManager . getTransactions  ( ) . size  ( ) == 1 )  {   maxVersionNumber =  versionedDataObject . getLatestPersistentVersion  ( ) ; }   versionedDataObject . removePersistentValues  ( maxVersionNumber ) ;   versionedDataObject . removeAllTemporaryValues  ( this ) ;   long  minRange = 0 ;  TransactionImpl  realOldestTransaction =  ( TransactionImpl )  transactionManager . getOldestTransaction  ( ) ;   long  maxRange =  realOldestTransaction . persistentVersionAtBot ;   versionedDataObject . removePersistentValues  ( minRange , maxRange ) ;  synchronized  (  transactionManager . transactionList )  {  if  (    transactionManager . transactionList . size  ( ) > 1 )  {  for (   int  i = 0 ;  i <    transactionManager . transactionList . size  ( ) - 1 ;  i ++ )  {  TransactionImpl  t1 =  ( TransactionImpl )   transactionManager . getTransactions  ( ) . get  ( i ) ;  TransactionImpl  t2 =  ( TransactionImpl )   transactionManager . getTransactions  ( ) . get  (  i + 1 ) ;   minRange =  t1 . persistentVersionAtBot ;   maxRange =  t2 . persistentVersionAtBot ;  if  (  minRange > maxRange )  {  throw  new GraphException  ( "This should not happen. The transactions in transaction list should be sorted asc by persistentVersionAtBot." ) ; }   versionedDataObject . removePersistentValues  ( minRange , maxRange ) ; } } } } } }   private void removeAllTemporaryValues  ( )  {  if  (  logger != null )  {   logger . finest  (  "tx id=" + id ) ; }  if  (  temporaryValueMap != null )  {   temporaryValueMap . clear  ( ) ;   temporaryValueMap = null ; }  if  (  temporaryVersionMap != null )  {   temporaryVersionMap . clear  ( ) ;   temporaryVersionMap = null ; } }    @ Override public Savepoint defineSavepoint  ( )  {  if  (  logger != null )  {   logger . fine  (  "tx id=" + id ) ; }  if  (  thread !=  Thread . currentThread  ( ) )  {  throw  new GraphException  ( "Transaction is not active in current thread." ) ; }  if  ( readOnly )  {  throw  new GraphException  ( "Read-only transactions are not allowed to define save-points." ) ; }  if  (  savepointList == null )  {   savepointList =  new  ArrayList  < Savepoint >  ( 1 ) ; }  SavepointImpl  savepoint =  new SavepointImpl  ( this ,  ++ savepointIdCounter ) ;   latestDefinedSavepoint = savepoint ;   savepointList . add  ( savepoint ) ;  if  (  temporaryValueMap != null )  {  synchronized  ( temporaryValueMap )  {   Set  <  VersionedDataObject  <  ? > >  versionedDataObjects =  new  HashSet  <  VersionedDataObject  <  ? > >  (  temporaryValueMap . keySet  ( ) ) ;  for (  VersionedDataObject  <  ? > dataObject : versionedDataObjects )  {    (  (  VersionedDataObjectImpl  <  ? > ) dataObject ) . moveTemporaryVersion  ( this ) ; } } }  if  (  logger != null )  {   logger . fine  (  "--> created sp id=" +  savepoint . getID  ( ) ) ; }  return savepoint ; }    @ Override public Graph getGraph  ( )  {  return graph ; }    @ Override public  int getID  ( )  {  return id ; }    @ Override public  List  < Savepoint > getSavepoints  ( )  {  if  (  thread !=  Thread . currentThread  ( ) )  {  throw  new GraphException  ( "Transaction is not active in current thread." ) ; }  if  (  savepointList == null )  {  return  new  ArrayList  < Savepoint >  ( 1 ) ; }  synchronized  ( savepointList )  {   List  < Savepoint >  savepointList =  new  ArrayList  < Savepoint >  (  this . savepointList ) ;  return savepointList ; } }    @ Override public TransactionState getState  ( )  {  return state ; }   protected void setThread  (  Thread thread )  {    this . thread = thread ; }    @ Override public Thread getThread  ( )  {  return thread ; }    @ Override public boolean isReadOnly  ( )  {  return readOnly ; }    @ Override public void restoreSavepoint  (  Savepoint savepoint )  throws InvalidSavepointException  {  if  (  logger != null )  {   logger . fine  (    "tx id=" + id + ", sp id=" +  savepoint . getID  ( ) ) ; }  if  (  thread !=  Thread . currentThread  ( ) )  {  throw  new GraphException  ( "Transaction is not active in current thread." ) ; }  if  (    savepointList == null ||  !  savepointList . contains  ( savepoint ) ||   savepoint . getTransaction  ( ) != this )  {  throw  new InvalidSavepointException  ( this , savepoint ) ; }  SavepointImpl  sp =  ( SavepointImpl ) savepoint ;   latestDefinedSavepoint = sp ;   latestRestoredSavepoint = sp ;   addedEdges =  sp . addedEdges ;   addedVertices =  sp . addedVertices ;   deletedEdges =  sp . deletedEdges ;   deletedVertices =  sp . deletedVertices ;   changedEseqEdges =  sp . changedEseqEdges ;   changedVseqVertices =  sp . changedVseqVertices ;   changedIncidences =  sp . changedIncidences ;   changedAttributes =  sp . changedAttributes ; }   protected void removeInvalidSavepoints  ( )  {  if  (  logger != null )  {   logger . finest  (  "tx id=" + id ) ; }  assert   latestDefinedSavepoint != null &&  latestRestoredSavepoint != null ;  for (   int  i =   savepointList . indexOf  ( latestRestoredSavepoint ) + 1 ;  i <  savepointList . size  ( ) ;  i ++ )  {  if  (  logger != null )  {   logger . finest  (  "--> remove sp id=" +   savepointList . get  ( i ) . getID  ( ) ) ; }   savepointList . remove  ( i ) ; }  if  (  temporaryVersionMap != null )  {   Set  <  VersionedDataObject  <  ? > >  versionedDataObjects =  new  HashSet  <  VersionedDataObject  <  ? > >  (  temporaryVersionMap . keySet  ( ) ) ;  for (  VersionedDataObject  <  ? > versionedDataObject : versionedDataObjects )  {   versionedDataObject . removeTemporaryValues  (  latestRestoredSavepoint . versionAtSavepoint , this ) ;  if  (  !  versionedDataObject . hasTemporaryValue  ( this ) )  {   temporaryVersionMap . remove  ( versionedDataObject ) ; } } }   temporaryVersionCounter =  latestRestoredSavepoint . versionAtSavepoint ;   latestRestoredSavepoint = null ; }    @ Override public boolean isInConflict  ( )  {  if  (  thread !=  Thread . currentThread  ( ) )  {  throw  new GraphException  ( "Transaction is not active in current thread." ) ; }   state =  TransactionState . VALIDATING ;  boolean  result = false ;     transactionManager . commitValidatingSync . readLock  ( ) . lock  ( ) ;   result =  internalIsInConflict  ( ) ;     transactionManager . commitValidatingSync . readLock  ( ) . unlock  ( ) ;   state =  TransactionState . RUNNING ;  return result ; }   private boolean internalIsInConflict  ( )  {  assert  thread ==  Thread . currentThread  ( ) ;   state =  TransactionState . VALIDATING ;  if  ( readOnly )  {  return false ; }  if  (  validationComponent == null )  {   validationComponent =  new ValidationComponent  ( this ) ; }  return  validationComponent . isInConflict  ( ) ; }    @ Override public void removeSavepoint  (  Savepoint savepoint )  {  if  (  logger != null )  {   logger . fine  (    "tx id=" + id + ", sp id=" +  savepoint . getID  ( ) ) ; }  if  (  thread !=  Thread . currentThread  ( ) )  {  throw  new GraphException  ( "Transaction is not active in current thread." ) ; }  if  (   savepoint . getTransaction  ( ) != this )  {  throw  new GraphException  ( "This savepoint doesn't belong to this transaction." ) ; }  if  (   savepointList != null &&  !  savepointList . isEmpty  ( ) )  {  synchronized  ( savepointList )  {   int  position =  savepointList . indexOf  ( savepoint ) ;   savepointList . remove  ( savepoint ) ;  if  (   savepointList . isEmpty  ( ) &&  latestRestoredSavepoint != savepoint )  {  for (  Entry  <  VersionedDataObject  <  ? > ,  SortedMap  < Long , Object > > entries :  temporaryVersionMap . entrySet  ( ) )  {   VersionedDataObject  <  ? >  versionedDataObject =  entries . getKey  ( ) ;   SortedMap  < Long , Object >  versionsMap =  entries . getValue  ( ) ;   temporaryValueMap . put  ( versionedDataObject ,  versionsMap . get  (  versionsMap . lastKey  ( ) ) ) ;   temporaryVersionMap . remove  ( versionedDataObject ) ; }   temporaryVersionMap = null ; } else  {  if  (   savepointList . size  ( ) == position )  { ; } else  { ; } } } } }    @ Override public boolean isValid  ( )  {  return    getState  ( ) !=  TransactionState . ABORTED &&   getState  ( ) !=  TransactionState . COMMITTED ; }    @ Override public String toString  ( )  {  return      "TA-" + id + "_Graph-" +  graph . getId  ( ) + "-" + state ; }   public  Set  <  VersionedDataObject  <  ? > > getRemainingVersionedDataObjects  ( )  {   Set  <  VersionedDataObject  <  ? > >  versionedDataObjects =  new  HashSet  <  VersionedDataObject  <  ? > >  ( ) ;  if  (   temporaryValueMap != null &&   temporaryValueMap . size  ( ) > 0 )  {   versionedDataObjects =  new  HashSet  <  VersionedDataObject  <  ? > >  (  temporaryValueMap . keySet  ( ) ) ; }  if  (   temporaryVersionMap != null &&   temporaryVersionMap . size  ( ) > 0 )  {   versionedDataObjects =  new  HashSet  <  VersionedDataObject  <  ? > >  (  temporaryVersionMap . keySet  ( ) ) ; }  if  (   versionedDataObjects . size  ( ) > 0 )  {   Set  < EdgeImpl >  edges =  new  HashSet  < EdgeImpl >  ( ) ;   Set  < ReversedEdgeImpl >  reversedEdges =  new  HashSet  < ReversedEdgeImpl >  ( ) ;  if  (  addedEdges != null )  {   edges . addAll  ( addedEdges ) ; }  if  (  changedEdges != null )  {   edges . addAll  (  changedEdges . keySet  ( ) ) ; }  if  (  changedEseqEdges != null )  {   edges . addAll  (  changedEseqEdges . keySet  ( ) ) ; }  if  (  deletedEdges != null )  {   edges . addAll  ( deletedEdges ) ; }  if  (  changedIncidences != null )  {  for (  Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > > map :  changedIncidences . values  ( ) )  {  for ( IncidenceImpl incidence :  map . keySet  ( ) )  {  if  (  incidence instanceof EdgeImpl )  {   edges . add  (  ( EdgeImpl ) incidence ) ; }  if  (  incidence instanceof ReversedEdgeImpl )  {   reversedEdges . add  (  ( ReversedEdgeImpl ) incidence ) ; } } } }  for ( EdgeImpl edge : edges )  {   versionedDataObjects . remove  (  edge . incidentVertex ) ;   versionedDataObjects . remove  (  edge . nextEdge ) ;   versionedDataObjects . remove  (  edge . nextIncidence ) ;   versionedDataObjects . remove  (  edge . prevEdge ) ;   versionedDataObjects . remove  (  edge . prevIncidence ) ; }  for ( ReversedEdgeImpl reversedEdge : reversedEdges )  {   versionedDataObjects . remove  (  reversedEdge . incidentVertex ) ;   versionedDataObjects . remove  (  reversedEdge . nextIncidence ) ;   versionedDataObjects . remove  (  reversedEdge . prevIncidence ) ; }   Set  < VertexImpl >  vertices =  new  HashSet  < VertexImpl >  ( ) ;  if  (  addedVertices != null )  {   vertices . addAll  ( addedVertices ) ; }  if  (  changedVseqVertices != null )  {   vertices . addAll  (  changedVseqVertices . keySet  ( ) ) ; }  if  (  deletedVertices != null )  {   vertices . addAll  ( deletedVertices ) ; }  if  (  changedIncidences != null )  {   vertices . addAll  (  changedIncidences . keySet  ( ) ) ; }  for ( VertexImpl vertex : vertices )  {   versionedDataObjects . remove  (  vertex . firstIncidence ) ;   versionedDataObjects . remove  (  vertex . incidenceListVersion ) ;   versionedDataObjects . remove  (  vertex . lastIncidence ) ;   versionedDataObjects . remove  (  vertex . nextVertex ) ;   versionedDataObjects . remove  (  vertex . prevVertex ) ; }  if  (  changedAttributes != null )  {  for (  Entry  < AttributedElement ,  Set  <  VersionedDataObject  <  ? > > > entry :  changedAttributes . entrySet  ( ) )  {   Set  <  VersionedDataObject  <  ? > >  attributes =  entry . getValue  ( ) ;  for (  VersionedDataObject  <  ? > attribute : attributes )  {   versionedDataObjects . remove  ( attribute ) ; } } } }  return versionedDataObjects ; }    @ Override public TraversalContext getTraversalContext  ( )  {  return tc ; }    @ Override public TraversalContext setTraversalContext  (  TraversalContext tc )  {  TraversalContext  oldTC =  this . tc ;    this . tc = tc ;  return oldTC ; } }