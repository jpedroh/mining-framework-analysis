  package     de . uni_koblenz . jgralab . impl . trans ;   import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . Map ;  import   java . util . Set ;  import    de . uni_koblenz . jgralab . AttributedElement ;  import    de . uni_koblenz . jgralab . Edge ;  import    de . uni_koblenz . jgralab . Graph ;  import    de . uni_koblenz . jgralab . GraphException ;  import    de . uni_koblenz . jgralab . GraphIOException ;  import    de . uni_koblenz . jgralab . Vertex ;  import     de . uni_koblenz . jgralab . impl . InternalEdge ;  import     de . uni_koblenz . jgralab . impl . IncidenceImpl ;  import     de . uni_koblenz . jgralab . impl . InternalVertex ;  import     de . uni_koblenz . jgralab . impl . VertexBaseImpl ;  import     de . uni_koblenz . jgralab . schema . Attribute ;  import     de . uni_koblenz . jgralab . trans . ListPosition ;  import     de . uni_koblenz . jgralab . trans . Transaction ;  import     de . uni_koblenz . jgralab . trans . TransactionState ;  import     de . uni_koblenz . jgralab . trans . VersionedDataObject ;  import     de . uni_koblenz . jgralab . trans . VersionedIncidence ;  import     de . uni_koblenz . jgralab . trans . VertexPosition ;   public abstract class EdgeImpl  extends     de . uni_koblenz . jgralab . impl . EdgeBaseImpl  implements  VersionedIncidence  {   protected  VersionedReferenceImpl  < EdgeImpl >  nextEdge ;   protected  VersionedReferenceImpl  < EdgeImpl >  prevEdge ;   protected  VersionedReferenceImpl  < VertexBaseImpl >  incidentVertex ;   protected  VersionedReferenceImpl  < IncidenceImpl >  nextIncidence ;   protected  VersionedReferenceImpl  < IncidenceImpl >  prevIncidence ;   protected EdgeImpl  (   int anId ,  Graph graph ,  Vertex alpha ,  Vertex omega )  {  super  ( anId , graph ) ;    (  ( GraphImpl ) graph ) . addEdge  ( this , alpha , omega ) ; }    @ Override public  int getId  ( )  {  if  (  !  graph . isLoading  ( ) )  {  Transaction  transaction =  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  if  (   (   transaction . getState  ( ) ==  TransactionState . RUNNING ) &&  !  isValid  ( ) )  {  return 0 ; } }  return id ; }    @ Override public InternalEdge getNextEdgeInESeq  ( )  {  if  (  nextEdge == null )  {  return null ; }  return  nextEdge . getValidValue  (  graph . getCurrentTransaction  ( ) ) ; }    @ Override public InternalEdge getPrevEdgeInESeq  ( )  {  if  (  prevEdge == null )  {  return null ; }  return  prevEdge . getValidValue  (  graph . getCurrentTransaction  ( ) ) ; }    @ Override public InternalVertex getIncidentVertex  ( )  {  if  (  incidentVertex == null )  {  return null ; }  return  incidentVertex . getValidValue  (  graph . getCurrentTransaction  ( ) ) ; }    @ Override public IncidenceImpl getNextIncidenceInISeq  ( )  {  if  (  nextIncidence == null )  {  return null ; }  return  nextIncidence . getValidValue  (  graph . getCurrentTransaction  ( ) ) ; }    @ Override public IncidenceImpl getPrevIncidenceInISeq  ( )  {  if  (  prevIncidence == null )  {  return null ; }  return  prevIncidence . getValidValue  (  graph . getCurrentTransaction  ( ) ) ; }    @ Override public void setId  (   int id )  {  if  (  graph . isLoading  ( ) )  {    this . id = id ; } else  {  Transaction  transaction =  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  TransactionState  state =  transaction . getState  ( ) ;  if  (   (  state ==  TransactionState . RUNNING ) &&  (  id != 0 ) )  {    this . id = id ; } } }    @ Override public void setNextEdgeInGraph  (  Edge nextEdge )  {  if  (  graph . isLoading  ( ) )  {    this . nextEdge =  new  VersionedReferenceImpl  < EdgeImpl >  ( this ,  ( EdgeImpl ) nextEdge , "$nextEdge" ) ; } else  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  boolean  explicitChange = false ;  if  (   transaction . getState  ( ) ==  TransactionState . WRITING )  {  if  (   transaction . changedEseqEdges != null )  {   explicitChange =    transaction . changedEseqEdges . containsKey  ( this ) &&  (    transaction . changedEseqEdges . get  ( this ) . containsKey  (  ListPosition . NEXT ) ) ; } }  if  (   this . nextEdge == null )  {    this . nextEdge =  new  VersionedReferenceImpl  < EdgeImpl >  ( this , null , "$nextEdge" ) ; }    this . nextEdge . setValidValue  (  ( EdgeImpl ) nextEdge , transaction , explicitChange ) ; } }    @ Override public void setPrevEdgeInGraph  (  Edge prevEdge )  {  if  (  graph . isLoading  ( ) )  {    this . prevEdge =  new  VersionedReferenceImpl  < EdgeImpl >  ( this ,  ( EdgeImpl ) prevEdge , "$prevEdge" ) ; } else  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  boolean  explicitChange = false ;  if  (   transaction . getState  ( ) ==  TransactionState . WRITING )  {  if  (   transaction . changedEseqEdges != null )  {   explicitChange =    transaction . changedEseqEdges . containsKey  ( this ) &&  (    transaction . changedEseqEdges . get  ( this ) . containsKey  (  ListPosition . PREV ) ) ; } }  if  (   this . prevEdge == null )  {    this . prevEdge =  new  VersionedReferenceImpl  < EdgeImpl >  ( this , null , "$prevEdge" ) ; }    this . prevEdge . setValidValue  (  ( EdgeImpl ) prevEdge , transaction , explicitChange ) ; } }    @ Override public void setIncidentVertex  (  Vertex v )  {  if  (  graph . isLoading  ( ) )  {   incidentVertex =  new  VersionedReferenceImpl  < VertexBaseImpl >  ( this ,  ( VertexBaseImpl ) v ) ; } else  {  if  (  incidentVertex == null )  {   incidentVertex =  new  VersionedReferenceImpl  < VertexBaseImpl >  ( this ) ; }   incidentVertex . setValidValue  (  ( VertexBaseImpl ) v ,  graph . getCurrentTransaction  ( ) ) ; } }    @ Override public void setNextIncidenceInternal  (  InternalEdge nextIncidence )  {  if  (  graph . isLoading  ( ) )  {    this . nextIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( this ,  ( IncidenceImpl ) nextIncidence ) ; } else  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  boolean  explicitChange = false ;  if  (   transaction . getState  ( ) ==  TransactionState . WRITING )  {  if  (   transaction . changedIncidences != null )  {  InternalVertex  temporaryIncidentVertex =  incidentVertex . getTemporaryValue  ( transaction ) ;   Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > >  incidenceList =   transaction . changedIncidences . get  ( temporaryIncidentVertex ) ;  if  (  incidenceList != null )  {   explicitChange =   incidenceList . containsKey  ( this ) &&  (    incidenceList . get  ( this ) . keySet  ( ) . contains  (  ListPosition . NEXT ) ) ; } } }  if  (   this . nextIncidence == null )  {    this . nextIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( this ) ; }    this . nextIncidence . setValidValue  (  ( IncidenceImpl ) nextIncidence , transaction , explicitChange ) ; } }    @ Override public void setPrevIncidenceInternal  (  InternalEdge prevIncidence )  {  if  (  graph . isLoading  ( ) )  {    this . prevIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( this ,  ( IncidenceImpl ) prevIncidence ) ; } else  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  boolean  explicitChange = false ;  if  (   transaction . getState  ( ) ==  TransactionState . WRITING )  {  if  (   transaction . changedIncidences != null )  {  InternalVertex  temporaryIncidentVertex =  incidentVertex . getTemporaryValue  ( transaction ) ;   Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > >  incidenceList =   transaction . changedIncidences . get  ( temporaryIncidentVertex ) ;  if  (  incidenceList != null )  {   explicitChange =   incidenceList . containsKey  ( this ) &&  (    incidenceList . get  ( this ) . keySet  ( ) . contains  (  ListPosition . PREV ) ) ; } } }  if  (   this . prevIncidence == null )  {    this . prevIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( this ) ; }    this . prevIncidence . setValidValue  (  ( IncidenceImpl ) prevIncidence , transaction , explicitChange ) ; } }    @ Override public void setAlpha  (  Vertex alpha )  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  if  (  !  isValid  ( ) )  {  throw  new GraphException  (   "Edge " + this + " is not valid within the current transaction." ) ; }  InternalVertex  oldAlpha =  getIncidentVertex  ( ) ;  synchronized  ( transaction )  {   super . setAlpha  ( alpha ) ;  assert  (     (  transaction != null ) &&  !  transaction . isReadOnly  ( ) &&  transaction . isValid  ( ) &&  (   transaction . getState  ( ) !=  TransactionState . NOTRUNNING ) ) ;  if  (   transaction . getState  ( ) ==  TransactionState . RUNNING )  {  if  (   transaction . changedEdges == null )  {    transaction . changedEdges =  new  HashMap  < EdgeImpl , VertexPosition >  ( 1 ,  TransactionManagerImpl . LOAD_FACTOR ) ; }  VertexPosition  position =   transaction . changedEdges . get  ( this ) ;  if  (  position == null )  {   position =  VertexPosition . ALPHA ; } else  if  (  position ==  VertexPosition . OMEGA )  {   position =  VertexPosition . ALPHAOMEGA ; }    transaction . changedEdges . put  ( this , position ) ;  if  (   transaction . changedIncidences != null )  {   Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > >  oldAlphaIncidences =   transaction . changedIncidences . get  ( oldAlpha ) ;  if  (  oldAlphaIncidences != null )  {   oldAlphaIncidences . remove  ( this ) ; } } } } }    @ Override public void setOmega  (  Vertex omega )  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  if  (  !  isValid  ( ) )  {  throw  new GraphException  (   "Edge " + this + " is not valid within the current transaction." ) ; }  InternalVertex  oldOmega =   (  ( ReversedEdgeImpl ) reversedEdge ) . getIncidentVertex  ( ) ;  synchronized  ( transaction )  {   super . setOmega  ( omega ) ;  assert  (     (  transaction != null ) &&  !  transaction . isReadOnly  ( ) &&  transaction . isValid  ( ) &&  (   transaction . getState  ( ) !=  TransactionState . NOTRUNNING ) ) ;  if  (   transaction . getState  ( ) ==  TransactionState . RUNNING )  {  if  (   transaction . changedEdges == null )  {    transaction . changedEdges =  new  HashMap  < EdgeImpl , VertexPosition >  ( 1 ,  TransactionManagerImpl . LOAD_FACTOR ) ; }  VertexPosition  position =   transaction . changedEdges . get  ( this ) ;  if  (  position == null )  {   position =  VertexPosition . OMEGA ; } else  if  (  position ==  VertexPosition . ALPHA )  {   position =  VertexPosition . ALPHAOMEGA ; }    transaction . changedEdges . put  ( this , position ) ;  if  (   transaction . changedIncidences != null )  {   Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > >  oldOmegaIncidences =   transaction . changedIncidences . get  ( oldOmega ) ;  if  (  oldOmegaIncidences != null )  {   oldOmegaIncidences . remove  ( reversedEdge ) ; } } } } }   protected void attributeChanged  (   VersionedDataObjectImpl  <  ? > versionedAttribute )  {  if  (  !  graph . isLoading  ( ) )  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  assert  (     (  transaction != null ) &&  (   transaction . getState  ( ) !=  TransactionState . NOTRUNNING ) &&  transaction . isValid  ( ) &&  !  transaction . isReadOnly  ( ) ) ;  if  (   transaction . getState  ( ) ==  TransactionState . RUNNING )  {  if  (  !  isValid  ( ) )  {  throw  new GraphException  (     "Trying to change the attribute '" + versionedAttribute + "' of Edge " + this + ", that has been deleted within the current transaction." ) ; }  if  (   transaction . changedAttributes == null )  {    transaction . changedAttributes =  new  HashMap  < AttributedElement ,  Set  <  VersionedDataObject  <  ? > > >  ( 1 ,  TransactionManagerImpl . LOAD_FACTOR ) ; }   Set  <  VersionedDataObject  <  ? > >  attributes =   transaction . changedAttributes . get  ( this ) ;  if  (  attributes == null )  {   attributes =  new  HashSet  <  VersionedDataObject  <  ? > >  ( 1 ,  TransactionManagerImpl . LOAD_FACTOR ) ;    transaction . changedAttributes . put  ( this , attributes ) ; }   attributes . add  ( versionedAttribute ) ; } } }   abstract public  Set  <  VersionedDataObject  <  ? > > attributes  ( ) ;    @ Override public boolean isValid  ( )  {      (  ( GraphImpl ) graph ) . edgeSync . readLock  ( ) . lock  ( ) ;  boolean  result =  super . isValid  ( ) ;      (  ( GraphImpl ) graph ) . edgeSync . readLock  ( ) . unlock  ( ) ;  return result ; }    @ Override public  VersionedReferenceImpl  < IncidenceImpl > getVersionedNextIncidence  ( )  {  return nextIncidence ; }    @ Override public  VersionedReferenceImpl  < IncidenceImpl > getVersionedPrevIncidence  ( )  {  return prevIncidence ; }    @ Override public void internalSetDefaultValue  (  Attribute attr )  throws GraphIOException  {   attr . setDefaultTransactionValue  ( this ) ; } 
<<<<<<<
=======
   @ Override protected void setIncidentVertex  (  VertexBaseImpl v )  {  if  (  graph . isLoading  ( ) )  {   incidentVertex =  new  VersionedReferenceImpl  < VertexBaseImpl >  ( this , v , "$incidentVertex" ) ; } else  {  if  (  incidentVertex == null )  {   incidentVertex =  new  VersionedReferenceImpl  < VertexBaseImpl >  ( this , null , "$incidentVertex" ) ; }   incidentVertex . setValidValue  ( v ,  graph . getCurrentTransaction  ( ) ) ; } }
>>>>>>>
 
<<<<<<<
=======
   @ Override protected void setNextIncidenceInternal  (  IncidenceImpl nextIncidence )  {  if  (  graph . isLoading  ( ) )  {    this . nextIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( this , nextIncidence , "$nextIncidence" ) ; } else  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  boolean  explicitChange = false ;  if  (   transaction . getState  ( ) ==  TransactionState . WRITING )  {  if  (   transaction . changedIncidences != null )  {  VertexBaseImpl  temporaryIncidentVertex =  incidentVertex . getTemporaryValue  ( transaction ) ;   Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > >  incidenceList =   transaction . changedIncidences . get  ( temporaryIncidentVertex ) ;  if  (  incidenceList != null )  {   explicitChange =   incidenceList . containsKey  ( this ) &&  (    incidenceList . get  ( this ) . keySet  ( ) . contains  (  ListPosition . NEXT ) ) ; } } }  if  (   this . nextIncidence == null )  {    this . nextIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( this , null , "$nextIncidence" ) ; }    this . nextIncidence . setValidValue  ( nextIncidence , transaction , explicitChange ) ; } }
>>>>>>>
 
<<<<<<<
=======
   @ Override protected void setPrevIncidenceInternal  (  IncidenceImpl prevIncidence )  {  if  (  graph . isLoading  ( ) )  {    this . prevIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( this , prevIncidence , "$prevIncidence" ) ; } else  {  TransactionImpl  transaction =  ( TransactionImpl )  graph . getCurrentTransaction  ( ) ;  if  (  transaction == null )  {  throw  new GraphException  ( "Current transaction is null." ) ; }  boolean  explicitChange = false ;  if  (   transaction . getState  ( ) ==  TransactionState . WRITING )  {  if  (   transaction . changedIncidences != null )  {  VertexBaseImpl  temporaryIncidentVertex =  incidentVertex . getTemporaryValue  ( transaction ) ;   Map  < IncidenceImpl ,  Map  < ListPosition , Boolean > >  incidenceList =   transaction . changedIncidences . get  ( temporaryIncidentVertex ) ;  if  (  incidenceList != null )  {   explicitChange =   incidenceList . containsKey  ( this ) &&  (    incidenceList . get  ( this ) . keySet  ( ) . contains  (  ListPosition . PREV ) ) ; } } }  if  (   this . prevIncidence == null )  {    this . prevIncidence =  new  VersionedReferenceImpl  < IncidenceImpl >  ( this , null , "$prevIncidence" ) ; }    this . prevIncidence . setValidValue  ( prevIncidence , transaction , explicitChange ) ; } }
>>>>>>>
 }