  package    de . uni_koblenz . jgralab . impl ;   import    java . lang . ref . WeakReference ;  import    java . lang . reflect . Constructor ;  import   java . util . ArrayList ;  import   java . util . Comparator ;  import   java . util . Iterator ;  import   java . util . LinkedList ;  import   java . util . List ;  import   java . util . NoSuchElementException ;  import    de . uni_koblenz . jgralab . AttributedElement ;  import    de . uni_koblenz . jgralab . Edge ;  import    de . uni_koblenz . jgralab . Graph ;  import    de . uni_koblenz . jgralab . GraphException ;  import    de . uni_koblenz . jgralab . GraphFactory ;  import    de . uni_koblenz . jgralab . GraphIOException ;  import    de . uni_koblenz . jgralab . GraphStructureChangedListener ;  import    de . uni_koblenz . jgralab . GraphStructureChangedListenerWithAutoRemove ;  import    de . uni_koblenz . jgralab . RandomIdGenerator ;  import    de . uni_koblenz . jgralab . TraversalContext ;  import    de . uni_koblenz . jgralab . Vertex ;  import     de . uni_koblenz . jgralab . eca . ECARuleManagerInterface ;  import     de . uni_koblenz . jgralab . schema . AggregationKind ;  import     de . uni_koblenz . jgralab . schema . Attribute ;  import     de . uni_koblenz . jgralab . schema . EdgeClass ;  import     de . uni_koblenz . jgralab . schema . GraphClass ;  import     de . uni_koblenz . jgralab . schema . Schema ;  import     de . uni_koblenz . jgralab . schema . VertexClass ;   public abstract class GraphBaseImpl  implements  Graph , GraphBase  {   private String  id ;   private final Schema  schema ;   protected GraphFactory  graphFactory ;   private  long  graphVersion ;   private boolean  loading ;   protected  int  vMax ;   protected FreeIndexList  freeVertexList ;   protected  int  eMax ;   protected FreeIndexList  freeEdgeList ;   protected GraphBaseImpl  (  String id ,  GraphClass cls )  {  this  ( id , cls , 1000 , 1000 ) ; }    @ Override public void initializeAttributesWithDefaultValues  ( )  {  for ( Attribute attr :   getAttributedElementClass  ( ) . getAttributeList  ( ) )  {  try  {  if  (   (   attr . getDefaultValueAsString  ( ) != null ) &&  !   attr . getDefaultValueAsString  ( ) . isEmpty  ( ) )  {   internalSetDefaultValue  ( attr ) ; } }  catch (   GraphIOException e )  {   e . printStackTrace  ( ) ; } } }   public void internalSetDefaultValue  (  Attribute attr )  throws GraphIOException  {   attr . setDefaultValue  ( this ) ; }   protected GraphBaseImpl  (  String id ,  GraphClass cls ,   int vMax ,   int eMax )  {  if  (  vMax < 1 )  {  throw  new GraphException  ( "vMax must not be less than 1" , null ) ; }  if  (  eMax < 1 )  {  throw  new GraphException  ( "eMax must not be less than 1" , null ) ; }   schema =  cls . getSchema  ( ) ;   graphFactory =  schema . getGraphFactory  ( ) ;   setId  (   id == null ?  RandomIdGenerator . generateId  ( ) : id ) ;   graphVersion =  - 1 ;   setGraphVersion  ( 0 ) ;   expandVertexArray  ( vMax ) ;   setFirstVertex  ( null ) ;   setLastVertex  ( null ) ;   setVCount  ( 0 ) ;   setDeleteVertexList  (  new  LinkedList  < VertexBase >  ( ) ) ;   expandEdgeArray  ( eMax ) ;   setFirstEdgeInGraph  ( null ) ;   setLastEdgeInGraph  ( null ) ;   setECount  ( 0 ) ; }   public void addEdge  (  Edge newEdge ,  Vertex alpha ,  Vertex omega )  {  assert  newEdge != null ;  assert    (  alpha != null ) &&  alpha . isValid  ( ) &&  containsVertex  ( alpha ) : "Alpha vertex is invalid" ;  assert    (  omega != null ) &&  omega . isValid  ( ) &&  containsVertex  ( omega ) : "Omega vertex is invalid" ;  assert  newEdge . isNormal  ( ) : "Can't add reversed edge" ;  assert    (   alpha . getSchema  ( ) ==  omega . getSchema  ( ) ) &&  (   alpha . getSchema  ( ) == schema ) &&  (   newEdge . getSchema  ( ) == schema ) : "The schemas of alpha, omega, newEdge and this graph don't match!" ;  assert    (   alpha . getGraph  ( ) ==  omega . getGraph  ( ) ) &&  (   alpha . getGraph  ( ) == this ) &&  (   newEdge . getGraph  ( ) == this ) : "The graph of alpha, omega, newEdge and this graph don't match!" ;  EdgeBaseImpl  e =  ( EdgeBaseImpl ) newEdge ;  VertexBase  a =  ( VertexBase ) alpha ;  if  (  !  a . isValidAlpha  ( e ) )  {  throw  new GraphException  (    "Edges of class " +   e . getAttributedElementClass  ( ) . getQualifiedName  ( ) + " may not start at vertices of class " +   a . getAttributedElementClass  ( ) . getQualifiedName  ( ) ) ; }  VertexBase  o =  ( VertexBase ) omega ;  if  (  !  o . isValidOmega  ( e ) )  {  throw  new GraphException  (    "Edges of class " +   e . getAttributedElementClass  ( ) . getQualifiedName  ( ) + " may not end at vertices of class " +   o . getAttributedElementClass  ( ) . getQualifiedName  ( ) ) ; }   int  eId =  e . getId  ( ) ;  if  (  isLoading  ( ) )  {  if  (  eId > 0 )  {  if  (  containsEdgeId  ( eId ) )  {  throw  new GraphException  (   "edge with id " +  e . getId  ( ) + " already exists" ) ; }  if  (  eId > eMax )  {  throw  new GraphException  (   "edge id " +  e . getId  ( ) + " is bigger than eSize" ) ; } } else  {  throw  new GraphException  ( "can not load an edge with id <= 0" ) ; } } else  {  if  (  !  canAddGraphElement  ( eId ) )  {  throw  new GraphException  ( "can not add an edge with id != 0" ) ; }   eId =  allocateEdgeIndex  ( eId ) ;  assert  eId != 0 ;   e . setId  ( eId ) ;   a . appendIncidenceToLambdaSeq  ( e ) ;   o . appendIncidenceToLambdaSeq  (  e . reversedEdge ) ; }   appendEdgeToESeq  ( e ) ;  if  (  !  isLoading  ( ) )  {   a . incidenceListModified  ( ) ;   o . incidenceListModified  ( ) ;   edgeListModified  ( ) ;   internalEdgeAdded  ( e ) ; } } 
<<<<<<<
  protected void internalEdgeAdded  (  EdgeBaseImpl e )  {   notifyEdgeAdded  ( e ) ;  if  (   this . getECARuleManagerIfThere  ( ) != null )  {    getECARuleManagerIfThere  ( ) . fireAfterCreateEdgeEvents  ( e ) ; } }
=======
>>>>>>>
   public void addVertex  (  Vertex newVertex )  {  VertexBase  v =  ( VertexBase ) newVertex ;   int  vId =  v . getId  ( ) ;  if  (  isLoading  ( ) )  {  if  (  vId > 0 )  {  if  (  containsVertexId  ( vId ) )  {  throw  new GraphException  (   "vertex with id " + vId + " already exists" ) ; }  if  (  vId > vMax )  {  throw  new GraphException  (   "vertex id " + vId + " is bigger than vSize" ) ; } } else  {  throw  new GraphException  ( "can not load a vertex with id <= 0" ) ; } } else  {  if  (  !  canAddGraphElement  ( vId ) )  {  throw  new GraphException  (  "can not add a vertex with vId " + vId ) ; }   vId =  allocateVertexIndex  ( vId ) ;  assert  vId != 0 ;   v . setId  ( vId ) ; }   appendVertexToVSeq  ( v ) ;  if  (  !  isLoading  ( ) )  {   vertexListModified  ( ) ;   internalVertexAdded  ( v ) ; } } 
<<<<<<<
  protected void internalVertexAdded  (  VertexBaseImpl v )  {   notifyVertexAdded  ( v ) ;  if  (   this . getECARuleManagerIfThere  ( ) != null )  {    getECARuleManager  ( ) . fireAfterCreateVertexEvents  ( v ) ; } }
=======
>>>>>>>
    @ Override public  int getExpandedVertexCount  ( )  {  return  computeNewSize  ( vMax ) ; }   private  int computeNewSize  (   int n )  {  return   n >= 1048576 ?  n + 131072 :   n >= 262144 ?  n + 262144 :  n + n ; }    @ Override public  int getExpandedEdgeCount  ( )  {  return  computeNewSize  ( eMax ) ; }    @ Override public  int compareTo  (  AttributedElement a )  {  if  (  a instanceof Graph )  {  Graph  g =  ( Graph ) a ;  return   hashCode  ( ) -  g . hashCode  ( ) ; }  return  - 1 ; }    @ Override public boolean containsEdge  (  Edge e )  {  if  (  e == null )  {  return false ; }  if  (   e . getGraph  ( ) != this )  {  return false ; }  if  (  !  containsEdgeId  (   (  ( EdgeBaseImpl )  e . getNormalEdge  ( ) ) . id ) )  {  return false ; }  if  (  !  (   getEdge  (   (  ( EdgeBaseImpl )  e . getNormalEdge  ( ) ) . id ) ==  e . getNormalEdge  ( ) ) )  {  return false ; }  return true ; }   private final boolean containsEdgeId  (   int eId )  {  if  (  eId < 0 )  {   eId =  - eId ; }  if  (  !  (  eId > 0 ) )  {  return false ; }  if  (  !  (  eId <= eMax ) )  {  return false ; }   EdgeBase  [ ]  edge =  getEdge  ( ) ;  if  (  !  (   edge [ eId ] != null ) )  {  return false ; }   EdgeBase  [ ]  revEdge =  getRevEdge  ( ) ;  if  (  !  (   revEdge [ eId ] != null ) )  {  return false ; }  return true ; }    @ Override public boolean containsVertex  (  Vertex v )  {   VertexBase  [ ]  vertex =  getVertex  ( ) ;  return     (  v != null ) &&  (   v . getGraph  ( ) == this ) &&  containsVertexId  (   (  ( VertexBaseImpl ) v ) . id ) &&  (   vertex [   (  ( VertexBaseImpl ) v ) . id ] == v ) ; }   private final boolean containsVertexId  (   int vId )  {  return    (  vId > 0 ) &&  (  vId <= vMax ) &&  (    getVertex  ( ) [ vId ] != null ) ; }    @ SuppressWarnings  ( "unchecked" )  @ Override public  <  T  extends Edge > T createEdge  (   Class  < T > cls ,  Vertex alpha ,  Vertex omega )  {  try  {  return  ( T )  internalCreateEdge  ( cls , alpha , omega ) ; }  catch (   Exception exception )  {  if  (  exception instanceof GraphException )  {  throw  ( GraphException ) exception ; } else  {  throw  new GraphException  (  "Error creating edge of class " +  cls . getName  ( ) , exception ) ; } } }   public Edge internalCreateEdge  (   Class  <  ? extends Edge > cls ,  Vertex alpha ,  Vertex omega )  {  return  graphFactory . createEdge  ( cls , 0 , this , alpha , omega ) ; }    @ SuppressWarnings  ( "unchecked" )  @ Override public  <  T  extends Vertex > T createVertex  (   Class  < T > cls )  {  try  {  return  ( T )  internalCreateVertex  ( cls ) ; }  catch (   Exception ex )  {  if  (  ex instanceof GraphException )  {  throw  ( GraphException ) ex ; }  throw  new GraphException  (  "Error creating vertex of class " +  cls . getName  ( ) , ex ) ; } }   public Vertex internalCreateVertex  (   Class  <  ? extends Vertex > cls )  {  return  graphFactory . createVertex  ( cls , 0 , this ) ; }    @ Override public void deleteEdge  (  Edge e )  {  assert    (  e != null ) &&  e . isValid  ( ) &&  containsEdge  ( e ) ;   internalDeleteEdge  ( e ) ;   edgeListModified  ( ) ; }    @ Override public void deleteVertex  (  Vertex v )  {  assert    (  v != null ) &&  v . isValid  ( ) &&  containsVertex  ( v ) ;    getDeleteVertexList  ( ) . add  (  ( VertexBase ) v ) ;   internalDeleteVertex  ( ) ; }   public void edgeAfterDeleted  (  Edge e ,  Vertex oldAlpha ,  Vertex oldOmega )  { }   public void edgeListModified  ( )  {   setEdgeListVersion  (   getEdgeListVersion  ( ) + 1 ) ;   setGraphVersion  (   getGraphVersion  ( ) + 1 ) ; }    @ Override public  Iterable  < Edge > edges  ( )  {  return  new  EdgeIterable  < Edge >  ( this ) ; }    @ Override public  Iterable  < Edge > edges  (   Class  <  ? extends Edge > edgeClass )  {  return  new  EdgeIterable  < Edge >  ( this , edgeClass ) ; }    @ Override public  Iterable  < Edge > edges  (  EdgeClass edgeClass )  {  return  new  EdgeIterable  < Edge >  ( this ,  edgeClass . getM1Class  ( ) ) ; }   public void expandEdgeArray  (   int newSize )  {  if  (  newSize <= eMax )  {  throw  new GraphException  (    "newSize must be > eSize: eSize=" + eMax + ", newSize=" + newSize ) ; }   EdgeBase  [ ]  e =  new EdgeBase  [  newSize + 1 ] ;  if  (   getEdge  ( ) != null )  {   System . arraycopy  (  getEdge  ( ) , 0 , e , 0 ,   getEdge  ( ) . length ) ; }   setEdge  ( e ) ;   ReversedEdgeBaseImpl  [ ]  r =  new ReversedEdgeBaseImpl  [  newSize + 1 ] ;  if  (   getRevEdge  ( ) != null )  {   System . arraycopy  (  getRevEdge  ( ) , 0 , r , 0 ,   getRevEdge  ( ) . length ) ; }   setRevEdge  ( r ) ;  if  (   getFreeEdgeList  ( ) == null )  {   setFreeEdgeList  (  new FreeIndexList  ( newSize ) ) ; } else  {    getFreeEdgeList  ( ) . expandBy  (  newSize - eMax ) ; }   eMax = newSize ;   notifyMaxEdgeCountIncreased  ( newSize ) ; }   public void expandVertexArray  (   int newSize )  {  if  (  newSize <= vMax )  {  throw  new GraphException  (    "newSize must > vSize: vSize=" + vMax + ", newSize=" + newSize ) ; }   VertexBase  [ ]  expandedArray =  new VertexBase  [  newSize + 1 ] ;  if  (   getVertex  ( ) != null )  {   System . arraycopy  (  getVertex  ( ) , 0 , expandedArray , 0 ,   getVertex  ( ) . length ) ; }  if  (   getFreeVertexList  ( ) == null )  {   setFreeVertexList  (  new FreeIndexList  ( newSize ) ) ; } else  {    getFreeVertexList  ( ) . expandBy  (  newSize - vMax ) ; }   setVertex  ( expandedArray ) ;   vMax = newSize ;   notifyMaxVertexCountIncreased  ( newSize ) ; }    @ Override public  int getECount  ( )  {  TraversalContext  tc =  getTraversalContext  ( ) ;  return   tc == null ?  getBaseECount  ( ) :  tc . getECount  ( ) ; }    @ Override public Edge getEdge  (   int eId )  {  assert  eId != 0 :  "The edge id must be != 0, given was " + eId ;  try  {  return   eId < 0 ?   getRevEdge  ( ) [  - eId ] :   getEdge  ( ) [ eId ] ; }  catch (   ArrayIndexOutOfBoundsException e )  {  return null ; } }    @ Override public Edge getFirstEdge  ( )  {  Edge  firstEdge =  getFirstBaseEdge  ( ) ;  TraversalContext  tc =  getTraversalContext  ( ) ;  if  (  !  (    tc == null ||  firstEdge == null ||  tc . containsEdge  ( firstEdge ) ) )  {   firstEdge =  firstEdge . getNextEdge  ( ) ; }  return firstEdge ; }    @ Override public Edge getLastEdge  ( )  {  Edge  lastEdge =  getLastBaseEdge  ( ) ;  TraversalContext  tc =  getTraversalContext  ( ) ;  if  (  !  (    tc == null ||  lastEdge == null ||  tc . containsEdge  ( lastEdge ) ) )  {   lastEdge =  lastEdge . getPrevEdge  ( ) ; }  return lastEdge ; }    @ Override public Edge getFirstEdge  (   Class  <  ? extends Edge > edgeClass )  {  assert  edgeClass != null ;  Edge  currentEdge =  getFirstEdge  ( ) ;  if  (  currentEdge == null )  {  return null ; }  if  (  edgeClass . isInstance  ( currentEdge ) )  {  return currentEdge ; }  return  currentEdge . getNextEdge  ( edgeClass ) ; }    @ Override public Edge getFirstEdge  (  EdgeClass edgeClass )  {  assert  edgeClass != null ;  return  getFirstEdge  (  edgeClass . getM1Class  ( ) ) ; }    @ Override public Vertex getFirstVertex  ( )  {  Vertex  firstVertex =  getFirstBaseVertex  ( ) ;  TraversalContext  tc =  getTraversalContext  ( ) ;  if  (  !  (    tc == null ||  firstVertex == null ||  tc . containsVertex  ( firstVertex ) ) )  {   firstVertex =  firstVertex . getNextVertex  ( ) ; }  return firstVertex ; }    @ Override public Vertex getLastVertex  ( )  {  Vertex  lastVertex =  getLastBaseVertex  ( ) ;  TraversalContext  tc =  getTraversalContext  ( ) ;  if  (  !  (    tc == null ||  lastVertex == null ||  tc . containsVertex  ( lastVertex ) ) )  {   lastVertex =  lastVertex . getPrevVertex  ( ) ; }  return lastVertex ; }    @ Override public Vertex getFirstVertex  (   Class  <  ? extends Vertex > vertexClass )  {  assert  vertexClass != null ;  Vertex  firstVertex =  getFirstVertex  ( ) ;  if  (  firstVertex == null )  {  return null ; }  if  (  vertexClass . isInstance  ( firstVertex ) )  {  return firstVertex ; }  return  firstVertex . getNextVertex  ( vertexClass ) ; }    @ Override public Vertex getFirstVertex  (  VertexClass vertexClass )  {  assert  vertexClass != null ;  return  getFirstVertex  (  vertexClass . getM1Class  ( ) ) ; }    @ Override public GraphClass getGraphClass  ( )  {  return  ( GraphClass )  getAttributedElementClass  ( ) ; }    @ Override public  long getGraphVersion  ( )  {  return graphVersion ; }    @ Override public String getId  ( )  {  return id ; }    @ Override public  int getMaxECount  ( )  {  return eMax ; }    @ Override public  int getMaxVCount  ( )  {  return vMax ; }    @ Override public Schema getSchema  ( )  {  return schema ; }    @ Override public  int getVCount  ( )  {  TraversalContext  tc =  getTraversalContext  ( ) ;  return   tc == null ?  getBaseVCount  ( ) :  tc . getVCount  ( ) ; }    @ Override public Vertex getVertex  (   int vId )  {  assert  (  vId > 0 ) :  "The vertex id must be > 0, given was " + vId ;  try  {  return   getVertex  ( ) [ vId ] ; }  catch (   ArrayIndexOutOfBoundsException e )  {  return null ; } }   public void graphModified  ( )  {   setGraphVersion  (   getGraphVersion  ( ) + 1 ) ; }   public void ecaAttributeChanging  (  String name ,  Object oldValue ,  Object newValue )  {  if  (  !  isLoading  ( ) )  {    getECARuleManager  ( ) . fireBeforeChangeAttributeEvents  ( this , name , oldValue , newValue ) ; } }   public void ecaAttributeChanged  (  String name ,  Object oldValue ,  Object newValue )  {  if  (  !  isLoading  ( ) )  {    getECARuleManager  ( ) . fireAfterChangeAttributeEvents  ( this , name , oldValue , newValue ) ; } }   private void internalDeleteEdge  (  Edge edge )  {  assert    (  edge != null ) &&  edge . isValid  ( ) &&  containsEdge  ( edge ) ;  if  (   this . getECARuleManagerIfThere  ( ) != null )  {    getECARuleManagerIfThere  ( ) . fireBeforeDeleteEdgeEvents  ( edge ) ; }  EdgeBase  e =  ( EdgeBase )  edge . getNormalEdge  ( ) ;   internalEdgeDeleted  ( e ) ;  VertexBase  alpha =  e . getIncidentVertex  ( ) ;   alpha . removeIncidenceFromLambdaSeq  ( e ) ;   alpha . incidenceListModified  ( ) ;  VertexBase  omega =    (  ( EdgeBaseImpl ) e ) . reversedEdge . getIncidentVertex  ( ) ;   omega . removeIncidenceFromLambdaSeq  (   (  ( EdgeBaseImpl ) e ) . reversedEdge ) ;   omega . incidenceListModified  ( ) ;   removeEdgeFromESeq  ( e ) ;   edgeListModified  ( ) ;  if  (   this . getECARuleManagerIfThere  ( ) != null )  {    getECARuleManagerIfThere  ( ) . fireAfterDeleteEdgeEvents  (  e . getM1Class  ( ) ) ; }   edgeAfterDeleted  ( e , alpha , omega ) ; }   private void internalDeleteVertex  ( )  {  while  (  !   getDeleteVertexList  ( ) . isEmpty  ( ) )  {  VertexBase  v =   getDeleteVertexList  ( ) . remove  ( 0 ) ;  assert    (  v != null ) &&  v . isValid  ( ) &&  containsVertex  ( v ) ;  if  (   this . getECARuleManagerIfThere  ( ) != null )  {    getECARuleManagerIfThere  ( ) . fireBeforeDeleteVertexEvents  ( v ) ; }   internalVertexDeleted  ( v ) ;  Edge  e =  v . getFirstIncidence  ( ) ;  while  (  e != null )  {  assert   e . isValid  ( ) &&  containsEdge  ( e ) ;  if  (   e . getThatAggregationKind  ( ) ==  AggregationKind . COMPOSITE )  {  VertexBase  other =  ( VertexBase )  e . getThat  ( ) ;  if  (    (  other != v ) &&  containsVertex  ( other ) &&  !   getDeleteVertexList  ( ) . contains  ( other ) )  {    getDeleteVertexList  ( ) . add  ( other ) ; } }   deleteEdge  ( e ) ;   e =  v . getFirstIncidence  ( ) ; }   removeVertexFromVSeq  ( v ) ;   vertexListModified  ( ) ;  if  (   this . getECARuleManagerIfThere  ( ) != null )  {    getECARuleManagerIfThere  ( ) . fireAfterDeleteVertexEvents  (  v . getM1Class  ( ) ) ; }   vertexAfterDeleted  ( v ) ; } }    @ Override public boolean isEdgeListModified  (   long edgeListVersion )  {  return   getEdgeListVersion  ( ) != edgeListVersion ; }    @ Override public boolean isGraphModified  (   long previousVersion )  {  return   getGraphVersion  ( ) != previousVersion ; }    @ Override public boolean isLoading  ( )  {  return loading ; }    @ Override public boolean isVertexListModified  (   long previousVersion )  {  return   getVertexListVersion  ( ) != previousVersion ; }    @ Override public void loadingCompleted  ( )  { }   public void internalLoadingCompleted  (    int  [ ] firstIncidence ,    int  [ ] nextIncidence )  {    getFreeVertexList  ( ) . reinitialize  (  getVertex  ( ) ) ;    getFreeEdgeList  ( ) . reinitialize  (  getEdge  ( ) ) ;  for (   int  vId = 1 ;  vId <   getVertex  ( ) . length ;  ++ vId )  {  VertexBase  v =   getVertex  ( ) [ vId ] ;  if  (  v != null )  {   int  eId =  firstIncidence [ vId ] ;  while  (  eId != 0 )  {   v . appendIncidenceToLambdaSeq  (   eId < 0 ?   getRevEdge  ( ) [  - eId ] :   getEdge  ( ) [ eId ] ) ;   eId =  nextIncidence [  eMax + eId ] ; } } } }   public void setGraphVersion  (   long graphVersion )  {    this . graphVersion = graphVersion ; }    @ Override public void setId  (  String id )  {    this . id = id ; }   public void setLoading  (  boolean isLoading )  {   loading = isLoading ; }   public void vertexListModified  ( )  {   setVertexListVersion  (   getVertexListVersion  ( ) + 1 ) ;   setGraphVersion  (   getGraphVersion  ( ) + 1 ) ; }    @ Override public  Iterable  < Vertex > vertices  ( )  {  return  new  VertexIterable  < Vertex >  ( this ) ; }    @ Override public  Iterable  < Vertex > vertices  (   Class  <  ? extends Vertex > vertexClass )  {  return  new  VertexIterable  < Vertex >  ( this , vertexClass ) ; }    @ Override public  Iterable  < Vertex > vertices  (  VertexClass vertexClass )  {  return  new  VertexIterable  < Vertex >  ( this ,  vertexClass . getM1Class  ( ) ) ; }    @ Override public void defragment  ( )  {  TraversalContext  tc =  setTraversalContext  ( null ) ;  try  {  if  (   getBaseVCount  ( ) < vMax )  {  if  (   getBaseVCount  ( ) > 0 )  {   int  vId = vMax ;  while  (   getFreeVertexList  ( ) . isFragmented  ( ) )  {  while  (   (  vId >= 1 ) &&  (    getVertex  ( ) [ vId ] == null ) )  {   -- vId ; }  assert  vId >= 1 ;  VertexBase  v =   getVertex  ( ) [ vId ] ;     getVertex  ( ) [ vId ] = null ;    getFreeVertexList  ( ) . freeIndex  ( vId ) ;   int  newId =  allocateVertexIndex  ( vId ) ;  assert  newId < vId ;   v . setId  ( newId ) ;     getVertex  ( ) [ newId ] = v ;   -- vId ; } }   int  newVMax =    getBaseVCount  ( ) == 0 ? 1 :  getBaseVCount  ( ) ;  if  (  newVMax != vMax )  {   vMax = newVMax ;   VertexBase  [ ]  newVertex =  new VertexBase  [  vMax + 1 ] ;   System . arraycopy  (  getVertex  ( ) , 0 , newVertex , 0 ,  newVertex . length ) ;   setVertex  ( newVertex ) ; }   graphModified  ( ) ;   System . gc  ( ) ; }  if  (   getBaseECount  ( ) < eMax )  {  if  (   getBaseECount  ( ) > 0 )  {   int  eId = eMax ;  while  (   getFreeEdgeList  ( ) . isFragmented  ( ) )  {  while  (   (  eId >= 1 ) &&  (    getEdge  ( ) [ eId ] == null ) )  {   -- eId ; }  assert  eId >= 1 ;  EdgeBase  e =   getEdge  ( ) [ eId ] ;     getEdge  ( ) [ eId ] = null ;    getFreeEdgeList  ( ) . freeIndex  ( eId ) ;   int  newId =  allocateEdgeIndex  ( eId ) ;  assert  newId < eId ;   e . setId  ( newId ) ;     getEdge  ( ) [ newId ] = e ;   -- eId ; } }   int  newEMax =    getBaseECount  ( ) == 0 ? 1 :  getBaseECount  ( ) ;  if  (  newEMax != eMax )  {   eMax = newEMax ;   EdgeBase  [ ]  newEdge =  new EdgeBase  [  eMax + 1 ] ;   System . arraycopy  (  getEdge  ( ) , 0 , newEdge , 0 ,  newEdge . length ) ;   setEdge  ( newEdge ) ;   System . gc  ( ) ; }   graphModified  ( ) ;   System . gc  ( ) ; } }  finally  {   setTraversalContext  ( tc ) ; } }   public void setFreeVertexList  (  FreeIndexList freeVertexList )  {    this . freeVertexList = freeVertexList ; }   public void setFreeEdgeList  (  FreeIndexList freeEdgeList )  {    this . freeEdgeList = freeEdgeList ; }    @ Override public void sortVertices  (   Comparator  < Vertex > comp )  {  if  (   getFirstBaseVertex  ( ) == null )  {  return ; }  class VertexList  {  VertexBase  first ;  VertexBase  last ;   public VertexBase remove  ( )  {  if  (  first == null )  {  throw  new NoSuchElementException  ( ) ; }  VertexBase  out ;  if  (  first == last )  {   out = first ;   first = null ;   last = null ;  return out ; }   out = first ;   first =  out . getNextBaseVertex  ( ) ;   first . setPrevVertex  ( null ) ;  return out ; }   public boolean isEmpty  ( )  {  assert  (   (  first == null ) ==  (  last == null ) ) ;  return  first == null ; }   public void add  (  VertexBase v )  {  if  (  first == null )  {   first = v ;  assert  (  last == null ) ;   last = v ; } else  {   v . setPrevVertex  ( last ) ;   last . setNextVertex  ( v ) ;   last = v ; }   v . setNextVertex  ( null ) ; } }  VertexList  a =  new VertexList  ( ) ;  VertexList  b =  new VertexList  ( ) ;  VertexList  out = a ;  VertexBase  last ;  VertexList  l =  new VertexList  ( ) ;    l . first =  getFirstBaseVertex  ( ) ;    l . last =  getLastBaseVertex  ( ) ;   out . add  (  last =  l . remove  ( ) ) ;  while  (  !  l . isEmpty  ( ) )  {  VertexBase  current =  l . remove  ( ) ;  if  (   comp . compare  ( current , last ) < 0 )  {   out =   (  out == a ) ? b : a ; }   out . add  ( current ) ;   last = current ; }  if  (   a . isEmpty  ( ) ||  b . isEmpty  ( ) )  {   out =   a . isEmpty  ( ) ? b : a ;   setFirstVertex  (  out . first ) ;   setLastVertex  (  out . last ) ;  return ; }  while  ( true )  {  if  (   a . isEmpty  ( ) ||  b . isEmpty  ( ) )  {   out =   a . isEmpty  ( ) ? b : a ;   setFirstVertex  (  out . first ) ;   setLastVertex  (  out . last ) ;   edgeListModified  ( ) ;  return ; }  VertexList  c =  new VertexList  ( ) ;  VertexList  d =  new VertexList  ( ) ;   out = c ;   last = null ;  while  (   !  a . isEmpty  ( ) &&  !  b . isEmpty  ( ) )  {   int  compareAToLast =   last != null ?  comp . compare  (  a . first , last ) : 0 ;   int  compareBToLast =   last != null ?  comp . compare  (  b . first , last ) : 0 ;  if  (   (  compareAToLast >= 0 ) &&  (  compareBToLast >= 0 ) )  {  if  (   comp . compare  (  a . first ,  b . first ) <= 0 )  {   out . add  (  last =  a . remove  ( ) ) ; } else  {   out . add  (  last =  b . remove  ( ) ) ; } } else  if  (   (  compareAToLast < 0 ) &&  (  compareBToLast < 0 ) )  {   out =   (  out == c ) ? d : c ;   last = null ; } else  if  (   (  compareAToLast < 0 ) &&  (  compareBToLast >= 0 ) )  {   out . add  (  last =  b . remove  ( ) ) ; } else  {   out . add  (  last =  a . remove  ( ) ) ; } }  while  (  !  a . isEmpty  ( ) )  {  VertexBase  current =  a . remove  ( ) ;  if  (   comp . compare  ( current , last ) < 0 )  {   out =   (  out == c ) ? d : c ; }   out . add  ( current ) ;   last = current ; }  while  (  !  b . isEmpty  ( ) )  {  VertexBase  current =  b . remove  ( ) ;  if  (   comp . compare  ( current , last ) < 0 )  {   out =   (  out == c ) ? d : c ; }   out . add  ( current ) ;   last = current ; }   a = c ;   b = d ; } }    @ Override public void sortEdges  (   Comparator  < Edge > comp )  {  if  (   getFirstBaseEdge  ( ) == null )  {  return ; }  class EdgeList  {  EdgeBase  first ;  EdgeBase  last ;   public EdgeBase remove  ( )  {  if  (  first == null )  {  throw  new NoSuchElementException  ( ) ; }  EdgeBase  out ;  if  (  first == last )  {   out = first ;   first = null ;   last = null ;  return out ; }   out = first ;   first =  out . getNextBaseEdge  ( ) ;   first . setPrevEdgeInGraph  ( null ) ;  return out ; }   public boolean isEmpty  ( )  {  assert  (   (  first == null ) ==  (  last == null ) ) ;  return  first == null ; }   public void add  (  EdgeBase e )  {  if  (  first == null )  {   first = e ;  assert  (  last == null ) ;   last = e ; } else  {   e . setPrevEdgeInGraph  ( last ) ;   last . setNextEdgeInGraph  ( e ) ;   last = e ; }   e . setNextEdgeInGraph  ( null ) ; } }  EdgeList  a =  new EdgeList  ( ) ;  EdgeList  b =  new EdgeList  ( ) ;  EdgeList  out = a ;  EdgeBase  last ;  EdgeList  l =  new EdgeList  ( ) ;    l . first =  getFirstBaseEdge  ( ) ;    l . last =  getLastBaseEdge  ( ) ;   out . add  (  last =  l . remove  ( ) ) ;  while  (  !  l . isEmpty  ( ) )  {  EdgeBase  current =  l . remove  ( ) ;  if  (   comp . compare  ( current , last ) < 0 )  {   out =   (  out == a ) ? b : a ; }   out . add  ( current ) ;   last = current ; }  if  (   a . isEmpty  ( ) ||  b . isEmpty  ( ) )  {   out =   a . isEmpty  ( ) ? b : a ;   setFirstEdgeInGraph  (  out . first ) ;   setLastEdgeInGraph  (  out . last ) ;  return ; }  while  ( true )  {  if  (   a . isEmpty  ( ) ||  b . isEmpty  ( ) )  {   out =   a . isEmpty  ( ) ? b : a ;   setFirstEdgeInGraph  (  out . first ) ;   setLastEdgeInGraph  (  out . last ) ;   edgeListModified  ( ) ;  return ; }  EdgeList  c =  new EdgeList  ( ) ;  EdgeList  d =  new EdgeList  ( ) ;   out = c ;   last = null ;  while  (   !  a . isEmpty  ( ) &&  !  b . isEmpty  ( ) )  {   int  compareAToLast =   last != null ?  comp . compare  (  a . first , last ) : 0 ;   int  compareBToLast =   last != null ?  comp . compare  (  b . first , last ) : 0 ;  if  (   (  compareAToLast >= 0 ) &&  (  compareBToLast >= 0 ) )  {  if  (   comp . compare  (  a . first ,  b . first ) <= 0 )  {   out . add  (  last =  a . remove  ( ) ) ; } else  {   out . add  (  last =  b . remove  ( ) ) ; } } else  if  (   (  compareAToLast < 0 ) &&  (  compareBToLast < 0 ) )  {   out =   (  out == c ) ? d : c ;   last = null ; } else  if  (   (  compareAToLast < 0 ) &&  (  compareBToLast >= 0 ) )  {   out . add  (  last =  b . remove  ( ) ) ; } else  {   out . add  (  last =  a . remove  ( ) ) ; } }  while  (  !  a . isEmpty  ( ) )  {  EdgeBase  current =  a . remove  ( ) ;  if  (   comp . compare  ( current , last ) < 0 )  {   out =   (  out == c ) ? d : c ; }   out . add  ( current ) ;   last = current ; }  while  (  !  b . isEmpty  ( ) )  {  EdgeBase  current =  b . remove  ( ) ;  if  (   comp . compare  ( current , last ) < 0 )  {   out =   (  out == c ) ? d : c ; }   out . add  ( current ) ;   last = current ; }   a = c ;   b = d ; } }   private ECARuleManagerInterface  ecaRuleManager ;    @ Override public ECARuleManagerInterface getECARuleManager  ( )  {  if  (  ecaRuleManager == null )  {   Constructor  <  ? >  ruleManagerConstructor ;  try  {   ruleManagerConstructor =   Class . forName  ( "de.uni_koblenz.jgralab.eca.ECARuleManager" ) . getConstructor  (  Graph . class ) ;   ecaRuleManager =  ( ECARuleManagerInterface )  ruleManagerConstructor . newInstance  ( this ) ; }  catch (   Exception e )  {   e . printStackTrace  ( ) ; }  assert  ecaRuleManager != null ; }  return ecaRuleManager ; }    @ Override public ECARuleManagerInterface getECARuleManagerIfThere  ( )  {  return ecaRuleManager ; }   protected  List  <  WeakReference  < GraphStructureChangedListener > >  graphStructureChangedListenersWithAutoRemoval ;   protected  List  < GraphStructureChangedListener >  graphStructureChangedListeners ;  {   graphStructureChangedListenersWithAutoRemoval = null ;   graphStructureChangedListeners =  new  ArrayList  < GraphStructureChangedListener >  ( ) ; }   private void lazyCreateGraphStructureChangedListenersWithAutoRemoval  ( )  {  if  (  graphStructureChangedListenersWithAutoRemoval == null )  {   graphStructureChangedListenersWithAutoRemoval =  new  LinkedList  <  WeakReference  < GraphStructureChangedListener > >  ( ) ; } }    @ Override public void addGraphStructureChangedListener  (  GraphStructureChangedListener newListener )  {  assert  newListener != null ;  if  (  newListener instanceof GraphStructureChangedListenerWithAutoRemove )  {   lazyCreateGraphStructureChangedListenersWithAutoRemoval  ( ) ;   graphStructureChangedListenersWithAutoRemoval . add  (  new  WeakReference  < GraphStructureChangedListener >  ( newListener ) ) ; } else  {   graphStructureChangedListeners . add  ( newListener ) ; } }    @ Override public void removeGraphStructureChangedListener  (  GraphStructureChangedListener listener )  {  assert  listener != null ;  if  (  listener instanceof GraphStructureChangedListenerWithAutoRemove )  {   Iterator  <  WeakReference  < GraphStructureChangedListener > >  iterator =  getListenerListIteratorForAutoRemove  ( ) ;  while  (   (  iterator != null ) &&  iterator . hasNext  ( ) )  {  GraphStructureChangedListener  currentListener =   iterator . next  ( ) . get  ( ) ;  if  (   (  currentListener == null ) ||  (  currentListener == listener ) )  {   iterator . remove  ( ) ; } } } else  {   Iterator  < GraphStructureChangedListener >  iterator =  getListenerListIterator  ( ) ;  while  (   (  iterator != null ) &&  iterator . hasNext  ( ) )  {  GraphStructureChangedListener  currentListener =  iterator . next  ( ) ;  if  (  currentListener == listener )  {   iterator . remove  ( ) ; } } } }   private void setAutoListenerListToNullIfEmpty  ( )  {  if  (  graphStructureChangedListenersWithAutoRemoval . isEmpty  ( ) )  {   graphStructureChangedListenersWithAutoRemoval = null ; } }    @ Override public void removeAllGraphStructureChangedListeners  ( )  {   graphStructureChangedListenersWithAutoRemoval = null ;   graphStructureChangedListeners . clear  ( ) ; }    @ Override public  int getGraphStructureChangedListenerCount  ( )  {  return   graphStructureChangedListenersWithAutoRemoval == null ?  graphStructureChangedListeners . size  ( ) :   graphStructureChangedListenersWithAutoRemoval . size  ( ) +  graphStructureChangedListeners . size  ( ) ; }   private  Iterator  <  WeakReference  < GraphStructureChangedListener > > getListenerListIteratorForAutoRemove  ( )  {  return   graphStructureChangedListenersWithAutoRemoval != null ?  graphStructureChangedListenersWithAutoRemoval . iterator  ( ) : null ; }   private  Iterator  < GraphStructureChangedListener > getListenerListIterator  ( )  {  return   graphStructureChangedListeners != null ?  graphStructureChangedListeners . iterator  ( ) : null ; }   public void notifyVertexDeleted  (  Vertex v )  {  assert    (  v != null ) &&  v . isValid  ( ) &&  containsVertex  ( v ) ;  if  (  graphStructureChangedListenersWithAutoRemoval != null )  {   Iterator  <  WeakReference  < GraphStructureChangedListener > >  iterator =  getListenerListIteratorForAutoRemove  ( ) ;  while  (  iterator . hasNext  ( ) )  {  GraphStructureChangedListener  currentListener =   iterator . next  ( ) . get  ( ) ;  if  (  currentListener == null )  {   iterator . remove  ( ) ; } else  {   currentListener . vertexDeleted  ( v ) ; } }   setAutoListenerListToNullIfEmpty  ( ) ; }   int  n =  graphStructureChangedListeners . size  ( ) ;  for (   int  i = 0 ;  i < n ;  i ++ )  {    graphStructureChangedListeners . get  ( i ) . vertexDeleted  ( v ) ; } }   public void notifyVertexAdded  (  Vertex v )  {  assert    (  v != null ) &&  v . isValid  ( ) &&  containsVertex  ( v ) ;  if  (  graphStructureChangedListenersWithAutoRemoval != null )  {   Iterator  <  WeakReference  < GraphStructureChangedListener > >  iterator =  getListenerListIteratorForAutoRemove  ( ) ;  while  (  iterator . hasNext  ( ) )  {  GraphStructureChangedListener  currentListener =   iterator . next  ( ) . get  ( ) ;  if  (  currentListener == null )  {   iterator . remove  ( ) ; } else  {   currentListener . vertexAdded  ( v ) ; } }   setAutoListenerListToNullIfEmpty  ( ) ; }   int  n =  graphStructureChangedListeners . size  ( ) ;  for (   int  i = 0 ;  i < n ;  i ++ )  {    graphStructureChangedListeners . get  ( i ) . vertexAdded  ( v ) ; } }   public void notifyEdgeDeleted  (  Edge e )  {  assert     (  e != null ) &&  e . isValid  ( ) &&  e . isNormal  ( ) &&  containsEdge  ( e ) ;  if  (  graphStructureChangedListenersWithAutoRemoval != null )  {   Iterator  <  WeakReference  < GraphStructureChangedListener > >  iterator =  getListenerListIteratorForAutoRemove  ( ) ;  while  (  iterator . hasNext  ( ) )  {  GraphStructureChangedListener  currentListener =   iterator . next  ( ) . get  ( ) ;  if  (  currentListener == null )  {   iterator . remove  ( ) ; } else  {   currentListener . edgeDeleted  ( e ) ; } }   setAutoListenerListToNullIfEmpty  ( ) ; }   int  n =  graphStructureChangedListeners . size  ( ) ;  for (   int  i = 0 ;  i < n ;  i ++ )  {    graphStructureChangedListeners . get  ( i ) . edgeDeleted  ( e ) ; } }   public void notifyEdgeAdded  (  Edge e )  {  assert     (  e != null ) &&  e . isValid  ( ) &&  e . isNormal  ( ) &&  containsEdge  ( e ) ;  if  (  graphStructureChangedListenersWithAutoRemoval != null )  {   Iterator  <  WeakReference  < GraphStructureChangedListener > >  iterator =  getListenerListIteratorForAutoRemove  ( ) ;  while  (  iterator . hasNext  ( ) )  {  GraphStructureChangedListener  currentListener =   iterator . next  ( ) . get  ( ) ;  if  (  currentListener == null )  {   iterator . remove  ( ) ; } else  {   currentListener . edgeAdded  ( e ) ; } }   setAutoListenerListToNullIfEmpty  ( ) ; }   int  n =  graphStructureChangedListeners . size  ( ) ;  for (   int  i = 0 ;  i < n ;  i ++ )  {    graphStructureChangedListeners . get  ( i ) . edgeAdded  ( e ) ; } }   public void notifyMaxVertexCountIncreased  (   int newValue )  {  if  (  graphStructureChangedListenersWithAutoRemoval != null )  {   Iterator  <  WeakReference  < GraphStructureChangedListener > >  iterator =  getListenerListIteratorForAutoRemove  ( ) ;  while  (  iterator . hasNext  ( ) )  {  GraphStructureChangedListener  currentListener =   iterator . next  ( ) . get  ( ) ;  if  (  currentListener == null )  {   iterator . remove  ( ) ; } else  {   currentListener . maxVertexCountIncreased  ( newValue ) ; } }   setAutoListenerListToNullIfEmpty  ( ) ; }   int  n =  graphStructureChangedListeners . size  ( ) ;  for (   int  i = 0 ;  i < n ;  i ++ )  {    graphStructureChangedListeners . get  ( i ) . maxVertexCountIncreased  ( newValue ) ; } }   public void notifyMaxEdgeCountIncreased  (   int newValue )  {  if  (  graphStructureChangedListenersWithAutoRemoval != null )  {   Iterator  <  WeakReference  < GraphStructureChangedListener > >  iterator =  getListenerListIteratorForAutoRemove  ( ) ;  while  (  iterator . hasNext  ( ) )  {  GraphStructureChangedListener  currentListener =   iterator . next  ( ) . get  ( ) ;  if  (  currentListener == null )  {   iterator . remove  ( ) ; } else  {   currentListener . maxEdgeCountIncreased  ( newValue ) ; } }   setAutoListenerListToNullIfEmpty  ( ) ; }   int  n =  graphStructureChangedListeners . size  ( ) ;  for (   int  i = 0 ;  i < n ;  i ++ )  {    graphStructureChangedListeners . get  ( i ) . maxEdgeCountIncreased  ( newValue ) ; } }   protected boolean canAddGraphElement  (   int graphElementId )  {  return  graphElementId == 0 ; }   public void internalEdgeAdded  (  EdgeBase e )  {   notifyEdgeAdded  ( e ) ;    getECARuleManager  ( ) . fireAfterCreateEdgeEvents  ( e ) ; }   public void internalVertexAdded  (  VertexBase v )  {   notifyVertexAdded  ( v ) ;    getECARuleManager  ( ) . fireAfterCreateVertexEvents  ( v ) ; }   public void appendEdgeToESeq  (  EdgeBase e )  {     getEdge  ( ) [   (  ( EdgeBaseImpl ) e ) . id ] = e ;     getRevEdge  ( ) [   (  ( EdgeBaseImpl ) e ) . id ] =   (  ( EdgeBaseImpl ) e ) . reversedEdge ;   setECount  (   getBaseECount  ( ) + 1 ) ;  if  (   getFirstBaseEdge  ( ) == null )  {   setFirstEdgeInGraph  ( e ) ; }  if  (   getLastBaseEdge  ( ) != null )  {    (  getLastBaseEdge  ( ) ) . setNextEdgeInGraph  ( e ) ;   e . setPrevEdgeInGraph  (  getLastBaseEdge  ( ) ) ; }   setLastEdgeInGraph  ( e ) ; }   public void appendVertexToVSeq  (  VertexBase v )  {     getVertex  ( ) [   (  ( VertexBaseImpl ) v ) . id ] = v ;   setVCount  (   getBaseVCount  ( ) + 1 ) ;  if  (   getFirstBaseVertex  ( ) == null )  {   setFirstVertex  ( v ) ; }  if  (   getLastBaseVertex  ( ) != null )  {    (  getLastBaseVertex  ( ) ) . setNextVertex  ( v ) ;   v . setPrevVertex  (  getLastBaseVertex  ( ) ) ; }   setLastVertex  ( v ) ; }   public void internalEdgeDeleted  (  EdgeBase e )  {  assert  e != null ;   notifyEdgeDeleted  ( e ) ; }   public void internalVertexDeleted  (  VertexBase v )  {  assert  v != null ;   notifyVertexDeleted  ( v ) ; }   public void removeVertexFromVSeq  (  VertexBase v )  {  assert  v != null ;  if  (  v ==  getFirstBaseVertex  ( ) )  {   setFirstVertex  (  v . getNextBaseVertex  ( ) ) ;  if  (   getFirstBaseVertex  ( ) != null )  {    (  getFirstBaseVertex  ( ) ) . setPrevVertex  ( null ) ; }  if  (  v ==  getLastBaseVertex  ( ) )  {   setLastVertex  ( null ) ; } } else  if  (  v ==  getLastBaseVertex  ( ) )  {   setLastVertex  (  v . getPrevBaseVertex  ( ) ) ;  if  (   getLastBaseVertex  ( ) != null )  {    (  getLastBaseVertex  ( ) ) . setNextVertex  ( null ) ; } } else  {    (  v . getPrevBaseVertex  ( ) ) . setNextVertex  (  v . getNextBaseVertex  ( ) ) ;    (  v . getNextBaseVertex  ( ) ) . setPrevVertex  (  v . getPrevBaseVertex  ( ) ) ; }   freeVertexIndex  (  v . getId  ( ) ) ;     getVertex  ( ) [  v . getId  ( ) ] = null ;   v . setPrevVertex  ( null ) ;   v . setNextVertex  ( null ) ;   v . setId  ( 0 ) ;   setVCount  (   getBaseVCount  ( ) - 1 ) ; }   public void removeEdgeFromESeq  (  EdgeBase e )  {  assert  e != null ;   removeEdgeFromESeqWithoutDeletingIt  ( e ) ;   freeEdgeIndex  (  e . getId  ( ) ) ;     getEdge  ( ) [  e . getId  ( ) ] = null ;     getRevEdge  ( ) [  e . getId  ( ) ] = null ;   e . setPrevEdgeInGraph  ( null ) ;   e . setNextEdgeInGraph  ( null ) ;   e . setId  ( 0 ) ;   setECount  (   getBaseECount  ( ) - 1 ) ; }   private void removeEdgeFromESeqWithoutDeletingIt  (  EdgeBase e )  {  if  (  e ==  getFirstBaseEdge  ( ) )  {   setFirstEdgeInGraph  (  e . getNextBaseEdge  ( ) ) ;  if  (   getFirstBaseEdge  ( ) != null )  {    (  getFirstBaseEdge  ( ) ) . setPrevEdgeInGraph  ( null ) ; }  if  (  e ==  getLastBaseEdge  ( ) )  {   setLastEdgeInGraph  ( null ) ; } } else  if  (  e ==  getLastBaseEdge  ( ) )  {   setLastEdgeInGraph  (  e . getPrevBaseEdge  ( ) ) ;  if  (   getLastBaseEdge  ( ) != null )  {    (  getLastBaseEdge  ( ) ) . setNextEdgeInGraph  ( null ) ; } } else  {    (  e . getPrevBaseEdge  ( ) ) . setNextEdgeInGraph  (  e . getNextBaseEdge  ( ) ) ;    (  e . getNextBaseEdge  ( ) ) . setPrevEdgeInGraph  (  e . getPrevBaseEdge  ( ) ) ; } }   public void putEdgeAfterInGraph  (  EdgeBase targetEdge ,  EdgeBase movedEdge )  {  assert    (  targetEdge != null ) &&  targetEdge . isValid  ( ) &&  containsEdge  ( targetEdge ) ;  assert    (  movedEdge != null ) &&  movedEdge . isValid  ( ) &&  containsEdge  ( movedEdge ) ;  assert  targetEdge != movedEdge ;  if  (   (  targetEdge == movedEdge ) ||  (   targetEdge . getNextBaseEdge  ( ) == movedEdge ) )  {  return ; }  assert   getFirstBaseEdge  ( ) !=  getLastBaseEdge  ( ) ;  if  (  movedEdge ==  getFirstBaseEdge  ( ) )  {   setFirstEdgeInGraph  (  movedEdge . getNextBaseEdge  ( ) ) ;    (  movedEdge . getNextBaseEdge  ( ) ) . setPrevEdgeInGraph  ( null ) ; } else  if  (  movedEdge ==  getLastBaseEdge  ( ) )  {   setLastEdgeInGraph  (  movedEdge . getPrevBaseEdge  ( ) ) ;    (  movedEdge . getPrevBaseEdge  ( ) ) . setNextEdgeInGraph  ( null ) ; } else  {    (  movedEdge . getPrevBaseEdge  ( ) ) . setNextEdgeInGraph  (  movedEdge . getNextBaseEdge  ( ) ) ;    (  movedEdge . getNextBaseEdge  ( ) ) . setPrevEdgeInGraph  (  movedEdge . getPrevBaseEdge  ( ) ) ; }  if  (  targetEdge ==  getLastBaseEdge  ( ) )  {   setLastEdgeInGraph  ( movedEdge ) ;   movedEdge . setNextEdgeInGraph  ( null ) ; } else  {    (  targetEdge . getNextBaseEdge  ( ) ) . setPrevEdgeInGraph  ( movedEdge ) ;   movedEdge . setNextEdgeInGraph  (  targetEdge . getNextBaseEdge  ( ) ) ; }   movedEdge . setPrevEdgeInGraph  ( targetEdge ) ;   targetEdge . setNextEdgeInGraph  ( movedEdge ) ;   edgeListModified  ( ) ; }   public void putVertexAfter  (  VertexBase targetVertex ,  VertexBase movedVertex )  {  assert    (  targetVertex != null ) &&  targetVertex . isValid  ( ) &&  containsVertex  ( targetVertex ) ;  assert    (  movedVertex != null ) &&  movedVertex . isValid  ( ) &&  containsVertex  ( movedVertex ) ;  assert  targetVertex != movedVertex ;  Vertex  nextVertex =  targetVertex . getNextBaseVertex  ( ) ;  if  (   (  targetVertex == movedVertex ) ||  (  nextVertex == movedVertex ) )  {  return ; }  assert   getFirstBaseVertex  ( ) !=  getLastBaseVertex  ( ) ;  if  (  movedVertex ==  getFirstBaseVertex  ( ) )  {  VertexBase  newFirstVertex =  movedVertex . getNextBaseVertex  ( ) ;   setFirstVertex  ( newFirstVertex ) ;   newFirstVertex . setPrevVertex  ( null ) ; } else  if  (  movedVertex ==  getLastBaseVertex  ( ) )  {   setLastVertex  (  movedVertex . getPrevBaseVertex  ( ) ) ;    (  movedVertex . getPrevBaseVertex  ( ) ) . setNextVertex  ( null ) ; } else  {    (  movedVertex . getPrevBaseVertex  ( ) ) . setNextVertex  (  movedVertex . getNextBaseVertex  ( ) ) ;    (  movedVertex . getNextBaseVertex  ( ) ) . setPrevVertex  (  movedVertex . getPrevBaseVertex  ( ) ) ; }  if  (  targetVertex ==  getLastBaseVertex  ( ) )  {   setLastVertex  ( movedVertex ) ;   movedVertex . setNextVertex  ( null ) ; } else  {    (  targetVertex . getNextBaseVertex  ( ) ) . setPrevVertex  ( movedVertex ) ;   movedVertex . setNextVertex  (  targetVertex . getNextBaseVertex  ( ) ) ; }   movedVertex . setPrevVertex  ( targetVertex ) ;   targetVertex . setNextVertex  ( movedVertex ) ;   vertexListModified  ( ) ; }   public void putEdgeBeforeInGraph  (  EdgeBase targetEdge ,  EdgeBase movedEdge )  {  assert    (  targetEdge != null ) &&  targetEdge . isValid  ( ) &&  containsEdge  ( targetEdge ) ;  assert    (  movedEdge != null ) &&  movedEdge . isValid  ( ) &&  containsEdge  ( movedEdge ) ;  assert  targetEdge != movedEdge ;  if  (   (  targetEdge == movedEdge ) ||  (   targetEdge . getPrevBaseEdge  ( ) == movedEdge ) )  {  return ; }  assert   getFirstBaseEdge  ( ) !=  getLastBaseEdge  ( ) ;   removeEdgeFromESeqWithoutDeletingIt  ( movedEdge ) ;  if  (  targetEdge ==  getFirstBaseEdge  ( ) )  {   setFirstEdgeInGraph  ( movedEdge ) ;   movedEdge . setPrevEdgeInGraph  ( null ) ; } else  {  EdgeBase  previousEdge =  (  targetEdge . getPrevBaseEdge  ( ) ) ;   previousEdge . setNextEdgeInGraph  ( movedEdge ) ;   movedEdge . setPrevEdgeInGraph  ( previousEdge ) ; }   movedEdge . setNextEdgeInGraph  ( targetEdge ) ;   targetEdge . setPrevEdgeInGraph  ( movedEdge ) ;   edgeListModified  ( ) ; }   public void putVertexBefore  (  VertexBase targetVertex ,  VertexBase movedVertex )  {  assert    (  targetVertex != null ) &&  targetVertex . isValid  ( ) &&  containsVertex  ( targetVertex ) ;  assert    (  movedVertex != null ) &&  movedVertex . isValid  ( ) &&  containsVertex  ( movedVertex ) ;  assert  targetVertex != movedVertex ;  Vertex  prevVertex =  targetVertex . getPrevBaseVertex  ( ) ;  if  (   (  targetVertex == movedVertex ) ||  (  prevVertex == movedVertex ) )  {  return ; }  assert   getFirstBaseVertex  ( ) !=  getLastBaseVertex  ( ) ;  if  (  movedVertex ==  getFirstBaseVertex  ( ) )  {   setFirstVertex  (  movedVertex . getNextBaseVertex  ( ) ) ;    (  movedVertex . getNextBaseVertex  ( ) ) . setPrevVertex  ( null ) ; } else  if  (  movedVertex ==  getLastBaseVertex  ( ) )  {   setLastVertex  (  movedVertex . getPrevBaseVertex  ( ) ) ;    (  movedVertex . getPrevBaseVertex  ( ) ) . setNextVertex  ( null ) ; } else  {    (  movedVertex . getPrevBaseVertex  ( ) ) . setNextVertex  (  movedVertex . getNextBaseVertex  ( ) ) ;    (  movedVertex . getNextBaseVertex  ( ) ) . setPrevVertex  (  movedVertex . getPrevBaseVertex  ( ) ) ; }  if  (  targetVertex ==  getFirstBaseVertex  ( ) )  {   setFirstVertex  ( movedVertex ) ;   movedVertex . setPrevVertex  ( null ) ; } else  {  VertexBase  previousVertex =  targetVertex . getPrevBaseVertex  ( ) ;   previousVertex . setNextVertex  ( movedVertex ) ;   movedVertex . setPrevVertex  ( previousVertex ) ; }   movedVertex . setNextVertex  ( targetVertex ) ;   targetVertex . setPrevVertex  ( movedVertex ) ;   vertexListModified  ( ) ; } }