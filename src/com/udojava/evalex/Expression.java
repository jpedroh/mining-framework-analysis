  package   com . udojava . evalex ;   import   java . math . BigDecimal ;  import   java . math . BigInteger ;  import   java . math . MathContext ;  import   java . math . RoundingMode ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . Iterator ;  import   java . util . List ;  import   java . util . Locale ;  import   java . util . Map ;  import   java . util . Set ;  import   java . util . Stack ;  import   java . util . TreeMap ;   public class Expression  {   public static final BigDecimal  PI =  new BigDecimal  ( "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679" ) ;   public static final BigDecimal  e =  new BigDecimal  ( "2.71828182845904523536028747135266249775724709369995957496696762772407663" ) ;   private MathContext  mc = null ;   private String  firstVarChars = "_" ;   private String  varChars = "_" ;   private final String  originalExpression ;   private String  expression = null ;   private  List  < Token >  rpn = null ;   private  Map  < String , Operator >  operators =  new  TreeMap  < String , Operator >  (  String . CASE_INSENSITIVE_ORDER ) ;   private  Map  < String , LazyFunction >  functions =  new  TreeMap  < String , LazyFunction >  (  String . CASE_INSENSITIVE_ORDER ) ;   private  Map  < String , BigDecimal >  variables =  new  TreeMap  < String , BigDecimal >  (  String . CASE_INSENSITIVE_ORDER ) ;   private static final  char  decimalSeparator = '.' ;   private static final  char  minusSign = '-' ;   private static final LazyNumber  PARAMS_START =  new LazyNumber  ( )  {   public BigDecimal eval  ( )  {  return null ; }   public String getString  ( )  {  return null ; } } ;   public static class ExpressionException  extends RuntimeException  {   private static final  long  serialVersionUID = 1118142866870779047L ;   public ExpressionException  (  String message )  {  super  ( message ) ; } }  interface LazyNumber  {  BigDecimal eval  ( ) ;  String getString  ( ) ; }   public abstract class LazyFunction  {   private String  name ;   private  int  numParams ;   public LazyFunction  (  String name ,   int numParams )  {    this . name =  name . toUpperCase  (  Locale . ROOT ) ;    this . numParams = numParams ; }   public String getName  ( )  {  return name ; }   public  int getNumParams  ( )  {  return numParams ; }   public boolean numParamsVaries  ( )  {  return  numParams < 0 ; }   public abstract LazyNumber lazyEval  (   List  < LazyNumber > lazyParams ) ; }   public abstract class Function  extends LazyFunction  {   public Function  (  String name ,   int numParams )  {  super  ( name , numParams ) ; }   public LazyNumber lazyEval  (   List  < LazyNumber > lazyParams )  {   final  List  < BigDecimal >  params =  new  ArrayList  < BigDecimal >  ( ) ;  for ( LazyNumber lazyParam : lazyParams )  {   params . add  (  lazyParam . eval  ( ) ) ; }  return  new LazyNumber  ( )  {   public BigDecimal eval  ( )  {  return   Function . this . eval  ( params ) ; }   public String getString  ( )  {  return  String . valueOf  (   Function . this . eval  ( params ) ) ; } } ; }   public abstract BigDecimal eval  (   List  < BigDecimal > parameters ) ; }   public abstract class Operator  {   private String  oper ;   private  int  precedence ;   private boolean  leftAssoc ;   public Operator  (  String oper ,   int precedence ,  boolean leftAssoc )  {    this . oper = oper ;    this . precedence = precedence ;    this . leftAssoc = leftAssoc ; }   public String getOper  ( )  {  return oper ; }   public  int getPrecedence  ( )  {  return precedence ; }   public boolean isLeftAssoc  ( )  {  return leftAssoc ; }   public abstract BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 ) ; }   private class Tokenizer  implements   Iterator  < Token >  {   private  int  pos = 0 ;   private String  input ;   private Token  previousToken ;   public Tokenizer  (  String input )  {    this . input =  input . trim  ( ) ; }    @ Override public boolean hasNext  ( )  {  return  (  pos <  input . length  ( ) ) ; }   private  char peekNextChar  ( )  {  if  (  pos <  (   input . length  ( ) - 1 ) )  {  return  input . charAt  (  pos + 1 ) ; } else  {  return 0 ; } }    @ Override public Token next  ( )  {  Token  token =  new Token  ( ) ;  if  (  pos >=  input . length  ( ) )  {  return  previousToken = null ; }   char  ch =  input . charAt  ( pos ) ;  while  (   Character . isWhitespace  ( ch ) &&  pos <  input . length  ( ) )  {   ch =  input . charAt  (  ++ pos ) ; }    token . pos = pos ;  if  (  Character . isDigit  ( ch ) )  {  while  (   (       Character . isDigit  ( ch ) ||  ch == decimalSeparator ||  ch == 'e' ||  ch == 'E' ||  (    ch == minusSign &&   token . length  ( ) > 0 &&  (   'e' ==  token . charAt  (   token . length  ( ) - 1 ) ||  'E' ==  token . charAt  (   token . length  ( ) - 1 ) ) ) ||  (    ch == '+' &&   token . length  ( ) > 0 &&  (   'e' ==  token . charAt  (   token . length  ( ) - 1 ) ||  'E' ==  token . charAt  (   token . length  ( ) - 1 ) ) ) ) &&  (  pos <  input . length  ( ) ) )  {   token . append  (  input . charAt  (  pos ++ ) ) ;   ch =   pos ==  input . length  ( ) ? 0 :  input . charAt  ( pos ) ; }    token . type =  TokenType . LITERAL ; } else  if  (    ch == minusSign &&  Character . isDigit  (  peekNextChar  ( ) ) &&  (     previousToken == null ||   previousToken . type ==  TokenType . OPEN_PAREN ||   previousToken . type ==  TokenType . COMMA ||   previousToken . type ==  TokenType . OPERATOR ) )  {   token . append  ( minusSign ) ;   pos ++ ;   token . append  (   next  ( ) . toString  ( ) ) ;    token . type =  TokenType . LITERAL ; } else  if  (   Character . isLetter  ( ch ) ||   firstVarChars . indexOf  ( ch ) >= 0 )  {  while  (   (     Character . isLetter  ( ch ) ||  Character . isDigit  ( ch ) ||   varChars . indexOf  ( ch ) >= 0 ||    token . length  ( ) == 0 &&   firstVarChars . indexOf  ( ch ) >= 0 ) &&  (  pos <  input . length  ( ) ) )  {   token . append  (  input . charAt  (  pos ++ ) ) ;   ch =   pos ==  input . length  ( ) ? 0 :  input . charAt  ( pos ) ; }    token . type =   ch == '(' ?  TokenType . FUNCTION :  TokenType . VARIABLE ; } else  if  (    ch == '(' ||  ch == ')' ||  ch == ',' )  {  if  (  ch == '(' )  {    token . type =  TokenType . OPEN_PAREN ; } else  if  (  ch == ')' )  {    token . type =  TokenType . CLOSE_PAREN ; } else  {    token . type =  TokenType . COMMA ; }   token . append  ( ch ) ;   pos ++ ; } else  {  while  (         !  Character . isLetter  ( ch ) &&  !  Character . isDigit  ( ch ) &&   firstVarChars . indexOf  ( ch ) < 0 &&  !  Character . isWhitespace  ( ch ) &&  ch != '(' &&  ch != ')' &&  ch != ',' &&  (  pos <  input . length  ( ) ) )  {   token . append  (  input . charAt  ( pos ) ) ;   pos ++ ;   ch =   pos ==  input . length  ( ) ? 0 :  input . charAt  ( pos ) ;  if  (  ch == minusSign )  {  break ; } }    token . type =  TokenType . OPERATOR ; }  return  previousToken = token ; }    @ Override public void remove  ( )  {  throw  new ExpressionException  ( "remove() not supported" ) ; } }   public Expression  (  String expression )  {  this  ( expression ,  MathContext . DECIMAL32 ) ; }   public Expression  (  String expression ,  MathContext defaultMathContext )  {    this . mc = defaultMathContext ;    this . expression = expression ;    this . originalExpression = expression ;   addOperator  (  new Operator  ( "+" , 20 , true )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return  v1 . add  ( v2 , mc ) ; } } ) ;   addOperator  (  new Operator  ( "-" , 20 , true )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return  v1 . subtract  ( v2 , mc ) ; } } ) ;   addOperator  (  new Operator  ( "*" , 30 , true )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return  v1 . multiply  ( v2 , mc ) ; } } ) ;   addOperator  (  new Operator  ( "/" , 30 , true )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return  v1 . divide  ( v2 , mc ) ; } } ) ;   addOperator  (  new Operator  ( "%" , 30 , true )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return  v1 . remainder  ( v2 , mc ) ; } } ) ;   addOperator  (  new Operator  ( "^" , 40 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {   int  signOf2 =  v2 . signum  ( ) ;   double  dn1 =  v1 . doubleValue  ( ) ;   v2 =  v2 . multiply  (  new BigDecimal  ( signOf2 ) ) ;  BigDecimal  remainderOf2 =  v2 . remainder  (  BigDecimal . ONE ) ;  BigDecimal  n2IntPart =  v2 . subtract  ( remainderOf2 ) ;  BigDecimal  intPow =  v1 . pow  (  n2IntPart . intValueExact  ( ) , mc ) ;  BigDecimal  doublePow =  new BigDecimal  (  Math . pow  ( dn1 ,  remainderOf2 . doubleValue  ( ) ) ) ;  BigDecimal  result =  intPow . multiply  ( doublePow , mc ) ;  if  (  signOf2 ==  - 1 )  {   result =   BigDecimal . ONE . divide  ( result ,  mc . getPrecision  ( ) ,  RoundingMode . HALF_UP ) ; }  return result ; } } ) ;   addOperator  (  new Operator  ( "&&" , 4 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  boolean  b1 =  !  v1 . equals  (  BigDecimal . ZERO ) ;  boolean  b2 =  !  v2 . equals  (  BigDecimal . ZERO ) ;  return   b1 && b2 ?  BigDecimal . ONE :  BigDecimal . ZERO ; } } ) ;   addOperator  (  new Operator  ( "||" , 2 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  boolean  b1 =  !  v1 . equals  (  BigDecimal . ZERO ) ;  boolean  b2 =  !  v2 . equals  (  BigDecimal . ZERO ) ;  return   b1 || b2 ?  BigDecimal . ONE :  BigDecimal . ZERO ; } } ) ;   addOperator  (  new Operator  ( ">" , 10 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return    v1 . compareTo  ( v2 ) == 1 ?  BigDecimal . ONE :  BigDecimal . ZERO ; } } ) ;   addOperator  (  new Operator  ( ">=" , 10 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return    v1 . compareTo  ( v2 ) >= 0 ?  BigDecimal . ONE :  BigDecimal . ZERO ; } } ) ;   addOperator  (  new Operator  ( "<" , 10 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return    v1 . compareTo  ( v2 ) ==  - 1 ?  BigDecimal . ONE :  BigDecimal . ZERO ; } } ) ;   addOperator  (  new Operator  ( "<=" , 10 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return    v1 . compareTo  ( v2 ) <= 0 ?  BigDecimal . ONE :  BigDecimal . ZERO ; } } ) ;   addOperator  (  new Operator  ( "=" , 7 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return    v1 . compareTo  ( v2 ) == 0 ?  BigDecimal . ONE :  BigDecimal . ZERO ; } } ) ;   addOperator  (  new Operator  ( "==" , 7 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return   operators . get  ( "=" ) . eval  ( v1 , v2 ) ; } } ) ;   addOperator  (  new Operator  ( "!=" , 7 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return    v1 . compareTo  ( v2 ) != 0 ?  BigDecimal . ONE :  BigDecimal . ZERO ; } } ) ;   addOperator  (  new Operator  ( "<>" , 7 , false )  {    @ Override public BigDecimal eval  (  BigDecimal v1 ,  BigDecimal v2 )  {  return   operators . get  ( "!=" ) . eval  ( v1 , v2 ) ; } } ) ;   addFunction  (  new Function  ( "NOT" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {  boolean  zero =    parameters . get  ( 0 ) . compareTo  (  BigDecimal . ZERO ) == 0 ;  return  zero ?  BigDecimal . ONE :  BigDecimal . ZERO ; } } ) ;   addLazyFunction  (  new LazyFunction  ( "IF" , 3 )  {    @ Override public LazyNumber lazyEval  (   List  < LazyNumber > lazyParams )  {  boolean  isTrue =  !    lazyParams . get  ( 0 ) . eval  ( ) . equals  (  BigDecimal . ZERO ) ;  return  isTrue ?  lazyParams . get  ( 1 ) :  lazyParams . get  ( 2 ) ; } } ) ;   addFunction  (  new Function  ( "RANDOM" , 0 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . random  ( ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "SIN" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . sin  (  Math . toRadians  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "COS" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . cos  (  Math . toRadians  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "TAN" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . tan  (  Math . toRadians  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "ASIN" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . toDegrees  (  Math . asin  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "ACOS" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . toDegrees  (  Math . acos  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "ATAN" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . toDegrees  (  Math . atan  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "SINH" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . sinh  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "COSH" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . cosh  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "TANH" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . tanh  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "RAD" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . toRadians  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "DEG" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . toDegrees  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "MAX" ,  - 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {  if  (   parameters . size  ( ) == 0 )  {  throw  new ExpressionException  ( "MAX requires at least one parameter" ) ; }  BigDecimal  max = null ;  for ( BigDecimal parameter : parameters )  {  if  (   max == null ||   parameter . compareTo  ( max ) > 0 )  {   max = parameter ; } }  return max ; } } ) ;   addFunction  (  new Function  ( "MIN" ,  - 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {  if  (   parameters . size  ( ) == 0 )  {  throw  new ExpressionException  ( "MIN requires at least one parameter" ) ; }  BigDecimal  min = null ;  for ( BigDecimal parameter : parameters )  {  if  (   min == null ||   parameter . compareTo  ( min ) < 0 )  {   min = parameter ; } }  return min ; } } ) ;   addFunction  (  new Function  ( "ABS" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {  return   parameters . get  ( 0 ) . abs  ( mc ) ; } } ) ;   addFunction  (  new Function  ( "LOG" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . log  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "LOG10" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {   double  d =  Math . log10  (   parameters . get  ( 0 ) . doubleValue  ( ) ) ;  return  new BigDecimal  ( d , mc ) ; } } ) ;   addFunction  (  new Function  ( "ROUND" , 2 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {  BigDecimal  toRound =  parameters . get  ( 0 ) ;   int  precision =   parameters . get  ( 1 ) . intValue  ( ) ;  return  toRound . setScale  ( precision ,  mc . getRoundingMode  ( ) ) ; } } ) ;   addFunction  (  new Function  ( "FLOOR" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {  BigDecimal  toRound =  parameters . get  ( 0 ) ;  return  toRound . setScale  ( 0 ,  RoundingMode . FLOOR ) ; } } ) ;   addFunction  (  new Function  ( "CEILING" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {  BigDecimal  toRound =  parameters . get  ( 0 ) ;  return  toRound . setScale  ( 0 ,  RoundingMode . CEILING ) ; } } ) ;   addFunction  (  new Function  ( "SQRT" , 1 )  {    @ Override public BigDecimal eval  (   List  < BigDecimal > parameters )  {  BigDecimal  x =  parameters . get  ( 0 ) ;  if  (   x . compareTo  (  BigDecimal . ZERO ) == 0 )  {  return  new BigDecimal  ( 0 ) ; }  if  (   x . signum  ( ) < 0 )  {  throw  new ExpressionException  ( "Argument to SQRT() function must not be negative" ) ; }  BigInteger  n =   x . movePointRight  (   mc . getPrecision  ( ) << 1 ) . toBigInteger  ( ) ;   int  bits =   (   n . bitLength  ( ) + 1 ) >> 1 ;  BigInteger  ix =  n . shiftRight  ( bits ) ;  BigInteger  ixPrev ;  do  {   ixPrev = ix ;   ix =   ix . add  (  n . divide  ( ix ) ) . shiftRight  ( 1 ) ;   Thread . yield  ( ) ; } while  (   ix . compareTo  ( ixPrev ) != 0 ) ;  return  new BigDecimal  ( ix ,  mc . getPrecision  ( ) ) ; } } ) ;   variables . put  ( "e" , e ) ;   variables . put  ( "PI" , PI ) ;   variables . put  ( "TRUE" ,  BigDecimal . ONE ) ;   variables . put  ( "FALSE" ,  BigDecimal . ZERO ) ; }   private boolean isNumber  (  String st )  {  if  (    st . charAt  ( 0 ) == minusSign &&   st . length  ( ) == 1 )  return false ;  if  (    st . charAt  ( 0 ) == '+' &&   st . length  ( ) == 1 )  return false ;  if  (    st . charAt  ( 0 ) == 'e' ||   st . charAt  ( 0 ) == 'E' )  return false ;  for (  char ch :  st . toCharArray  ( ) )  {  if  (       !  Character . isDigit  ( ch ) &&  ch != minusSign &&  ch != decimalSeparator &&  ch != 'e' &&  ch != 'E' &&  ch != '+' )  return false ; }  return true ; }   private  List  < Token > shuntingYard  (  String expression )  {   List  < Token >  outputQueue =  new  ArrayList  < Token >  ( ) ;   Stack  < Token >  stack =  new  Stack  < Token >  ( ) ;  Tokenizer  tokenizer =  new Tokenizer  ( expression ) ;  Token  lastFunction = null ;  Token  previousToken = null ;  while  (  tokenizer . hasNext  ( ) )  {  Token  token =  tokenizer . next  ( ) ;  switch  (  token . type )  {   case LITERAL :   outputQueue . add  ( token ) ;  break ;   case VARIABLE :   outputQueue . add  ( token ) ;  break ;   case FUNCTION :   stack . push  ( token ) ;   lastFunction = token ;  break ;   case COMMA :  if  (   previousToken != null &&   previousToken . type ==  TokenType . OPERATOR )  {  throw  new ExpressionException  (    "Missing parameter(s) for operator " + previousToken + " at character position " +  previousToken . pos ) ; }  while  (   !  stack . isEmpty  ( ) &&    stack . peek  ( ) . type !=  TokenType . OPEN_PAREN )  {   outputQueue . add  (  stack . pop  ( ) ) ; }  if  (  stack . isEmpty  ( ) )  {  throw  new ExpressionException  (   "Parse error for function '" + lastFunction + "'" ) ; }  break ;   case OPERATOR :  if  (   previousToken != null &&  (    previousToken . type ==  TokenType . COMMA ||   previousToken . type ==  TokenType . OPEN_PAREN ) )  {  throw  new ExpressionException  (    "Missing parameter(s) for operator " + token + " at character position " +  token . pos ) ; }  Operator  o1 =  operators . get  (  token . surface ) ;  if  (  o1 == null )  {  throw  new ExpressionException  (    "Unknown operator '" + token + "' at position " +  (   token . pos + 1 ) ) ; }  String  token2 =   stack . isEmpty  ( ) ? null :   stack . peek  ( ) . toString  ( ) ;  while  (    token2 != null &&  operators . containsKey  ( token2 ) &&  (   (   o1 . isLeftAssoc  ( ) &&   o1 . getPrecedence  ( ) <=   operators . get  ( token2 ) . getPrecedence  ( ) ) ||  (   o1 . getPrecedence  ( ) <   operators . get  ( token2 ) . getPrecedence  ( ) ) ) )  {   outputQueue . add  (  stack . pop  ( ) ) ;   token2 =   stack . isEmpty  ( ) ? null :   stack . peek  ( ) . toString  ( ) ; }   stack . push  ( token ) ;  break ;   case OPEN_PAREN :  if  (  previousToken != null )  {  if  (   previousToken . type ==  TokenType . LITERAL )  {  throw  new ExpressionException  (  "Missing operator at character position " +  (   token . pos + 1 ) ) ; }  if  (   previousToken . type ==  TokenType . FUNCTION )  {   outputQueue . add  ( token ) ; } }   stack . push  ( token ) ;  break ;   case CLOSE_PAREN :  if  (   previousToken != null &&   previousToken . type ==  TokenType . OPERATOR )  {  throw  new ExpressionException  (    "Missing parameter(s) for operator " + previousToken + " at character position " +  previousToken . pos ) ; }  while  (   !  stack . isEmpty  ( ) &&    stack . peek  ( ) . type !=  TokenType . OPEN_PAREN )  {   outputQueue . add  (  stack . pop  ( ) ) ; }  if  (  stack . isEmpty  ( ) )  {  throw  new ExpressionException  ( "Mismatched parentheses" ) ; }   stack . pop  ( ) ;  if  (   !  stack . isEmpty  ( ) &&    stack . peek  ( ) . type ==  TokenType . FUNCTION )  {   outputQueue . add  (  stack . pop  ( ) ) ; } }   previousToken = token ; }  while  (  !  stack . isEmpty  ( ) )  {  Token  element =  stack . pop  ( ) ;  if  (    element . type ==  TokenType . OPEN_PAREN ||   element . type ==  TokenType . CLOSE_PAREN )  {  throw  new ExpressionException  ( "Mismatched parentheses" ) ; }   outputQueue . add  ( element ) ; }  return outputQueue ; }   public BigDecimal eval  ( )  {   Stack  < LazyNumber >  stack =  new  Stack  < LazyNumber >  ( ) ;  for (  final Token token :  getRPN  ( ) )  { 
<<<<<<<
 if  (  operators . containsKey  ( token ) )  {   final LazyNumber  v1 =  stack . pop  ( ) ;   final LazyNumber  v2 =  stack . pop  ( ) ;  LazyNumber  number =  new LazyNumber  ( )  {   public BigDecimal eval  ( )  {  return   operators . get  ( token ) . eval  (  v2 . eval  ( ) ,  v1 . eval  ( ) ) ; }   public String getString  ( )  {  return  String . valueOf  (   operators . get  ( token ) . eval  (  v2 . eval  ( ) ,  v1 . eval  ( ) ) ) ; } } ;   stack . push  ( number ) ; } else  if  (  variables . containsKey  ( token ) )  {   stack . push  (  new LazyNumber  ( )  {   public BigDecimal eval  ( )  {  return   variables . get  ( token ) . round  ( mc ) ; }   public String getString  ( )  {  return  String . valueOf  (   variables . get  ( token ) . round  ( mc ) ) ; } } ) ; } else  if  (  functions . containsKey  (  token . toUpperCase  (  Locale . ROOT ) ) )  {  LazyFunction  f =  functions . get  (  token . toUpperCase  (  Locale . ROOT ) ) ;   ArrayList  < LazyNumber >  p =  new  ArrayList  < LazyNumber >  (   !  f . numParamsVaries  ( ) ?  f . getNumParams  ( ) : 0 ) ;  while  (   !  stack . isEmpty  ( ) &&   stack . peek  ( ) != PARAMS_START )  {   p . add  ( 0 ,  stack . pop  ( ) ) ; }  if  (   stack . peek  ( ) == PARAMS_START )  {   stack . pop  ( ) ; }  LazyNumber  fResult =  f . lazyEval  ( p ) ;   stack . push  ( fResult ) ; } else  if  (  "(" . equals  ( token ) )  {   stack . push  ( PARAMS_START ) ; } else  {   stack . push  (  new LazyNumber  ( )  {   public BigDecimal eval  ( )  {  return  new BigDecimal  ( token , mc ) ; }   public String getString  ( )  {  return token ; } } ) ; }
=======
 switch  (  token . type )  {   case OPERATOR :   final LazyNumber  v1 =  stack . pop  ( ) ;   final LazyNumber  v2 =  stack . pop  ( ) ;  LazyNumber  number =  new LazyNumber  ( )  {   public BigDecimal eval  ( )  {  return   operators . get  (  token . surface ) . eval  (  v2 . eval  ( ) ,  v1 . eval  ( ) ) ; } } ;   stack . push  ( number ) ;  break ;   case VARIABLE :  if  (  !  variables . containsKey  (  token . surface ) )  {  throw  new ExpressionException  (  "Unknown operator or function: " + token ) ; }   stack . push  (  new LazyNumber  ( )  {   public BigDecimal eval  ( )  {  return   variables . get  (  token . surface ) . round  ( mc ) ; } } ) ;  break ;   case FUNCTION :  LazyFunction  f =  functions . get  (   token . surface . toUpperCase  (  Locale . ROOT ) ) ;   ArrayList  < LazyNumber >  p =  new  ArrayList  < LazyNumber >  (   !  f . numParamsVaries  ( ) ?  f . getNumParams  ( ) : 0 ) ;  while  (   !  stack . isEmpty  ( ) &&   stack . peek  ( ) != PARAMS_START )  {   p . add  ( 0 ,  stack . pop  ( ) ) ; }  if  (   stack . peek  ( ) == PARAMS_START )  {   stack . pop  ( ) ; }  LazyNumber  fResult =  f . lazyEval  ( p ) ;   stack . push  ( fResult ) ;  break ;   case OPEN_PAREN :   stack . push  ( PARAMS_START ) ;  break ;   case LITERAL :   stack . push  (  new LazyNumber  ( )  {   public BigDecimal eval  ( )  {  return  new BigDecimal  (  token . surface , mc ) ; } } ) ; }
>>>>>>>
 }  return    stack . pop  ( ) . eval  ( ) . stripTrailingZeros  ( ) ; }   public Expression setPrecision  (   int precision )  {    this . mc =  new MathContext  ( precision ) ;  return this ; }   public Expression setRoundingMode  (  RoundingMode roundingMode )  {    this . mc =  new MathContext  (  mc . getPrecision  ( ) , roundingMode ) ;  return this ; }   public Expression setFirstVariableCharacters  (  String chars )  {    this . firstVarChars = chars ;  return this ; }   public Expression setVariableCharacters  (  String chars )  {    this . varChars = chars ;  return this ; }   public Operator addOperator  (  Operator operator )  {  return  operators . put  (  operator . getOper  ( ) , operator ) ; }   public Function addFunction  (  Function function )  {  return  ( Function )  functions . put  (  function . getName  ( ) , function ) ; }   public LazyFunction addLazyFunction  (  LazyFunction function )  {  return  functions . put  (  function . getName  ( ) , function ) ; }   public Expression setVariable  (  String variable ,  BigDecimal value )  {   variables . put  ( variable , value ) ;  return this ; }   public Expression setVariable  (  String variable ,  String value )  {  if  (  isNumber  ( value ) )   variables . put  ( variable ,  new BigDecimal  ( value ) ) ; else  {   expression =  expression . replaceAll  (   "(?i)\\b" + variable + "\\b" ,   "(" + value + ")" ) ;   rpn = null ; }  return this ; }   public Expression with  (  String variable ,  BigDecimal value )  {  return  setVariable  ( variable , value ) ; }   public Expression and  (  String variable ,  String value )  {  return  setVariable  ( variable , value ) ; }   public Expression and  (  String variable ,  BigDecimal value )  {  return  setVariable  ( variable , value ) ; }   public Expression with  (  String variable ,  String value )  {  return  setVariable  ( variable , value ) ; }   public  Iterator  < String > getExpressionTokenizer  ( )  {   final String  expression =  this . expression ;  return  new  Iterator  < String >  ( )  {  Tokenizer  tokenizer =  new Tokenizer  ( expression ) ;    @ Override public boolean hasNext  ( )  {  return  tokenizer . hasNext  ( ) ; }    @ Override public String next  ( )  {  Token  nextToken =  tokenizer . next  ( ) ;  return   nextToken == null ? null :  nextToken . toString  ( ) ; }    @ Override public void remove  ( )  {   tokenizer . remove  ( ) ; } } ; }   private  List  < Token > getRPN  ( )  {  if  (  rpn == null )  {   rpn =  shuntingYard  (  this . expression ) ;   validate  ( rpn ) ; }  return rpn ; }   public String toRPN  ( )  {  StringBuilder  result =  new StringBuilder  ( ) ;  for ( Token t :  getRPN  ( ) )  {  if  (   result . length  ( ) != 0 )   result . append  ( " " ) ;   result . append  (  t . toString  ( ) ) ; }  return  result . toString  ( ) ; }   public  Set  < String > getDeclaredVariables  ( )  {  return  Collections . unmodifiableSet  (  variables . keySet  ( ) ) ; }   public  Set  < String > getDeclaredOperators  ( )  {  return  Collections . unmodifiableSet  (  operators . keySet  ( ) ) ; }   public  Set  < String > getDeclaredFunctions  ( )  {  return  Collections . unmodifiableSet  (  functions . keySet  ( ) ) ; }   public String getExpression  ( )  {  return expression ; }   public  List  < String > getUsedVariables  ( )  {   List  < String >  result =  new  ArrayList  < String >  ( ) ;  Tokenizer  tokenizer =  new Tokenizer  ( expression ) ;  while  (  tokenizer . hasNext  ( ) )  {  Token  nextToken =  tokenizer . next  ( ) ;  String  token =  nextToken . toString  ( ) ;  if  (       nextToken . type !=  TokenType . VARIABLE ||  token . equals  ( "PI" ) ||  token . equals  ( "e" ) ||  token . equals  ( "TRUE" ) ||  token . equals  ( "FALSE" ) )  {  continue ; }   result . add  ( token ) ; }  return result ; }   public String getOriginalExpression  ( )  {  return  this . originalExpression ; }    @ Override public boolean equals  (  Object o )  {  if  (  this == o )  return true ;  if  (   o == null ||   getClass  ( ) !=  o . getClass  ( ) )  return false ;  Expression  that =  ( Expression ) o ;  if  (   this . expression == null )  {  return   that . expression == null ; } else  {  return   this . expression . equals  (  that . expression ) ; } }    @ Override public  int hashCode  ( )  {  return    this . expression == null ? 0 :   this . expression . hashCode  ( ) ; }    @ Override public String toString  ( )  {  return  this . expression ; }  enum TokenType  {  VARIABLE ,  FUNCTION ,  LITERAL ,  OPERATOR ,  OPEN_PAREN ,  COMMA ,  CLOSE_PAREN }  class Token  {   public String  surface = "" ;   public TokenType  type ;   public  int  pos ;   public void append  (   char c )  {   surface += c ; }   public void append  (  String s )  {   surface += s ; }   public  char charAt  (   int pos )  {  return  surface . charAt  ( pos ) ; }   public  int length  ( )  {  return  surface . length  ( ) ; }    @ Override public String toString  ( )  {  return surface ; } }   private void validate  (   List  < Token > rpn )  {   Stack  < Integer >  stack =  new  Stack  < Integer >  ( ) ;   stack . push  ( 0 ) ;  for (  final Token token : rpn )  {  switch  (  token . type )  {   case OPERATOR :  if  (   stack . peek  ( ) < 2 )  {  throw  new ExpressionException  (  "Missing parameter(s) for operator " + token ) ; }   stack . set  (   stack . size  ( ) - 1 ,    stack . peek  ( ) - 2 + 1 ) ;  break ;   case VARIABLE :   stack . set  (   stack . size  ( ) - 1 ,   stack . peek  ( ) + 1 ) ;  break ;   case FUNCTION :  LazyFunction  f =  functions . get  (   token . surface . toUpperCase  (  Locale . ROOT ) ) ;  if  (  f == null )  {  throw  new ExpressionException  (    "Unknown function '" + token + "' at position " +  (   token . pos + 1 ) ) ; }   int  numParams =  stack . pop  ( ) ;  if  (   !  f . numParamsVaries  ( ) &&  numParams !=  f . getNumParams  ( ) )  {  throw  new ExpressionException  (      "Function " + token + " expected " +  f . getNumParams  ( ) + " parameters, got " + numParams ) ; }  if  (   stack . size  ( ) <= 0 )  {  throw  new ExpressionException  ( "Too many function calls, maximum scope exceeded" ) ; }   stack . set  (   stack . size  ( ) - 1 ,   stack . peek  ( ) + 1 ) ;  break ;   case OPEN_PAREN :   stack . push  ( 0 ) ;  break ;   default :   stack . set  (   stack . size  ( ) - 1 ,   stack . peek  ( ) + 1 ) ; } }  if  (   stack . size  ( ) > 1 )  {  throw  new ExpressionException  ( "Too many unhandled function parameter lists" ) ; } else  if  (   stack . peek  ( ) > 1 )  {  throw  new ExpressionException  ( "Too many numbers or variables" ) ; } else  if  (   stack . peek  ( ) < 1 )  {  throw  new ExpressionException  ( "Empty expression" ) ; } } }