  package   com . mercadopago . core ;   import     com . google . common . collect . MapDifference ;  import     com . google . common . collect . Maps ;  import    com . google . gson . Gson ;  import    com . google . gson . JsonObject ;  import     com . google . gson . reflect . TypeToken ;  import   com . mercadopago . MPConf ;  import    com . mercadopago . core . restannotations .  * ;  import    com . mercadopago . exceptions . MPException ;  import     org . apache . commons . lang3 . StringUtils ;  import    java . lang . annotation . Annotation ;  import    java . lang . reflect . AnnotatedElement ;  import    java . lang . reflect . Method ;  import    java . lang . reflect . Type ;  import    com . google . gson . GsonBuilder ;  import   java . util . Arrays ;  import   java . util . HashMap ;  import   java . util . List ;  import   java . util . Map ;   public abstract class MPBase  {   private transient JsonObject  lastKnownJson = null ;   private static final  List  < String >  ALLOWED_METHODS =  Arrays . asList  ( "load" , "loadAll" , "save" , "create" , "update" , "delete" ) ;   protected String processMethod  (  String methodName )  throws MPException  {   HashMap  < String , String >  mapParams = null ;  return  processMethod  ( methodName , mapParams ) ; }   protected String processMethod  (  String methodName ,  String param1 )  throws MPException  {   HashMap  < String , String >  mapParams =  new  HashMap  < String , String >  ( ) ;   mapParams . put  ( "param1" , param1 ) ;  return  processMethod  ( methodName , mapParams ) ; }   protected String processMethod  (  String methodName ,  String param1 ,  String param2 )  throws MPException  {   HashMap  < String , String >  mapParams =  new  HashMap  < String , String >  ( ) ;   mapParams . put  ( "param1" , param1 ) ;   mapParams . put  ( "param2" , param2 ) ;  return  processMethod  ( methodName , mapParams ) ; }   protected String processMethod  (  String methodName ,   HashMap  < String , String > mapParams )  throws MPException  {  if  (  !  ALLOWED_METHODS . contains  ( methodName ) )  throw  new MPException  (   "Method \"" + methodName + "\" not allowed" ) ;  AnnotatedElement  annotatedMethod =  getAnnotatedMethod  ( methodName ) ;   HashMap  < String , Object >  hashAnnotation =  getRestInformation  ( annotatedMethod ) ;  String  httpMethod =   hashAnnotation . get  ( "method" ) . toString  ( ) ;  String  path =  parsePath  (   hashAnnotation . get  ( "path" ) . toString  ( ) , mapParams ) ;   MPValidator . validate  ( this ) ;  PayloadType  payloadType =  ( PayloadType )  hashAnnotation . get  ( "payloadType" ) ;  JsonObject  payload =  generatePayload  ( httpMethod ) ;  String  response =  callApi  ( httpMethod , path , payload , payloadType ) ;   lastKnownJson =  getJson  ( ) ;  return response ; }   private String callApi  (  String httpMethod ,  String path ,  JsonObject payload ,  PayloadType payloadType )  throws MPException  {  String  response =     "{\"method\":\"" + httpMethod + "\",\"path\":\"" + path + "\"" ;  if  (   payload != null &&  StringUtils . isNotEmpty  (  payload . toString  ( ) ) )   response +=  ",\"payload\":" + payload ;   response += "}" ;  return response ; }   private String parsePath  (  String path ,   HashMap  < String , String > mapParams )  throws MPException  {  String  processedPath = "" ;  if  (  path . contains  ( ":" ) )  {   int  paramIterator = 0 ;  while  (  path . contains  ( ":" ) )  {   paramIterator ++ ;   processedPath =  processedPath +  path . substring  ( 0 ,  path . indexOf  ( ":" ) ) ;   path =  path . substring  (   path . indexOf  ( ":" ) + 1 ) ;  String  param = path ;  if  (  path . contains  ( "/" ) )  {   param =  path . substring  ( 0 ,  path . indexOf  ( "/" ) ) ; }  String  value = null ;  if  (    paramIterator <= 2 &&  mapParams != null &&  StringUtils . isNotEmpty  (  mapParams . get  (  "param" +  String . valueOf  ( paramIterator ) ) ) )  {   value =  mapParams . get  (  "param" +  String . valueOf  ( paramIterator ) ) ; } else  if  (   mapParams != null &&  StringUtils . isNotEmpty  (  mapParams . get  ( param ) ) )  {   value =  mapParams . get  ( param ) ; } else  {  JsonObject  json =  getJson  ( ) ;  if  (   json . get  ( param ) != null )  {   value =   json . get  ( param ) . getAsString  ( ) ; } }  if  (  StringUtils . isEmpty  ( value ) )  {  throw  new MPException  ( "No argument supplied/found for method path" ) ; }   processedPath =  processedPath + value ;  if  (  path . contains  ( "/" ) )  {   path =  path . substring  (  path . indexOf  ( "/" ) ) ; } } } else  {   processedPath = path ; }   processedPath =   MPConf . getBaseUrl  ( ) + processedPath ;  return processedPath ; }   private JsonObject generatePayload  (  String httpMethod )  {  JsonObject  payload = null ;  if  (  httpMethod . equals  ( "POST" ) )  {   payload =  getJson  ( ) ; } else  if  (  httpMethod . equals  ( "PUT" ) )  {  JsonObject  actualJson =  getJson  ( ) ;  Type  mapType =   new  TypeToken  <  Map  < String , Object > >  ( )  { } . getType  ( ) ;  Gson  gson =  new Gson  ( ) ;   Map  < String , Object >  oldMap =  gson . fromJson  (  this . lastKnownJson , mapType ) ;   Map  < String , Object >  newMap =  gson . fromJson  ( actualJson , mapType ) ;   MapDifference  < String , Object >  mapDifferences =  Maps . difference  ( oldMap , newMap ) ;   payload =  new JsonObject  ( ) ;    mapDifferences . entriesDiffering  ( ) . size  ( ) ;  for (   Map . Entry  < String ,   MapDifference . ValueDifference  < Object > > entry :   mapDifferences . entriesDiffering  ( ) . entrySet  ( ) )  {   payload . addProperty  (  entry . getKey  ( ) ,    entry . getValue  ( ) . rightValue  ( ) . toString  ( ) ) ; } }  return payload ; }   private JsonObject getJson  ( )  {  String  FORMAT_ISO8601 = "yyyy-MM-dd'T'HH:mm:ssZ" ;  Gson  gson =    new GsonBuilder  ( ) . setDateFormat  ( FORMAT_ISO8601 ) . create  ( ) ;  return  ( JsonObject )  gson . toJsonTree  ( this ) ; }   private  HashMap  < String , Object > getRestInformation  (  AnnotatedElement element )  throws MPException  {  if  (    element . getAnnotations  ( ) . length == 0 )  throw  new MPException  ( "No rest method found" ) ;   HashMap  < String , Object >  hashAnnotation =  new  HashMap  < String , Object >  ( ) ;  for ( Annotation annotation :  element . getAnnotations  ( ) )  {  if  (  annotation instanceof DELETE )  {  DELETE  delete =  ( DELETE ) annotation ;  if  (  StringUtils . isEmpty  (  delete . path  ( ) ) )  {  throw  new MPException  ( "Path not found for DELETE method" ) ; }   hashAnnotation =  fillHashAnnotations  ( hashAnnotation , "DELETE" ,  delete . path  ( ) , null ) ; } else  if  (  annotation instanceof GET )  {  GET  get =  ( GET ) annotation ;  if  (  StringUtils . isEmpty  (  get . path  ( ) ) )  {  throw  new MPException  ( "Path not found for GET method" ) ; }   hashAnnotation =  fillHashAnnotations  ( hashAnnotation , "GET" ,  get . path  ( ) , null ) ; } else  if  (  annotation instanceof POST )  {  POST  post =  ( POST ) annotation ;  if  (  StringUtils . isEmpty  (  post . path  ( ) ) )  {  throw  new MPException  ( "Path not found for POST method" ) ; }   hashAnnotation =  fillHashAnnotations  ( hashAnnotation , "POST" ,  post . path  ( ) ,  post . payloadType  ( ) ) ; } else  if  (  annotation instanceof PUT )  {  PUT  put =  ( PUT ) annotation ;  if  (  StringUtils . isEmpty  (  put . path  ( ) ) )  {  throw  new MPException  ( "Path not found for PUT method" ) ; }   hashAnnotation =  fillHashAnnotations  ( hashAnnotation , "PUT" ,  put . path  ( ) ,  put . payloadType  ( ) ) ; } }  return hashAnnotation ; }   private  HashMap  < String , Object > fillHashAnnotations  (   HashMap  < String , Object > hashAnnotation ,  String method ,  String path ,  PayloadType payloadType )  throws MPException  {  if  (  hashAnnotation . containsKey  ( "method" ) )  {  throw  new MPException  ( "Multiple rest methods found" ) ; }   hashAnnotation . put  ( "method" , method ) ;   hashAnnotation . put  ( "path" , path ) ;   hashAnnotation . put  ( "payloadType" , payloadType ) ;  return hashAnnotation ; }   private AnnotatedElement getAnnotatedMethod  (  String methodName )  throws MPException  {  for ( Method method :   this . getClass  ( ) . getDeclaredMethods  ( ) )  {  if  (   method . getName  ( ) . equals  ( methodName ) )  {  return method ; } }  throw  new MPException  ( "No method found" ) ; } }