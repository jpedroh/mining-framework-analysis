  package stormpot ;   import   org . junit . After ;  import   org . junit . Before ;  import   org . junit . Rule ;  import   org . junit . Test ;  import    org . junit . rules . TestRule ;  import    org . junit . runner . RunWith ;  import    org . junit . runners . Parameterized ;  import     org . junit . runners . Parameterized . Parameters ;  import   javax . management . JMX ;  import   javax . management . MBeanServer ;  import   javax . management . MBeanServerFactory ;  import   javax . management . ObjectName ;  import    java . lang . ref . WeakReference ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . List ;  import   java . util . Optional ;  import   java . util . concurrent .  * ;  import     java . util . concurrent . atomic . AtomicBoolean ;  import     java . util . concurrent . atomic . AtomicInteger ;  import     java . util . concurrent . atomic . AtomicLong ;  import     java . util . concurrent . atomic . AtomicReference ;  import     java . util . concurrent . locks . Lock ;  import     java . util . concurrent . locks . LockSupport ;  import     java . util . concurrent . locks . ReentrantLock ;  import    java . util . function . Consumer ;  import    java . util . function . Function ;  import static     java . util . function . Function . identity ;  import static   org . hamcrest . Matchers .  * ;  import static   org . junit . Assert .  * ;  import static    org . junit . Assume . assumeThat ;  import static  stormpot . AlloKit .  * ;  import static   stormpot . AlloKit . $countDown ;  import static   stormpot . AlloKit . $if ;  import static  stormpot . ExpireKit .  * ;  import static   stormpot . ExpireKit . $countDown ;  import static   stormpot . ExpireKit . $if ;  import static  stormpot . UnitKit .  * ;    @ RunWith  (  Parameterized . class ) public class PoolTest  {   private static final  int  TIMEOUT = 42424 ;    @ Rule public final TestRule  failurePrinter =  new FailurePrinterTestRule  ( ) ;   private static final  Expiration  < Poolable >  oneMsTTL =  new  TimeExpiration  < >  ( 1 ,  TimeUnit . MILLISECONDS ) ;   private static final  Expiration  < Poolable >  fiveMsTTL =  new  TimeExpiration  < >  ( 5 ,  TimeUnit . MILLISECONDS ) ;   private static final Timeout  longTimeout =  new Timeout  ( 5 ,  TimeUnit . MINUTES ) ;   private static final Timeout  mediumTimeout =  new Timeout  ( 10 ,  TimeUnit . MILLISECONDS ) ;   private static final Timeout  shortTimeout =  new Timeout  ( 1 ,  TimeUnit . MILLISECONDS ) ;   private static final Timeout  zeroTimeout =  new Timeout  ( 0 ,  TimeUnit . MILLISECONDS ) ;   private final PoolFixture  fixture ;   private CountingAllocator  allocator ;   private  Config  < GenericPoolable >  config ;   private  Pool  < GenericPoolable >  pool ;    @ Parameters  (  name = "{0}" ) public static  Object  [ ] [ ] dataPoints  ( )  {  return  new Object  [ ] [ ]  {  { "blazePool" ,  new BlazePoolFixture  ( ) } ,  { "queuePool" ,  new QueuePoolFixture  ( ) } } ; }    @ SuppressWarnings  ( "UnusedParameters" ) public PoolTest  (  String implementationName ,  PoolFixture fixture )  {    this . fixture = fixture ; }    @ Before public void setUp  ( )  {   allocator =  allocator  ( ) ;   config =    new  Config  < GenericPoolable >  ( ) . setSize  ( 1 ) . setAllocator  ( allocator ) ; }    @ After public void shutPoolDown  ( )  throws InterruptedException  {  if  (  pool != null )  {  String  poolName =   pool . getClass  ( ) . getSimpleName  ( ) ;   assertTrue  (  "Pool did not shut down within timeout: " + poolName ,   pool . shutdown  ( ) . await  ( longTimeout ) ) ; } }   private void createPool  ( )  {   pool =  fixture . initPool  ( config ) ; }   private ManagedPool assumeManagedPool  ( )  {   createPool  ( ) ;   assumeThat  ( pool ,  instanceOf  (  ManagedPool . class ) ) ;  return  ( ManagedPool ) pool ; }    @ Test  (  expected =  IllegalArgumentException . class ) public void timeoutCannotBeNull  ( )  throws Exception  {   createPool  ( ) ;   pool . claim  ( null ) ; }    @ Test  (  timeout = TIMEOUT ) public void claimMustReturnIfWithinTimeout  ( )  throws Exception  {   createPool  ( ) ;  Poolable  obj =  pool . claim  ( longTimeout ) ;  try  {   assertThat  ( obj ,  not  (  nullValue  ( ) ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void claimMustReturnNullIfTimeoutElapses  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;  Poolable  b =  pool . claim  ( shortTimeout ) ;  try  {   assertThat  ( b ,  is  (  nullValue  ( ) ) ) ; }  finally  {   a . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void mustGetPooledObjectsFromAllocator  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {   assertThat  (  allocator . countAllocations  ( ) ,  is  (  greaterThan  ( 0 ) ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void blockingClaimWithTimeoutMustWaitIfPoolIsEmpty  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   assertNotNull  ( "Did not deplete pool in time" , obj ) ;   AtomicReference  < GenericPoolable >  ref =  new  AtomicReference  < >  ( ) ;  Thread  thread =  fork  (  capture  (  $claim  ( pool , longTimeout ) , ref ) ) ;  try  {   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ; }  finally  {   obj . release  ( ) ;   thread . join  ( ) ;    ref . get  ( ) . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void blockingOnClaimWithTimeoutMustResumeWhenPoolablesAreReleased  ( )  throws Exception  {   createPool  ( ) ;  Poolable  obj =  pool . claim  ( longTimeout ) ;   assertNotNull  ( "Did not deplete pool in time" , obj ) ;   AtomicReference  < GenericPoolable >  ref =  new  AtomicReference  < >  ( ) ;  Thread  thread =  fork  (  capture  (  $claim  ( pool , longTimeout ) , ref ) ) ;   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ;   obj . release  ( ) ;   join  ( thread ) ;    ref . get  ( ) . release  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustReuseAllocatedObjects  ( )  throws Exception  {   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   assertThat  (  allocator . countAllocations  ( ) ,  is  ( 1 ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalArgumentException . class ) public void constructorMustThrowOnPoolSizeLessThanOne  ( )  {   fixture . initPool  (  config . setSize  ( 0 ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalArgumentException . class ) public void constructorMustThrowOnNullExpiration  ( )  {   fixture . initPool  (  config . setExpiration  ( null ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalArgumentException . class ) public void constructorMustThrowOnNullAllocator  ( )  {   fixture . initPool  (  config . setAllocator  ( null ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalArgumentException . class ) public void constructorMustThrowOnNullThreadFactory  ( )  {   fixture . initPool  (  config . setThreadFactory  ( null ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  NullPointerException . class ) public void constructorMustThrowIfConfiguredThreadFactoryReturnsNull  ( )  {  ThreadFactory  factory =  r -> null ;   config . setThreadFactory  ( factory ) ;   createPool  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustUseProvidedExpiration  ( )  throws Exception  {   config . setAllocator  (  allocator  ( ) ) ;  CountingExpiration  expiration =  expire  ( $fresh ) ;   config . setExpiration  ( expiration ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   assertThat  (  expiration . countExpirations  ( ) ,  greaterThanOrEqualTo  ( 1 ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  SomeRandomException . class ) public void exceptionsFromExpirationMustBubbleOut  ( )  throws Throwable  {   config . setExpiration  (  expire  (  $throwExpire  (  new SomeRandomException  ( ) ) ) ) ;   createPool  ( ) ;  try  {    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ; }  catch (   PoolException e )  {  throw  e . getCause  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void slotsThatMakeTheExpirationThrowAreInvalid  ( )  throws Exception  {   config . setExpiration  (  expire  (  $throwExpire  (  new SomeRandomException  ( ) ) ) ) ;   createPool  ( ) ;  try  {   pool . claim  ( longTimeout ) ;   fail  ( "should throw" ) ; }  catch (   PoolException e )  {   assertThat  (  e . getCause  ( ) ,  instanceOf  (  SomeRandomException . class ) ) ; }  try  {   pool . claim  ( longTimeout ) ; }  catch (   PoolException e )  {   assertThat  (  e . getCause  ( ) ,  instanceOf  (  SomeRandomException . class ) ) ; }   assertThat  (  allocator . countDeallocations  ( ) ,  greaterThanOrEqualTo  ( 1 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void slotInfoClaimCountMustIncreaseWithClaims  ( )  throws Exception  {   final AtomicLong  claims =  new AtomicLong  ( ) ;   config . setExpiration  (  expire  (  $capture  (  $claimCount  ( claims ) , $fresh ) ) ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   assertThat  (  claims . get  ( ) ,  is  ( 2L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void slotInfoMustHaveReferenceToItsPoolable  ( )  throws Exception  {   final  AtomicReference  < Poolable >  lastPoolable =  new  AtomicReference  < >  ( ) ;   config . setExpiration  (  expire  (  $capture  (  $poolable  ( lastPoolable ) , $fresh ) ) ) ;   createPool  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;   a . release  ( ) ;  GenericPoolable  b =  pool . claim  ( longTimeout ) ;   b . release  ( ) ;  GenericPoolable  poolable =  ( GenericPoolable )  lastPoolable . get  ( ) ;   assertThat  ( poolable ,  anyOf  (  is  ( a ) ,  is  ( b ) ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void slotInfoMustBeAbleToProduceRandomNumbers  ( )  throws Exception  {   final  AtomicReference  <  SlotInfo  <  ? extends Poolable > >  slotInfoRef =  new  AtomicReference  < >  ( ) ;   config . setExpiration  (  expire  (  $capture  (  $slotInfo  ( slotInfoRef ) , $fresh ) ) ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   SlotInfo  <  ? extends Poolable >  slotInfo =  slotInfoRef . get  ( ) ;   int  nums = 1000000 ;   int  bits =  32 * nums ;   int  ones = 0 ;  for (   int  i = 0 ;  i < nums ;  i ++ )  {   ones +=  Integer . bitCount  (  slotInfo . randomInt  ( ) ) ; }   double  diff =  Math . abs  (  bits -  ones * 2 ) ;   assertThat  ( diff ,  lessThan  (  bits * 0.005 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void slotInfoClaimCountMustResetIfSlotsAreReused  ( )  throws Exception  {   final AtomicLong  maxClaimCount =  new AtomicLong  ( ) ;   Expiration  < Poolable >  expiration =  info ->  {   maxClaimCount . set  (  Math . max  (  maxClaimCount . get  ( ) ,  info . getClaimCount  ( ) ) ) ;  return   info . getClaimCount  ( ) > 1 ; } ;   config . setExpiration  ( expiration ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   assertThat  (  maxClaimCount . get  ( ) ,  is  ( 2L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void slotInfoMustRememberStamp  ( )  throws Exception  {   final AtomicBoolean  rememberedStamp =  new AtomicBoolean  ( ) ;   Expiration  < Poolable >  expiration =  info ->  {   long  stamp =  info . getStamp  ( ) ;  if  (  stamp == 0 )  {   info . setStamp  ( 13 ) ; } else  if  (  stamp == 13 )  {   rememberedStamp . set  ( true ) ; }  return false ; } ;   config . setExpiration  ( expiration ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   assertTrue  (  rememberedStamp . get  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void slotInfoStampMustResetIfSlotsAreReused  ( )  throws Exception  {   final AtomicLong  zeroStampsCounted =  new AtomicLong  ( 0 ) ;   Expiration  < Poolable >  expiration =  info ->  {   long  stamp =  info . getStamp  ( ) ;   info . setStamp  ( 15 ) ;  if  (  stamp == 0 )  {   zeroStampsCounted . incrementAndGet  ( ) ;  return false ; }  return true ; } ;   config . setExpiration  ( expiration ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   assertThat  (  zeroStampsCounted . get  ( ) ,  is  ( 3L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void slotInfoMustHaveAgeInMillis  ( )  throws InterruptedException  {   final AtomicLong  age =  new AtomicLong  ( ) ;   config . setExpiration  (  expire  (  $capture  (  $age  ( age ) , $fresh ) ) ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   long  firstAge =  age . get  ( ) ;   spinwait  ( 5 ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   long  secondAge =  age . get  ( ) ;   assertThat  (  secondAge - firstAge ,  greaterThanOrEqualTo  ( 5L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void slotInfoAgeMustResetAfterAllocation  ( )  throws InterruptedException  {   final AtomicBoolean  hasExpired =  new AtomicBoolean  ( ) ;   final AtomicLong  age =  new AtomicLong  ( ) ;   config . setExpiration  (  expire  (  $capture  (  $age  ( age ) ,  $expiredIf  ( hasExpired ) ) ) ) ;   config . setAllocator  (  reallocator  (  realloc  (  $throw  (  new Exception  ( ) ) ) ) ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   Thread . sleep  ( 100 ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   long  firstAge =  age . get  ( ) ;   hasExpired . set  ( true ) ;  try  {    pool . claim  ( longTimeout ) . release  ( ) ; }  catch (   Exception e )  { }   hasExpired . set  ( false ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   long  secondAge =  age . get  ( ) ;   assertThat  ( secondAge ,  lessThan  ( firstAge ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void slotInfoAgeMustResetAfterReallocation  ( )  throws InterruptedException  {   final AtomicBoolean  hasExpired =  new AtomicBoolean  ( ) ;   final AtomicLong  age =  new AtomicLong  ( ) ;   config . setExpiration  (  expire  (  $capture  (  $age  ( age ) ,  $expiredIf  ( hasExpired ) ) ) ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   Thread . sleep  ( 100 ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   long  firstAge =  age . get  ( ) ;   hasExpired . set  ( true ) ;   assertNull  (  pool . claim  ( zeroTimeout ) ) ;   hasExpired . set  ( false ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   long  secondAge =  age . get  ( ) ;   assertThat  ( secondAge ,  lessThan  ( firstAge ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalStateException . class ) public void preventClaimFromPoolThatIsShutDown  ( )  throws Exception  {   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   pool . shutdown  ( ) ;   pool . claim  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustReplaceExpiredPoolables  ( )  throws Exception  {   config . setExpiration  ( oneMsTTL ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   spinwait  ( 2 ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   assertThat  (  allocator . countAllocations  ( ) ,  greaterThanOrEqualTo  ( 2 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustDeallocateExpiredPoolablesAndStayWithinSizeLimit  ( )  throws Exception  {   config . setExpiration  ( oneMsTTL ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   spinwait  ( 2 ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   assertThat  (  allocator . countDeallocations  ( ) ,  greaterThanOrEqualTo  ( 1 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustDeallocateAllPoolablesBeforeShutdownTaskReturns  ( )  throws Exception  {   config . setSize  ( 2 ) ;   createPool  ( ) ;  Poolable  p1 =  pool . claim  ( longTimeout ) ;  Poolable  p2 =  pool . claim  ( longTimeout ) ;   p1 . release  ( ) ;   p2 . release  ( ) ;    pool . shutdown  ( ) . await  ( longTimeout ) ;   assertThat  (  allocator . countDeallocations  ( ) ,  is  ( 2 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void shutdownCallMustReturnFastIfPoolablesAreStillClaimed  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {   pool . shutdown  ( ) ;   assertNotNull  ( "Did not deplete pool in time" , obj ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void shutdownMustNotDeallocateClaimedPoolables  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   assertNotNull  ( "Did not deplete pool in time" , obj ) ;    pool . shutdown  ( ) . await  ( mediumTimeout ) ;  try  {   assertThat  (  allocator . countDeallocations  ( ) ,  is  ( 0 ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void awaitOnShutdownMustReturnWhenClaimedObjectsAreReleased  ( )  throws Exception  {   createPool  ( ) ;  Poolable  obj =  pool . claim  ( longTimeout ) ;  Completion  completion =  pool . shutdown  ( ) ;  Thread  thread =  fork  (  $await  ( completion , longTimeout ) ) ;   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ;   obj . release  ( ) ;   join  ( thread ) ; }    @ Test  (  timeout = TIMEOUT ) public void awaitWithTimeoutMustReturnFalseIfTimeoutElapses  ( )  throws Exception  {   createPool  ( ) ;  Poolable  obj =  pool . claim  ( longTimeout ) ;   assertFalse  (   pool . shutdown  ( ) . await  ( shortTimeout ) ) ;   obj . release  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void awaitWithTimeoutMustReturnTrueIfCompletesWithinTimeout  ( )  throws Exception  {   createPool  ( ) ;  Poolable  obj =  pool . claim  ( longTimeout ) ;  AtomicBoolean  result =  new AtomicBoolean  ( false ) ;  Completion  completion =  pool . shutdown  ( ) ;  Thread  thread =  fork  (  $await  ( completion , longTimeout , result ) ) ;   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ;   obj . release  ( ) ;   join  ( thread ) ;   assertTrue  (  result . get  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void awaitingOnAlreadyCompletedShutDownMustNotBlock  ( )  throws Exception  {   createPool  ( ) ;  Completion  completion =  pool . shutdown  ( ) ;   completion . await  ( longTimeout ) ;   completion . await  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ) public void blockedClaimMustThrowWhenPoolIsShutDown  ( )  throws Exception  {   createPool  ( ) ;   AtomicReference  < Exception >  caught =  new  AtomicReference  < >  ( ) ;  Poolable  obj =  pool . claim  ( longTimeout ) ;  Thread  thread =  fork  (  $catchFrom  (  $claim  ( pool , longTimeout ) , caught ) ) ;   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ;   pool . shutdown  ( ) ;   obj . release  ( ) ;   join  ( thread ) ;   assertThat  (  caught . get  ( ) ,  instanceOf  (  IllegalStateException . class ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustNotDeallocateTheSameObjectMoreThanOnce  ( )  throws Exception  {   config . setExpiration  ( oneMsTTL ) ;   createPool  ( ) ;  Poolable  obj =  pool . claim  ( longTimeout ) ;   spinwait  ( 2 ) ;   obj . release  ( ) ;  for (   int  i = 0 ;  i < 10 ;  i ++ )  {  try  {   obj . release  ( ) ; }  catch (   Exception ignore )  { } }    pool . claim  ( longTimeout ) . release  ( ) ;   List  < GenericPoolable >  deallocations =  allocator . getDeallocations  ( ) ;  for ( Poolable elm : deallocations )  {   assertThat  (  "Deallocations of " + elm ,  Collections . frequency  ( deallocations , elm ) ,  is  ( 1 ) ) ; } }    @ Test  (  timeout = TIMEOUT ) public void shutdownMustNotDeallocateEmptySlots  ( )  throws Exception  {   final AtomicBoolean  wasNull =  new AtomicBoolean  ( ) ;   allocator =  allocator  (  dealloc  (  $observeNull  ( wasNull , $null ) ) ) ;    config . setAllocator  ( allocator ) . setExpiration  ( oneMsTTL ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . shutdown  ( ) . await  ( longTimeout ) ;   assertFalse  (  wasNull . get  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void shutdownMustEventuallyDeallocateAllPoolables  ( )  throws Exception  {   int  size = 10 ;   config . setSize  ( size ) ;   createPool  ( ) ;   List  < GenericPoolable >  objs =  new  ArrayList  < >  ( ) ;  for (   int  i = 0 ;  i < size ;  i ++ )  {   objs . add  (  pool . claim  ( longTimeout ) ) ; }  Completion  completion =  pool . shutdown  ( ) ;   completion . await  ( shortTimeout ) ;  for ( GenericPoolable obj : objs )  {   obj . release  ( ) ; }   completion . await  ( longTimeout ) ;   assertThat  (  allocator . countDeallocations  ( ) ,  is  ( size ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustPropagateExceptionsFromAllocateThroughClaim  ( )  throws Exception  {   final RuntimeException  expectedException =  new RuntimeException  ( "boo" ) ;   allocator =  allocator  (  alloc  (  $throw  ( expectedException ) ) ) ;   config . setAllocator  ( allocator ) ;   createPool  ( ) ;  try  {   pool . claim  ( longTimeout ) ;   fail  ( "expected claim to throw" ) ; }  catch (   PoolException poolException )  {   assertThat  (  poolException . getCause  ( ) ,  is  (  ( Throwable ) expectedException ) ) ; } }    @ Test  (  timeout = TIMEOUT ) public void mustPropagateExceptionsFromReallocateThroughClaim  ( )  throws Exception  {   final RuntimeException  expectedException =  new RuntimeException  ( "boo" ) ;  AtomicBoolean  hasExpired =  new AtomicBoolean  ( ) ;   config . setAllocator  (  reallocator  (  realloc  (  $throw  ( expectedException ) ) ) ) ;   config . setExpiration  (  expire  (  $expiredIf  ( hasExpired ) ) ) ;   config . setSize  ( 2 ) ;   createPool  ( ) ;   hasExpired . set  ( false ) ;  GenericPoolable  obj1 =  pool . claim  ( longTimeout ) ;  GenericPoolable  obj2 =  pool . claim  ( longTimeout ) ;   obj1 . release  ( ) ;   obj2 . release  ( ) ;   hasExpired . set  ( true ) ;  try  {   pool . claim  ( longTimeout ) ;   fail  ( "expected claim to throw" ) ; }  catch (   PoolException poolException )  {   assertThat  (  poolException . getCause  ( ) ,  is  (  ( Throwable ) expectedException ) ) ; } }    @ Test  (  timeout = TIMEOUT ) public void mustStillBeUsableAfterExceptionInAllocate  ( )  throws Exception  {   allocator =  allocator  (  alloc  (  $throw  (  new RuntimeException  ( "boo" ) ) , $new ) ) ;   config . setAllocator  ( allocator ) ;   createPool  ( ) ;  try  {    pool . claim  ( longTimeout ) . release  ( ) ; }  catch (   PoolException ignore )  { }  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   assertThat  ( obj ,  is  (  notNullValue  ( ) ) ) ;   obj . release  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustStillBeUsableAfterExceptionInReallocate  ( )  throws Exception  {   final AtomicBoolean  throwInAllocate =  new AtomicBoolean  ( ) ;   final AtomicBoolean  hasExpired =  new AtomicBoolean  ( ) ;   final CountDownLatch  allocationLatch =  new CountDownLatch  ( 2 ) ;   config . setAllocator  (  reallocator  (  alloc  (  $if  ( throwInAllocate ,  $throw  (  new RuntimeException  ( "boo" ) ) ,  $countDown  ( allocationLatch , $new ) ) ) ,  realloc  (  $throw  (  new RuntimeException  ( "boo" ) ) ) ) ) ;   config . setExpiration  (  expire  (  $expiredIf  ( hasExpired ) ) ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   throwInAllocate . set  ( true ) ;   hasExpired . set  ( true ) ;  try  {   pool . claim  ( longTimeout ) ;   fail  ( "claim should have thrown" ) ; }  catch (   PoolException ignore )  { }   throwInAllocate . set  ( false ) ;   hasExpired . set  ( false ) ;   allocationLatch . await  ( ) ;  GenericPoolable  claim =  pool . claim  ( longTimeout ) ;   assertThat  ( claim ,  is  (  notNullValue  ( ) ) ) ;   claim . release  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustSwallowExceptionsFromDeallocateThroughRelease  ( )  throws Exception  {   allocator =  allocator  (  dealloc  (  $throw  (  new RuntimeException  ( "boo" ) ) ) ) ;   config . setAllocator  ( allocator ) ;   config . setExpiration  ( oneMsTTL ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   spinwait  ( 2 ) ;    pool . claim  ( longTimeout ) . release  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustSwallowExceptionsFromDeallocateThroughShutdown  ( )  throws Exception  {  CountingAllocator  allocator =  allocator  (  dealloc  (  $throw  (  new RuntimeException  ( "boo" ) ) ) ) ;    config . setAllocator  ( allocator ) . setSize  ( 2 ) ;   createPool  ( ) ;  Poolable  obj =  pool . claim  ( longTimeout ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   obj . release  ( ) ;    pool . shutdown  ( ) . await  ( longTimeout ) ;   assertThat  (  allocator . countDeallocations  ( ) ,  is  ( 2 ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  InterruptedException . class ) public void awaitOnCompletionWhenInterruptedMustThrow  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   assertNotNull  ( "Did not deplete pool in time" , obj ) ;  Completion  completion =  pool . shutdown  ( ) ;    Thread . currentThread  ( ) . interrupt  ( ) ;  try  {   completion . await  ( longTimeout ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ,  expected =  InterruptedException . class ) public void awaitWithTimeoutOnCompletionMustThrowUponInterruption  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   assertNotNull  ( "Did not deplete pool in time" , obj ) ;  Completion  completion =  pool . shutdown  ( ) ;   forkFuture  (  $interruptUponState  (  Thread . currentThread  ( ) ,   Thread . State . TIMED_WAITING ) ) ;  try  {   completion . await  ( longTimeout ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void awaitOnCompletionWhenInterruptedMustClearInterruption  ( )  throws Exception  {  try  {   awaitOnCompletionWhenInterruptedMustThrow  ( ) ; }  catch (   InterruptedException ignore )  { }   assertFalse  (  Thread . interrupted  ( ) ) ;  try  {   awaitWithTimeoutOnCompletionMustThrowUponInterruption  ( ) ; }  catch (   InterruptedException ignore )  { }   assertFalse  (  Thread . interrupted  ( ) ) ; }   private Completion givenFinishedInterruptedCompletion  ( )  throws InterruptedException  {   createPool  ( ) ;    pool . shutdown  ( ) . await  ( longTimeout ) ;    Thread . currentThread  ( ) . interrupt  ( ) ;  return  pool . shutdown  ( ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  InterruptedException . class ) public void awaitWithTimeoutOnFinishedCompletionWhenInterruptedMustThrow  ( )  throws InterruptedException  {    givenFinishedInterruptedCompletion  ( ) . await  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ) public void awaitOnFinishedCompletionMustClearInterruption  ( )  {  try  {   awaitWithTimeoutOnFinishedCompletionWhenInterruptedMustThrow  ( ) ; }  catch (   InterruptedException ignore )  { }   assertFalse  (  Thread . interrupted  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  PoolException . class ) public void claimMustThrowIfAllocationReturnsNull  ( )  throws Exception  {   Allocator  < GenericPoolable >  allocator =  allocator  (  alloc  ( $null ) ) ;   Pool  < GenericPoolable >  pool =  fixture . initPool  (  config . setAllocator  ( allocator ) ) ;   pool . claim  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  PoolException . class ) public void claimMustThrowIfReallocationReturnsNull  ( )  throws Exception  {   allocator =  reallocator  (  realloc  ( $null ) ) ;  AtomicBoolean  hasExpired =  new AtomicBoolean  ( ) ;   config . setAllocator  ( allocator ) ;   config . setExpiration  (  expire  (  $expiredIf  ( hasExpired ) ) ) ;   config . setSize  ( 2 ) ;   createPool  ( ) ;   hasExpired . set  ( false ) ;  GenericPoolable  obj1 =  pool . claim  ( longTimeout ) ;  GenericPoolable  obj2 =  pool . claim  ( longTimeout ) ;   obj1 . release  ( ) ;   obj2 . release  ( ) ;   hasExpired . set  ( true ) ;   pool . claim  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  InterruptedException . class ) public void claimWhenInterruptedMustThrow  ( )  throws Exception  {   createPool  ( ) ;    Thread . currentThread  ( ) . interrupt  ( ) ;   pool . claim  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  InterruptedException . class ) public void blockedClaimWithTimeoutMustThrowUponInterruption  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;   assertNotNull  ( "Did not deplete pool in time" , a ) ;   forkFuture  (  $interruptUponState  (  Thread . currentThread  ( ) ,   Thread . State . TIMED_WAITING ) ) ;  try  {   pool . claim  ( longTimeout ) ; }  finally  {   a . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void throwingInterruptedExceptionFromClaimMustClearInterruptedFlag  ( )  throws Exception  {  try  {   blockedClaimWithTimeoutMustThrowUponInterruption  ( ) ;   fail  ( "expected InterruptedException from claim" ) ; }  catch (   InterruptedException ignore )  { }   assertFalse  (  Thread . interrupted  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void claimMustStayWithinDeadlineEvenIfAllocatorBlocks  ( )  throws Exception  {  Semaphore  semaphore =  new Semaphore  ( 0 ) ;   allocator =  allocator  (  alloc  (  $acquire  ( semaphore , $new ) ) ) ;   config . setAllocator  ( allocator ) ;   createPool  ( ) ;  try  {   pool . claim  ( shortTimeout ) ; }  finally  {   semaphore . release  ( 10 ) ; } }    @ Test  (  timeout = TIMEOUT ) public void claimMustStayWithinTimeoutEvenIfExpiredObjectIsReleased  ( )  throws Exception  {   final  Poolable  [ ]  objs =  new Poolable  [ 50 ] ;   final Lock  lock =  new ReentrantLock  ( ) ;   allocator =  allocator  (  alloc  (  $sync  ( lock , $new ) ) ) ;   config . setAllocator  ( allocator ) ;   config . setExpiration  ( fiveMsTTL ) ;   config . setSize  (  objs . length ) ;   createPool  ( ) ;  for (   int  i = 0 ;  i <  objs . length ;  i ++ )  {    objs [ i ] =  pool . claim  ( longTimeout ) ;   assertNotNull  ( "Did not claim an object in time" ,  objs [ i ] ) ; }   lock . lock  ( ) ;  Thread  thread =  fork  (  $delayedReleases  ( objs , 10 ,  TimeUnit . MILLISECONDS ) ) ;  try  {  GenericPoolable  obj =  pool . claim  (  new Timeout  ( 50 ,  TimeUnit . MILLISECONDS ) ) ;  if  (  obj != null )  {   obj . release  ( ) ; } }  finally  {   thread . interrupt  ( ) ;   thread . join  ( ) ;   lock . unlock  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void claimWithTimeoutValueLessThanOneMustReturnImmediately  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   assertNotNull  ( "Did not deplete pool in time" , obj ) ;  try  {   pool . claim  ( zeroTimeout ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void awaitCompletionWithTimeoutLessThanOneMustReturnImmediately  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {   assertNotNull  ( "Did not deplete pool in time" , obj ) ;    pool . shutdown  ( ) . await  ( zeroTimeout ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalArgumentException . class ) public void awaitCompletionWithNullTimeUnitMustThrow  ( )  throws Exception  {   createPool  ( ) ;    pool . shutdown  ( ) . await  ( null ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustCompleteShutDownEvenIfAllSlotsHaveNullErrors  ( )  throws Exception  {   Allocator  < GenericPoolable >  allocator =  allocator  (  alloc  ( $null ) ) ;   Pool  < GenericPoolable >  pool =  givenPoolWithFailedAllocation  ( allocator ) ;    pool . shutdown  ( ) . await  ( longTimeout ) ; }   private  Pool  < GenericPoolable > givenPoolWithFailedAllocation  (   Allocator  < GenericPoolable > allocator )  {   config . setAllocator  ( allocator ) ;   createPool  ( ) ;  try  {   pool . claim  ( longTimeout ) ;   fail  ( "allocation attempt should have failed!" ) ; }  catch (   Exception ignore )  { }  return pool ; }    @ Test  (  timeout = TIMEOUT ) public void mustCompleteShutDownEvenIfAllSlotsHaveAllocationErrors  ( )  throws Exception  {   Allocator  < GenericPoolable >  allocator =  allocator  (  alloc  (  $throw  (  new Exception  ( "it's terrible stuff!!!" ) ) ) ) ;   Pool  < GenericPoolable >  pool =  givenPoolWithFailedAllocation  ( allocator ) ;    pool . shutdown  ( ) . await  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustBeAbleToShutDownWhenAllocateAlwaysThrows  ( )  throws Exception  {  AtomicLong  counter =  new AtomicLong  ( ) ;   allocator =  allocator  (  alloc  (  $incrementAnd  ( counter ,  $throw  (  new RuntimeException  ( "boo" ) ) ) ) ) ;   config . setAllocator  ( allocator ) ;   config . setSize  ( 3 ) ;   createPool  ( ) ;  while  (   counter . get  ( ) < 2 )  { }    pool . shutdown  ( ) . await  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustBeAbleToShutDownEvenIfInterrupted  ( )  throws Exception  {   createPool  ( ) ;    Thread . currentThread  ( ) . interrupt  ( ) ;  Completion  completion =  pool . shutdown  ( ) ;   Thread . interrupted  ( ) ;   completion . await  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ) public void callingShutdownMustNotAffectInterruptionStatus  ( )  throws Exception  {   createPool  ( ) ;    Thread . currentThread  ( ) . interrupt  ( ) ;   pool . shutdown  ( ) ;   assertTrue  (  Thread . interrupted  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustUnbiasObjectsNoLongerClaimed  ( )  throws Exception  {   createPool  ( ) ;  Poolable  obj =  pool . claim  ( longTimeout ) ;   obj . release  ( ) ;   AtomicReference  < GenericPoolable >  ref =  new  AtomicReference  < >  ( ) ;   join  (  forkFuture  (  capture  (  $claim  ( pool , longTimeout ) , ref ) ) ) ;  try  {   assertThat  (  ref . get  ( ) ,  is  ( obj ) ) ; }  finally  {    ref . get  ( ) . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void biasedClaimMustUpgradeToOrdinaryClaimIfTheObjectIsPulledFromTheQueue  ( )  throws Exception  {   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   AtomicReference  < GenericPoolable >  ref =  new  AtomicReference  < >  ( ) ;   join  (  forkFuture  (  capture  (  $claim  ( pool , zeroTimeout ) , ref ) ) ) ;  try  {   assertThat  (  ref . get  ( ) ,  nullValue  ( ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalStateException . class ) public void depletedPoolThatHasBeenShutDownMustThrowUponClaim  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   pool . shutdown  ( ) ;  try  {   pool . claim  ( longTimeout ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalStateException . class ) public void depletedPoolThatHasBeenShutDownMustThrowUponClaimEvenAfterSomeTime  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   pool . shutdown  ( ) ;   spinwait  ( 10 ) ;  try  {   pool . claim  ( longTimeout ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalStateException . class ) public void poolThatHasBeenShutDownMustThrowUponClaimEvenIfItHasAvailableUnbiasedObjects  ( )  throws Exception  {   config . setSize  ( 4 ) ;   createPool  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;  GenericPoolable  b =  pool . claim  ( longTimeout ) ;  GenericPoolable  c =  pool . claim  ( longTimeout ) ;  GenericPoolable  d =  pool . claim  ( longTimeout ) ;   a . release  ( ) ;   pool . shutdown  ( ) ;   b . release  ( ) ;   c . release  ( ) ;   d . release  ( ) ;   pool . claim  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustNotThrowWhenReleasingObjectClaimedByAnotherThread  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =   forkFuture  (  $claim  ( pool , longTimeout ) ) . get  ( ) ;   obj . release  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustNotCachePoisonedSlots  ( )  throws Exception  {   config . setSize  ( 3 ) ;   final Semaphore  semaphore =  new Semaphore  ( 3 ) ;   final AtomicBoolean  hasExpired =  new AtomicBoolean  ( false ) ;   config . setExpiration  (  expire  (  $expiredIf  ( hasExpired ) ) ) ;   final String  allocationCause = "allocation blew up!" ;   final  AtomicReference  < Slot >  failOnAllocatingSlot =  new  AtomicReference  < >  ( ) ;   final AtomicInteger  observedFailedAllocation =  new AtomicInteger  ( ) ;  Action  observeFailure =   ( slot , obj ) ->  {  if  (  slot ==  failOnAllocatingSlot . get  ( ) )  {   observedFailedAllocation . incrementAndGet  ( ) ;  throw  new RuntimeException  ( allocationCause ) ; }  return  new GenericPoolable  ( slot ) ; } ;   allocator =  allocator  (  alloc  (  $acquire  ( semaphore , observeFailure ) ) ) ;   config . setAllocator  ( allocator ) ;   createPool  ( ) ;  while  (   allocator . countAllocations  ( ) < 3 )  {   Thread . yield  ( ) ; }  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   failOnAllocatingSlot . set  (  obj . slot ) ;   obj . release  ( ) ;   hasExpired . set  ( true ) ;   AtomicReference  < GenericPoolable >  ref =  new  AtomicReference  < >  ( ) ;  try  {    forkFuture  (  capture  (  $claim  ( pool , shortTimeout ) , ref ) ) . get  ( ) ; }  catch (   ExecutionException ignore )  { }   assertNull  (  ref . get  ( ) ) ;   semaphore . release  ( 3 ) ;  while  (   observedFailedAllocation . get  ( ) < 1 )  {   Thread . yield  ( ) ; }   spinwait  ( 5 ) ;   hasExpired . set  ( false ) ;    pool . claim  ( longTimeout ) . release  ( ) ; }    @ Test  (  expected =  IllegalArgumentException . class ) public void targetSizeMustBeGreaterThanZero  ( )  {   createPool  ( ) ;   pool . setTargetSize  ( 0 ) ; }    @ Test public void targetSizeMustBeConfiguredSizeByDefault  ( )  {   config . setSize  ( 23 ) ;   createPool  ( ) ;   assertThat  (  pool . getTargetSize  ( ) ,  is  ( 23 ) ) ; }    @ Test public void getTargetSizeMustReturnLastSetTargetSize  ( )  {   createPool  ( ) ;   pool . setTargetSize  ( 3 ) ;   assertThat  (  pool . getTargetSize  ( ) ,  is  ( 3 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void increasingSizeMustAllowMoreAllocations  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;   pool . setTargetSize  ( 2 ) ;  GenericPoolable  b =  pool . claim  ( longTimeout ) ;   a . release  ( ) ;   b . release  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void decreasingSizeMustEventuallyDeallocateSurplusObjects  ( )  throws Exception  {   int  startingSize = 5 ;   int  newSize = 1 ;   allocator =  allocator  ( ) ;   config . setSize  ( startingSize ) ;   config . setAllocator  ( allocator ) ;   createPool  ( ) ;   List  < GenericPoolable >  objs =  new  ArrayList  < >  ( ) ;  while  (   allocator . countAllocations  ( ) != startingSize )  {   objs . add  (  pool . claim  ( longTimeout ) ) ; }   pool . setTargetSize  ( newSize ) ;  while  (   allocator . countDeallocations  ( ) !=  startingSize - newSize )  {  if  (   objs . size  ( ) > 0 )  {    objs . remove  ( 0 ) . release  ( ) ; } else  {    pool . claim  ( longTimeout ) . release  ( ) ; }   LockSupport . parkNanos  ( 10000000 ) ; }   int  actualSize =   allocator . countAllocations  ( ) -  allocator . countDeallocations  ( ) ;  try  {   assertThat  ( actualSize ,  is  ( newSize ) ) ; }  finally  {  for ( GenericPoolable obj : objs )  {   obj . release  ( ) ; } } }    @ Test  (  timeout = TIMEOUT ) public void mustNotReallocateWhenReleasingExpiredObjectsIntoShrunkPool  ( )  throws Exception  {   int  startingSize = 5 ;   int  newSize = 1 ;   Expiration  < GenericPoolable >  expiration =  expire  ( $fresh , $fresh , $fresh , $fresh , $fresh , $expired ) ;    config . setExpiration  ( expiration ) . setAllocator  ( allocator ) ;   config . setSize  ( startingSize ) ;   createPool  ( ) ;   List  < GenericPoolable >  objs =  new  ArrayList  < >  ( ) ;  for (   int  i = 0 ;  i < startingSize ;  i ++ )  {   objs . add  (  pool . claim  ( longTimeout ) ) ; }   assertThat  (  objs . size  ( ) ,  is  ( startingSize ) ) ;   pool . setTargetSize  ( newSize ) ;  for (   int  i = 0 ;  i <  startingSize - newSize ;  i ++ )  {    objs . remove  ( 0 ) . release  ( ) ; }  try  {   assertThat  (  pool . claim  ( shortTimeout ) ,  nullValue  ( ) ) ;   assertThat  (  allocator . countAllocations  ( ) ,  is  ( startingSize ) ) ; }  finally  {    objs . remove  ( 0 ) . release  ( ) ; } }    @ Test public void settingTargetSizeOnPoolThatHasBeenShutDownDoesNothing  ( )  {   config . setSize  ( 3 ) ;   createPool  ( ) ;   pool . shutdown  ( ) ;   pool . setTargetSize  ( 10 ) ;   assertThat  (  pool . getTargetSize  ( ) ,  is  ( 3 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void increasingAndDecreasingSizeInQuickSuccessionMustEventuallyReachTargetSize  ( )  throws Exception  {   createPool  ( ) ;   pool . setTargetSize  ( 20 ) ;   pool . setTargetSize  ( 1 ) ;   int  deallocations ;   int  allocations ;  do  {   Thread . sleep  ( 1 ) ;   deallocations =  allocator . countDeallocations  ( ) ;   allocations =  allocator . countAllocations  ( ) ; } while  (   allocations - deallocations > 1 ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {   assertThat  (  pool . claim  ( shortTimeout ) ,  nullValue  ( ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void mustNotLeakSlotsIfExpirationThrowsThrowableInsteadOfException  ( )  throws InterruptedException  {   final AtomicBoolean  shouldThrow =  new AtomicBoolean  ( true ) ;   config . setExpiration  (  expire  (  $if  ( shouldThrow ,  $throwExpire  (  new SomeRandomThrowable  ( "Boom!" ) ) , $fresh ) ) ) ;   createPool  ( ) ;  try  {   pool . claim  ( longTimeout ) ;   fail  ( "Expected claim to throw" ) ; }  catch (   PoolException pe )  {   assertThat  (  pe . getCause  ( ) ,  instanceOf  (  SomeRandomThrowable . class ) ) ; }   shouldThrow . set  ( false ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   pool . shutdown  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustProactivelyReallocatePoisonedSlotsWhenAllocatorStopsThrowingExceptions  ( )  throws Exception  {   final CountDownLatch  allocationLatch =  new CountDownLatch  ( 1 ) ;   allocator =  allocator  (  alloc  (  $throw  (  new Exception  ( "boom" ) ) ,  $countDown  ( allocationLatch , $new ) ) ) ;   config . setAllocator  ( allocator ) ;   createPool  ( ) ;   allocationLatch . await  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {   assertThat  ( obj ,  is  (  notNullValue  ( ) ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void mustProactivelyReallocatePoisonedSlotsWhenReallocatorStopsThrowingExceptions  ( )  throws Exception  {   final AtomicBoolean  expired =  new AtomicBoolean  ( ) ;   final CountDownLatch  allocationLatch =  new CountDownLatch  ( 2 ) ;   allocator =  reallocator  (  alloc  (  $countDown  ( allocationLatch , $new ) ) ,  realloc  (  $throw  (  new Exception  ( "boom" ) ) , $new ) ) ;   config . setAllocator  ( allocator ) ;   config . setExpiration  (  expire  (  $expiredIf  ( expired ) ) ) ;   createPool  ( ) ;   expired . set  ( false ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   expired . set  ( true ) ;  GenericPoolable  obj =  pool . claim  ( zeroTimeout ) ;   assertThat  ( obj ,  is  (  nullValue  ( ) ) ) ;   allocationLatch . await  ( ) ;   expired . set  ( false ) ;   obj =  pool . claim  ( longTimeout ) ;  try  {   assertThat  ( obj ,  is  (  notNullValue  ( ) ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void mustProactivelyReallocatePoisonedSlotsWhenAllocatorStopsReturningNull  ( )  throws Exception  {   final CountDownLatch  allocationLatch =  new CountDownLatch  ( 1 ) ;   allocator =  allocator  (  alloc  ( $null ,  $countDown  ( allocationLatch , $new ) ) ) ;   config . setAllocator  ( allocator ) ;   createPool  ( ) ;   allocationLatch . await  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {   assertThat  ( obj ,  is  (  notNullValue  ( ) ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void mustProactivelyReallocatePoisonedSlotsWhenReallocatorStopsReturningNull  ( )  throws Exception  {  AtomicBoolean  expired =  new AtomicBoolean  ( ) ;  CountDownLatch  allocationLatch =  new CountDownLatch  ( 1 ) ;  Semaphore  fixReallocLatch =  new Semaphore  ( 0 ) ;   allocator =  reallocator  (  alloc  ( $new ,  $countDown  ( allocationLatch ,  $acquire  ( fixReallocLatch , $new ) ) ) ,  realloc  ( $null , $new ) ) ;   config . setAllocator  ( allocator ) ;   config . setExpiration  (  expire  (  $expiredIf  ( expired ) ) ) ;   createPool  ( ) ;   expired . set  ( false ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   expired . set  ( true ) ;  GenericPoolable  obj =  pool . claim  ( zeroTimeout ) ;   assertThat  ( obj ,  is  (  nullValue  ( ) ) ) ;   fixReallocLatch . release  ( ) ;   allocationLatch . await  ( ) ;   expired . set  ( false ) ;   obj =  pool . claim  ( longTimeout ) ;  try  {   assertThat  ( obj ,  is  (  notNullValue  ( ) ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void mustNotFrivolouslyReallocateNonPoisonedSlotsDuringEagerRecovery  ( )  throws Exception  {   final CountDownLatch  allocationLatch =  new CountDownLatch  ( 3 ) ;   allocator =  allocator  (  alloc  (  $countDown  ( allocationLatch , $null ) ,  $countDown  ( allocationLatch , $new ) ) ) ;    config . setAllocator  ( allocator ) . setSize  ( 2 ) ;   createPool  ( ) ;   allocationLatch . await  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;  GenericPoolable  b =  pool . claim  ( longTimeout ) ;  try  {   assertThat  (  allocator . countAllocations  ( ) ,  is  ( 3 ) ) ;   assertThat  (  allocator . countDeallocations  ( ) ,  is  ( 0 ) ) ;   assertThat  (  allocator . getDeallocations  ( ) ,  not  (  contains  ( a , b ) ) ) ; }  finally  {   a . release  ( ) ;   b . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void mustCompleteShutdownEvenIfAllocatorEatsTheInterruptSignal  ( )  throws Exception  {   config . setAllocator  (  reallocator  (  alloc  (  $sleep  ( 1000 , $new ) ) ,  realloc  (  $sleep  ( 1000 , $new ) ) ) ) ;   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( mediumTimeout ) ;  if  (  obj != null )  {   obj . release  ( ) ; }    pool . shutdown  ( ) . await  ( longTimeout ) ; }    @ Test  (  timeout = TIMEOUT ) public void poolMustTolerateInterruptedExceptionFromAllocatorWhenNotShutDown  ( )  throws InterruptedException  {   config . setAllocator  (  allocator  (  alloc  (  $throw  (  new InterruptedException  ( "boom" ) ) , $new ) ) ) ;  AtomicBoolean  hasExpired =  new AtomicBoolean  ( ) ;   config . setExpiration  (  expire  (  $expiredIf  ( hasExpired ) ) ) ;   createPool  ( ) ;  try  {    pool . claim  ( longTimeout ) . release  ( ) ; }  catch (   PoolException e )  {   assertThat  (  e . getCause  ( ) ,  instanceOf  (  InterruptedException . class ) ) ; }    pool . claim  ( longTimeout ) . release  ( ) ;   hasExpired . set  ( true ) ;   assertNull  (  pool . claim  ( shortTimeout ) ) ;   hasExpired . set  ( false ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   shutPoolDown  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void poolMustUseConfiguredThreadFactoryWhenCreatingBackgroundThreads  ( )  throws InterruptedException  {   final ThreadFactory  delegateThreadFactory =  config . getThreadFactory  ( ) ;   final  List  < Thread >  createdThreads =  new  ArrayList  < >  ( ) ;  ThreadFactory  factory =  r ->  {  Thread  thread =  delegateThreadFactory . newThread  ( r ) ;   createdThreads . add  ( thread ) ;  return thread ; } ;   config . setThreadFactory  ( factory ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   assertThat  (  createdThreads . size  ( ) ,  is  ( 1 ) ) ;   assertTrue  (   createdThreads . get  ( 0 ) . isAlive  ( ) ) ;    pool . shutdown  ( ) . await  ( longTimeout ) ;   assertThat  (  createdThreads . size  ( ) ,  is  ( 1 ) ) ;  Thread  thread =  createdThreads . get  ( 0 ) ;   thread . join  ( ) ;   assertFalse  (  thread . isAlive  ( ) ) ; }    @ Test public void managedPoolInterfaceMustBeMXBeanConformant  ( )  {   assertTrue  (  JMX . isMXBeanInterface  (  ManagedPool . class ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustBeExposableThroughAnMBeanServerAsAnMXBean  ( )  throws Exception  {   config . setSize  ( 3 ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;  GenericPoolable  b =  pool . claim  ( longTimeout ) ;  GenericPoolable  c =  pool . claim  ( longTimeout ) ;  try  {  MBeanServer  server =  MBeanServerFactory . newMBeanServer  ( "domain" ) ;  ObjectName  name =  new ObjectName  ( "domain:pool=stormpot" ) ;   server . registerMBean  ( managedPool , name ) ;  ManagedPool  proxy =  JMX . newMBeanProxy  ( server , name ,  ManagedPool . class ) ;   assertThat  (  proxy . getAllocationCount  ( ) ,  is  ( 3L ) ) ; }  finally  {   a . release  ( ) ;   b . release  ( ) ;   c . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustCountAllocations  ( )  throws InterruptedException  {  AtomicBoolean  hasExpired =  new AtomicBoolean  ( ) ;   config . setExpiration  (  expire  (  $expiredIf  ( hasExpired ) ) ) ;  CountingReallocator  reallocator =  reallocator  ( ) ;   config . setAllocator  ( reallocator ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   hasExpired . set  ( true ) ;   assertNull  (  pool . claim  ( zeroTimeout ) ) ;   hasExpired . set  ( false ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   long  allocationCount =  managedPool . getAllocationCount  ( ) ;   long  expectedCount =   reallocator . countAllocations  ( ) +  reallocator . countReallocations  ( ) ;   assertThat  ( allocationCount ,  allOf  (  greaterThanOrEqualTo  ( 2L ) ,  equalTo  ( expectedCount ) ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustCountAllocationsFailingWithExceptions  ( )  throws Exception  {  CountDownLatch  latch =  new CountDownLatch  ( 1 ) ;  Exception  exception =  new Exception  ( "boo" ) ;    config . setSize  ( 2 ) . setAllocator  (  allocator  (  alloc  ( $new ,  $throw  ( exception ) ,  $throw  ( exception ) ,  $countDown  ( latch , $new ) ) ) ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   latch . await  ( ) ;   assertThat  (  managedPool . getFailedAllocationCount  ( ) ,  is  ( 2L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustCountAllocationsFailingByReturningNull  ( )  throws Exception  {    config . setSize  ( 2 ) . setAllocator  (  allocator  (  alloc  ( $new , $null , $null , $new ) ) ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;  GenericPoolable  a = null ;  GenericPoolable  b = null ;  do  {  try  {   a =  pool . claim  ( longTimeout ) ; }  catch (   PoolException ignore )  { } } while  (  a == null ) ;  do  {  try  {   b =  pool . claim  ( longTimeout ) ; }  catch (   PoolException ignore )  { } } while  (  b == null ) ;   a . release  ( ) ;   b . release  ( ) ;   assertThat  (  managedPool . getFailedAllocationCount  ( ) ,  is  ( 2L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustCountReallocationsFailingWithExceptions  ( )  throws Exception  {   config . setSize  ( 1 ) ;  Exception  exception =  new Exception  ( "boo" ) ;   config . setAllocator  (  reallocator  (  realloc  (  $throw  ( exception ) , $new ) ) ) ;   config . setExpiration  (  expire  ( $expired , $fresh ) ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;  GenericPoolable  obj = null ;  do  {  try  {   obj =  pool . claim  ( longTimeout ) ; }  catch (   PoolException ignore )  { } } while  (  obj == null ) ;   obj . release  ( ) ;   assertThat  (  managedPool . getFailedAllocationCount  ( ) ,  is  ( 1L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustCountReallocationsFailingByReturningNull  ( )  throws Exception  {   config . setSize  ( 1 ) ;   config . setAllocator  (  reallocator  (  realloc  ( $null , $new ) ) ) ;   config . setExpiration  (  expire  ( $expired , $fresh ) ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;  GenericPoolable  obj = null ;  do  {  try  {   obj =  pool . claim  ( longTimeout ) ; }  catch (   PoolException ignore )  { } } while  (  obj == null ) ;   obj . release  ( ) ;   assertThat  (  managedPool . getFailedAllocationCount  ( ) ,  is  ( 1L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustAllowGettingAndSettingPoolTargetSize  ( )  {   config . setSize  ( 2 ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   assertThat  (  managedPool . getTargetSize  ( ) ,  is  ( 2 ) ) ;   managedPool . setTargetSize  ( 5 ) ;   assertThat  (  managedPool . getTargetSize  ( ) ,  is  ( 5 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustGivePoolState  ( )  {  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   assertFalse  (  managedPool . isShutDown  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustReturnNaNWhenNoMetricsRecorderHasBeenConfigured  ( )  {  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   assertThat  (  managedPool . getAllocationLatencyPercentile  ( 0.5 ) ,  is  (  Double . NaN ) ) ;   assertThat  (  managedPool . getObjectLifetimePercentile  ( 0.5 ) ,  is  (  Double . NaN ) ) ;   assertThat  (  managedPool . getAllocationFailureLatencyPercentile  ( 0.5 ) ,  is  (  Double . NaN ) ) ;   assertThat  (  managedPool . getReallocationLatencyPercentile  ( 0.5 ) ,  is  (  Double . NaN ) ) ;   assertThat  (  managedPool . getReallocationFailureLatencyPercentile  ( 0.5 ) ,  is  (  Double . NaN ) ) ;   assertThat  (  managedPool . getDeallocationLatencyPercentile  ( 0.5 ) ,  is  (  Double . NaN ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustGetLatencyPercentilesFromConfiguredMetricsRecorder  ( )  {   config . setMetricsRecorder  (  new FixedMeanMetricsRecorder  ( 1.37 , 2.37 , 3.37 , 4.37 , 5.37 , 6.37 ) ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   assertThat  (  managedPool . getObjectLifetimePercentile  ( 0.5 ) ,  is  ( 1.37 ) ) ;   assertThat  (  managedPool . getAllocationLatencyPercentile  ( 0.5 ) ,  is  ( 2.37 ) ) ;   assertThat  (  managedPool . getAllocationFailureLatencyPercentile  ( 0.5 ) ,  is  ( 3.37 ) ) ;   assertThat  (  managedPool . getReallocationLatencyPercentile  ( 0.5 ) ,  is  ( 4.37 ) ) ;   assertThat  (  managedPool . getReallocationFailureLatencyPercentile  ( 0.5 ) ,  is  ( 5.37 ) ) ;   assertThat  (  managedPool . getDeallocationLatencyPercentile  ( 0.5 ) ,  is  ( 6.37 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustRecordObjectLifetimeOnDeallocateInConfiguredMetricsRecorder  ( )  throws InterruptedException  {  CountDownLatch  deallocLatch =  new CountDownLatch  ( 1 ) ;   config . setMetricsRecorder  (  new LastSampleMetricsRecorder  ( ) ) ;   config . setSize  ( 2 ) ;   config . setAllocator  (  reallocator  (  dealloc  (  $countDown  ( deallocLatch , $null ) ) ) ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;  GenericPoolable  b =  pool . claim  ( longTimeout ) ;   spinwait  ( 5 ) ;   a . release  ( ) ;   b . release  ( ) ;   pool . setTargetSize  ( 1 ) ;   deallocLatch . await  ( ) ;   assertThat  (  managedPool . getObjectLifetimePercentile  ( 0.0 ) ,  allOf  (  greaterThanOrEqualTo  ( 5.0 ) ,  not  (  Double . NaN ) ,  lessThan  ( 50000.0 ) ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustNotRecordObjectLifetimeLatencyBeforeFirstDeallocation  ( )  throws InterruptedException  {   config . setMetricsRecorder  (  new LastSampleMetricsRecorder  ( ) ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {   assertThat  (  managedPool . getObjectLifetimePercentile  ( 0.0 ) ,  is  (  Double . NaN ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustRecordObjectLifetimeOnReallocateInConfiguredMetricsRecorder  ( )  throws InterruptedException  {   config . setMetricsRecorder  (  new LastSampleMetricsRecorder  ( ) ) ;  Semaphore  semaphore =  new Semaphore  ( 0 ) ;   config . setAllocator  (  reallocator  (  realloc  (  $acquire  ( semaphore , $new ) , $new ) ) ) ;  AtomicBoolean  hasExpired =  new AtomicBoolean  ( ) ;   config . setExpiration  (  expire  (  $expiredIf  ( hasExpired ) ) ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   spinwait  ( 5 ) ;   obj . release  ( ) ;   hasExpired . set  ( true ) ;   assertNull  (  pool . claim  ( zeroTimeout ) ) ;   hasExpired . set  ( false ) ;   semaphore . release  ( 1 ) ;   obj =  pool . claim  ( longTimeout ) ;  try  {   assertThat  (  managedPool . getObjectLifetimePercentile  ( 0.0 ) ,  allOf  (  greaterThanOrEqualTo  ( 5.0 ) ,  not  (  Double . NaN ) ,  lessThan  ( 50000.0 ) ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void managedPoolLeakedObjectCountMustStartAtZero  ( )  {  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   assertThat  (  managedPool . getLeakedObjectsCount  ( ) ,  is  ( 0L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustCountLeakedObjects  ( )  throws Exception  {   config . setSize  ( 2 ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   pool . claim  ( longTimeout ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   allocator . clearLists  ( ) ;   System . gc  ( ) ;   System . gc  ( ) ;   System . gc  ( ) ;   pool = null ;   assertThat  (  managedPool . getLeakedObjectsCount  ( ) ,  is  ( 1L ) ) ; }    @ SuppressWarnings  ( "UnusedAssignment" )  @ Test  (  timeout = TIMEOUT ) public void mustNotHoldOnToDeallocatedObjectsWhenLeakDetectionIsEnabled  ( )  throws Exception  {  AtomicBoolean  hasExpired =  new AtomicBoolean  ( ) ;   config . setExpiration  (  expire  (  $expiredIf  ( hasExpired ) ) ) ;   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   WeakReference  < GenericPoolable >  weakReference =  new  WeakReference  < >  ( obj ) ;   obj . release  ( ) ;   obj = null ;   hasExpired . set  ( true ) ;   obj =  pool . claim  ( zeroTimeout ) ;  if  (  obj != null )  {   obj . release  ( ) ; }   hasExpired . set  ( false ) ;    pool . claim  ( longTimeout ) . release  ( ) ;   allocator . clearLists  ( ) ;   System . gc  ( ) ;   System . gc  ( ) ;   System . gc  ( ) ;   assertNull  (  weakReference . get  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustNotHoldOnToDeallocatedObjectsWhenLeakDetectionIsDisabled  ( )  throws Exception  {   config . setPreciseLeakDetectionEnabled  ( false ) ;   mustNotHoldOnToDeallocatedObjectsWhenLeakDetectionIsEnabled  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustNotCountShutDownAsLeak  ( )  throws Exception  {   config . setSize  ( 2 ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   claimRelease  ( 2 , pool , longTimeout ) ;    pool . shutdown  ( ) . await  ( longTimeout ) ;   allocator . clearLists  ( ) ;   System . gc  ( ) ;   System . gc  ( ) ;   System . gc  ( ) ;   assertThat  (  managedPool . getLeakedObjectsCount  ( ) ,  is  ( 0L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustNotCountResizeAsLeak  ( )  throws Exception  {   config . setSize  ( 2 ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   claimRelease  ( 2 , pool , longTimeout ) ;   managedPool . setTargetSize  ( 4 ) ;   claimRelease  ( 4 , pool , longTimeout ) ;   managedPool . setTargetSize  ( 1 ) ;  while  (   allocator . countDeallocations  ( ) < 3 )  {   spinwait  ( 1 ) ; }   allocator . clearLists  ( ) ;   System . gc  ( ) ;   System . gc  ( ) ;   System . gc  ( ) ;   assertThat  (  managedPool . getLeakedObjectsCount  ( ) ,  is  ( 0L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void managedPoolMustReturnMinusOneForLeakedObjectCountWhenDetectionIsDisabled  ( )  {   config . setPreciseLeakDetectionEnabled  ( false ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   assertThat  (  managedPool . getLeakedObjectsCount  ( ) ,  is  (  - 1L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void disabledLeakDetectionMustNotBreakResize  ( )  throws Exception  {   config . setPreciseLeakDetectionEnabled  ( false ) ;   config . setSize  ( 2 ) ;  ManagedPool  managedPool =  assumeManagedPool  ( ) ;   claimRelease  ( 2 , pool , longTimeout ) ;   pool . setTargetSize  ( 6 ) ;   claimRelease  ( 6 , pool , longTimeout ) ;   pool . setTargetSize  ( 2 ) ;  while  (   allocator . countDeallocations  ( ) < 4 )  {   spinwait  ( 1 ) ; }   assertThat  (  managedPool . getLeakedObjectsCount  ( ) ,  is  (  - 1L ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustCheckObjectExpirationInBackgroundWhenEnabled  ( )  throws Exception  {  CountDownLatch  latch =  new CountDownLatch  ( 1 ) ;  CountingReallocator  reallocator =  reallocator  ( ) ;  CountingExpiration  expiration =  expire  ( $expired ,  $countDown  ( latch , $fresh ) ) ;   config . setExpiration  ( expiration ) ;   config . setAllocator  ( reallocator ) ;   config . setBackgroundExpirationEnabled  ( true ) ;   createPool  ( ) ;   latch . await  ( ) ;   assertThat  (  reallocator . countAllocations  ( ) ,  is  ( 1 ) ) ;   assertThat  (  reallocator . countDeallocations  ( ) ,  is  ( 0 ) ) ;   assertThat  (  reallocator . countReallocations  ( ) ,  is  ( 1 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void objectMustBeClaimableAfterBackgroundReallocation  ( )  throws Exception  {  CountDownLatch  latch =  new CountDownLatch  ( 1 ) ;  CountingExpiration  expiration =  expire  (  $countDown  ( latch , $expired ) , $fresh ) ;   config . setExpiration  ( expiration ) ;   config . setBackgroundExpirationEnabled  ( true ) ;   createPool  ( ) ;   latch . await  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustNotReallocateObjectsThatAreNotExpiredByTheBackgroundCheck  ( )  throws Exception  {  CountDownLatch  latch =  new CountDownLatch  ( 2 ) ;  CountingExpiration  expiration =  expire  (  $countDown  ( latch , $fresh ) ) ;  CountingReallocator  reallocator =  reallocator  ( ) ;   config . setExpiration  ( expiration ) ;   config . setBackgroundExpirationEnabled  ( true ) ;   createPool  ( ) ;   latch . await  ( ) ;   assertThat  (  reallocator . countReallocations  ( ) ,  is  ( 0 ) ) ;   assertThat  (  reallocator . countDeallocations  ( ) ,  is  ( 0 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void backgroundExpirationMustExpireObjectsWhenExpirationThrows  ( )  throws Exception  {  CountDownLatch  latch =  new CountDownLatch  ( 1 ) ;  CountingExpiration  expiration =  expire  (  $throwExpire  (  new Exception  ( ) ) ,  $countDown  ( latch , $fresh ) ) ;   config . setExpiration  ( expiration ) ;   config . setBackgroundExpirationEnabled  ( true ) ;   createPool  ( ) ;   latch . await  ( ) ;   assertThat  (  allocator . countAllocations  ( ) ,  is  ( 2 ) ) ;   assertThat  (  allocator . countDeallocations  ( ) ,  is  ( 1 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void backgroundExpirationMustNotExpireObjectsThatAreClaimed  ( )  throws Exception  {  AtomicBoolean  hasExpired =  new AtomicBoolean  ( ) ;  CountDownLatch  latch =  new CountDownLatch  ( 4 ) ;  CountingExpiration  expiration =  expire  (  $countDown  ( latch ,  $expiredIf  ( hasExpired ) ) ) ;   config . setExpiration  ( expiration ) ;   config . setBackgroundExpirationEnabled  ( true ) ;   config . setSize  ( 2 ) ;   createPool  ( ) ;    pool . claim  ( longTimeout ) . release  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   hasExpired . set  ( true ) ;   latch . await  ( ) ;   hasExpired . set  ( false ) ;   List  < GenericPoolable >  deallocations =  allocator . getDeallocations  ( ) ;  synchronized  ( deallocations )  {   assertThat  ( deallocations ,  not  (  hasItem  ( obj ) ) ) ; }   obj . release  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustDeallocateExplicitlyExpiredObjects  ( )  throws Exception  {   int  poolSize = 2 ;   config . setSize  ( poolSize ) ;   createPool  ( ) ;  for (   int  i = 0 ;  i < poolSize ;  i ++ )  {  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   obj . expire  ( ) ;   obj . release  ( ) ; }   List  < GenericPoolable >  objs =  new  ArrayList  < >  ( ) ;  for (   int  i = 0 ;  i < poolSize ;  i ++ )  {   objs . add  (  pool . claim  ( longTimeout ) ) ; }  for ( GenericPoolable obj : objs )  {   obj . release  ( ) ; }   assertThat  ( "allocations" ,  allocator . countAllocations  ( ) ,  is  (  2 * poolSize ) ) ;   assertThat  ( "deallocations" ,  allocator . countDeallocations  ( ) ,  is  ( poolSize ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustReallocateExplicitlyExpiredObjectsInBackgroundWithBackgroundExpiration  ( )  throws Exception  {  CountDownLatch  latch =  new CountDownLatch  ( 2 ) ;   allocator =  allocator  (  alloc  (  $countDown  ( latch , $new ) ) ) ;    config . setAllocator  ( allocator ) . setSize  ( 1 ) ;   config . setBackgroundExpirationEnabled  ( true ) ;   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   obj . expire  ( ) ;   obj . release  ( ) ;   latch . await  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustReallocateExplicitlyExpiredObjectsInBackgroundWithoutBgExpiration  ( )  throws Exception  {  CountDownLatch  latch =  new CountDownLatch  ( 2 ) ;   allocator =  allocator  (  alloc  (  $countDown  ( latch , $new ) ) ) ;    config . setAllocator  ( allocator ) . setSize  ( 1 ) ;   config . setBackgroundExpirationEnabled  ( false ) ;   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   obj . expire  ( ) ;   obj . release  ( ) ;   latch . await  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void mustReplaceExplicitlyExpiredObjectsEvenIfDeallocationFails  ( )  throws Exception  {   allocator =  allocator  (  dealloc  (  $throw  (  new Exception  ( "Boom!" ) ) ) ) ;    config . setAllocator  ( allocator ) . setSize  ( 1 ) ;   createPool  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;   a . expire  ( ) ;   a . release  ( ) ;  GenericPoolable  b =  pool . claim  ( longTimeout ) ;   b . release  ( ) ;   assertThat  ( a ,  not  (  sameInstance  ( b ) ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void explicitExpiryFromExpirationMustAllowOneClaimPerObject  ( )  throws Exception  {   config . setExpiration  (  expire  ( $explicitExpire ) ) ;   createPool  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;   a . release  ( ) ;  GenericPoolable  b =  pool . claim  ( longTimeout ) ;   b . release  ( ) ;   assertThat  ( a ,  not  (  sameInstance  ( b ) ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void explicitlyExpiryMustBeIdempotent  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  a =  pool . claim  ( longTimeout ) ;   a . expire  ( ) ;   a . expire  ( ) ;   a . expire  ( ) ;   a . release  ( ) ;  GenericPoolable  b =  pool . claim  ( longTimeout ) ;   b . release  ( ) ;   assertThat  ( a ,  not  (  sameInstance  ( b ) ) ) ;   assertThat  (  allocator . countAllocations  ( ) ,  is  ( 2 ) ) ;   assertThat  (  allocator . countDeallocations  ( ) ,  is  ( 1 ) ) ; }   private static final  Consumer  < GenericPoolable >  nullConsumer =   ( obj ) ->  { } ;    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalArgumentException . class ) public void applyMustThrowOnNullTimeout  ( )  throws Exception  {   createPool  ( ) ;   pool . apply  ( null ,  identity  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalArgumentException . class ) public void supplyMustThrowOnNullTimeout  ( )  throws Exception  {   createPool  ( ) ;   pool . supply  ( null , nullConsumer ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  NullPointerException . class ) public void applyMustThrowOnNullFunction  ( )  throws Exception  {   createPool  ( ) ;   pool . apply  ( longTimeout , null ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  NullPointerException . class ) public void supplyMustThrowOnNullConsumer  ( )  throws Exception  {   createPool  ( ) ;   pool . supply  ( longTimeout , null ) ; }    @ Test  (  timeout = TIMEOUT ) public void applyMustReturnEmptyIfTimeoutElapses  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {   assertFalse  (   pool . apply  ( shortTimeout ,  identity  ( ) ) . isPresent  ( ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void supplyMustReturnFalseIfTimeoutElapses  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {   assertFalse  (  pool . supply  ( shortTimeout , nullConsumer ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void applyMustNotCallFunctionIfTimeoutElapses  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {  AtomicInteger  counter =  new AtomicInteger  ( ) ;   pool . apply  ( shortTimeout ,   ( x ) ->  ( Object )  counter . incrementAndGet  ( ) ) ;   assertThat  (  counter . get  ( ) ,  is  ( 0 ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void supplyMustNotCallConsumerIfTimeoutElapses  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  try  {   AtomicReference  < GenericPoolable >  ref =  new  AtomicReference  < >  ( ) ;   pool . supply  ( shortTimeout ,  ref :: set ) ;   assertThat  (  ref . get  ( ) ,  is  (  nullValue  ( ) ) ) ; }  finally  {   obj . release  ( ) ; } }    @ Test  (  timeout = TIMEOUT ) public void applyMustCallFunctionIfObjectClaimedWithinTimeout  ( )  throws Exception  {   createPool  ( ) ;  AtomicInteger  counter =  new AtomicInteger  ( ) ;   pool . apply  ( longTimeout ,   ( x ) ->  ( Object )  counter . incrementAndGet  ( ) ) ;   assertThat  (  counter . get  ( ) ,  is  ( 1 ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void supplyMustCallConsumerIfObjectClaimedWithinTimeout  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   obj . release  ( ) ;   AtomicReference  < GenericPoolable >  ref =  new  AtomicReference  < >  ( ) ;   pool . supply  ( shortTimeout ,  ref :: set ) ;   assertThat  (  ref . get  ( ) ,  is  (  sameInstance  ( obj ) ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void applyMustReturnResultOfFunction  ( )  throws Exception  {   createPool  ( ) ;  String  expectedResult = "Result!" ;   Optional  < String >  actualResult =  pool . apply  ( longTimeout ,   ( obj ) -> expectedResult ) ;   assertTrue  (  actualResult . isPresent  ( ) ) ;   assertThat  (  actualResult . get  ( ) ,  is  ( expectedResult ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void applyMustReturnEmptyIfFunctionReturnsNull  ( )  throws Exception  {   createPool  ( ) ;   assertThat  (  pool . apply  ( longTimeout ,   ( obj ) -> null ) ,  is  (  Optional . empty  ( ) ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void applyMustReleaseClaimedObject  ( )  throws Exception  {   createPool  ( ) ;   pool . apply  ( longTimeout ,  identity  ( ) ) ;   pool . apply  ( longTimeout ,  identity  ( ) ) ;    fork  (   ( ) ->  pool . apply  ( longTimeout ,  identity  ( ) ) ) . join  ( ) ;    fork  (   ( ) ->  pool . apply  ( longTimeout ,  identity  ( ) ) ) . join  ( ) ;   pool . apply  ( longTimeout ,  identity  ( ) ) ;   pool . apply  ( longTimeout ,  identity  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void supplyMustReleaseClaimedObject  ( )  throws Exception  {   createPool  ( ) ;   pool . supply  ( longTimeout , nullConsumer ) ;   pool . supply  ( longTimeout , nullConsumer ) ;    fork  (   ( ) ->  pool . supply  ( longTimeout , nullConsumer ) ) . join  ( ) ;    fork  (   ( ) ->  pool . supply  ( longTimeout , nullConsumer ) ) . join  ( ) ;   pool . supply  ( longTimeout , nullConsumer ) ;   pool . supply  ( longTimeout , nullConsumer ) ; }   private static Object expectException  (   Callable  <  ? > callable )  {  try  {   callable . call  ( ) ;   fail  ( "The ExpectedException was not thrown" ) ; }  catch (   ExpectedException ignore )  { }  catch (   Exception e )  {  throw  new AssertionError  ( "Failed for other reason" , e ) ; }  return null ; }    @ Test  (  timeout = TIMEOUT ) public void applyMustReleaseClaimedObjectEvenIfFunctionThrows  ( )  throws Exception  {   createPool  ( ) ;   Function  < GenericPoolable , Object >  thrower =   ( obj ) ->  {  throw  new ExpectedException  ( ) ; } ;   expectException  (   ( ) ->  pool . apply  ( longTimeout , thrower ) ) ;   expectException  (   ( ) ->  pool . apply  ( longTimeout , thrower ) ) ;    fork  (   ( ) ->  expectException  (   ( ) ->  pool . apply  ( longTimeout , thrower ) ) ) . join  ( ) ;    fork  (   ( ) ->  expectException  (   ( ) ->  pool . apply  ( longTimeout , thrower ) ) ) . join  ( ) ;   expectException  (   ( ) ->  pool . apply  ( longTimeout , thrower ) ) ;   expectException  (   ( ) ->  pool . apply  ( longTimeout , thrower ) ) ; }    @ Test  (  timeout = TIMEOUT ) public void supplyMustReleaseClaimedObjectEvenIfConsumerThrows  ( )  throws Exception  {   createPool  ( ) ;   Consumer  < GenericPoolable >  thrower =   ( obj ) ->  {  throw  new ExpectedException  ( ) ; } ;   expectException  (   ( ) ->  pool . supply  ( longTimeout , thrower ) ) ;   expectException  (   ( ) ->  pool . supply  ( longTimeout , thrower ) ) ;    fork  (   ( ) ->  expectException  (   ( ) ->  pool . supply  ( longTimeout , thrower ) ) ) . join  ( ) ;    fork  (   ( ) ->  expectException  (   ( ) ->  pool . supply  ( longTimeout , thrower ) ) ) . join  ( ) ;   expectException  (   ( ) ->  pool . supply  ( longTimeout , thrower ) ) ;   expectException  (   ( ) ->  pool . supply  ( longTimeout , thrower ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalStateException . class ) public void applyMustThrowIfThePoolIsShutDown  ( )  throws Exception  {   createPool  ( ) ;    pool . shutdown  ( ) . await  ( longTimeout ) ;   pool . apply  ( longTimeout ,  identity  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalStateException . class ) public void supplyMustThrowIfThePoolIsShutDown  ( )  throws Exception  {   createPool  ( ) ;    pool . shutdown  ( ) . await  ( longTimeout ) ;   pool . supply  ( longTimeout , nullConsumer ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalStateException . class ) public void shuttingPoolDownMustUnblockApplyAndThrow  ( )  throws Throwable  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  Thread  thread =  fork  (   ( ) ->  pool . apply  ( longTimeout ,  identity  ( ) ) ) ;   AtomicReference  < Throwable >  exception =  capture  ( thread ) ;   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ;  Completion  shutdown =  pool . shutdown  ( ) ;   join  ( thread ) ;   obj . release  ( ) ;   shutdown . await  ( longTimeout ) ;  throw  exception . get  ( ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  IllegalStateException . class ) public void shuttingPoolDownMustUnblockSupplyAndThrow  ( )  throws Throwable  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  Thread  thread =  fork  (   ( ) ->  pool . supply  ( longTimeout , nullConsumer ) ) ;   AtomicReference  < Throwable >  exception =  capture  ( thread ) ;   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ;  Completion  shutdown =  pool . shutdown  ( ) ;   join  ( thread ) ;   obj . release  ( ) ;   shutdown . await  ( longTimeout ) ;  throw  exception . get  ( ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  InterruptedException . class ) public void applyMustThrowOnInterrupt  ( )  throws Exception  {   createPool  ( ) ;    Thread . currentThread  ( ) . interrupt  ( ) ;   pool . apply  ( longTimeout ,  identity  ( ) ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  InterruptedException . class ) public void supplyMustThrowOnInterrupt  ( )  throws Exception  {   createPool  ( ) ;    Thread . currentThread  ( ) . interrupt  ( ) ;   pool . supply  ( longTimeout , nullConsumer ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  InterruptedException . class ) public void blockedApplyMustThrowOnInterrupt  ( )  throws Throwable  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  Thread  thread =  fork  (   ( ) ->  pool . apply  ( longTimeout ,  identity  ( ) ) ) ;   AtomicReference  < Throwable >  exception =  capture  ( thread ) ;   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ;   thread . interrupt  ( ) ;   join  ( thread ) ;   obj . release  ( ) ;  throw  exception . get  ( ) ; }    @ Test  (  timeout = TIMEOUT ,  expected =  InterruptedException . class ) public void blockedSupplyMustThrowOnInterrupt  ( )  throws Throwable  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  Thread  thread =  fork  (   ( ) ->  pool . supply  ( longTimeout , nullConsumer ) ) ;   AtomicReference  < Throwable >  exception =  capture  ( thread ) ;   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ;   thread . interrupt  ( ) ;   join  ( thread ) ;   obj . release  ( ) ;  throw  exception . get  ( ) ; }    @ Test  (  timeout = TIMEOUT ) public void applyMustUnblockByConcurrentRelease  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  Thread  thread =  fork  (   ( ) ->  pool . apply  ( longTimeout ,  identity  ( ) ) ) ;   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ;   obj . release  ( ) ;   join  ( thread ) ; }    @ Test  (  timeout = TIMEOUT ) public void supplyMustUnblockByConcurrentRelease  ( )  throws Exception  {   createPool  ( ) ;  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;  Thread  thread =  fork  (   ( ) ->  pool . supply  ( longTimeout , nullConsumer ) ) ;   waitForThreadState  ( thread ,   Thread . State . TIMED_WAITING ) ;   obj . release  ( ) ;   join  ( thread ) ; } 
<<<<<<<
=======
   @ Test  (  timeout = 601 )  @ Theory public void mustNotCachePoisonedSlots  (  PoolFixture fixture )  throws Exception  {   config . setSize  ( 3 ) ;   final Semaphore  semaphore =  new Semaphore  ( 3 ) ;   final AtomicBoolean  hasExpired =  new AtomicBoolean  ( false ) ;   config . setExpiration  (  expire  (  $expiredIf  ( hasExpired ) ) ) ;   final String  allocationCause = "allocation blew up!" ;   final  AtomicReference  < Slot >  failOnAllocatingSlot =  new  AtomicReference  < Slot >  ( ) ;   final AtomicInteger  observedFailedAllocation =  new AtomicInteger  ( ) ;  Action  observeFailure =  new Action  ( )  {    @ Override public GenericPoolable apply  (  Slot slot ,  GenericPoolable obj )  throws Exception  {  if  (  slot ==  failOnAllocatingSlot . get  ( ) )  {   observedFailedAllocation . incrementAndGet  ( ) ;  throw  new RuntimeException  ( allocationCause ) ; }  return  new GenericPoolable  ( slot ) ; } } ;   allocator =  allocator  (  alloc  (  $acquire  ( semaphore , observeFailure ) ) ) ;   config . setAllocator  ( allocator ) ;   createPool  ( fixture ) ;  while  (   allocator . countAllocations  ( ) < 3 )  {   Thread . yield  ( ) ; }  GenericPoolable  obj =  pool . claim  ( longTimeout ) ;   failOnAllocatingSlot . set  (  obj . slot ) ;   obj . release  ( ) ;   hasExpired . set  ( true ) ;   AtomicReference  < GenericPoolable >  ref =  new  AtomicReference  < GenericPoolable >  ( ) ;  try  {    forkFuture  (  capture  (  $claim  ( pool , shortTimeout ) , ref ) ) . get  ( ) ; }  catch (   ExecutionException ignore )  { }   assertNull  (  ref . get  ( ) ) ;   semaphore . release  ( 3 ) ;  while  (   observedFailedAllocation . get  ( ) < 1 )  {   Thread . yield  ( ) ; }   spinwait  ( 15 ) ;   hasExpired . set  ( false ) ;    pool . claim  ( longTimeout ) . release  ( ) ; }
>>>>>>>
 }