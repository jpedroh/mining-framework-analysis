  package    org . apache . commons . collections4 ;   import   java . io . ByteArrayInputStream ;  import   java . io . ByteArrayOutputStream ;  import   java . io . File ;  import   java . io . FileInputStream ;  import   java . io . FileOutputStream ;  import   java . io . IOException ;  import   java . io . InputStream ;  import   java . io . ObjectInputStream ;  import   java . io . ObjectOutputStream ;  import   java . io . OutputStream ;  import   java . io . Serializable ;   public abstract class AbstractObjectTest  extends BulkTest  {   public static final  int  COLLECTIONS_MAJOR_VERSION = 4 ;   public AbstractObjectTest  (   final String testName )  {  super  ( testName ) ; }   public abstract Object makeObject  ( ) ;   public boolean supportsEmptyCollections  ( )  {  return true ; }   public boolean supportsFullCollections  ( )  {  return true ; }   public boolean isTestSerialization  ( )  {  return true ; }   public boolean isEqualsCheckable  ( )  {  return true ; }   public void testObjectEqualsSelf  ( )  {   final Object  obj =  makeObject  ( ) ;   assertEquals  ( obj , obj ) ; }   public void testEqualsNull  ( )  {   final Object  obj =  makeObject  ( ) ;   assertEquals  ( false ,  obj . equals  ( null ) ) ; }   public void testObjectHashCodeEqualsSelfHashCode  ( )  {   final Object  obj =  makeObject  ( ) ;   assertEquals  (  obj . hashCode  ( ) ,  obj . hashCode  ( ) ) ; }   public void testObjectHashCodeEqualsContract  ( )  {   final Object  obj1 =  makeObject  ( ) ;  if  (  obj1 . equals  ( obj1 ) )  {   assertEquals  (  obj1 . hashCode  ( ) ,  obj1 . hashCode  ( ) ) ; }   final Object  obj2 =  makeObject  ( ) ;  if  (  obj1 . equals  ( obj2 ) )  {   assertEquals  (  obj1 . hashCode  ( ) ,  obj2 . hashCode  ( ) ) ;   assertTrue  (  obj2 . equals  ( obj1 ) ) ; } }   protected Object serializeDeserialize  (   final Object obj )  throws Exception  {   final ByteArrayOutputStream  buffer =  new ByteArrayOutputStream  ( ) ;   final ObjectOutputStream  out =  new ObjectOutputStream  ( buffer ) ;   out . writeObject  ( obj ) ;   out . close  ( ) ;   final ObjectInputStream  in =  new ObjectInputStream  (  new ByteArrayInputStream  (  buffer . toByteArray  ( ) ) ) ;   final Object  dest =  in . readObject  ( ) ;   in . close  ( ) ;  return dest ; }   public void testSerializeDeserializeThenCompare  ( )  throws Exception  {   final Object  obj =  makeObject  ( ) ;  if  (   obj instanceof Serializable &&  isTestSerialization  ( ) )  {   final Object  dest =  serializeDeserialize  ( obj ) ;  if  (  isEqualsCheckable  ( ) )  {   assertEquals  ( obj , dest ) ; } } }   public void testSimpleSerialization  ( )  throws Exception  {   final Object  o =  makeObject  ( ) ;  if  (   o instanceof Serializable &&  isTestSerialization  ( ) )  {   final   byte  [ ]  objekt =  writeExternalFormToBytes  (  ( Serializable ) o ) ;   readExternalFormFromBytes  ( objekt ) ; } }   public void testCanonicalEmptyCollectionExists  ( )  {  if  (    supportsEmptyCollections  ( ) &&  isTestSerialization  ( ) &&  !  skipSerializedCanonicalTests  ( ) )  {   final Object  object =  makeObject  ( ) ;  if  (  object instanceof Serializable )  {   final String  name =  getCanonicalEmptyCollectionName  ( object ) ;   assertTrue  ( 
<<<<<<<
=======
  "Canonical empty collection (" + name + ") is not in SCM"
>>>>>>>
   new File  ( name ) . exists  ( ) ) ; } } }   public void testCanonicalFullCollectionExists  ( )  {  if  (    supportsFullCollections  ( ) &&  isTestSerialization  ( ) &&  !  skipSerializedCanonicalTests  ( ) )  {   final Object  object =  makeObject  ( ) ;  if  (  object instanceof Serializable )  {   final String  name =  getCanonicalFullCollectionName  ( object ) ;   assertTrue  ( 
<<<<<<<
=======
  "Canonical full collection (" + name + ") is not in SCM"
>>>>>>>
   new File  ( name ) . exists  ( ) ) ; } } }   public String getCompatibilityVersion  ( )  {  return "4" ; }   protected String getCanonicalEmptyCollectionName  (   final Object object )  {   final StringBuilder  retval =  new StringBuilder  ( ) ;   retval . append  ( TEST_DATA_PATH ) ;  String  colName =   object . getClass  ( ) . getName  ( ) ;   colName =  colName . substring  (   colName . lastIndexOf  ( "." ) + 1 ,  colName . length  ( ) ) ;   retval . append  ( colName ) ;   retval . append  ( ".emptyCollection.version" ) ;   retval . append  (  getCompatibilityVersion  ( ) ) ;   retval . append  ( ".obj" ) ;  return  retval . toString  ( ) ; }   protected String getCanonicalFullCollectionName  (   final Object object )  {   final StringBuilder  retval =  new StringBuilder  ( ) ;   retval . append  ( TEST_DATA_PATH ) ;  String  colName =   object . getClass  ( ) . getName  ( ) ;   colName =  colName . substring  (   colName . lastIndexOf  ( "." ) + 1 ,  colName . length  ( ) ) ;   retval . append  ( colName ) ;   retval . append  ( ".fullCollection.version" ) ;   retval . append  (  getCompatibilityVersion  ( ) ) ;   retval . append  ( ".obj" ) ;  return  retval . toString  ( ) ; }   protected void writeExternalFormToDisk  (   final Serializable o ,   final String path )  throws IOException  {   final FileOutputStream  fileStream =  new FileOutputStream  ( path ) ;  try  {   writeExternalFormToStream  ( o , fileStream ) ; }  finally  {   fileStream . close  ( ) ; } }   protected   byte  [ ] writeExternalFormToBytes  (   final Serializable o )  throws IOException  {   final ByteArrayOutputStream  byteStream =  new ByteArrayOutputStream  ( ) ;   writeExternalFormToStream  ( o , byteStream ) ;  return  byteStream . toByteArray  ( ) ; }   protected Object readExternalFormFromDisk  (   final String path )  throws IOException , ClassNotFoundException  {   final FileInputStream  stream =  new FileInputStream  ( path ) ;  try  {  return  readExternalFormFromStream  ( stream ) ; }  finally  {   stream . close  ( ) ; } }   protected Object readExternalFormFromBytes  (   final   byte  [ ] b )  throws IOException , ClassNotFoundException  {   final ByteArrayInputStream  stream =  new ByteArrayInputStream  ( b ) ;  return  readExternalFormFromStream  ( stream ) ; }   protected boolean skipSerializedCanonicalTests  ( )  {  return  Boolean . getBoolean  ( "org.apache.commons.collections:with-clover" ) ; }   private Object readExternalFormFromStream  (   final InputStream stream )  throws IOException , ClassNotFoundException  {   final ObjectInputStream  oStream =  new ObjectInputStream  ( stream ) ;  return  oStream . readObject  ( ) ; }   private void writeExternalFormToStream  (   final Serializable o ,   final OutputStream stream )  throws IOException  {   final ObjectOutputStream  oStream =  new ObjectOutputStream  ( stream ) ;   oStream . writeObject  ( o ) ; } }