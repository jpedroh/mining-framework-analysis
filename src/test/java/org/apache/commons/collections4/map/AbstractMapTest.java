  package     org . apache . commons . collections4 . map ;   import static      org . junit . jupiter . api . Assertions . assertFalse ;  import static      org . junit . jupiter . api . Assertions . assertEquals ;  import static      org . junit . jupiter . api . Assertions . assertNotNull ;  import static      org . junit . jupiter . api . Assertions . assertNull ;  import static      org . junit . jupiter . api . Assertions . assertThrows ;  import static      org . junit . jupiter . api . Assertions . assertTrue ;  import   java . io . Serializable ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . Iterator ;  import   java . util . List ;  import   java . util . Map ;  import    java . util . Map . Entry ;  import   java . util . Set ;  import     org . apache . commons . collections4 . AbstractObjectTest ;  import     org . apache . commons . collections4 . BulkTest ;  import     org . apache . commons . collections4 . CollectionUtils ;  import      org . apache . commons . collections4 . collection . AbstractCollectionTest ;  import      org . apache . commons . collections4 . keyvalue . DefaultMapEntry ;  import      org . apache . commons . collections4 . set . AbstractSetTest ;   public abstract class AbstractMapTest  <  K ,  V >  extends AbstractObjectTest  {   private static final boolean  JDK12 ;  static  {   final String  str =  System . getProperty  ( "java.version" ) ;   JDK12 =  str . startsWith  ( "1.2" ) ; }   protected  Map  < K , V >  map ;   protected  Set  <   Map . Entry  < K , V > >  entrySet ;   protected  Set  < K >  keySet ;   protected  Collection  < V >  values ;   protected  Map  < K , V >  confirmed ;   public AbstractMapTest  (   final String testName )  {  super  ( testName ) ; }   public boolean isPutAddSupported  ( )  {  return true ; }   public boolean isPutChangeSupported  ( )  {  return true ; }   public boolean isSetValueSupported  ( )  {  return  isPutChangeSupported  ( ) ; }   public boolean isRemoveSupported  ( )  {  return true ; }   public boolean isGetStructuralModify  ( )  {  return false ; }   public boolean isSubMapViewsSerializable  ( )  {  return true ; }   public boolean isAllowNullKey  ( )  {  return true ; }   public boolean isAllowNullValue  ( )  {  return true ; }   public boolean isAllowDuplicateValues  ( )  {  return true ; }   public boolean isFailFastExpected  ( )  {  return true ; }   public boolean areEqualElementsDistinguishable  ( )  {  return false ; }    @ SuppressWarnings  ( "unchecked" ) public  K  [ ] getSampleKeys  ( )  {   final  Object  [ ]  result =  new Object  [ ]  { "blah" , "foo" , "bar" , "baz" , "tmp" , "gosh" , "golly" , "gee" , "hello" , "goodbye" , "we'll" , "see" , "you" , "all" , "again" , "key" , "key2" ,    isAllowNullKey  ( ) &&  ! JDK12 ? null : "nonnullkey" } ;  return  (  K  [ ] ) result ; }    @ SuppressWarnings  ( "unchecked" ) public  K  [ ] getOtherKeys  ( )  {  return  (  K  [ ] )  getOtherNonNullStringElements  ( ) ; }    @ SuppressWarnings  ( "unchecked" ) public  V  [ ] getOtherValues  ( )  {  return  (  V  [ ] )  getOtherNonNullStringElements  ( ) ; }    @ SuppressWarnings  ( "unchecked" ) protected  <  E >  List  < E > getAsList  (   final  Object  [ ] o )  {   final  ArrayList  < E >  result =  new  ArrayList  < >  ( ) ;  for (  final Object element : o )  {   result . add  (  ( E ) element ) ; }  return result ; }   public  Object  [ ] getOtherNonNullStringElements  ( )  {  return  new Object  [ ]  { "For" , "then" , "despite" , "space" , "I" , "would" , "be" , "brought" , "From" , "limits" , "far" , "remote" , "where" , "thou" , "dost" , "stay" } ; }    @ SuppressWarnings  ( "unchecked" ) public  V  [ ] getSampleValues  ( )  {   final  Object  [ ]  result =  new Object  [ ]  { "blahv" , "foov" , "barv" , "bazv" , "tmpv" , "goshv" , "gollyv" , "geev" , "hellov" , "goodbyev" , "we'llv" , "seev" , "youv" , "allv" , "againv" ,    isAllowNullValue  ( ) &&  ! JDK12 ? null : "nonnullvalue" , "value" ,   isAllowDuplicateValues  ( ) ? "value" : "value2" , } ;  return  (  V  [ ] ) result ; }    @ SuppressWarnings  ( "unchecked" ) public  V  [ ] getNewSampleValues  ( )  {   final  Object  [ ]  result =  new Object  [ ]  {     isAllowNullValue  ( ) &&  ! JDK12 &&  isAllowDuplicateValues  ( ) ? null : "newnonnullvalue" , "newvalue" ,   isAllowDuplicateValues  ( ) ? "newvalue" : "newvalue2" , "newblahv" , "newfoov" , "newbarv" , "newbazv" , "newtmpv" , "newgoshv" , "newgollyv" , "newgeev" , "newhellov" , "newgoodbyev" , "newwe'llv" , "newseev" , "newyouv" , "newallv" , "newagainv" , } ;  return  (  V  [ ] ) result ; }   public void addSampleMappings  (   final  Map  <  ? super K ,  ? super V > m )  {   final  K  [ ]  keys =  getSampleKeys  ( ) ;   final  V  [ ]  values =  getSampleValues  ( ) ;  for (   int  i = 0 ;  i <  keys . length ;  i ++ )  {  try  {   m . put  (  keys [ i ] ,  values [ i ] ) ; }  catch (   final  NullPointerException exception )  {   assertTrue  (  "NullPointerException only allowed to be thrown " + "if either the key or value is null." ,    keys [ i ] == null ||   values [ i ] == null ) ;   assertTrue  (  "NullPointerException on null key, but " + "isAllowNullKey is not overridden to return false." ,    keys [ i ] == null ||  !  isAllowNullKey  ( ) ) ;   assertTrue  (  "NullPointerException on null value, but " + "isAllowNullValue is not overridden to return false." ,    values [ i ] == null ||  !  isAllowNullValue  ( ) ) ;   assertTrue  ( "Unknown reason for NullPointer." , false ) ; } }   assertEquals  ( "size must reflect number of mappings added." ,  keys . length ,  m . size  ( ) ) ; }    @ Override public abstract  Map  < K , V > makeObject  ( ) ;   public  Map  < K , V > makeFullMap  ( )  {   final  Map  < K , V >  m =  makeObject  ( ) ;   addSampleMappings  ( m ) ;  return m ; }   public  Map  < K , V > makeConfirmedMap  ( )  {  return  new  HashMap  < >  ( ) ; }   public static  <  K ,  V >   Map . Entry  < K , V > cloneMapEntry  (   final   Map . Entry  < K , V > entry )  {   final  HashMap  < K , V >  map =  new  HashMap  < >  ( ) ;   map . put  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ;  return    map . entrySet  ( ) . iterator  ( ) . next  ( ) ; }    @ Override public String getCompatibilityVersion  ( )  {  return  super . getCompatibilityVersion  ( ) ; }   public void testSampleMappings  ( )  {   final  Object  [ ]  keys =  getSampleKeys  ( ) ;   final  Object  [ ]  values =  getSampleValues  ( ) ;   final  Object  [ ]  newValues =  getNewSampleValues  ( ) ;   assertNotNull  (  "failure in test: Must have keys returned from " + "getSampleKeys." , keys ) ;   assertNotNull  (  "failure in test: Must have values returned from " + "getSampleValues." , values ) ;   assertEquals  (  "failure in test: not the same number of sample " + "keys and values." ,  keys . length ,  values . length ) ;   assertEquals  ( "failure in test: not the same number of values and new values." ,  values . length ,  newValues . length ) ;  for (   int  i = 0 ;  i <   keys . length - 1 ;  i ++ )  {  for (   int  j =  i + 1 ;  j <  keys . length ;  j ++ )  {   assertTrue  ( "failure in test: duplicate null keys." ,    keys [ i ] != null ||   keys [ j ] != null ) ;   assertTrue  ( "failure in test: duplicate non-null key." ,     keys [ i ] == null ||   keys [ j ] == null ||   !   keys [ i ] . equals  (  keys [ j ] ) &&  !   keys [ j ] . equals  (  keys [ i ] ) ) ; }   assertTrue  (  "failure in test: found null key, but isNullKeySupported " + "is false." ,    keys [ i ] != null ||  isAllowNullKey  ( ) ) ;   assertTrue  (  "failure in test: found null value, but isNullValueSupported " + "is false." ,    values [ i ] != null ||  isAllowNullValue  ( ) ) ;   assertTrue  (  "failure in test: found null new value, but isNullValueSupported " + "is false." ,    newValues [ i ] != null ||  isAllowNullValue  ( ) ) ;   assertTrue  ( "failure in test: values should not be the same as new value" ,    values [ i ] !=  newValues [ i ] &&  (    values [ i ] == null ||  !   values [ i ] . equals  (  newValues [ i ] ) ) ) ; } }   public void testMakeMap  ( )  {   final  Map  < K , V >  em =  makeObject  ( ) ;   assertTrue  ( "failure in test: makeEmptyMap must return a non-null map." ,  em != null ) ;   final  Map  < K , V >  em2 =  makeObject  ( ) ;   assertTrue  ( "failure in test: makeEmptyMap must return a non-null map." ,  em != null ) ;   assertTrue  (  "failure in test: makeEmptyMap must return a new map " + "with each invocation." ,  em != em2 ) ;   final  Map  < K , V >  fm =  makeFullMap  ( ) ;   assertTrue  ( "failure in test: makeFullMap must return a non-null map." ,  fm != null ) ;   final  Map  < K , V >  fm2 =  makeFullMap  ( ) ;   assertTrue  ( "failure in test: makeFullMap must return a non-null map." ,  fm != null ) ;   assertTrue  (  "failure in test: makeFullMap must return a new map " + "with each invocation." ,  fm != fm2 ) ; }   public void testMapIsEmpty  ( )  {   resetEmpty  ( ) ;   assertEquals  ( "Map.isEmpty() should return true with an empty map" , true ,   getMap  ( ) . isEmpty  ( ) ) ;   verify  ( ) ;   resetFull  ( ) ;   assertEquals  ( "Map.isEmpty() should return false with a non-empty map" , false ,   getMap  ( ) . isEmpty  ( ) ) ;   verify  ( ) ; }   public void testMapSize  ( )  {   resetEmpty  ( ) ;   assertEquals  ( "Map.size() should be 0 with an empty map" , 0 ,   getMap  ( ) . size  ( ) ) ;   verify  ( ) ;   resetFull  ( ) ;   assertEquals  (  "Map.size() should equal the number of entries " + "in the map" ,   getSampleKeys  ( ) . length ,   getMap  ( ) . size  ( ) ) ;   verify  ( ) ; }   public void testMapClear  ( )  {  if  (  !  isRemoveSupported  ( ) )  {   resetFull  ( ) ;  Exception  exception =  assertThrows  (  UnsupportedOperationException . class ,   ( ) ->  {    getMap  ( ) . clear  ( ) ; } ) ;  if  (  null !=  exception . getMessage  ( ) )  {   assertTrue  (   exception . getMessage  ( ) . contains  ( "Map is fixed size" ) ) ; }  return ; }   resetEmpty  ( ) ;    getMap  ( ) . clear  ( ) ;    getConfirmed  ( ) . clear  ( ) ;   verify  ( ) ;   resetFull  ( ) ;    getMap  ( ) . clear  ( ) ;    getConfirmed  ( ) . clear  ( ) ;   verify  ( ) ; }   public void testMapContainsKey  ( )  {   final  Object  [ ]  keys =  getSampleKeys  ( ) ;   resetEmpty  ( ) ;  for (  final Object key : keys )  {   assertTrue  ( "Map must not contain key when map is empty" ,  !   getMap  ( ) . containsKey  ( key ) ) ; }   verify  ( ) ;   resetFull  ( ) ;  for (  final Object key : keys )  {   assertTrue  (   "Map must contain key for a mapping in the map. " + "Missing: " + key ,   getMap  ( ) . containsKey  ( key ) ) ; }   verify  ( ) ; }   public void testMapContainsValue  ( )  {   final  Object  [ ]  values =  getSampleValues  ( ) ;   resetEmpty  ( ) ;  for (  final Object value : values )  {   assertTrue  ( "Empty map must not contain value" ,  !   getMap  ( ) . containsValue  ( value ) ) ; }   verify  ( ) ;   resetFull  ( ) ;  for (  final Object value : values )  {   assertTrue  ( "Map must contain value for a mapping in the map." ,   getMap  ( ) . containsValue  ( value ) ) ; }   verify  ( ) ; }   public void testMapEquals  ( )  {   resetEmpty  ( ) ;   assertTrue  ( "Empty maps unequal." ,   getMap  ( ) . equals  ( confirmed ) ) ;   verify  ( ) ;   resetFull  ( ) ;   assertTrue  ( "Full maps unequal." ,   getMap  ( ) . equals  ( confirmed ) ) ;   verify  ( ) ;   resetFull  ( ) ;   final  Iterator  < K >  iter =   confirmed . keySet  ( ) . iterator  ( ) ;   iter . next  ( ) ;   iter . remove  ( ) ;   assertTrue  ( "Different maps equal." ,  !   getMap  ( ) . equals  ( confirmed ) ) ;   resetFull  ( ) ;   assertTrue  ( "equals(null) returned true." ,  !   getMap  ( ) . equals  ( null ) ) ;   assertTrue  ( "equals(new Object()) returned true." ,  !   getMap  ( ) . equals  (  new Object  ( ) ) ) ;   verify  ( ) ; }   public void testMapGet  ( )  {   resetEmpty  ( ) ;   final  Object  [ ]  keys =  getSampleKeys  ( ) ;   final  Object  [ ]  values =  getSampleValues  ( ) ;  for (  final Object key : keys )  {   assertTrue  ( "Empty map.get() should return null." ,    getMap  ( ) . get  ( key ) == null ) ; }   verify  ( ) ;   resetFull  ( ) ;  for (   int  i = 0 ;  i <  keys . length ;  i ++ )  {   assertEquals  ( "Full map.get() should return value from mapping." ,  values [ i ] ,   getMap  ( ) . get  (  keys [ i ] ) ) ; } }   public void testMapHashCode  ( )  {   resetEmpty  ( ) ;   assertTrue  ( "Empty maps have different hashCodes." ,    getMap  ( ) . hashCode  ( ) ==  confirmed . hashCode  ( ) ) ;   resetFull  ( ) ;   assertTrue  ( "Equal maps have different hashCodes." ,    getMap  ( ) . hashCode  ( ) ==  confirmed . hashCode  ( ) ) ; }   public void testMapToString  ( )  {   resetEmpty  ( ) ;   assertTrue  ( "Empty map toString() should not return null" ,    getMap  ( ) . toString  ( ) != null ) ;   verify  ( ) ;   resetFull  ( ) ;   assertTrue  ( "Empty map toString() should not return null" ,    getMap  ( ) . toString  ( ) != null ) ;   verify  ( ) ; }   public void testEmptyMapCompatibility  ( )  throws Exception  {   final  Map  < K , V >  map =  makeObject  ( ) ;  if  (    map instanceof Serializable &&  !  skipSerializedCanonicalTests  ( ) &&  isTestSerialization  ( ) )  {    @ SuppressWarnings  ( "unchecked" ) final  Map  < K , V >  map2 =  (  Map  < K , V > )  readExternalFormFromDisk  (  getCanonicalEmptyCollectionName  ( map ) ) ;   assertEquals  ( "Map is empty" , 0 ,  map2 . size  ( ) ) ; } }   public void testFullMapCompatibility  ( )  throws Exception  {   final  Map  < K , V >  map =  makeFullMap  ( ) ;  if  (    map instanceof Serializable &&  !  skipSerializedCanonicalTests  ( ) &&  isTestSerialization  ( ) )  {    @ SuppressWarnings  ( "unchecked" ) final  Map  < K , V >  map2 =  (  Map  < K , V > )  readExternalFormFromDisk  (  getCanonicalFullCollectionName  ( map ) ) ;   assertEquals  ( "Map is the right size" ,   getSampleKeys  ( ) . length ,  map2 . size  ( ) ) ; } }   public void testMapPut  ( )  {   resetEmpty  ( ) ;   final  K  [ ]  keys =  getSampleKeys  ( ) ;   final  V  [ ]  values =  getSampleValues  ( ) ;   final  V  [ ]  newValues =  getNewSampleValues  ( ) ;  if  (  isPutAddSupported  ( ) )  {  for (   int  i = 0 ;  i <  keys . length ;  i ++ )  {   final Object  o =   getMap  ( ) . put  (  keys [ i ] ,  values [ i ] ) ;    getConfirmed  ( ) . put  (  keys [ i ] ,  values [ i ] ) ;   verify  ( ) ;   assertTrue  ( "First map.put should return null" ,  o == null ) ;   assertTrue  ( "Map should contain key after put" ,   getMap  ( ) . containsKey  (  keys [ i ] ) ) ;   assertTrue  ( "Map should contain value after put" ,   getMap  ( ) . containsValue  (  values [ i ] ) ) ; }  if  (  isPutChangeSupported  ( ) )  {  for (   int  i = 0 ;  i <  keys . length ;  i ++ )  {   final Object  o =   getMap  ( ) . put  (  keys [ i ] ,  newValues [ i ] ) ;    getConfirmed  ( ) . put  (  keys [ i ] ,  newValues [ i ] ) ;   verify  ( ) ;   assertEquals  ( "Map.put should return previous value when changed" ,  values [ i ] , o ) ;   assertTrue  ( "Map should still contain key after put when changed" ,   getMap  ( ) . containsKey  (  keys [ i ] ) ) ;   assertTrue  ( "Map should contain new value after put when changed" ,   getMap  ( ) . containsValue  (  newValues [ i ] ) ) ;  if  (  !  isAllowDuplicateValues  ( ) )  {   assertTrue  ( "Map should not contain old value after put when changed" ,  !   getMap  ( ) . containsValue  (  values [ i ] ) ) ; } } } else  {  Exception  exception =  assertThrows  (  IllegalArgumentException . class ,   ( ) ->  {    getMap  ( ) . put  (  keys [ 0 ] ,  newValues [ 0 ] ) ; } ) ;   assertNull  (  exception . getMessage  ( ) ) ; } } else  if  (  isPutChangeSupported  ( ) )  {   resetEmpty  ( ) ;  Exception  exception =  assertThrows  (  Exception . class ,   ( ) ->  {    getMap  ( ) . put  (  keys [ 0 ] ,  values [ 0 ] ) ; } ) ;  if  (  null !=  exception . getMessage  ( ) )  {   assertTrue  (   exception . getMessage  ( ) . contains  ( "Map is fixed size" ) ) ; }   resetFull  ( ) ;   int  i = 0 ;  for (   final  Iterator  < K >  it =    getMap  ( ) . keySet  ( ) . iterator  ( ) ;   it . hasNext  ( ) &&  i <  newValues . length ;  i ++ )  {   final K  key =  it . next  ( ) ;   final V  o =   getMap  ( ) . put  ( key ,  newValues [ i ] ) ;   final V  value =   getConfirmed  ( ) . put  ( key ,  newValues [ i ] ) ;   verify  ( ) ;   assertEquals  ( "Map.put should return previous value when changed" , value , o ) ;   assertTrue  ( "Map should still contain key after put when changed" ,   getMap  ( ) . containsKey  ( key ) ) ;   assertTrue  ( "Map should contain new value after put when changed" ,   getMap  ( ) . containsValue  (  newValues [ i ] ) ) ;  if  (  !  isAllowDuplicateValues  ( ) )  {   assertTrue  ( "Map should not contain old value after put when changed" ,  !   getMap  ( ) . containsValue  (  values [ i ] ) ) ; } } } else  {  Exception  exception =  assertThrows  (  UnsupportedOperationException . class ,   ( ) ->  {    getMap  ( ) . put  (  keys [ 0 ] ,  values [ 0 ] ) ; } ) ;   assertNull  (  exception . getMessage  ( ) ) ; } }   public void testMapPutNullKey  ( )  {   resetFull  ( ) ;   final  V  [ ]  values =  getSampleValues  ( ) ;  if  (  isPutAddSupported  ( ) )  {  if  (  isAllowNullKey  ( ) )  {    getMap  ( ) . put  ( null ,  values [ 0 ] ) ; } else  {  Exception  exception =  assertThrows  (  Exception . class ,   ( ) ->  {    getMap  ( ) . put  ( null ,  values [ 0 ] ) ; } ) ;  if  (  null !=  exception . getMessage  ( ) )  {   assertNotNull  (  exception . getMessage  ( ) ) ; } } } }   public void testMapPutNullValue  ( )  {   resetFull  ( ) ;   final  K  [ ]  keys =  getSampleKeys  ( ) ;  if  (  isPutAddSupported  ( ) )  {  if  (  isAllowNullValue  ( ) )  {    getMap  ( ) . put  (  keys [ 0 ] , null ) ; } else  {  Exception  exception =  assertThrows  (  NullPointerException . class ,   ( ) ->  {    getMap  ( ) . put  (  keys [ 0 ] , null ) ; } ) ;  if  (  null !=  exception . getMessage  ( ) )  {   assertNotNull  (  exception . getMessage  ( ) ) ; } } } }   public void testMapPutAll  ( )  {  if  (  !  isPutAddSupported  ( ) )  {  if  (  !  isPutChangeSupported  ( ) )  {   final  Map  < K , V >  temp =  makeFullMap  ( ) ;   resetEmpty  ( ) ;  Exception  exception =  assertThrows  (  UnsupportedOperationException . class ,   ( ) ->  {    getMap  ( ) . putAll  ( temp ) ; } ) ;   assertNull  (  exception . getMessage  ( ) ) ; }  return ; }   resetEmpty  ( ) ;   assertEquals  ( 0 ,   getMap  ( ) . size  ( ) ) ;    getMap  ( ) . putAll  (  new  HashMap  < K , V >  ( ) ) ;   assertEquals  ( 0 ,   getMap  ( ) . size  ( ) ) ;   resetFull  ( ) ;   final  int  size =   getMap  ( ) . size  ( ) ;    getMap  ( ) . putAll  (  new  HashMap  < K , V >  ( ) ) ;   assertEquals  ( size ,   getMap  ( ) . size  ( ) ) ;   resetEmpty  ( ) ;   Map  < K , V >  m2 =  makeFullMap  ( ) ;    getMap  ( ) . putAll  ( m2 ) ;    getConfirmed  ( ) . putAll  ( m2 ) ;   verify  ( ) ;   resetEmpty  ( ) ;   m2 =  makeConfirmedMap  ( ) ;   final  K  [ ]  keys =  getSampleKeys  ( ) ;   final  V  [ ]  values =  getSampleValues  ( ) ;  for (   int  i = 0 ;  i <  keys . length ;  i ++ )  {   m2 . put  (  keys [ i ] ,  values [ i ] ) ; }    getMap  ( ) . putAll  ( m2 ) ;    getConfirmed  ( ) . putAll  ( m2 ) ;   verify  ( ) ;   resetEmpty  ( ) ;   m2 =  makeConfirmedMap  ( ) ;    getMap  ( ) . put  (  keys [ 0 ] ,  values [ 0 ] ) ;    getConfirmed  ( ) . put  (  keys [ 0 ] ,  values [ 0 ] ) ;   verify  ( ) ;  for (   int  i = 1 ;  i <  keys . length ;  i ++ )  {   m2 . put  (  keys [ i ] ,  values [ i ] ) ; }    getMap  ( ) . putAll  ( m2 ) ;    getConfirmed  ( ) . putAll  ( m2 ) ;   verify  ( ) ; }   public void testMapRemove  ( )  {  if  (  !  isRemoveSupported  ( ) )  {   resetFull  ( ) ;  Exception  exception =  assertThrows  (  UnsupportedOperationException . class ,   ( ) ->  {    getMap  ( ) . remove  (     getMap  ( ) . keySet  ( ) . iterator  ( ) . next  ( ) ) ; } ) ;  if  (  null !=  exception . getMessage  ( ) )  {   assertTrue  (   exception . getMessage  ( ) . contains  ( "Map is fixed size" ) ) ; }  return ; }   resetEmpty  ( ) ;   final  Object  [ ]  keys =  getSampleKeys  ( ) ;   final  Object  [ ]  values =  getSampleValues  ( ) ;  for (  final Object key : keys )  {   final Object  o =   getMap  ( ) . remove  ( key ) ;   assertNull  ( o ) ; }   verify  ( ) ;   resetFull  ( ) ;  for (   int  i = 0 ;  i <  keys . length ;  i ++ )  {   final Object  o =   getMap  ( ) . remove  (  keys [ i ] ) ;    getConfirmed  ( ) . remove  (  keys [ i ] ) ;   verify  ( ) ;   assertEquals  ( "map.remove with valid key should return value" ,  values [ i ] , o ) ; }   final  Object  [ ]  other =  getOtherKeys  ( ) ;   resetFull  ( ) ;   final  int  size =   getMap  ( ) . size  ( ) ;  for (  final Object element : other )  {   final Object  o =   getMap  ( ) . remove  ( element ) ;   assertNull  ( o ) ;   assertEquals  (  "map.remove for nonexistent key should not " + "shrink map" , size ,   getMap  ( ) . size  ( ) ) ; }   verify  ( ) ; }   public void testValuesClearChangesMap  ( )  {  if  (  !  isRemoveSupported  ( ) )  {  return ; }   resetFull  ( ) ;   Collection  < V >  values =   getMap  ( ) . values  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) > 0 ) ;   assertTrue  (   values . size  ( ) > 0 ) ;   values . clear  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) == 0 ) ;   assertTrue  (   values . size  ( ) == 0 ) ;   resetFull  ( ) ;   values =   getMap  ( ) . values  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) > 0 ) ;   assertTrue  (   values . size  ( ) > 0 ) ;    getMap  ( ) . clear  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) == 0 ) ;   assertTrue  (   values . size  ( ) == 0 ) ; }   public void testKeySetClearChangesMap  ( )  {  if  (  !  isRemoveSupported  ( ) )  {  return ; }   resetFull  ( ) ;   Set  < K >  keySet =   getMap  ( ) . keySet  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) > 0 ) ;   assertTrue  (   keySet . size  ( ) > 0 ) ;   keySet . clear  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) == 0 ) ;   assertTrue  (   keySet . size  ( ) == 0 ) ;   resetFull  ( ) ;   keySet =   getMap  ( ) . keySet  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) > 0 ) ;   assertTrue  (   keySet . size  ( ) > 0 ) ;    getMap  ( ) . clear  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) == 0 ) ;   assertTrue  (   keySet . size  ( ) == 0 ) ; }   public void testEntrySetClearChangesMap  ( )  {  if  (  !  isRemoveSupported  ( ) )  {  return ; }   resetFull  ( ) ;   Set  <   Map . Entry  < K , V > >  entrySet =   getMap  ( ) . entrySet  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) > 0 ) ;   assertTrue  (   entrySet . size  ( ) > 0 ) ;   entrySet . clear  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) == 0 ) ;   assertTrue  (   entrySet . size  ( ) == 0 ) ;   resetFull  ( ) ;   entrySet =   getMap  ( ) . entrySet  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) > 0 ) ;   assertTrue  (   entrySet . size  ( ) > 0 ) ;    getMap  ( ) . clear  ( ) ;   assertTrue  (    getMap  ( ) . size  ( ) == 0 ) ;   assertTrue  (   entrySet . size  ( ) == 0 ) ; }   public void testEntrySetContains1  ( )  {   resetFull  ( ) ;   final  Set  <   Map . Entry  < K , V > >  entrySet =   getMap  ( ) . entrySet  ( ) ;   final   Map . Entry  < K , V >  entry =   entrySet . iterator  ( ) . next  ( ) ;   assertEquals  ( true ,  entrySet . contains  ( entry ) ) ; }   public void testEntrySetContains2  ( )  {   resetFull  ( ) ;   final  Set  <   Map . Entry  < K , V > >  entrySet =   getMap  ( ) . entrySet  ( ) ;   final   Map . Entry  < K , V >  entry =   entrySet . iterator  ( ) . next  ( ) ;   final   Map . Entry  < K , V >  test =  cloneMapEntry  ( entry ) ;   assertEquals  ( true ,  entrySet . contains  ( test ) ) ; }    @ SuppressWarnings  ( "unchecked" ) public void testEntrySetContains3  ( )  {   resetFull  ( ) ;   final  Set  <   Map . Entry  < K , V > >  entrySet =   getMap  ( ) . entrySet  ( ) ;   final   Map . Entry  < K , V >  entry =   entrySet . iterator  ( ) . next  ( ) ;   final  HashMap  < K , V >  temp =  new  HashMap  < >  ( ) ;   temp . put  (  entry . getKey  ( ) ,  ( V ) "A VERY DIFFERENT VALUE" ) ;   final   Map . Entry  < K , V >  test =    temp . entrySet  ( ) . iterator  ( ) . next  ( ) ;   assertEquals  ( false ,  entrySet . contains  ( test ) ) ; }   public void testEntrySetRemove1  ( )  {  if  (  !  isRemoveSupported  ( ) )  {  return ; }   resetFull  ( ) ;   final  int  size =   getMap  ( ) . size  ( ) ;   final  Set  <   Map . Entry  < K , V > >  entrySet =   getMap  ( ) . entrySet  ( ) ;   final   Map . Entry  < K , V >  entry =   entrySet . iterator  ( ) . next  ( ) ;   final K  key =  entry . getKey  ( ) ;   assertEquals  ( true ,  entrySet . remove  ( entry ) ) ;   assertEquals  ( false ,   getMap  ( ) . containsKey  ( key ) ) ;   assertEquals  (  size - 1 ,   getMap  ( ) . size  ( ) ) ; }   public void testEntrySetRemove2  ( )  {  if  (  !  isRemoveSupported  ( ) )  {  return ; }   resetFull  ( ) ;   final  int  size =   getMap  ( ) . size  ( ) ;   final  Set  <   Map . Entry  < K , V > >  entrySet =   getMap  ( ) . entrySet  ( ) ;   final   Map . Entry  < K , V >  entry =   entrySet . iterator  ( ) . next  ( ) ;   final K  key =  entry . getKey  ( ) ;   final   Map . Entry  < K , V >  test =  cloneMapEntry  ( entry ) ;   assertEquals  ( true ,  entrySet . remove  ( test ) ) ;   assertEquals  ( false ,   getMap  ( ) . containsKey  ( key ) ) ;   assertEquals  (  size - 1 ,   getMap  ( ) . size  ( ) ) ; }    @ SuppressWarnings  ( "unchecked" ) public void testEntrySetRemove3  ( )  {  if  (  !  isRemoveSupported  ( ) )  {  return ; }   resetFull  ( ) ;   final  int  size =   getMap  ( ) . size  ( ) ;   final  Set  <   Map . Entry  < K , V > >  entrySet =   getMap  ( ) . entrySet  ( ) ;   final   Map . Entry  < K , V >  entry =   entrySet . iterator  ( ) . next  ( ) ;   final K  key =  entry . getKey  ( ) ;   final  HashMap  < K , V >  temp =  new  HashMap  < >  ( ) ;   temp . put  (  entry . getKey  ( ) ,  ( V ) "A VERY DIFFERENT VALUE" ) ;   final   Map . Entry  < K , V >  test =    temp . entrySet  ( ) . iterator  ( ) . next  ( ) ;   assertEquals  ( false ,  entrySet . remove  ( test ) ) ;   assertEquals  ( true ,   getMap  ( ) . containsKey  ( key ) ) ;   assertEquals  ( size ,   getMap  ( ) . size  ( ) ) ; }   public void testValuesRemoveChangesMap  ( )  {   resetFull  ( ) ;   final  V  [ ]  sampleValues =  getSampleValues  ( ) ;   final  Collection  < V >  values =   getMap  ( ) . values  ( ) ;  for (  final V sampleValue : sampleValues )  {  if  (  map . containsValue  ( sampleValue ) )  {   int  j = 0 ;  while  (   values . contains  ( sampleValue ) &&  j < 10000 )  {  try  {   values . remove  ( sampleValue ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   j ++ ; }   assertTrue  (  j < 10000 ) ;   assertTrue  (  !   getMap  ( ) . containsValue  ( sampleValue ) ) ; } } }   public void testValuesRemoveAll  ( )  {   resetFull  ( ) ;   final  Collection  < V >  values =   getMap  ( ) . values  ( ) ;   final  List  < V >  sampleValuesAsList =  Arrays . asList  (  getSampleValues  ( ) ) ;  if  (  !  values . equals  ( sampleValuesAsList ) )  {  return ; }  try  {   assertFalse  (  values . removeAll  (  Collections .  < V > emptySet  ( ) ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertEquals  (  sampleValuesAsList . size  ( ) ,   getMap  ( ) . size  ( ) ) ;  try  {   assertTrue  (  values . removeAll  ( sampleValuesAsList ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertTrue  (   getMap  ( ) . isEmpty  ( ) ) ; }   public void testValuesRetainAll  ( )  {   resetFull  ( ) ;   final  Collection  < V >  values =   getMap  ( ) . values  ( ) ;   final  List  < V >  sampleValuesAsList =  Arrays . asList  (  getSampleValues  ( ) ) ;  if  (  !  values . equals  ( sampleValuesAsList ) )  {  return ; }  try  {   assertFalse  (  values . retainAll  ( sampleValuesAsList ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertEquals  (  sampleValuesAsList . size  ( ) ,   getMap  ( ) . size  ( ) ) ;  try  {   assertTrue  (  values . retainAll  (  Collections .  < V > emptySet  ( ) ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertTrue  (   getMap  ( ) . isEmpty  ( ) ) ; }    @ SuppressWarnings  ( "boxing" ) public void testValuesIteratorRemoveChangesMap  ( )  {   resetFull  ( ) ;   final  List  < V >  sampleValuesAsList =  Arrays . asList  (  getSampleValues  ( ) ) ;   final  Map  < V , Integer >  cardinality =  CollectionUtils . getCardinalityMap  ( sampleValuesAsList ) ;   final  Collection  < V >  values =   getMap  ( ) . values  ( ) ;  for (   final  Iterator  < V >  iter =  values . iterator  ( ) ;  iter . hasNext  ( ) ; )  {   final V  value =  iter . next  ( ) ;  Integer  count =  cardinality . get  ( value ) ;  if  (  count == null )  {  return ; }  try  {   iter . remove  ( ) ;   cardinality . put  ( value ,  -- count ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   final boolean  expected =  count > 0 ;   final StringBuilder  msg =  new StringBuilder  ( "Value should " ) ;   msg . append  (  expected ? "yet " : "no longer " ) ;   msg . append  ( "be present in the underlying map" ) ;   assertEquals  (  msg . toString  ( ) , expected ,   getMap  ( ) . containsValue  ( value ) ) ; }   assertTrue  (   getMap  ( ) . isEmpty  ( ) ) ; }   public void testKeySetRemoveChangesMap  ( )  {   resetFull  ( ) ;   final  K  [ ]  sampleKeys =  getSampleKeys  ( ) ;   final  Set  < K >  keys =   getMap  ( ) . keySet  ( ) ;  for (  final K sampleKey : sampleKeys )  {  try  {   keys . remove  ( sampleKey ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertTrue  (  !   getMap  ( ) . containsKey  ( sampleKey ) ) ; } }   public void testKeySetRemoveAll  ( )  {   resetFull  ( ) ;   final  Set  < K >  keys =   getMap  ( ) . keySet  ( ) ;   final  List  < K >  sampleKeysAsList =  Arrays . asList  (  getSampleKeys  ( ) ) ;  if  (  !  keys . equals  ( sampleKeysAsList ) )  {  return ; }  try  {   assertFalse  (  keys . removeAll  (  Collections .  < K > emptySet  ( ) ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertEquals  ( sampleKeysAsList , keys ) ;  try  {   assertTrue  (  keys . removeAll  ( sampleKeysAsList ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertTrue  (   getMap  ( ) . isEmpty  ( ) ) ; }   public void testKeySetRetainAll  ( )  {   resetFull  ( ) ;   final  Set  < K >  keys =   getMap  ( ) . keySet  ( ) ;   final  List  < K >  sampleKeysAsList =  Arrays . asList  (  getSampleKeys  ( ) ) ;  if  (  !  keys . equals  ( sampleKeysAsList ) )  {  return ; }  try  {   assertFalse  (  keys . retainAll  ( sampleKeysAsList ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertEquals  ( sampleKeysAsList , keys ) ;  try  {   assertTrue  (  keys . retainAll  (  Collections .  < K > emptySet  ( ) ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertTrue  (   getMap  ( ) . isEmpty  ( ) ) ; }   public void testKeySetIteratorRemoveChangesMap  ( )  {   resetFull  ( ) ;  for (   final  Iterator  < K >  iter =    getMap  ( ) . keySet  ( ) . iterator  ( ) ;  iter . hasNext  ( ) ; )  {   final K  key =  iter . next  ( ) ;  try  {   iter . remove  ( ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertFalse  (   getMap  ( ) . containsKey  ( key ) ) ; } }   public void testEntrySetRemoveChangesMap  ( )  {   resetFull  ( ) ;   final  K  [ ]  sampleKeys =  getSampleKeys  ( ) ;   final  V  [ ]  sampleValues =  getSampleValues  ( ) ;   final  Set  <   Map . Entry  < K , V > >  entrySet =   getMap  ( ) . entrySet  ( ) ;  for (   int  i = 0 ;  i <  sampleKeys . length ;  i ++ )  {  try  {   entrySet . remove  (  new  DefaultMapEntry  < >  (  sampleKeys [ i ] ,  sampleValues [ i ] ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertTrue  (  !   getMap  ( ) . containsKey  (  sampleKeys [ i ] ) ) ; } }   public void testEntrySetRemoveAll  ( )  {   resetFull  ( ) ;   final  K  [ ]  sampleKeys =  getSampleKeys  ( ) ;   final  V  [ ]  sampleValues =  getSampleValues  ( ) ;  for (   int  i = 0 ;  i <  sampleKeys . length ;  i ++ )  {  if  (  !   getMap  ( ) . containsKey  (  sampleKeys [ i ] ) )  {  return ; }   final V  value =  sampleValues [ i ] ;   final V  test =   getMap  ( ) . get  (  sampleKeys [ i ] ) ;  if  (   value == test ||   value != null &&  value . equals  ( test ) )  {  continue ; }  return ; }   final  Set  <   Map . Entry  < K , V > >  entrySet =   getMap  ( ) . entrySet  ( ) ;   final  HashSet  <   Map . Entry  < K , V > >  comparisonSet =  new  HashSet  < >  ( entrySet ) ;  try  {   assertFalse  (  entrySet . removeAll  (  Collections .  <   Map . Entry  < K , V > > emptySet  ( ) ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertEquals  (  sampleKeys . length ,   getMap  ( ) . size  ( ) ) ;  try  {   assertTrue  (  entrySet . removeAll  ( comparisonSet ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertTrue  (   getMap  ( ) . isEmpty  ( ) ) ; }   public void testEntrySetRetainAll  ( )  {   resetFull  ( ) ;   final  K  [ ]  sampleKeys =  getSampleKeys  ( ) ;   final  V  [ ]  sampleValues =  getSampleValues  ( ) ;  for (   int  i = 0 ;  i <  sampleKeys . length ;  i ++ )  {  if  (  !   getMap  ( ) . containsKey  (  sampleKeys [ i ] ) )  {  return ; }   final V  value =  sampleValues [ i ] ;   final V  test =   getMap  ( ) . get  (  sampleKeys [ i ] ) ;  if  (   value == test ||   value != null &&  value . equals  ( test ) )  {  continue ; }  return ; }   final  Set  <   Map . Entry  < K , V > >  entrySet =   getMap  ( ) . entrySet  ( ) ;   final  HashSet  <   Map . Entry  < K , V > >  comparisonSet =  new  HashSet  < >  ( entrySet ) ;  try  {   assertFalse  (  entrySet . retainAll  ( comparisonSet ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertEquals  (  sampleKeys . length ,   getMap  ( ) . size  ( ) ) ;  try  {   assertTrue  (  entrySet . retainAll  (  Collections .  <   Map . Entry  < K , V > > emptySet  ( ) ) ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertTrue  (   getMap  ( ) . isEmpty  ( ) ) ; }   public void testEntrySetIteratorRemoveChangesMap  ( )  {   resetFull  ( ) ;  for (   final  Iterator  <   Map . Entry  < K , V > >  iter =    getMap  ( ) . entrySet  ( ) . iterator  ( ) ;  iter . hasNext  ( ) ; )  {   final K  key =   iter . next  ( ) . getKey  ( ) ;  try  {   iter . remove  ( ) ; }  catch (   final  UnsupportedOperationException e )  {  return ; }   assertFalse  (   getMap  ( ) . containsKey  ( key ) ) ; } }    @ SuppressWarnings  ( "unchecked" ) private    Map . Entry  < K , V >  [ ] makeEntryArray  (   final  K  [ ] keys ,   final  V  [ ] values )  {   final    Map . Entry  < K , V >  [ ]  result =  new  Map . Entry  [  keys . length ] ;  for (   int  i = 0 ;  i <  keys . length ;  i ++ )  {   final  Map  < K , V >  map =  makeConfirmedMap  ( ) ;   map . put  (  keys [ i ] ,  values [ i ] ) ;    result [ i ] =    map . entrySet  ( ) . iterator  ( ) . next  ( ) ; }  return result ; }   public BulkTest bulkTestMapEntrySet  ( )  {  return  new TestMapEntrySet  ( ) ; }   public class TestMapEntrySet  extends  AbstractSetTest  <   Map . Entry  < K , V > >  {   public TestMapEntrySet  ( )  {  super  ( "MapEntrySet" ) ; }    @ Override public   Entry  < K , V >  [ ] getFullElements  ( )  {  return  getFullNonNullElements  ( ) ; }    @ Override public    Map . Entry  < K , V >  [ ] getFullNonNullElements  ( )  {   final  K  [ ]  k =  getSampleKeys  ( ) ;   final  V  [ ]  v =  getSampleValues  ( ) ;  return  makeEntryArray  ( k , v ) ; }    @ Override public    Map . Entry  < K , V >  [ ] getOtherElements  ( )  {   final  K  [ ]  k =  getOtherKeys  ( ) ;   final  V  [ ]  v =  getOtherValues  ( ) ;  return  makeEntryArray  ( k , v ) ; }    @ Override public  Set  <   Map . Entry  < K , V > > makeObject  ( )  {  return    AbstractMapTest . this . makeObject  ( ) . entrySet  ( ) ; }    @ Override public  Set  <   Map . Entry  < K , V > > makeFullCollection  ( )  {  return   makeFullMap  ( ) . entrySet  ( ) ; }    @ Override public boolean isAddSupported  ( )  {  return false ; }    @ Override public boolean isRemoveSupported  ( )  {  return   AbstractMapTest . this . isRemoveSupported  ( ) ; }   public boolean isGetStructuralModify  ( )  {  return   AbstractMapTest . this . isGetStructuralModify  ( ) ; }    @ Override public boolean areEqualElementsDistinguishable  ( )  {  return   AbstractMapTest . this . areEqualElementsDistinguishable  ( ) ; }    @ Override public boolean isTestSerialization  ( )  {  return false ; }    @ Override public void resetFull  ( )  {    AbstractMapTest . this . resetFull  ( ) ;   setCollection  (    AbstractMapTest . this . getMap  ( ) . entrySet  ( ) ) ;    TestMapEntrySet . this . setConfirmed  (    AbstractMapTest . this . getConfirmed  ( ) . entrySet  ( ) ) ; }    @ Override public void resetEmpty  ( )  {    AbstractMapTest . this . resetEmpty  ( ) ;   setCollection  (    AbstractMapTest . this . getMap  ( ) . entrySet  ( ) ) ;    TestMapEntrySet . this . setConfirmed  (    AbstractMapTest . this . getConfirmed  ( ) . entrySet  ( ) ) ; }   public void testMapEntrySetIteratorEntry  ( )  {   resetFull  ( ) ;   final  Iterator  <   Map . Entry  < K , V > >  it =   getCollection  ( ) . iterator  ( ) ;   int  count = 0 ;  while  (  it . hasNext  ( ) )  {   final   Map . Entry  < K , V >  entry =  it . next  ( ) ;   assertEquals  ( true ,    AbstractMapTest . this . getMap  ( ) . containsKey  (  entry . getKey  ( ) ) ) ;   assertEquals  ( true ,    AbstractMapTest . this . getMap  ( ) . containsValue  (  entry . getValue  ( ) ) ) ;  if  (  !  isGetStructuralModify  ( ) )  {   assertEquals  (    AbstractMapTest . this . getMap  ( ) . get  (  entry . getKey  ( ) ) ,  entry . getValue  ( ) ) ; }   count ++ ; }   assertEquals  (   getCollection  ( ) . size  ( ) , count ) ; }   public void testMapEntrySetIteratorEntrySetValue  ( )  {   final K  key1 =   getSampleKeys  ( ) [ 0 ] ;   final K  key2 =     getSampleKeys  ( ) . length == 1 ?   getSampleKeys  ( ) [ 0 ] :   getSampleKeys  ( ) [ 1 ] ;   final V  newValue1 =   getNewSampleValues  ( ) [ 0 ] ;   final V  newValue2 =     getNewSampleValues  ( ) . length == 1 ?   getNewSampleValues  ( ) [ 0 ] :   getNewSampleValues  ( ) [ 1 ] ;   resetFull  ( ) ;   Iterator  <   Map . Entry  < K , V > >  it =    TestMapEntrySet . this . getCollection  ( ) . iterator  ( ) ;   final   Map . Entry  < K , V >  entry1 =  getEntry  ( it , key1 ) ;   it =    TestMapEntrySet . this . getCollection  ( ) . iterator  ( ) ;   final   Map . Entry  < K , V >  entry2 =  getEntry  ( it , key2 ) ;   Iterator  <   Map . Entry  < K , V > >  itConfirmed =    TestMapEntrySet . this . getConfirmed  ( ) . iterator  ( ) ;   final   Map . Entry  < K , V >  entryConfirmed1 =  getEntry  ( itConfirmed , key1 ) ;   itConfirmed =    TestMapEntrySet . this . getConfirmed  ( ) . iterator  ( ) ;   final   Map . Entry  < K , V >  entryConfirmed2 =  getEntry  ( itConfirmed , key2 ) ;   verify  ( ) ;  if  (  !  isSetValueSupported  ( ) )  {  try  {   entry1 . setValue  ( newValue1 ) ; }  catch (   final  UnsupportedOperationException ex )  { }  return ; }   entry1 . setValue  ( newValue1 ) ;   entryConfirmed1 . setValue  ( newValue1 ) ;   assertEquals  ( newValue1 ,  entry1 . getValue  ( ) ) ;   assertEquals  ( true ,    AbstractMapTest . this . getMap  ( ) . containsKey  (  entry1 . getKey  ( ) ) ) ;   assertEquals  ( true ,    AbstractMapTest . this . getMap  ( ) . containsValue  ( newValue1 ) ) ;   assertEquals  ( newValue1 ,    AbstractMapTest . this . getMap  ( ) . get  (  entry1 . getKey  ( ) ) ) ;   verify  ( ) ;   entry1 . setValue  ( newValue1 ) ;   entryConfirmed1 . setValue  ( newValue1 ) ;   assertEquals  ( newValue1 ,  entry1 . getValue  ( ) ) ;   assertEquals  ( true ,    AbstractMapTest . this . getMap  ( ) . containsKey  (  entry1 . getKey  ( ) ) ) ;   assertEquals  ( true ,    AbstractMapTest . this . getMap  ( ) . containsValue  ( newValue1 ) ) ;   assertEquals  ( newValue1 ,    AbstractMapTest . this . getMap  ( ) . get  (  entry1 . getKey  ( ) ) ) ;   verify  ( ) ;   entry2 . setValue  ( newValue2 ) ;   entryConfirmed2 . setValue  ( newValue2 ) ;   assertEquals  ( newValue2 ,  entry2 . getValue  ( ) ) ;   assertEquals  ( true ,    AbstractMapTest . this . getMap  ( ) . containsKey  (  entry2 . getKey  ( ) ) ) ;   assertEquals  ( true ,    AbstractMapTest . this . getMap  ( ) . containsValue  ( newValue2 ) ) ;   assertEquals  ( newValue2 ,    AbstractMapTest . this . getMap  ( ) . get  (  entry2 . getKey  ( ) ) ) ;   verify  ( ) ; }   public   Map . Entry  < K , V > getEntry  (   final  Iterator  <   Map . Entry  < K , V > > itConfirmed ,   final K key )  {    Map . Entry  < K , V >  entry = null ;  while  (  itConfirmed . hasNext  ( ) )  {   final   Map . Entry  < K , V >  temp =  itConfirmed . next  ( ) ;  if  (   temp . getKey  ( ) == null )  {  if  (  key == null )  {   entry = temp ;  break ; } } else  if  (   temp . getKey  ( ) . equals  ( key ) )  {   entry = temp ;  break ; } }   assertNotNull  (   "No matching entry in map for key '" + key + "'" , entry ) ;  return entry ; }   public void testMapEntrySetRemoveNonMapEntry  ( )  {  if  (  !  isRemoveSupported  ( ) )  {  return ; }   resetFull  ( ) ;   assertEquals  ( false ,   getCollection  ( ) . remove  ( null ) ) ;   assertEquals  ( false ,   getCollection  ( ) . remove  (  new Object  ( ) ) ) ; }    @ Override public void verify  ( )  {   super . verify  ( ) ;    AbstractMapTest . this . verify  ( ) ; } }   public BulkTest bulkTestMapKeySet  ( )  {  return  new TestMapKeySet  ( ) ; }   public class TestMapKeySet  extends  AbstractSetTest  < K >  {   public TestMapKeySet  ( )  {  super  ( "" ) ; }    @ Override public  K  [ ] getFullElements  ( )  {  return  getSampleKeys  ( ) ; }    @ Override public  K  [ ] getOtherElements  ( )  {  return  getOtherKeys  ( ) ; }    @ Override public  Set  < K > makeObject  ( )  {  return    AbstractMapTest . this . makeObject  ( ) . keySet  ( ) ; }    @ Override public  Set  < K > makeFullCollection  ( )  {  return    AbstractMapTest . this . makeFullMap  ( ) . keySet  ( ) ; }    @ Override public boolean isNullSupported  ( )  {  return   AbstractMapTest . this . isAllowNullKey  ( ) ; }    @ Override public boolean isAddSupported  ( )  {  return false ; }    @ Override public boolean isRemoveSupported  ( )  {  return   AbstractMapTest . this . isRemoveSupported  ( ) ; }    @ Override public boolean isTestSerialization  ( )  {  return false ; }    @ Override public void resetEmpty  ( )  {    AbstractMapTest . this . resetEmpty  ( ) ;   setCollection  (    AbstractMapTest . this . getMap  ( ) . keySet  ( ) ) ;    TestMapKeySet . this . setConfirmed  (    AbstractMapTest . this . getConfirmed  ( ) . keySet  ( ) ) ; }    @ Override public void resetFull  ( )  {    AbstractMapTest . this . resetFull  ( ) ;   setCollection  (    AbstractMapTest . this . getMap  ( ) . keySet  ( ) ) ;    TestMapKeySet . this . setConfirmed  (    AbstractMapTest . this . getConfirmed  ( ) . keySet  ( ) ) ; }    @ Override public void verify  ( )  {   super . verify  ( ) ;    AbstractMapTest . this . verify  ( ) ; } }   public BulkTest bulkTestMapValues  ( )  {  return  new TestMapValues  ( ) ; }   public class TestMapValues  extends  AbstractCollectionTest  < V >  {   public TestMapValues  ( )  {  super  ( "" ) ; }    @ Override public  V  [ ] getFullElements  ( )  {  return  getSampleValues  ( ) ; }    @ Override public  V  [ ] getOtherElements  ( )  {  return  getOtherValues  ( ) ; }    @ Override public  Collection  < V > makeObject  ( )  {  return    AbstractMapTest . this . makeObject  ( ) . values  ( ) ; }    @ Override public  Collection  < V > makeFullCollection  ( )  {  return    AbstractMapTest . this . makeFullMap  ( ) . values  ( ) ; }    @ Override public boolean isNullSupported  ( )  {  return   AbstractMapTest . this . isAllowNullKey  ( ) ; }    @ Override public boolean isAddSupported  ( )  {  return false ; }    @ Override public boolean isRemoveSupported  ( )  {  return   AbstractMapTest . this . isRemoveSupported  ( ) ; }    @ Override public boolean isTestSerialization  ( )  {  return false ; }    @ Override public boolean areEqualElementsDistinguishable  ( )  {  return true ; }    @ Override public  Collection  < V > makeConfirmedCollection  ( )  {  return null ; }    @ Override public  Collection  < V > makeConfirmedFullCollection  ( )  {  return null ; }    @ Override public void resetFull  ( )  {    AbstractMapTest . this . resetFull  ( ) ;   setCollection  (  map . values  ( ) ) ;    TestMapValues . this . setConfirmed  (    AbstractMapTest . this . getConfirmed  ( ) . values  ( ) ) ; }    @ Override public void resetEmpty  ( )  {    AbstractMapTest . this . resetEmpty  ( ) ;   setCollection  (  map . values  ( ) ) ;    TestMapValues . this . setConfirmed  (    AbstractMapTest . this . getConfirmed  ( ) . values  ( ) ) ; }    @ Override public void verify  ( )  {   super . verify  ( ) ;    AbstractMapTest . this . verify  ( ) ; } }   public void resetEmpty  ( )  {    this . map =  makeObject  ( ) ;   views  ( ) ;    this . confirmed =  makeConfirmedMap  ( ) ; }   public void resetFull  ( )  {    this . map =  makeFullMap  ( ) ;   views  ( ) ;    this . confirmed =  makeConfirmedMap  ( ) ;   final  K  [ ]  k =  getSampleKeys  ( ) ;   final  V  [ ]  v =  getSampleValues  ( ) ;  for (   int  i = 0 ;  i <  k . length ;  i ++ )  {   confirmed . put  (  k [ i ] ,  v [ i ] ) ; } }   private void views  ( )  {    this . keySet =   getMap  ( ) . keySet  ( ) ;    this . entrySet =   getMap  ( ) . entrySet  ( ) ; }   public void verify  ( )  {   verifyMap  ( ) ;   verifyEntrySet  ( ) ;   verifyKeySet  ( ) ;   verifyValues  ( ) ; }   public void verifyMap  ( )  {   final  int  size =   getConfirmed  ( ) . size  ( ) ;   final boolean  empty =   getConfirmed  ( ) . isEmpty  ( ) ;   assertEquals  ( "Map should be same size as HashMap" , size ,   getMap  ( ) . size  ( ) ) ;   assertEquals  ( "Map should be empty if HashMap is" , empty ,   getMap  ( ) . isEmpty  ( ) ) ;   assertEquals  ( "hashCodes should be the same" ,   getConfirmed  ( ) . hashCode  ( ) ,   getMap  ( ) . hashCode  ( ) ) ;   assertEquals  ( "Map should still equal HashMap" , map , confirmed ) ;   assertTrue  (   getMap  ( ) . equals  (  getConfirmed  ( ) ) ) ; }   public void verifyEntrySet  ( )  {   final  int  size =   getConfirmed  ( ) . size  ( ) ;   final boolean  empty =   getConfirmed  ( ) . isEmpty  ( ) ;   assertEquals  (     "entrySet should be same size as HashMap's" + "\nTest: " + entrySet + "\nReal: " +   getConfirmed  ( ) . entrySet  ( ) , size ,  entrySet . size  ( ) ) ;   assertEquals  (     "entrySet should be empty if HashMap is" + "\nTest: " + entrySet + "\nReal: " +   getConfirmed  ( ) . entrySet  ( ) , empty ,  entrySet . isEmpty  ( ) ) ;   assertTrue  (  entrySet . containsAll  (   getConfirmed  ( ) . entrySet  ( ) ) ) ;   assertEquals  (     "entrySet hashCodes should be the same" + "\nTest: " + entrySet + "\nReal: " +   getConfirmed  ( ) . entrySet  ( ) ,    getConfirmed  ( ) . entrySet  ( ) . hashCode  ( ) ,  entrySet . hashCode  ( ) ) ;   assertEquals  ( "Map's entry set should still equal HashMap's" ,   getConfirmed  ( ) . entrySet  ( ) , entrySet ) ; }   public void verifyKeySet  ( )  {   final  int  size =   getConfirmed  ( ) . size  ( ) ;   final boolean  empty =   getConfirmed  ( ) . isEmpty  ( ) ;   assertEquals  (     "keySet should be same size as HashMap's" + "\nTest: " + keySet + "\nReal: " +   getConfirmed  ( ) . keySet  ( ) , size ,  keySet . size  ( ) ) ;   assertEquals  (     "keySet should be empty if HashMap is" + "\nTest: " + keySet + "\nReal: " +   getConfirmed  ( ) . keySet  ( ) , empty ,  keySet . isEmpty  ( ) ) ;   assertTrue  (  keySet . containsAll  (   getConfirmed  ( ) . keySet  ( ) ) ) ;   assertEquals  (     "keySet hashCodes should be the same" + "\nTest: " + keySet + "\nReal: " +   getConfirmed  ( ) . keySet  ( ) ,    getConfirmed  ( ) . keySet  ( ) . hashCode  ( ) ,  keySet . hashCode  ( ) ) ;   assertEquals  ( "Map's key set should still equal HashMap's" ,   getConfirmed  ( ) . keySet  ( ) , keySet ) ; }   public void verifyValues  ( )  {   final  List  < V >  known =  new  ArrayList  < >  (   getConfirmed  ( ) . values  ( ) ) ;   values =   getMap  ( ) . values  ( ) ;   final  List  < V >  test =  new  ArrayList  < >  ( values ) ;   final  int  size =   getConfirmed  ( ) . size  ( ) ;   final boolean  empty =   getConfirmed  ( ) . isEmpty  ( ) ;   assertEquals  (     "values should be same size as HashMap's" + "\nTest: " + test + "\nReal: " + known , size ,  values . size  ( ) ) ;   assertEquals  (     "values should be empty if HashMap is" + "\nTest: " + test + "\nReal: " + known , empty ,  values . isEmpty  ( ) ) ;   assertTrue  (  test . containsAll  ( known ) ) ;   assertTrue  (  known . containsAll  ( test ) ) ;  for (  final V v : known )  {   final boolean  removed =  test . remove  ( v ) ;   assertTrue  ( removed ) ; }   assertTrue  (  test . isEmpty  ( ) ) ; }    @ Override public void tearDown  ( )  throws Exception  {   map = null ;   keySet = null ;   entrySet = null ;   values = null ;   confirmed = null ; }   public  Map  < K , V > getMap  ( )  {  return map ; }   public  Map  < K , V > getConfirmed  ( )  {  return confirmed ; } }