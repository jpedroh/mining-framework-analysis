  package     org . apache . commons . net . tftp ;   import   java . io . BufferedInputStream ;  import   java . io . BufferedOutputStream ;  import   java . io . File ;  import   java . io . FileInputStream ;  import   java . io . FileNotFoundException ;  import   java . io . FileOutputStream ;  import   java . io . IOException ;  import   java . io . InputStream ;  import   java . io . OutputStream ;  import   java . io . PrintStream ;  import   java . net . InetAddress ;  import   java . net . NetworkInterface ;  import   java . net . SocketTimeoutException ;  import   java . time . Duration ;  import   java . util . Enumeration ;  import   java . util . HashSet ;  import      org . apache . commons . net . io . FromNetASCIIOutputStream ;  import      org . apache . commons . net . io . ToNetASCIIInputStream ;   public class TFTPServer  implements  Runnable , AutoCloseable  {   public enum ServerMode  {  GET_ONLY ,  PUT_ONLY ,  GET_AND_PUT }   private class TFTPTransfer  implements  Runnable  {   private final TFTPPacket  tftpPacket ;   private boolean  shutdownTransfer ;  TFTP  transferTftp ;   public TFTPTransfer  (   final TFTPPacket tftpPacket )  {    this . tftpPacket = tftpPacket ; }   private File buildSafeFile  (   final File serverDirectory ,   final String fileName ,   final boolean createSubDirs )  throws IOException  {   final File  temp =   new File  ( serverDirectory , fileName ) . getCanonicalFile  ( ) ;  if  (  !  isSubdirectoryOf  ( serverDirectory , temp ) )  {  throw  new IOException  ( "Cannot access files outside of TFTP server root." ) ; }  if  ( createSubDirs )  {   createDirectory  (  temp . getParentFile  ( ) ) ; }  return temp ; }   private void createDirectory  (   final File file )  throws IOException  {   final File  parent =  file . getParentFile  ( ) ;  if  (  parent == null )  {  throw  new IOException  ( "Unexpected error creating requested directory" ) ; }  if  (  !  parent . exists  ( ) )  {   createDirectory  ( parent ) ; }  if  (  !  parent . isDirectory  ( ) )  {  throw  new IOException  ( "Invalid directory path - file in the way of requested folder" ) ; }  if  (  file . isDirectory  ( ) )  {  return ; }   final boolean  result =  file . mkdir  ( ) ;  if  (  ! result )  {  throw  new IOException  ( "Couldn't create requested directory" ) ; } }   private void handleRead  (   final TFTPReadRequestPacket trrp )  throws IOException , TFTPPacketException  {  if  (  mode ==  ServerMode . PUT_ONLY )  {   transferTftp . bufferedSend  (  new TFTPErrorPacket  (  trrp . getAddress  ( ) ,  trrp . getPort  ( ) ,  TFTPErrorPacket . ILLEGAL_OPERATION , "Read not allowed by server." ) ) ;  return ; }  InputStream  inputStream = null ;  try  {  try  {   inputStream =  new BufferedInputStream  (  new FileInputStream  (  buildSafeFile  ( serverReadDirectory ,  trrp . getFilename  ( ) , false ) ) ) ; }  catch (   final  FileNotFoundException e )  {   transferTftp . bufferedSend  (  new TFTPErrorPacket  (  trrp . getAddress  ( ) ,  trrp . getPort  ( ) ,  TFTPErrorPacket . FILE_NOT_FOUND ,  e . getMessage  ( ) ) ) ;  return ; }  catch (   final  Exception e )  {   transferTftp . bufferedSend  (  new TFTPErrorPacket  (  trrp . getAddress  ( ) ,  trrp . getPort  ( ) ,  TFTPErrorPacket . UNDEFINED ,  e . getMessage  ( ) ) ) ;  return ; }  if  (   trrp . getMode  ( ) ==  TFTP . NETASCII_MODE )  {   inputStream =  new ToNetASCIIInputStream  ( inputStream ) ; }   final   byte  [ ]  temp =  new  byte  [  TFTPDataPacket . MAX_DATA_LENGTH ] ;  TFTPPacket  answer ;   int  block = 1 ;  boolean  sendNext = true ;   int  readLength =  TFTPDataPacket . MAX_DATA_LENGTH ;  TFTPDataPacket  lastSentData = null ;  while  (   readLength ==  TFTPDataPacket . MAX_DATA_LENGTH &&  ! shutdownTransfer )  {  if  ( sendNext )  {   readLength =  inputStream . read  ( temp ) ;  if  (  readLength ==  - 1 )  {   readLength = 0 ; }   lastSentData =  new TFTPDataPacket  (  trrp . getAddress  ( ) ,  trrp . getPort  ( ) , block , temp , 0 , readLength ) ;   sendData  ( transferTftp , lastSentData ) ; }   answer = null ;   int  timeoutCount = 0 ;  while  (   ! shutdownTransfer &&  (    answer == null ||  !   answer . getAddress  ( ) . equals  (  trrp . getAddress  ( ) ) ||   answer . getPort  ( ) !=  trrp . getPort  ( ) ) )  {  if  (  answer != null )  {   log . println  ( "TFTP Server ignoring message from unexpected source." ) ;   transferTftp . bufferedSend  (  new TFTPErrorPacket  (  answer . getAddress  ( ) ,  answer . getPort  ( ) ,  TFTPErrorPacket . UNKNOWN_TID , "Unexpected Host or Port" ) ) ; }  try  {   answer =  transferTftp . bufferedReceive  ( ) ; }  catch (   final  SocketTimeoutException e )  {  if  (  timeoutCount >= maxTimeoutRetries )  {  throw e ; }   timeoutCount ++ ;   transferTftp . bufferedSend  ( lastSentData ) ;  continue ; } }  if  (   answer == null ||  !  (  answer instanceof TFTPAckPacket ) )  {  if  (  ! shutdownTransfer )  {   logError . println  (   "Unexpected response from tftp client during transfer (" + answer + ").  Transfer aborted." ) ; }  break ; }   final TFTPAckPacket  ack =  ( TFTPAckPacket ) answer ;  if  (   ack . getBlockNumber  ( ) != block )  {   sendNext = false ; } else  {   block ++ ;  if  (  block > 65535 )  {   block = 0 ; }   sendNext = true ; } } }  finally  {  try  {  if  (  inputStream != null )  {   inputStream . close  ( ) ; } }  catch (   final  IOException e )  { } } }   private void handleWrite  (   final TFTPWriteRequestPacket twrp )  throws IOException , TFTPPacketException  {  OutputStream  bos = null ;  try  {  if  (  mode ==  ServerMode . GET_ONLY )  {   transferTftp . bufferedSend  (  new TFTPErrorPacket  (  twrp . getAddress  ( ) ,  twrp . getPort  ( ) ,  TFTPErrorPacket . ILLEGAL_OPERATION , "Write not allowed by server." ) ) ;  return ; }   int  lastBlock = 0 ;   final String  fileName =  twrp . getFilename  ( ) ;  try  {   final File  temp =  buildSafeFile  ( serverWriteDirectory , fileName , true ) ;  if  (  temp . exists  ( ) )  {   transferTftp . bufferedSend  (  new TFTPErrorPacket  (  twrp . getAddress  ( ) ,  twrp . getPort  ( ) ,  TFTPErrorPacket . FILE_EXISTS , "File already exists" ) ) ;  return ; }   bos =  new BufferedOutputStream  (  new FileOutputStream  ( temp ) ) ;  if  (   twrp . getMode  ( ) ==  TFTP . NETASCII_MODE )  {   bos =  new FromNetASCIIOutputStream  ( bos ) ; } }  catch (   final  Exception e )  {   transferTftp . bufferedSend  (  new TFTPErrorPacket  (  twrp . getAddress  ( ) ,  twrp . getPort  ( ) ,  TFTPErrorPacket . UNDEFINED ,  e . getMessage  ( ) ) ) ;  return ; }  TFTPAckPacket  lastSentAck =  new TFTPAckPacket  (  twrp . getAddress  ( ) ,  twrp . getPort  ( ) , 0 ) ;   sendData  ( transferTftp , lastSentAck ) ;  while  ( true )  {  TFTPPacket  dataPacket = null ;   int  timeoutCount = 0 ;  while  (   ! shutdownTransfer &&  (    dataPacket == null ||  !   dataPacket . getAddress  ( ) . equals  (  twrp . getAddress  ( ) ) ||   dataPacket . getPort  ( ) !=  twrp . getPort  ( ) ) )  {  if  (  dataPacket != null )  {   log . println  ( "TFTP Server ignoring message from unexpected source." ) ;   transferTftp . bufferedSend  (  new TFTPErrorPacket  (  dataPacket . getAddress  ( ) ,  dataPacket . getPort  ( ) ,  TFTPErrorPacket . UNKNOWN_TID , "Unexpected Host or Port" ) ) ; }  try  {   dataPacket =  transferTftp . bufferedReceive  ( ) ; }  catch (   final  SocketTimeoutException e )  {  if  (  timeoutCount >= maxTimeoutRetries )  {  throw e ; }   transferTftp . bufferedSend  ( lastSentAck ) ;   timeoutCount ++ ;  continue ; } }  if  (  dataPacket instanceof TFTPWriteRequestPacket )  {   lastSentAck =  new TFTPAckPacket  (  twrp . getAddress  ( ) ,  twrp . getPort  ( ) , 0 ) ;   transferTftp . bufferedSend  ( lastSentAck ) ; } else  if  (   dataPacket == null ||  !  (  dataPacket instanceof TFTPDataPacket ) )  {  if  (  ! shutdownTransfer )  {   logError . println  (   "Unexpected response from tftp client during transfer (" + dataPacket + ").  Transfer aborted." ) ; }  break ; } else  {   final  int  block =   (  ( TFTPDataPacket ) dataPacket ) . getBlockNumber  ( ) ;   final   byte  [ ]  data =   (  ( TFTPDataPacket ) dataPacket ) . getData  ( ) ;   final  int  dataLength =   (  ( TFTPDataPacket ) dataPacket ) . getDataLength  ( ) ;   final  int  dataOffset =   (  ( TFTPDataPacket ) dataPacket ) . getDataOffset  ( ) ;  if  (   block > lastBlock ||   lastBlock == 65535 &&  block == 0 )  {   bos . write  ( data , dataOffset , dataLength ) ;   lastBlock = block ; }   lastSentAck =  new TFTPAckPacket  (  twrp . getAddress  ( ) ,  twrp . getPort  ( ) , block ) ;   sendData  ( transferTftp , lastSentAck ) ;  if  (  dataLength <  TFTPDataPacket . MAX_DATA_LENGTH )  {   bos . close  ( ) ;  for (   int  i = 0 ;  i < maxTimeoutRetries ;  i ++ )  {  try  {   dataPacket =  transferTftp . bufferedReceive  ( ) ; }  catch (   final  SocketTimeoutException e )  {  break ; }  if  (   dataPacket != null &&  (   !   dataPacket . getAddress  ( ) . equals  (  twrp . getAddress  ( ) ) ||   dataPacket . getPort  ( ) !=  twrp . getPort  ( ) ) )  {   transferTftp . bufferedSend  (  new TFTPErrorPacket  (  dataPacket . getAddress  ( ) ,  dataPacket . getPort  ( ) ,  TFTPErrorPacket . UNKNOWN_TID , "Unexpected Host or Port" ) ) ; } else  {   transferTftp . bufferedSend  ( lastSentAck ) ; } }  break ; } } } }  finally  {  if  (  bos != null )  {   bos . close  ( ) ; } } }   private boolean isSubdirectoryOf  (   final File parent ,   final File child )  {   final File  childsParent =  child . getParentFile  ( ) ;  if  (  childsParent == null )  {  return false ; }  if  (  childsParent . equals  ( parent ) )  {  return true ; }  return  isSubdirectoryOf  ( parent , childsParent ) ; }    @ Override public void run  ( )  {  try  {   transferTftp =  newTFTP  ( ) ;   transferTftp . beginBufferedOps  ( ) ;   transferTftp . setDefaultTimeout  ( socketTimeout ) ;   transferTftp . open  ( ) ;  if  (  tftpPacket instanceof TFTPReadRequestPacket )  {   handleRead  (  ( TFTPReadRequestPacket ) tftpPacket ) ; } else  if  (  tftpPacket instanceof TFTPWriteRequestPacket )  {   handleWrite  (  ( TFTPWriteRequestPacket ) tftpPacket ) ; } else  {   log . println  (   "Unsupported TFTP request (" + tftpPacket + ") - ignored." ) ; } }  catch (   final  Exception e )  {  if  (  ! shutdownTransfer )  {   logError . println  (  "Unexpected Error in during TFTP file transfer.  Transfer aborted. " + e ) ; } }  finally  {  try  {  if  (   transferTftp != null &&  transferTftp . isOpen  ( ) )  {   transferTftp . endBufferedOps  ( ) ;   transferTftp . close  ( ) ; } }  catch (   final  Exception e )  { }  synchronized  ( transfers )  {   transfers . remove  ( this ) ; } } }   public void shutdown  ( )  {   shutdownTransfer = true ;  try  {   transferTftp . close  ( ) ; }  catch (   final  RuntimeException e )  { } } }   private static final  int  DEFAULT_TFTP_PORT = 69 ;   private static final PrintStream  nullStream =  new PrintStream  (  new OutputStream  ( )  {    @ Override public void write  (   final   byte  [ ] b )  throws IOException  { }    @ Override public void write  (   final  int b )  { } } ) ;   private final  HashSet  < TFTPTransfer >  transfers =  new  HashSet  < >  ( ) ;   private volatile boolean  shutdownServer ;   private TFTP  serverTftp ;   private File  serverReadDirectory ;   private File  serverWriteDirectory ;   private final  int  port ;   private final InetAddress  localAddress ;   private Exception  serverException ;   private final ServerMode  mode ;   private PrintStream  log ;   private PrintStream  logError ;   private  int  maxTimeoutRetries = 3 ;   private  int  socketTimeout ;   private Thread  serverThread ;   public TFTPServer  (   final File serverReadDirectory ,   final File serverWriteDirectory ,   final  int port ,   final InetAddress localAddress ,   final ServerMode mode ,   final PrintStream log ,   final PrintStream errorLog )  throws IOException  {    this . port = port ;    this . mode = mode ;    this . localAddress = localAddress ;    this . log =   log == null ? nullStream : log ;    this . logError =   errorLog == null ? nullStream : errorLog ;   launch  ( serverReadDirectory , serverWriteDirectory ) ; }   public TFTPServer  (   final File serverReadDirectory ,   final File serverWriteDirectory ,   final  int port ,   final NetworkInterface localiface ,   final ServerMode mode ,   final PrintStream log ,   final PrintStream errorLog )  throws IOException  {    this . mode = mode ;    this . port = port ;  InetAddress  inetAddress = null ;  if  (  localiface != null )  {   final  Enumeration  < InetAddress >  ifaddrs =  localiface . getInetAddresses  ( ) ;  if  (   ifaddrs != null &&  ifaddrs . hasMoreElements  ( ) )  {   inetAddress =  ifaddrs . nextElement  ( ) ; } }    this . log =   log == null ? nullStream : log ;    this . logError =   errorLog == null ? nullStream : errorLog ;    this . localAddress = inetAddress ;   launch  ( serverReadDirectory , serverWriteDirectory ) ; }   public TFTPServer  (   final File serverReadDirectory ,   final File serverWriteDirectory ,   final  int port ,   final ServerMode mode ,   final PrintStream log ,   final PrintStream errorLog )  throws IOException  {    this . port = port ;    this . mode = mode ;    this . log =   log == null ? nullStream : log ;    this . logError =   errorLog == null ? nullStream : errorLog ;    this . localAddress = null ;   launch  ( serverReadDirectory , serverWriteDirectory ) ; }   public TFTPServer  (   final File serverReadDirectory ,   final File serverWriteDirectory ,   final ServerMode mode )  throws IOException  {  this  ( serverReadDirectory , serverWriteDirectory , DEFAULT_TFTP_PORT , mode , null , null ) ; }    @ Override public void close  ( )  {   shutdownServer = true ;  synchronized  ( transfers )  {   transfers . forEach  (  TFTPTransfer :: shutdown ) ; }  try  {   serverTftp . close  ( ) ; }  catch (   final  RuntimeException e )  { }  try  {   serverThread . join  ( ) ; }  catch (   final  InterruptedException e )  { } }    @ Override protected void finalize  ( )  throws Throwable  {   close  ( ) ; }   public  int getMaxTimeoutRetries  ( )  {  return maxTimeoutRetries ; }   public  int getPort  ( )  {  return port ; }   public  int getSocketTimeout  ( )  {  return socketTimeout ; }   public boolean isRunning  ( )  throws Exception  {  if  (  shutdownServer &&  serverException != null )  {  throw serverException ; }  return  ! shutdownServer ; }   private void launch  (   final File newServerReadDirectory ,   final File newServerWriteDirectory )  throws IOException  {   log . println  (        "Starting TFTP Server on port " + port + ".  Read directory: " + newServerReadDirectory + " Write directory: " + newServerWriteDirectory + " Server Mode is " + mode ) ;    this . serverReadDirectory =  newServerReadDirectory . getCanonicalFile  ( ) ;  if  (   !  serverReadDirectory . exists  ( ) ||  !  newServerReadDirectory . isDirectory  ( ) )  {  throw  new IOException  (   "The server read directory " +  this . serverReadDirectory + " does not exist" ) ; }    this . serverWriteDirectory =  newServerWriteDirectory . getCanonicalFile  ( ) ;  if  (   !   this . serverWriteDirectory . exists  ( ) ||  !  newServerWriteDirectory . isDirectory  ( ) )  {  throw  new IOException  (   "The server write directory " +  this . serverWriteDirectory + " does not exist" ) ; }   serverTftp =  new TFTP  ( ) ;   socketTimeout =  serverTftp . getDefaultTimeout  ( ) ;   serverTftp . setDefaultTimeout  (  Duration . ZERO ) ;  if  (  localAddress != null )  {   serverTftp . open  ( port , localAddress ) ; } else  {   serverTftp . open  ( port ) ; }   serverThread =  new Thread  ( this ) ;   serverThread . setDaemon  ( true ) ;   serverThread . start  ( ) ; }  TFTP newTFTP  ( )  {  return  new TFTP  ( ) ; }    @ Override public void run  ( )  {  try  {  while  (  ! shutdownServer )  {   final TFTPPacket  tftpPacket ;   tftpPacket =  serverTftp . receive  ( ) ;   final TFTPTransfer  tt =  new TFTPTransfer  ( tftpPacket ) ;  synchronized  ( transfers )  {   transfers . add  ( tt ) ; }   final Thread  thread =  new Thread  ( tt ) ;   thread . setDaemon  ( true ) ;   thread . start  ( ) ; } }  catch (   final  Exception e )  {  if  (  ! shutdownServer )  {   serverException = e ;   logError . println  (  "Unexpected Error in TFTP Server - Server shut down! + " + e ) ; } }  finally  {   shutdownServer = true ;  if  (   serverTftp != null &&  serverTftp . isOpen  ( ) )  {   serverTftp . close  ( ) ; } } }  void sendData  (   final TFTP tftp ,   final TFTPPacket data )  throws IOException  {   tftp . bufferedSend  ( data ) ; }   public void setLog  (   final PrintStream log )  {    this . log = log ; }   public void setLogError  (   final PrintStream logError )  {    this . logError = logError ; }   public void setMaxTimeoutRetries  (   final  int retries )  {  if  (  retries < 0 )  {  throw  new IllegalArgumentException  ( "Invalid Value" ) ; }   maxTimeoutRetries = retries ; }   public void setSocketTimeout  (   final  int timeout )  {  if  (  timeout < 10 )  {  throw  new IllegalArgumentException  ( "Invalid Value" ) ; }   socketTimeout = timeout ; }    @ Deprecated public void shutdown  ( )  {   close  ( ) ; } }