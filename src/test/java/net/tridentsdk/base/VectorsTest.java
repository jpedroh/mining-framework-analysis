  package   net . tridentsdk . base ;   import    net . tridentsdk . world . World ;  import   org . junit . Assert ;  import   org . junit . Test ;  import   org . mockito . Mockito ;  import    org . openjdk . jmh . annotations .  * ;  import     org . openjdk . jmh . infra . Blackhole ;  import     org . openjdk . jmh . results . RunResult ;  import     org . openjdk . jmh . runner . Runner ;  import     org . openjdk . jmh . runner . RunnerException ;  import      org . openjdk . jmh . runner . options . Options ;  import      org . openjdk . jmh . runner . options . OptionsBuilder ;  import   java . util . Collection ;  import    java . util . concurrent . ThreadLocalRandom ;  import    java . util . concurrent . TimeUnit ;  import static    org . junit . Assert . assertEquals ;  import static    org . junit . Assert . assertNotNull ;    @ State  (  Scope . Benchmark ) public class VectorsTest  {   private static final  double  CHANGE_TO =  - 1.382 ;   private static final  int  CHANGE_TO_I = 2919 ;   private final Vector  vec =  new Vector  ( ) ;   public static Vector rand  ( )  {  ThreadLocalRandom  r =  ThreadLocalRandom . current  ( ) ;  return  new Vector  (  r . nextDouble  ( ) ,  r . nextDouble  ( ) ,  r . nextDouble  ( ) ) ; }    @ Test public void testSetsEqualsHash  ( )  {    this . vec . setX  ( CHANGE_TO ) ;    this . vec . setY  ( CHANGE_TO ) ;    this . vec . setZ  ( CHANGE_TO ) ;  Vector  v2 =  new Vector  ( CHANGE_TO , CHANGE_TO , CHANGE_TO ) ;   assertEquals  ( v2 ,  this . vec ) ;   assertEquals  (  v2 . hashCode  ( ) ,   this . vec . hashCode  ( ) ) ;   Assert . assertFalse  (   this . vec . equals  (  new Object  ( ) ) ) ; }    @ Test public void testSGDouble  ( )  {    this . vec . setX  ( CHANGE_TO ) ;    this . vec . setY  ( CHANGE_TO ) ;    this . vec . setZ  ( CHANGE_TO ) ;   assertEquals  ( CHANGE_TO ,   this . vec . getX  ( ) , 0 ) ;   assertEquals  ( CHANGE_TO ,   this . vec . getY  ( ) , 0 ) ;   assertEquals  ( CHANGE_TO ,   this . vec . getZ  ( ) , 0 ) ; }    @ Test public void testSGInt  ( )  {    this . vec . setX  ( CHANGE_TO_I ) ;    this . vec . setY  ( CHANGE_TO_I ) ;    this . vec . setZ  ( CHANGE_TO_I ) ;   assertEquals  ( CHANGE_TO_I ,   this . vec . getIntX  ( ) ) ;   assertEquals  ( CHANGE_TO_I ,   this . vec . getIntY  ( ) ) ;   assertEquals  ( CHANGE_TO_I ,   this . vec . getIntZ  ( ) ) ; }    @ Test public void testOps  ( )  {  Vector  v2 =  new Vector  ( CHANGE_TO , CHANGE_TO , CHANGE_TO ) ;    this . vec . add  ( v2 ) ;    this . vec . add  ( CHANGE_TO , CHANGE_TO , CHANGE_TO ) ;    this . vec . add  ( CHANGE_TO_I , CHANGE_TO_I , CHANGE_TO_I ) ;    this . vec . subtract  ( v2 ) ;    this . vec . subtract  ( CHANGE_TO , CHANGE_TO , CHANGE_TO ) ;    this . vec . subtract  ( CHANGE_TO_I , CHANGE_TO_I , CHANGE_TO_I ) ;    this . vec . multiply  ( v2 ) ;    this . vec . multiply  ( CHANGE_TO , CHANGE_TO , CHANGE_TO ) ;    this . vec . multiply  ( CHANGE_TO_I , CHANGE_TO_I , CHANGE_TO_I ) ;    this . vec . divide  ( v2 ) ;    this . vec . divide  ( CHANGE_TO , CHANGE_TO , CHANGE_TO ) ;    this . vec . divide  ( CHANGE_TO_I , CHANGE_TO_I , CHANGE_TO_I ) ;   assertEquals  (  new AbstractVector  ( ) ,  this . vec ) ; }    @ Test public void testIntConstructor  ( )  {   assertEquals  (  new AbstractVector  ( 0 , 0 , 0 ) ,  this . vec ) ;   assertEquals  (  new Vector  ( 0 , 0 , 0 ) ,  this . vec ) ; }    @ Test public void testWrite  ( )  {  Vector  v2 =  new Vector  ( CHANGE_TO , CHANGE_TO , CHANGE_TO ) ;   v2 . vecWrite  (  this . vec ) ;   v2 . write  (  this . vec ) ;   assertEquals  (  this . vec , v2 ) ; }    @ Test public void testNormalize  ( )  {  Vector  v2 =  new Vector  ( CHANGE_TO_I , CHANGE_TO_I , CHANGE_TO_I ) ;   v2 . normalize  ( ) ;   assertEquals  ( 1 ,  v2 . getMagnitude  ( ) , 0 ) ; }    @ Test public void testToString  ( )  {   assertNotNull  (   this . vec . toString  ( ) ) ; }    @ Test public void testToPosition  ( )  {  World  world =  Mockito . mock  (  World . class ) ;  Position  position =   this . vec . toPosition  ( world ) ;   assertEquals  ( world ,  position . world  ( ) ) ;   assertEquals  (  position . x  ( ) ,   this . vec . x  ( ) , 0 ) ;   assertEquals  (  position . y  ( ) ,   this . vec . y  ( ) , 0 ) ;   assertEquals  (  position . z  ( ) ,   this . vec . z  ( ) , 0 ) ; }   public static void main  (   String  [ ] args )  {   m2  ( ) ; }   public static void m1  ( )  {  Vector  vec =  new Vector  ( 0 , 0 , 0 ) ;   int  recursions = 600_000_000 ;   long  modulo = 100 ;   p  ( "Attempting to inline add(i, i, i)" ) ;   int  curMod = 0 ;  for (   int  i = 0 ;  i < recursions ;  i ++ )  {  if  (   (  i & modulo ) == 0 )  {   curMod =  i ^  (  int )  System . currentTimeMillis  ( ) ; }   vec . add  ( curMod , curMod , curMod ) ; }   p  (  "Finished attempt at " +  (    vec . getX  ( ) +  vec . getY  ( ) +  vec . getZ  ( ) ) ) ; }   private static void p  (  String s )  {    System . out . println  ( s ) ; }   public static void m2  ( )  {  Options  opt =           new OptionsBuilder  ( ) . include  (   ".*" +   VectorsTest . class . getSimpleName  ( ) + ".*" ) . timeUnit  (  TimeUnit . SECONDS ) . mode  (  Mode . Throughput ) . operationsPerInvocation  ( 1 ) . warmupIterations  ( 20 ) . measurementIterations  ( 5 ) . forks  ( 1 ) . threads  ( 4 ) . build  ( ) ;   Collection  < RunResult >  results = null ;  try  {   results =   new Runner  ( opt ) . run  ( ) ; }  catch (   RunnerException e )  {   e . printStackTrace  ( ) ; }  for ( RunResult result : results )  {    System . out . println  (     result . getPrimaryResult  ( ) . getLabel  ( ) + " - " +   result . getPrimaryResult  ( ) . getScore  ( ) ) ; } }   private  int  modifier ;   private Vector  adder ;    @ Setup  (  Level . Iteration ) public void setup  ( )  {    this . modifier =   ThreadLocalRandom . current  ( ) . nextInt  ( ) ;    this . adder =  new Vector  (  this . modifier ,  this . modifier ,  this . modifier ) ; }   public void add  ( )  {    this . vec . add  (  this . modifier ,  this . modifier ,  this . modifier ) ; }    @ Benchmark public void addT  ( )  {    this . vec . add  (  this . adder ) ; }    @ TearDown  (  Level . Trial ) public void teardown  (  Blackhole bh )  {   bh . consume  (     this . vec . getX  ( ) +   this . vec . getY  ( ) +   this . vec . getZ  ( ) ) ; }   public static void m3  ( )  {  while  ( true )  { } } }