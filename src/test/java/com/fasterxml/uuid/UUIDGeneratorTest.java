  package   com . fasterxml . uuid ;   import   java . nio . ByteBuffer ;  import   java . security . MessageDigest ;  import  java . util .  * ;  import   junit . framework . Test ;  import   junit . framework . TestCase ;  import   junit . framework . TestSuite ;  import   junit . textui . TestRunner ;  import     com . fasterxml . uuid . impl . UUIDUtil ;  import     com . fasterxml . uuid . impl . NameBasedGenerator ;  import     com . fasterxml . uuid . impl . RandomBasedGenerator ;  import     com . fasterxml . uuid . impl . TimeBasedEpochGenerator ;  import     com . fasterxml . uuid . impl . TimeBasedReorderedGenerator ;  import     com . fasterxml . uuid . impl . TimeBasedGenerator ;   public class UUIDGeneratorTest  extends TestCase  {   private static final  int  SIZE_OF_TEST_ARRAY = 9000 ;   public UUIDGeneratorTest  (    java . lang . String testName )  {  super  ( testName ) ; }   public static Test suite  ( )  {  TestSuite  suite =  new TestSuite  (  UUIDGeneratorTest . class ) ;  return suite ; }   public static void main  (   String  [ ] args )  {   TestRunner . run  (  suite  ( ) ) ; }   public void testGetDummyAddress  ( )  {  EthernetAddress  ethernet_address_array  [ ] =  new EthernetAddress  [ SIZE_OF_TEST_ARRAY ] ;  Random  rnd =  new Random  ( 123L ) ;  for (   int  i = 0 ;  i <  ethernet_address_array . length ;  i ++ )  {    ethernet_address_array [ i ] =  EthernetAddress . constructMulticastAddress  ( rnd ) ; }  EthernetAddress  null_ethernet_address =  new EthernetAddress  ( 0L ) ;  for (   int  i = 0 ;  i <  ethernet_address_array . length ;  i ++ )  {    byte  [ ]  ethernet_address =   ethernet_address_array [ i ] . asByteArray  ( ) ;   assertFalse  ( "dummy EthernetAddress was null" ,  Arrays . equals  (  null_ethernet_address . asByteArray  ( ) , ethernet_address ) ) ;   assertEquals  ( "dummy EthernetAddress was not broadcast" , 0x01 ,  (   ethernet_address [ 0 ] & 0x01 ) ) ; } }   public void testGenerateRandomBasedUUID  ( )  {  RandomBasedGenerator  uuid_gen =  Generators . randomBasedGenerator  ( ) ;  UUID  uuid_array  [ ] =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  ( ) ; }   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . RANDOM_BASED ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ; }   public void testGenerateTimeBasedUUID  ( )  {  TimeBasedGenerator  uuid_gen =  Generators . timeBasedGenerator  ( ) ;  UUID  uuid_array  [ ] =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;   long  start_time =  System . currentTimeMillis  ( ) ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  ( ) ; }   long  end_time =  System . currentTimeMillis  ( ) ;   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . TIME_BASED ) ;   checkUUIDArrayForCorrectOrdering  ( uuid_array ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;   checkUUIDArrayForCorrectCreationTime  ( uuid_array , start_time , end_time ) ; }   public void testGenerateTimeBasedUUIDWithEthernetAddress  ( )  {  EthernetAddress  ethernet_address =  new EthernetAddress  ( "87:F5:93:06:D3:0C" ) ;  TimeBasedGenerator  uuid_gen =  Generators . timeBasedGenerator  ( ethernet_address ) ;  UUID  uuid_array  [ ] =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;   long  start_time =  System . currentTimeMillis  ( ) ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  ( ) ; }   long  end_time =  System . currentTimeMillis  ( ) ;   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . TIME_BASED ) ;   checkUUIDArrayForCorrectOrdering  ( uuid_array ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;   checkUUIDArrayForCorrectCreationTime  ( uuid_array , start_time , end_time ) ;   checkUUIDArrayForCorrectEthernetAddress  ( uuid_array , ethernet_address ) ; }   public void testV7value  ( )  {  UUID  testValue =  UUID . fromString  ( "017F22E2-79B0-7CC3-98C4-DC0C0C07398F" ) ;   checkUUIDArrayForCorrectCreationTimeEpoch  (  new UUID  [ ]  { testValue } , 1645557742000L , 1645557742010L ) ; }   public void testGenerateTimeBasedEpochUUID  ( )  throws Exception  {  Random  entropy =  new Random  ( 0x666 ) ;  TimeBasedEpochGenerator  uuid_gen =  Generators . timeBasedEpochGenerator  ( entropy ) ;  UUID  uuid_array  [ ] =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;   long  start_time =  System . currentTimeMillis  ( ) ;   Thread . sleep  ( 2 ) ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  ( ) ; }   long  end_time =  System . currentTimeMillis  ( ) ;   Thread . sleep  ( 2 ) ;   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . TIME_BASED_EPOCH ) ;   checkUUIDArrayForCorrectOrdering  ( uuid_array ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;   checkUUIDArrayForCorrectCreationTimeEpoch  ( uuid_array , start_time , end_time ) ; }   public void testGenerateNameBasedUUIDNameSpaceAndName  ( )  {  NameBasedGenerator  uuid_gen =  Generators . nameBasedGenerator  (  NameBasedGenerator . NAMESPACE_URL ) ;  UUID  uuid_array  [ ] =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  (  "test name" + i ) ; }   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . NAME_BASED_SHA1 ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  (  "test name" + i ) ; }   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . NAME_BASED_SHA1 ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;   uuid_array =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;   uuid_gen =  Generators . nameBasedGenerator  (  NameBasedGenerator . NAMESPACE_URL ) ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  (  "test name" + i ) ; }  UUID  uuid_array2  [ ] =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;   uuid_gen =  Generators . nameBasedGenerator  (  NameBasedGenerator . NAMESPACE_URL ) ;  for (   int  i = 0 ;  i <  uuid_array2 . length ;  i ++ )  {    uuid_array2 [ i ] =  uuid_gen . generate  (  "test name" + i ) ; }   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForNonNullUUIDs  ( uuid_array2 ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . NAME_BASED_SHA1 ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array2 ,  UUIDType . NAME_BASED_SHA1 ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;   checkUUIDArrayForUniqueness  ( uuid_array2 ) ;   assertTrue  ( "expected both arrays to be equal, they were not!" ,  Arrays . equals  ( uuid_array , uuid_array2 ) ) ; }   public void testGenerateNameBasedUUIDNameSpaceNameAndMessageDigest  ( )  {  MessageDigest  MESSAGE_DIGEST = null ;  try  {   MESSAGE_DIGEST =  MessageDigest . getInstance  ( "MD5" ) ; }  catch (   Exception ex )  {   fail  (  "exception caught getting test digest : " + ex ) ; }  NameBasedGenerator  uuid_gen =  Generators . nameBasedGenerator  (  NameBasedGenerator . NAMESPACE_URL , MESSAGE_DIGEST ) ;  UUID  uuid_array  [ ] =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  (  "test name" + i ) ; }   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . NAME_BASED_MD5 ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  (  "test name" + i ) ; }   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . NAME_BASED_MD5 ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;   uuid_array =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  (  "test name" + i ) ; }  UUID  uuid_array2  [ ] =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;  for (   int  i = 0 ;  i <  uuid_array2 . length ;  i ++ )  {    uuid_array2 [ i ] =  uuid_gen . generate  (  "test name" + i ) ; }   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForNonNullUUIDs  ( uuid_array2 ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . NAME_BASED_MD5 ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array2 ,  UUIDType . NAME_BASED_MD5 ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;   checkUUIDArrayForUniqueness  ( uuid_array2 ) ;   assertTrue  ( "expected both arrays to be equal, they were not!" ,  Arrays . equals  ( uuid_array , uuid_array2 ) ) ; }   public void testGenerateTimeBasedReorderedUUID  ( )  {  TimeBasedReorderedGenerator  uuid_gen =  Generators . timeBasedReorderedGenerator  ( ) ;  UUID  uuid_array  [ ] =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;   long  start_time =  System . currentTimeMillis  ( ) ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  ( ) ; }   long  end_time =  System . currentTimeMillis  ( ) ;   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . TIME_BASED_REORDERED ) ;   checkUUIDArrayForCorrectOrdering  ( uuid_array ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;   checkUUIDArrayForCorrectCreationTimeReorder  ( uuid_array , start_time , end_time ) ; }   public void testGenerateTimeBasedReorderedUUIDWithEthernetAddress  ( )  {  EthernetAddress  ethernet_address =  new EthernetAddress  ( "87:F5:93:06:D3:0C" ) ;  TimeBasedReorderedGenerator  uuid_gen =  Generators . timeBasedReorderedGenerator  ( ethernet_address ) ;  UUID  uuid_array  [ ] =  new UUID  [ SIZE_OF_TEST_ARRAY ] ;   long  start_time =  System . currentTimeMillis  ( ) ;  for (   int  i = 0 ;  i <  uuid_array . length ;  i ++ )  {    uuid_array [ i ] =  uuid_gen . generate  ( ) ; }   long  end_time =  System . currentTimeMillis  ( ) ;   checkUUIDArrayForNonNullUUIDs  ( uuid_array ) ;   checkUUIDArrayForCorrectVariantAndVersion  ( uuid_array ,  UUIDType . TIME_BASED_REORDERED ) ;   checkUUIDArrayForCorrectOrdering  ( uuid_array ) ;   checkUUIDArrayForUniqueness  ( uuid_array ) ;   checkUUIDArrayForCorrectCreationTimeReorder  ( uuid_array , start_time , end_time ) ;   checkUUIDArrayForCorrectEthernetAddress  ( uuid_array , ethernet_address ) ; }  class ReverseOrderUUIDComparator  implements   Comparator  < UUID >  {    @ Override public  int compare  (  UUID uuid1 ,  UUID uuid2 )  {  return  -  uuid1 . compareTo  ( uuid2 ) ; }    @ Override public boolean equals  (  Object o )  {  return  super . equals  ( o ) ; } }   private void checkUUIDArrayForCorrectOrdering  (   UUID  [ ] uuidArray )  {  UUID  uuid_sorted_array  [ ] =  (  UUID  [ ] )  uuidArray . clone  ( ) ;   assertEquals  ( "Cloned array length did not match" ,  uuidArray . length ,  uuid_sorted_array . length ) ;  ReverseOrderUUIDComparator  rev_order_uuid_comp =  new ReverseOrderUUIDComparator  ( ) ;   Arrays . sort  ( uuid_sorted_array , rev_order_uuid_comp ) ;  for (   int  i = 0 ;  i <  uuid_sorted_array . length ;  i ++ )  {   assertTrue  (  "Reverse order check on uuid arrays failed on element " + i ,   uuidArray [ i ] . equals  (  uuid_sorted_array [   uuid_sorted_array . length -  (  1 + i ) ] ) ) ; }   Arrays . sort  ( uuid_sorted_array ) ;  for (   int  i = 0 ;  i <  uuid_sorted_array . length ;  i ++ )  {   assertTrue  (  "Same order check on uuid arrays failed on element " + i ,   uuidArray [ i ] . equals  (  uuid_sorted_array [ i ] ) ) ; } }   private void checkUUIDArrayForUniqueness  (   UUID  [ ] uuidArray )  {   HashSet  < UUID >  hash_set =  new  HashSet  < UUID >  ( ) ;  for (   int  i = 0 ;  i <  uuidArray . length ;  i ++ )  {   assertTrue  (    "Uniqueness test failed on insert into HashSet: index " + i + ", value " +  uuidArray [ i ] ,  hash_set . add  (  uuidArray [ i ] ) ) ;   assertFalse  ( "Paranoia Uniqueness test failed (second insert)" ,  hash_set . add  (  uuidArray [ i ] ) ) ; } }   private void checkUUIDArrayForCorrectVariantAndVersion  (   UUID  [ ] uuidArray ,  UUIDType expectedType )  {  for (   int  i = 0 ;  i <  uuidArray . length ;  i ++ )  {  UUIDType  actual =  UUIDUtil . typeOf  (  uuidArray [ i ] ) ;  if  (  actual != expectedType )  {   fail  (          "Expected version (type) did not match for UUID '" +  uuidArray [ i ] + "' " + i + " (of " +  uuidArray . length + "); expected " + expectedType + ", got " + actual ) ; }    byte  [ ]  temp_uuid =  UUIDUtil . asByteArray  (  uuidArray [ i ] ) ;   int  type =   (   temp_uuid [  UUIDUtil . BYTE_OFFSET_TYPE ] & 0xFF ) >> 4 ;   assertEquals  ( "Expected type did not match" ,  expectedType . raw  ( ) , type ) ;   int  variant =   (   temp_uuid [  UUIDUtil . BYTE_OFFSET_VARIATION ] & 0xFF ) >> 6 ;   assertEquals  ( "Expected variant did not match" , 2 , variant ) ; } }   private void checkUUIDArrayForCorrectCreationTime  (   UUID  [ ] uuidArray ,   long startTime ,   long endTime )  {   final  long  MILLI_CONVERSION_FACTOR = 10000L ;   final  long  GREGORIAN_CALENDAR_START_TO_UTC_START_OFFSET = 122192928000000000L ;   assertTrue  (    "Start time: " + startTime + " was after the end time: " + endTime ,  startTime <= endTime ) ;  for (   int  i = 0 ;  i <  uuidArray . length ;  i ++ )  {    byte  [ ]  temp_uuid =  UUIDUtil . asByteArray  (  uuidArray [ i ] ) ;   long  uuid_time = 0L ;   uuid_time |=  (   (   temp_uuid [ 3 ] & 0xF0L ) << 0 ) ;   uuid_time |=  (   (   temp_uuid [ 2 ] & 0xFFL ) << 8 ) ;   uuid_time |=  (   (   temp_uuid [ 1 ] & 0xFFL ) << 16 ) ;   uuid_time |=  (   (   temp_uuid [ 0 ] & 0xFFL ) << 24 ) ;   uuid_time |=  (   (   temp_uuid [ 5 ] & 0xFFL ) << 32 ) ;   uuid_time |=  (   (   temp_uuid [ 4 ] & 0xFFL ) << 40 ) ;   uuid_time |=  (   (   temp_uuid [ 7 ] & 0xFFL ) << 48 ) ;   uuid_time |=  (   (   temp_uuid [ 6 ] & 0x0FL ) << 56 ) ;   uuid_time -= GREGORIAN_CALENDAR_START_TO_UTC_START_OFFSET ;   uuid_time /= MILLI_CONVERSION_FACTOR ;   assertTrue  (    "Start time: " + startTime + " was not before UUID timestamp: " + uuid_time ,  startTime <= uuid_time ) ;   assertTrue  (    "UUID timestamp: " + uuid_time + " was not before the end time: " + endTime ,  uuid_time <= endTime ) ; } }   private void checkUUIDArrayForCorrectCreationTimeReorder  (   UUID  [ ] uuidArray ,   long startTime ,   long endTime )  {   final  long  MILLI_CONVERSION_FACTOR = 10000L ;   final  long  GREGORIAN_CALENDAR_START_TO_UTC_START_OFFSET = 122192928000000000L ;   assertTrue  (    "Start time: " + startTime + " was after the end time: " + endTime ,  startTime <= endTime ) ;  for (   int  i = 0 ;  i <  uuidArray . length ;  i ++ )  {    byte  [ ]  temp_uuid =  UUIDUtil . asByteArray  (  uuidArray [ i ] ) ;   long  uuid_time = 0L ;   uuid_time |=  (   (   temp_uuid [ 0 ] & 0xFFL ) << 52 ) ;   uuid_time |=  (   (   temp_uuid [ 1 ] & 0xFFL ) << 44 ) ;   uuid_time |=  (   (   temp_uuid [ 2 ] & 0xFFL ) << 36 ) ;   uuid_time |=  (   (   temp_uuid [ 3 ] & 0xFFL ) << 28 ) ;   uuid_time |=  (   (   temp_uuid [ 4 ] & 0xFFL ) << 20 ) ;   uuid_time |=  (   (   temp_uuid [ 5 ] & 0xFFL ) << 12 ) ;   uuid_time |=  (   (   temp_uuid [ 6 ] & 0x0FL ) << 8 ) ;   uuid_time |=  (  (   temp_uuid [ 7 ] & 0xFFL ) ) ;   uuid_time -= GREGORIAN_CALENDAR_START_TO_UTC_START_OFFSET ;   uuid_time /= MILLI_CONVERSION_FACTOR ;   assertTrue  (    "Start time: " + startTime + " was not before UUID timestamp: " + uuid_time ,  startTime <= uuid_time ) ;   assertTrue  (    "UUID timestamp: " + uuid_time + " was not before the end time: " + endTime ,  uuid_time <= endTime ) ; } }   private void checkUUIDArrayForCorrectCreationTimeEpoch  (   UUID  [ ] uuidArray ,   long startTime ,   long endTime )  {   assertTrue  (    "Start time: " + startTime + " was after the end time: " + endTime ,  startTime <= endTime ) ;  for (   int  i = 0 ;  i <  uuidArray . length ;  i ++ )  {    byte  [ ]  temp_uuid =  UUIDUtil . asByteArray  (  uuidArray [ i ] ) ;  ByteBuffer  buff =  ByteBuffer . wrap  ( temp_uuid ) ;   final  long  uuid_time =   buff . getLong  ( ) >>> 16 ;   assertTrue  (    "Start time: " + startTime + " was not before UUID timestamp: " + uuid_time ,  startTime <= uuid_time ) ;   assertTrue  (      "UUID: " + i + " timestamp: " + uuid_time + " was not before the end time: " + endTime ,  uuid_time <= endTime ) ; } }   private void checkUUIDArrayForCorrectEthernetAddress  (   UUID  [ ] uuidArray ,  EthernetAddress ethernetAddress )  {  for (   int  i = 0 ;  i <  uuidArray . length ;  i ++ )  {    byte  [ ]  uuid_ethernet_address =  new  byte  [ 6 ] ;   System . arraycopy  (  UUIDUtil . asByteArray  (  uuidArray [ i ] ) , 10 , uuid_ethernet_address , 0 , 6 ) ;    byte  [ ]  ethernet_address =  ethernetAddress . asByteArray  ( ) ;   assertTrue  ( "UUID ethernet address did not equal passed ethernetAddress" ,  Arrays . equals  ( ethernet_address , uuid_ethernet_address ) ) ; } }   private void checkUUIDArrayForNonNullUUIDs  (   UUID  [ ] uuidArray )  {  for (   int  i = 0 ;  i <  uuidArray . length ;  i ++ )  {  if  (   UUIDUtil . typeOf  (  uuidArray [ i ] ) ==  UUIDType . UNKNOWN )  {   fail  (   "Entry #" + i + " was UNKNOWN UUID, shouldn't be" ) ; } } } }