  package   com . esotericsoftware . kryo ;   import static    com . esotericsoftware . kryo . ReflectionAssert .  * ;  import static   java . lang . Integer .  * ;  import     com . esotericsoftware . kryo . SerializationCompatTestData . TestData ;  import     com . esotericsoftware . kryo . SerializationCompatTestData . TestDataJava8 ;  import     com . esotericsoftware . kryo . io . ByteBufferInput ;  import     com . esotericsoftware . kryo . io . ByteBufferOutput ;  import     com . esotericsoftware . kryo . io . Input ;  import     com . esotericsoftware . kryo . io . Output ;  import     com . esotericsoftware . kryo . util . DefaultInstantiatorStrategy ;  import    com . esotericsoftware . minlog . Log ;  import   java . io . File ;  import   java . io . FileInputStream ;  import   java . io . FileNotFoundException ;  import   java . io . FileOutputStream ;  import    java . lang . reflect . Field ;  import   java . util . ArrayList ;  import   java . util . EnumSet ;  import   java . util . List ;  import    org . objenesis . strategy . StdInstantiatorStrategy ;  import static     org . junit . jupiter . api . Assertions .  * ;  import     org . junit . jupiter . api . BeforeEach ;  import     org . junit . jupiter . api . Test ;  class SerializationCompatTest  extends KryoTestCase  {   private static final boolean  DELETE_FAILED_TEST_FILES = false ;   private static final  int  JAVA_VERSION ;  static  {   String  [ ]  strVersions =   System . getProperty  ( "java.version" ) . split  ( "\\." ) ;  if  (   strVersions . length == 1 )  {   JAVA_VERSION =  parseInt  (  strVersions [ 0 ] ) ; } else  {    int  [ ]  versions =  new  int  [ ]  {  parseInt  (  strVersions [ 0 ] ) ,  parseInt  (  strVersions [ 1 ] ) } ;   JAVA_VERSION =    versions [ 0 ] > 1 ?  versions [ 0 ] :  versions [ 1 ] ; } }   private static final  int  EXPECTED_DEFAULT_SERIALIZER_COUNT =   JAVA_VERSION < 11 ? 58 : 
<<<<<<<
  JAVA_VERSION < 14 ? 67 : 68
=======
68
>>>>>>>
 ;   private static final  List  < TestDataDescription >  TEST_DATAS =  new  ArrayList  < >  ( ) ;  static  {   TEST_DATAS . add  (  new  TestDataDescription  < >  (  new TestData  ( ) , 1940 , 1958 ) ) ;  if  (  JAVA_VERSION >= 8 )   TEST_DATAS . add  (  new  TestDataDescription  < >  (  new TestDataJava8  ( ) , 2098 , 2116 ) ) ;  if  (  JAVA_VERSION >= 11 )   TEST_DATAS . add  (  new  TestDataDescription  < >  (  createTestData  ( 11 ) , 2182 , 2210 ) ) ;  if  (  JAVA_VERSION >= 14 )   TEST_DATAS . add  (  new  TestDataDescription  < >  (  createTestData  ( 14 ) , 1948 , 1966 ) ) ; } ;   private static TestData createTestData  (   int version )  {  try  {  return  ( TestData )    Class . forName  (  "com.esotericsoftware.kryo.TestDataJava" + version ) . getConstructor  ( ) . newInstance  ( ) ; }  catch (   ReflectiveOperationException e )  {  throw  new RuntimeException  (   "TestDataJava" + version + " could not be instantiated" , e ) ; } }   public  @ BeforeEach void setUp  ( )  throws Exception  {   super . setUp  ( ) ;   kryo . setInstantiatorStrategy  (  new DefaultInstantiatorStrategy  (  new StdInstantiatorStrategy  ( ) ) ) ;   kryo . setReferences  ( true ) ;   kryo . setRegistrationRequired  ( false ) ;   kryo . register  (  EnumSet . class ) ; }    @ Test void testDefaultSerializers  ( )  throws Exception  {  Field  defaultSerializersField =   Kryo . class . getDeclaredField  ( "defaultSerializers" ) ;   defaultSerializersField . setAccessible  ( true ) ;  List  defaultSerializers =  ( List )  defaultSerializersField . get  ( kryo ) ;   assertEquals  ( EXPECTED_DEFAULT_SERIALIZER_COUNT ,  defaultSerializers . size  ( ) ,     "The registered default serializers have changed.\n" + "Because serialization compatibility shall be checked for default serializers, you must extend " + "SerializationCompatTestData.TestData to have a field for the type of the new default serializer.\n" + "After that's done, you must create new versions of 'test/resources/data*' because the new TestData instance will " + "no longer be equals the formerly written/serialized one." ) ; }    @ Test void testStandard  ( )  throws Exception  {   runTests  ( "standard" ,  new  Function1  < File , Input >  ( )  {   public Input apply  (  File file )  throws FileNotFoundException  {  return  new Input  (  new FileInputStream  ( file ) ) ; } } ,  new  Function1  < File , Output >  ( )  {   public Output apply  (  File file )  throws Exception  {  return  new Output  (  new FileOutputStream  ( file ) ) ; } } ) ; }    @ Test void testByteBuffer  ( )  throws Exception  {   runTests  ( "bytebuffer" ,  new  Function1  < File , Input >  ( )  {   public Input apply  (  File file )  throws FileNotFoundException  {  return  new ByteBufferInput  (  new FileInputStream  ( file ) ) ; } } ,  new  Function1  < File , Output >  ( )  {   public Output apply  (  File file )  throws Exception  {  return  new ByteBufferOutput  (  new FileOutputStream  ( file ) ) ; } } ) ; }   private void runTests  (  String variant ,   Function1  < File , Input > inputFactory ,   Function1  < File , Output > outputFactory )  throws Exception  {   setUp  ( ) ;  for ( TestDataDescription description : TEST_DATAS )   runTest  ( description , variant , inputFactory , outputFactory ) ; }   private void runTest  (  TestDataDescription description ,  String variant ,   Function1  < File , Input > inputFactory ,   Function1  < File , Output > outputFactory )  throws Exception  {  File  testDir =  new File  ( "test" ) ;  if  (  !  testDir . exists  ( ) )   testDir =  new File  ( "../test" ) ;  File  file =  new File  ( testDir ,     "resources/" +  description . classSimpleName  ( ) + "-" + variant + ".ser" ) ;    file . getParentFile  ( ) . mkdirs  ( ) ;  if  (  file . exists  ( ) )  {   Log . info  (      "Reading and testing " +  description . classSimpleName  ( ) + " with mode '" + variant + "' from file " +  file . getAbsolutePath  ( ) ) ;  Input  in =  inputFactory . apply  ( file ) ;  try  {   readAndRunTest  ( description , in ) ; }  catch (   Throwable ex )  {  if  ( DELETE_FAILED_TEST_FILES )  {    System . out . println  (  "Failed: " +  file . getAbsolutePath  ( ) ) ;   in . close  ( ) ;   file . delete  ( ) ; } else  throw ex ; }   in . close  ( ) ; } else  {   Log . info  (      "Testing and writing " +  description . classSimpleName  ( ) + " with mode '" + variant + "' to file " +  file . getAbsolutePath  ( ) ) ;  Output  out =  outputFactory . apply  ( file ) ;  try  {   runTestAndWrite  ( description , out ) ;   out . close  ( ) ; }  catch (   Exception e )  {   out . close  ( ) ;   file . delete  ( ) ;  throw e ; } } }   private void readAndRunTest  (   TestDataDescription  <  ? > description ,  Input in )  throws FileNotFoundException  {  TestData  actual =  kryo . readObject  ( in ,  description . testDataClass  ( ) ) ;   roundTrip  (  description . length ,  description . noGenericsLength , actual ) ;  try  {   assertReflectionEquals  ( actual ,  description . testData ) ; }  catch (   AssertionError e )  {   Log . info  (    "Serialization format is broken, please check " +   getClass  ( ) . getSimpleName  ( ) + "'s class doc to see" + " what this means and how to proceed." ) ;  throw e ; } }   private void runTestAndWrite  (  TestDataDescription description ,  Output out )  throws FileNotFoundException  {   roundTrip  (  description . length ,  description . noGenericsLength ,  description . testData ) ;   kryo . writeObject  ( out ,  description . testData ) ; }   protected void doAssertEquals  (   final Object one ,   final Object another )  {  try  {   assertReflectionEquals  ( one , another ) ; }  catch (   Exception e )  {   fail  (  "Test failed: " + e ) ; } }   private interface Function1  <  A ,  B >  {  B apply  (  A input )  throws Exception ; }   private static class TestDataDescription  <  T  extends TestData >  {   final T  testData ;   final  int  length ;   final  int  noGenericsLength ;  TestDataDescription  (  T testData ,   int length ,   int noGenericsLength )  {    this . testData = testData ;    this . length = length ;    this . noGenericsLength = noGenericsLength ; }   Class  < T > testDataClass  ( )  {  return  (  Class  < T > )  testData . getClass  ( ) ; }  String classSimpleName  ( )  {  return   testData . getClass  ( ) . getSimpleName  ( ) ; } } }