  package    com . mpush . core . router ;   import     com . google . common . eventbus . Subscribe ;  import     com . mpush . api . connection . Connection ;  import     com . mpush . api . connection . SessionContext ;  import     com . mpush . api . event . RouterChangeEvent ;  import     com . mpush . api . router . ClientLocation ;  import     com . mpush . api . router . Router ;  import     com . mpush . common . message . KickUserMessage ;  import      com . mpush . common . message . gateway . GatewayKickUserMessage ;  import     com . mpush . common . router . RemoteRouter ;  import     com . mpush . core . server . GatewayUDPConnector ;  import    com . mpush . tools . Jsons ;  import    com . mpush . tools . Utils ;  import     com . mpush . tools . config . CC ;  import     com . mpush . tools . event . EventConsumer ;  import     com . mpush . tools . log . Logs ;  import   java . net . InetSocketAddress ;  import      com . mpush . api . spi . common . MQClient ;  import      com . mpush . api . spi . common . MQClientFactory ;  import      com . mpush . api . spi . common . MQMessageReceiver ;  import    com . mpush . common . ServerNodes ;  import     com . mpush . common . router . KickRemoteMsg ;  import static     com . mpush . common . ServerNodes . GS ;   public final class RouterChangeListener  extends EventConsumer  implements  MQMessageReceiver  {   public static final String  KICK_CHANNEL_ = "/mpush/kick/" ;   private final String  kick_channel =  KICK_CHANNEL_ +  GS . getHostAndPort  ( ) ;   private final boolean  udpGateway =    CC . mp . net . udpGateway  ( ) ;   public RouterChangeListener  ( )  {  if  (  ! udpGateway )  {   mqClient =  MQClientFactory . create  ( ) ;   mqClient . subscribe  (  getKickChannel  ( ) , this ) ; } }   public String getKickChannel  ( )  {  return kick_channel ; }   public String getKickChannel  (  String hostAndPort )  {  return  KICK_CHANNEL_ + hostAndPort ; }    @ Subscribe void on  (  RouterChangeEvent event )  {  String  userId =  event . userId ;   Router  <  ? >  r =  event . router ;  if  (   r . getRouteType  ( ) . equals  (   Router . RouterType . LOCAL ) )  {   kickLocal  ( userId ,  ( LocalRouter ) r ) ; } else  {   kickRemote  ( userId ,  ( RemoteRouter ) r ) ; } }   private void kickLocal  (   final String userId ,   final LocalRouter router )  {  Connection  connection =  router . getRouteValue  ( ) ;  SessionContext  context =  connection . getSessionContext  ( ) ;  KickUserMessage  message =  KickUserMessage . build  ( connection ) ;    message . deviceId =  context . deviceId ;    message . userId = userId ;   message . send  (  future ->  {  if  (  future . isSuccess  ( ) )  {    Logs . CONN . info  ( "kick local connection success, userId={}, router={}, conn={}" , userId , router , connection ) ; } else  {    Logs . CONN . warn  ( "kick local connection failure, userId={}, router={}, conn={}" , userId , router , connection ) ; } } ) ; }   private void kickRemote  (  String userId ,  RemoteRouter remoteRouter )  {  ClientLocation  location =  remoteRouter . getRouteValue  ( ) ;  if  (  location . isThisPC  (  GS . getHost  ( ) ,  GS . getPort  ( ) ) )  {    Logs . CONN . debug  ( "kick remote router in local pc, ignore remote broadcast, userId={}" , userId ) ;  return ; }  if  ( udpGateway )  {  Connection  connection =   GatewayUDPConnector . I  ( ) . getConnection  ( ) ;           GatewayKickUserMessage . build  ( connection ) . setUserId  ( userId ) . setClientType  (  location . getClientType  ( ) ) . setConnId  (  location . getConnId  ( ) ) . setDeviceId  (  location . getDeviceId  ( ) ) . setTargetServer  (  location . getHost  ( ) ) . setTargetPort  (  location . getPort  ( ) ) . setRecipient  (  new InetSocketAddress  (  location . getHost  ( ) ,  location . getPort  ( ) ) ) . sendRaw  ( ) ; } else  {  RedisKickRemoteMessage  message =        new RedisKickRemoteMessage  ( ) . setUserId  ( userId ) . setClientType  (  location . getClientType  ( ) ) . setConnId  (  location . getConnId  ( ) ) . setDeviceId  (  location . getDeviceId  ( ) ) . setTargetServer  (  location . getHost  ( ) ) . setTargetPort  (  location . getPort  ( ) ) ;   mqClient . publish  (  getKickChannel  (  location . getHostAndPort  ( ) ) , message ) ; } }   public void onReceiveKickRemoteMsg  (  KickRemoteMsg msg )  {  if  (  !  msg . isTargetPC  ( ) )  {    Logs . CONN . error  ( "receive kick remote msg, target server error, localIp={}, msg={}" ,  Utils . getLocalIp  ( ) , msg ) ;  return ; }  String  userId =  msg . getUserId  ( ) ;   int  clientType =  msg . getClientType  ( ) ;  LocalRouterManager  localRouterManager =   RouterCenter . I . getLocalRouterManager  ( ) ;  LocalRouter  localRouter =  localRouterManager . lookup  ( userId , clientType ) ;  if  (  localRouter != null )  {    Logs . CONN . info  ( "receive kick remote msg, msg={}" , msg ) ;  if  (    localRouter . getRouteValue  ( ) . getId  ( ) . equals  (  msg . getConnId  ( ) ) )  {   localRouterManager . unRegister  ( userId , clientType ) ;   kickLocal  ( userId , localRouter ) ; } else  {    Logs . CONN . warn  ( "kick router failure target connId not match, localRouter={}, msg={}" , localRouter , msg ) ; } } else  {    Logs . CONN . warn  ( "kick router failure can't find local router, msg={}" , msg ) ; } }   private MQClient  mqClient ;    @ Override public void receive  (  String topic ,  Object message )  {  if  (   getKickChannel  ( ) . equals  ( topic ) )  {  KickRemoteMsg  msg =  Jsons . fromJson  (  message . toString  ( ) ,  RedisKickRemoteMessage . class ) ;  if  (  msg != null )  {   onReceiveKickRemoteMsg  ( msg ) ; } else  {    Logs . CONN . warn  ( "receive an error kick message={}" , message ) ; } } else  {    Logs . CONN . warn  ( "receive an error redis channel={}" , topic ) ; } } }