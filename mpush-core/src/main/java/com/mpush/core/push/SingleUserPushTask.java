  package    com . mpush . core . push ;   import    com . mpush . api . Message ;  import     com . mpush . api . connection . Connection ;  import      com . mpush . api . spi . push . IPushMessage ;  import     com . mpush . common . message . PushMessage ;  import     com . mpush . common . router . RemoteRouter ;  import     com . mpush . core . ack . AckTask ;  import     com . mpush . core . ack . AckTaskQueue ;  import     com . mpush . common . qps . FlowControl ;  import     com . mpush . core . router . LocalRouter ;  import     com . mpush . core . router . RouterCenter ;  import     com . mpush . tools . log . Logs ;  import    io . netty . channel . ChannelFuture ;  import    io . netty . channel . ChannelFutureListener ;  import    java . util . concurrent . ScheduledExecutorService ;  import    com . mpush . common . ServerNodes ;  import static     com . mpush . common . ServerNodes . GS ;   public final class SingleUserPushTask  implements  PushTask  {   private final FlowControl  flowControl ;   private final IPushMessage  message ;   public SingleUserPushTask  (  IPushMessage message ,  FlowControl flowControl )  {    this . flowControl = flowControl ;    this . message = message ; }    @ Override public ScheduledExecutorService getExecutor  ( )  {  return     (  ( Message ) message ) . getConnection  ( ) . getChannel  ( ) . eventLoop  ( ) ; }    @ Override public void run  ( )  {  if  (  !  checkLocal  ( message ) )  {   checkRemote  ( message ) ; } }   private boolean checkLocal  (  IPushMessage message )  {  String  userId =  message . getUserId  ( ) ;   int  clientType =  message . getClientType  ( ) ;  LocalRouter  localRouter =    RouterCenter . I . getLocalRouterManager  ( ) . lookup  ( userId , clientType ) ;  if  (  localRouter == null )  return false ;  Connection  connection =  localRouter . getRouteValue  ( ) ;  if  (  !  connection . isConnected  ( ) )  {    Logs . PUSH . warn  ( "[SingleUserPush] find local router but conn disconnected, message={}, conn={}" , message , connection ) ;     RouterCenter . I . getLocalRouterManager  ( ) . unRegister  ( userId , clientType ) ;  return false ; }  if  (  !   connection . getChannel  ( ) . isWritable  ( ) )  {     PushCenter . I . getPushListener  ( ) . onFailure  ( message ) ;    Logs . PUSH . error  ( "[SingleUserPush] push message to client failure, tcp sender too busy, message={}, conn={}" , message , connection ) ;  return true ; }  if  (  flowControl . checkQps  ( ) )  {  PushMessage  pushMessage =   PushMessage . build  ( connection ) . setContent  (  message . getContent  ( ) ) ;    pushMessage . getPacket  ( ) . addFlag  (  message . getFlags  ( ) ) ;   pushMessage . send  (  new PushFutureListener  ( message ,  pushMessage . getSessionId  ( ) ) ) ; } else  {    PushCenter . I . delayTask  (  flowControl . getDelay  ( ) , this ) ; }  return true ; }   private void checkRemote  (  IPushMessage message )  {  String  userId =  message . getUserId  ( ) ;   int  clientType =  message . getClientType  ( ) ;  RemoteRouter  remoteRouter =    RouterCenter . I . getRemoteRouterManager  ( ) . lookup  ( userId , clientType ) ;  if  (   remoteRouter == null ||  remoteRouter . isOffline  ( ) )  {     PushCenter . I . getPushListener  ( ) . onOffline  ( message ) ;    Logs . PUSH . info  ( "[SingleUserPush] remote router not exists user offline, message={}" , message ) ;  return ; }  if  (   remoteRouter . getRouteValue  ( ) . isThisPC  (  GS . getHost  ( ) ,  GS . getPort  ( ) ) )  {     PushCenter . I . getPushListener  ( ) . onOffline  ( message ) ;     RouterCenter . I . getRemoteRouterManager  ( ) . unRegister  ( userId , clientType ) ;    Logs . PUSH . info  ( "[SingleUserPush] find remote router in this pc, but local router not exists, userId={}, clientType={}, router={}" , userId , clientType , remoteRouter ) ;  return ; }     PushCenter . I . getPushListener  ( ) . onRedirect  ( message ) ;    Logs . PUSH . info  ( "[SingleUserPush] find router in another pc, userId={}, clientType={}, router={}" , userId , clientType , remoteRouter ) ; }   private static final class PushFutureListener  implements  ChannelFutureListener  {   private final IPushMessage  message ;   private final  int  messageId ;   private PushFutureListener  (  IPushMessage message ,   int messageId )  {    this . message = message ;    this . messageId = messageId ; }    @ Override public void operationComplete  (  ChannelFuture future )  throws Exception  {  if  (  future . isSuccess  ( ) )  {  if  (  message . isNeedAck  ( ) )  {   addAckTask  ( messageId ) ; } else  {     PushCenter . I . getPushListener  ( ) . onSuccess  ( message ) ; }    Logs . PUSH . info  ( "[SingleUserPush] push message to client success, message={}" , message ) ; } else  {     PushCenter . I . getPushListener  ( ) . onFailure  ( message ) ;    Logs . PUSH . error  ( "[SingleUserPush] push message to client failure, message={}, conn={}" , message ,  future . channel  ( ) ) ; } }   private void addAckTask  (   int messageId )  {   message . finalized  ( ) ;  AckTask  task =   AckTask . from  ( messageId ) . setCallback  (  new PushAckCallback  ( message ) ) ;    AckTaskQueue . I . add  ( task ,  message . getTimeoutMills  ( ) ) ; } } }