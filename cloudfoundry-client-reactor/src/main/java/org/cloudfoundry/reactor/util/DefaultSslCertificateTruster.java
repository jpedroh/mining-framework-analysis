  package    org . cloudfoundry . reactor . util ;   import    org . cloudfoundry . reactor . ProxyConfiguration ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     reactor . ipc . netty . tcp . TcpClient ;  import    reactor . util . function . Tuple2 ;  import    reactor . util . function . Tuples ;  import    javax . net . ssl . TrustManager ;  import    javax . net . ssl . TrustManagerFactory ;  import    javax . net . ssl . X509TrustManager ;  import   java . io . IOException ;  import   java . security . KeyStore ;  import   java . security . KeyStoreException ;  import   java . security . NoSuchAlgorithmException ;  import    java . security . cert . CertificateException ;  import    java . security . cert . X509Certificate ;  import   java . time . Duration ;  import   java . util . Collections ;  import   java . util . Optional ;  import   java . util . Set ;  import    java . util . concurrent . ConcurrentHashMap ;  import     java . util . concurrent . atomic . AtomicReference ;  import    io . netty . buffer . ByteBufAllocator ;  import    reactor . core . publisher . Mono ;  import     reactor . ipc . netty . resources . LoopResources ;  import static     io . netty . channel . ChannelOption . ALLOCATOR ;   public final class DefaultSslCertificateTruster  implements  SslCertificateTruster  {   private final Logger  logger =  LoggerFactory . getLogger  ( "cloudfoundry-client.trust" ) ;   private final  AtomicReference  < X509TrustManager >  delegate ;   private final  Optional  < ProxyConfiguration >  proxyConfiguration ;   private final  Set  <  Tuple2  < String , Integer > >  trustedHostsAndPorts ;    @ Override public void checkClientTrusted  (   X509Certificate  [ ] x509Certificates ,  String authType )  throws CertificateException  {     this . delegate . get  ( ) . checkClientTrusted  ( x509Certificates , authType ) ; }    @ Override public void checkServerTrusted  (   X509Certificate  [ ] x509Certificates ,  String authType )  throws CertificateException  {     this . delegate . get  ( ) . checkServerTrusted  ( x509Certificates , authType ) ; }    @ Override public  X509Certificate  [ ] getAcceptedIssuers  ( )  {  return    this . delegate . get  ( ) . getAcceptedIssuers  ( ) ; }    @ Override public  Mono  < Void > trust  (  String host ,   int port ,  Duration duration )  {   Tuple2  < String , Integer >  hostAndPort =  Tuples . of  ( host , port ) ;  if  (   this . trustedHostsAndPorts . contains  ( hostAndPort ) )  {  return  Mono . empty  ( ) ; }    this . logger . warn  ( "Trusting SSL Certificate for {}:{}" , host , port ) ;  X509TrustManager  trustManager =   this . delegate . get  ( ) ;  return    getUntrustedCertificates  ( duration , host , port ,  this . allocator ,  this . proxyConfiguration ,  this . threadPool , trustManager ) . doOnNext  (  untrustedCertificates ->  {  KeyStore  trustStore =  addToTrustStore  ( untrustedCertificates , trustManager ) ;    this . delegate . set  (  getTrustManager  (  getTrustManagerFactory  ( trustStore ) ) ) ;    this . trustedHostsAndPorts . add  ( hostAndPort ) ;    this . logger . debug  ( "Trusted SSL Certificate for {}:{}" , host , port ) ; } ) . then  ( ) ; }   private static KeyStore addToTrustStore  (   X509Certificate  [ ] untrustedCertificates ,  X509TrustManager trustManager )  {  try  {  KeyStore  trustStore =  KeyStore . getInstance  (  KeyStore . getDefaultType  ( ) ) ;   trustStore . load  ( null ) ;   int  count = 0 ;  for ( X509Certificate certificate : untrustedCertificates )  {   trustStore . setCertificateEntry  (  String . valueOf  (  count ++ ) , certificate ) ; }  for ( X509Certificate certificate :  trustManager . getAcceptedIssuers  ( ) )  {   trustStore . setCertificateEntry  (  String . valueOf  (  count ++ ) , certificate ) ; }  return trustStore ; }  catch (   CertificateException | NoSuchAlgorithmException | IOException | KeyStoreException e )  {  throw  new RuntimeException  ( e ) ; } } 
<<<<<<<
  private static TcpClient getTcpClient  (   Optional  < ProxyConfiguration > proxyConfiguration ,  CertificateCollectingTrustManager collector ,  String host ,   int port )  {  return  TcpClient . create  (  options ->  {      options . host  ( host ) . port  ( port ) . disablePool  ( ) . sslSupport  (  ssl ->  ssl . trustManager  (  new StaticTrustManagerFactory  ( collector ) ) ) ;   proxyConfiguration . ifPresent  (  c ->  c . configure  ( options ) ) ; } ) ; }
=======
>>>>>>>
   private static X509TrustManager getTrustManager  (  TrustManagerFactory trustManagerFactory )  {  for ( TrustManager trustManager :  trustManagerFactory . getTrustManagers  ( ) )  {  if  (  trustManager instanceof X509TrustManager )  {  return  ( X509TrustManager ) trustManager ; } }  throw  new IllegalStateException  ( "No X509TrustManager in TrustManagerFactory" ) ; }   private static TrustManagerFactory getTrustManagerFactory  (  KeyStore trustStore )  {  try  {  TrustManagerFactory  trustManagerFactory =  TrustManagerFactory . getInstance  (  TrustManagerFactory . getDefaultAlgorithm  ( ) ) ;   trustManagerFactory . init  ( trustStore ) ;  return trustManagerFactory ; }  catch (   KeyStoreException | NoSuchAlgorithmException e )  {  throw  new RuntimeException  ( e ) ; } }   private final ByteBufAllocator  allocator ;   private final LoopResources  threadPool ;   public DefaultSslCertificateTruster  (  ByteBufAllocator allocator ,   Optional  < ProxyConfiguration > proxyConfiguration ,  LoopResources threadPool )  {    this . allocator = allocator ;    this . proxyConfiguration = proxyConfiguration ;    this . threadPool = threadPool ;    this . delegate =  new  AtomicReference  < >  (  getTrustManager  (  getTrustManagerFactory  ( null ) ) ) ;    this . trustedHostsAndPorts =  Collections . newSetFromMap  (  new  ConcurrentHashMap  < >  ( ) ) ; }   private static TcpClient getTcpClient  (  ByteBufAllocator allocator ,   Optional  < ProxyConfiguration > proxyConfiguration ,  LoopResources threadPool ,  CertificateCollectingTrustManager collector ,  String host ,   int port )  {  return  TcpClient . create  (  options ->  {       options . connect  ( host , port ) . loopResources  ( threadPool ) . option  ( ALLOCATOR , allocator ) . disablePool  ( ) . sslSupport  (  ssl ->  ssl . trustManager  (  new StaticTrustManagerFactory  ( collector ) ) ) ;   proxyConfiguration . ifPresent  (  c ->  options . proxy  (   ClientOptions . Proxy . HTTP ,  c . getHost  ( ) ,   c . getPort  ( ) . orElse  ( null ) ,   c . getUsername  ( ) . orElse  ( null ) ,  u ->   c . getPassword  ( ) . orElse  ( null ) ) ) ; } ) ; }   private static  Mono  <  X509Certificate  [ ] > getUntrustedCertificates  (  Duration duration ,  String host ,   int port ,  ByteBufAllocator allocator ,   Optional  < ProxyConfiguration > proxyConfiguration ,  LoopResources threadPool ,  X509TrustManager delegate )  {  CertificateCollectingTrustManager  collector =  new CertificateCollectingTrustManager  ( delegate ) ;  return     getTcpClient  ( allocator , proxyConfiguration , threadPool , collector , host , port ) . newHandler  (   ( inbound , outbound ) ->   inbound . receive  ( ) . then  ( ) ) . timeout  ( duration ) . handle  (   ( c , sink ) ->  {   X509Certificate  [ ]  chain =  collector . getCollectedCertificateChain  ( ) ;  if  (  chain == null )  {   sink . error  (  new IllegalStateException  ( "Could not obtain server certificate chain" ) ) ; }  if  (  collector . isTrusted  ( ) )  {   sink . complete  ( ) ; } else  {   sink . next  ( chain ) ; } } ) ; } }