  package    org . structr . core . entity ;   import    java . lang . reflect . InvocationTargetException ;  import    java . lang . reflect . Method ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . Date ;  import   java . util . GregorianCalendar ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . Iterator ;  import   java . util . LinkedHashMap ;  import   java . util . LinkedHashSet ;  import   java . util . LinkedList ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Queue ;  import   java . util . Set ;  import       org . apache . chemistry . opencmis . commons . data . Ace ;  import       org . apache . chemistry . opencmis . commons . data . AllowableActions ;  import       org . apache . chemistry . opencmis . commons . enums . BaseTypeId ;  import       org . apache . chemistry . opencmis . commons . enums . PropertyType ;  import      org . apache . commons . codec . digest . DigestUtils ;  import     org . apache . commons . lang3 . ArrayUtils ;  import     org . apache . commons . lang3 . StringUtils ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import    org . structr . api . DatabaseService ;  import    org . structr . api . NativeQuery ;  import    org . structr . api . Predicate ;  import     org . structr . api . config . Settings ;  import     org . structr . api . graph . Direction ;  import     org . structr . api . graph . Identity ;  import     org . structr . api . graph . Node ;  import     org . structr . api . graph . PropagationDirection ;  import static      org . structr . api . graph . PropagationDirection . In ;  import static      org . structr . api . graph . PropagationDirection . Out ;  import static      org . structr . api . graph . PropagationMode . Add ;  import static      org . structr . api . graph . PropagationMode . Keep ;  import static      org . structr . api . graph . PropagationMode . Remove ;  import     org . structr . api . graph . PropertyContainer ;  import     org . structr . api . graph . Relationship ;  import     org . structr . api . graph . RelationshipType ;  import     org . structr . api . util . FixedSizeCache ;  import     org . structr . api . util . Iterables ;  import    org . structr . cmis . CMISInfo ;  import     org . structr . cmis . common . CMISExtensionsData ;  import     org . structr . cmis . common . StructrItemActions ;  import     org . structr . cmis . info . CMISDocumentInfo ;  import     org . structr . cmis . info . CMISFolderInfo ;  import     org . structr . cmis . info . CMISItemInfo ;  import     org . structr . cmis . info . CMISPolicyInfo ;  import     org . structr . cmis . info . CMISRelationshipInfo ;  import     org . structr . cmis . info . CMISSecondaryInfo ;  import    org . structr . common . AccessControllable ;  import    org . structr . common . Permission ;  import    org . structr . common . PermissionPropagation ;  import    org . structr . common . PermissionResolutionMask ;  import    org . structr . common . PropertyView ;  import    org . structr . common . SecurityContext ;  import    org . structr . common . ValidationHelper ;  import    org . structr . common . View ;  import     org . structr . common . error . ErrorBuffer ;  import     org . structr . common . error . FrameworkException ;  import     org . structr . common . error . InternalSystemPropertyToken ;  import     org . structr . common . error . NullArgumentToken ;  import     org . structr . common . error . ReadOnlyPropertyToken ;  import     org . structr . common . event . RuntimeUsageLog ;  import    org . structr . core . GraphObject ;  import    org . structr . core . IterableAdapter ;  import    org . structr . core . Services ;  import     org . structr . core . app . App ;  import     org . structr . core . app . StructrApp ;  import     org . structr . core . converter . PropertyConverter ;  import      org . structr . core . entity . relationship . Ownership ;  import      org . structr . core . entity . relationship . PrincipalOwnsNode ;  import     org . structr . core . graph . ModificationQueue ;  import     org . structr . core . graph . NodeInterface ;  import     org . structr . core . graph . NodeRelationshipStatisticsCommand ;  import     org . structr . core . graph . RelationshipFactory ;  import     org . structr . core . graph . RelationshipInterface ;  import     org . structr . core . property . FunctionProperty ;  import     org . structr . core . property . PropertyKey ;  import     org . structr . core . property . PropertyMap ;  import     org . structr . core . script . Scripting ;  import     org . structr . schema . action . ActionContext ;  import     org . structr . schema . action . EvaluationHints ;  import     org . structr . schema . action . Function ;  import     org . structr . common . error . AssertException ;   public abstract class AbstractNode  implements  NodeInterface , AccessControllable , CMISInfo , CMISItemInfo  {   private static final  int  permissionResolutionMaxLevel =   Settings . ResolutionDepth . getValue  ( ) ;   private static final Logger  logger =  LoggerFactory . getLogger  (   AbstractNode . class . getName  ( ) ) ;   private static final  FixedSizeCache  < String , Boolean >  isGrantedResultCache =  new  FixedSizeCache  < String , Boolean >  ( "Grant result cache" , 100000 ) ;   private static final  FixedSizeCache  < String , Object >  relationshipTemplateInstanceCache =  new  FixedSizeCache  < >  ( "Relationship template cache" , 1000 ) ;   private static final  Map  < String ,  Map  < String , PermissionResolutionResult > >  globalPermissionResolutionCache =  new  HashMap  < >  ( ) ;   public static final View  defaultView =  new View  (  AbstractNode . class ,  PropertyView . Public , id , type , name ) ;   public static final View  uiView =  new View  (  AbstractNode . class ,  PropertyView . Ui , id , name , owner , type , createdBy , hidden , createdDate , lastModifiedDate , visibleToPublicUsers , visibleToAuthenticatedUsers ) ;   private  Map  < String , Object >  tmpStorageContainer = null ;   public boolean  internalSystemPropertiesUnlocked = false ;   private Identity  rawPathSegmentId = null ;   private  long  sourceTransactionId =  - 1 ;   private boolean  readOnlyPropertiesUnlocked = false ;   protected String  cachedUuid = null ;   protected SecurityContext  securityContext = null ;   protected Principal  cachedOwnerNode = null ;   protected Class  entityType = null ;   protected Node  dbNode = null ;   public AbstractNode  ( )  { }   public AbstractNode  (  SecurityContext securityContext ,   final Node dbNode ,   final Class entityType ,   final  long sourceTransactionId )  {   init  ( securityContext , dbNode , entityType , sourceTransactionId ) ; }    @ Override public void onNodeCreation  ( )  { }    @ Override public void onNodeInstantiation  (   final boolean isCreation )  {    this . cachedUuid =  getProperty  (  GraphObject . id ) ; }    @ Override public void onNodeDeletion  ( )  { }    @ Override public final void init  (   final SecurityContext securityContext ,   final Node dbNode ,   final Class entityType ,   final  long sourceTransactionId )  {    this . sourceTransactionId = sourceTransactionId ;    this . dbNode = dbNode ;    this . entityType = entityType ;    this . securityContext = securityContext ;  if  (   dbNode != null &&  !  this . isGenericNode  ( ) )  {   final String  typeName =   getClass  ( ) . getSimpleName  ( ) ;   final Object  typeValue =  dbNode . getProperty  ( "type" ) ;  if  (  !  typeName . equals  ( typeValue ) )  {   logger . error  ( "{} {} failed validity check: actual type in node with ID {}: {}" , typeName ,  getUuid  ( ) ,  dbNode . getId  ( ) , typeValue ) ; } } }    @ Override public  long getSourceTransactionId  ( )  {  return sourceTransactionId ; }    @ Override public Class getEntityType  ( )  {  return entityType ; }    @ Override public final void setSecurityContext  (  SecurityContext securityContext )  {    this . securityContext = securityContext ; }    @ Override public final SecurityContext getSecurityContext  ( )  {  return securityContext ; }    @ Override public boolean equals  (   final Object o )  {  if  (  o == null )  {  return false ; }  if  (  !  (  o instanceof AbstractNode ) )  {  return false ; }  return  (   Integer . valueOf  (  this . hashCode  ( ) ) . equals  (  o . hashCode  ( ) ) ) ; }    @ Override public  int hashCode  ( )  {  if  (   this . dbNode == null )  {  return  (  super . hashCode  ( ) ) ; }  return   dbNode . getId  ( ) . hashCode  ( ) ; }    @ Override public  int compareTo  (   final Object other )  {  if  (  other instanceof AbstractNode )  {   final AbstractNode  node =  ( AbstractNode ) other ;   final String  _name =  getName  ( ) ;  if  (  _name == null )  {  return  - 1 ; }   final String  nodeName =  node . getName  ( ) ;  if  (  nodeName == null )  {  return  - 1 ; }  return  _name . compareTo  ( nodeName ) ; }  if  (  other instanceof String )  {  return   getUuid  ( ) . compareTo  (  ( String ) other ) ; }  if  (  other == null )  {  throw  new NullPointerException  ( ) ; }  throw  new IllegalStateException  (    "Cannot compare " + this + " to " + other ) ; }    @ Override public String toString  ( )  {  return  getUuid  ( ) ; }    @ Override public final void unlockReadOnlyPropertiesOnce  ( )  {    this . readOnlyPropertiesUnlocked = true ; }    @ Override public final void unlockSystemPropertiesOnce  ( )  {    this . internalSystemPropertiesUnlocked = true ;   unlockReadOnlyPropertiesOnce  ( ) ; }    @ Override public final void removeProperty  (   final PropertyKey key )  throws FrameworkException  {  if  (  !  isGranted  (  Permission . write , securityContext ) )  {   final Principal  currentUser =  securityContext . getUser  ( false ) ;  String  user = null ;  if  (  currentUser == null )  {   user =   securityContext . isSuperUser  ( ) ? "superuser" : "anonymous" ; } else  {   user =  currentUser . getProperty  (  AbstractNode . id ) ; }  throw  new FrameworkException  ( 403 ,       "Modification of node " +  this . getProperty  (  AbstractNode . id ) + " with type " +  this . getProperty  (  AbstractNode . type ) + " by user " + user + " not permitted." ) ; }  if  (   this . dbNode != null )  {  if  (  key == null )  {   logger . error  ( "Tried to set property with null key (action was denied)" ) ;  return ; }  if  (  key . isReadOnly  ( ) )  {  if  (  readOnlyPropertiesUnlocked ||  securityContext . isSuperUser  ( ) )  {   internalSystemPropertiesUnlocked = false ; } else  {  throw  new FrameworkException  ( 404 ,   "Property " +  key . jsonName  ( ) + " is read-only" ,  new ReadOnlyPropertyToken  (  getType  ( ) , key ) ) ; } }  if  (  key . isSystemInternal  ( ) )  {  if  ( internalSystemPropertiesUnlocked )  {   internalSystemPropertiesUnlocked = false ; } else  {  throw  new FrameworkException  ( 404 ,   "Property " +  key . jsonName  ( ) + " is read-only" ,  new InternalSystemPropertyToken  (  getType  ( ) , key ) ) ; } }   dbNode . removeProperty  (  key . dbName  ( ) ) ; } }    @ Override public final String getType  ( )  {  return  getProperty  (  AbstractNode . type ) ; }    @ Override public final PropertyContainer getPropertyContainer  ( )  {  return dbNode ; }    @ Override public final String getName  ( )  {  String  name =  getProperty  (  AbstractNode . name ) ;  if  (  name == null )  {   name =  getUuid  ( ) ; }  return name ; }    @ Override public final String getUuid  ( )  {  if  (  cachedUuid == null )  {   cachedUuid =  getProperty  (  GraphObject . id ) ; }  return cachedUuid ; }   public final boolean getVisibleToPublicUsers  ( )  {  return  getProperty  ( visibleToPublicUsers ) ; }   public final boolean getVisibleToAuthenticatedUsers  ( )  {  return  getProperty  ( visibleToPublicUsers ) ; }   public final boolean getHidden  ( )  {  return  getProperty  ( hidden ) ; }    @ Override public  Set  < PropertyKey > getPropertyKeys  (   final String propertyView )  {  if  (   securityContext != null &&  securityContext . hasCustomView  ( ) )  {   final  Set  < PropertyKey >  keys =  new  LinkedHashSet  < >  (   StructrApp . getConfiguration  ( ) . getPropertySet  ( entityType ,  PropertyView . All ) ) ;   final  Set  < String >  customView =  securityContext . getCustomView  ( ) ;  for (   Iterator  < PropertyKey >  it =  keys . iterator  ( ) ;  it . hasNext  ( ) ; )  {  if  (  !  customView . contains  (   it . next  ( ) . jsonName  ( ) ) )  {   it . remove  ( ) ; } }  return keys ; }  return   StructrApp . getConfiguration  ( ) . getPropertySet  ( entityType , propertyView ) ; }    @ Override public  <  T > T getProperty  (   final  PropertyKey  < T > key )  {  return  getProperty  ( key , null ) ; }    @ Override public  <  T > T getProperty  (   final  PropertyKey  < T > key ,   final  Predicate  < GraphObject > predicate )  {  return  getProperty  ( key , true , predicate ) ; }   private  <  T > T getProperty  (   final  PropertyKey  < T > key ,  boolean applyConverter ,   final  Predicate  < GraphObject > predicate )  {  if  (   key == null ||   key . dbName  ( ) == null )  {  return null ; }   RuntimeUsageLog . log  ( this , key ) ;  return  key . getProperty  ( securityContext , this , applyConverter , predicate ) ; }   public final String getPropertyMD5  (   final PropertyKey key )  {  Object  value =  getProperty  ( key ) ;  if  (  value instanceof String )  {  return  DigestUtils . md5Hex  (  ( String ) value ) ; } else  if  (  value instanceof   byte  [ ] )  {  return  DigestUtils . md5Hex  (  (   byte  [ ] ) value ) ; }   logger . warn  ( "Could not create MD5 hex out of value {}" , value ) ;  return null ; }    @ Override public final  <  T > Comparable getComparableProperty  (   final  PropertyKey  < T > key )  {  if  (  key != null )  {   final T  propertyValue =  getProperty  ( key ) ;   PropertyConverter  < T ,  ? >  converter =  key . databaseConverter  ( securityContext , this ) ;  if  (  converter != null )  {  try  {  return  converter . convertForSorting  ( propertyValue ) ; }  catch (   Throwable t )  {   logger . warn  ( "Unable to convert property {} of type {}: {}" ,  new Object  [ ]  {  key . dbName  ( ) ,   getClass  ( ) . getSimpleName  ( ) ,  t . getMessage  ( ) } ) ;   logger . warn  ( "" , t ) ; } }  if  (  propertyValue instanceof Comparable )  {  return  ( Comparable ) propertyValue ; }  if  (  propertyValue != null )  {  return  propertyValue . toString  ( ) ; } }  return null ; }   public final Iterable getIterableProperty  (   final  PropertyKey  <  ? extends Iterable > propertyKey )  {  return  ( Iterable )  getProperty  ( propertyKey ) ; }   public  Set  < AbstractNode > getNodesForModificationPropagation  ( )  {  return null ; }    @ Override public final Node getNode  ( )  {  return dbNode ; }    @ Override public boolean hasRelationshipTo  (   final RelationshipType type ,   final NodeInterface targetNode )  {  if  (    dbNode != null &&  type != null &&  targetNode != null )  {  return  dbNode . hasRelationshipTo  ( type ,  targetNode . getNode  ( ) ) ; }  return false ; }    @ Override public  <  R  extends AbstractRelationship > R getRelationshipTo  (   final RelationshipType type ,   final NodeInterface targetNode )  {  if  (    dbNode != null &&  type != null &&  targetNode != null )  {   final  RelationshipFactory  < R >  factory =  new  RelationshipFactory  < >  ( securityContext ) ;   final Relationship  rel =  dbNode . getRelationshipTo  ( type ,  targetNode . getNode  ( ) ) ;  if  (  rel != null )  {  return  factory . adapt  ( rel ) ; } }  return null ; }    @ Override public final  <  R  extends AbstractRelationship >  Iterable  < R > getRelationships  ( )  {  return  new  IterableAdapter  < >  (  dbNode . getRelationships  ( ) ,  new  RelationshipFactory  < R >  ( securityContext ) ) ; }    @ Override public final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  S  extends Source ,  T  extends Target ,  R  extends  Relation  < A , B , S , T > >  Iterable  < R > getRelationships  (   final  Class  < R > type )  {   final  RelationshipFactory  < R >  factory =  new  RelationshipFactory  < >  ( securityContext ) ;   final R  template =  getRelationshipForType  ( type ) ;   final Direction  direction =  template . getDirectionForType  ( entityType ) ;   final RelationshipType  relType = template ;  return  new  IterableAdapter  < >  (  dbNode . getRelationships  ( direction , relType ) , factory ) ; }    @ Override public final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  T  extends Target ,  R  extends  Relation  < A , B ,  OneStartpoint  < A > , T > > R getIncomingRelationship  (   final  Class  < R > type )  {   final  RelationshipFactory  < R >  factory =  new  RelationshipFactory  < >  ( securityContext ) ;   final R  template =  getRelationshipForType  ( type ) ;   final Relationship  relationship =   template . getSource  ( ) . getRawSource  ( securityContext , dbNode , null ) ;  if  (  relationship != null )  {  return  factory . adapt  ( relationship ) ; }  return null ; }    @ Override public final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  T  extends Target ,  R  extends  Relation  < A , B ,  OneStartpoint  < A > , T > > R getIncomingRelationshipAsSuperUser  (   final  Class  < R > type )  {   final SecurityContext  suContext =  SecurityContext . getSuperUserInstance  ( ) ;   final  RelationshipFactory  < R >  factory =  new  RelationshipFactory  < >  ( suContext ) ;   final R  template =  getRelationshipForType  ( type ) ;   final Relationship  relationship =   template . getSource  ( ) . getRawSource  ( suContext , dbNode , null ) ;  if  (  relationship != null )  {  return  factory . adapt  ( relationship ) ; }  return null ; }    @ Override public final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  T  extends Target ,  R  extends  Relation  < A , B ,  ManyStartpoint  < A > , T > >  Iterable  < R > getIncomingRelationships  (   final  Class  < R > type )  {   final  RelationshipFactory  < R >  factory =  new  RelationshipFactory  < >  ( securityContext ) ;   final R  template =  getRelationshipForType  ( type ) ;  return  new  IterableAdapter  < >  (   template . getSource  ( ) . getRawSource  ( securityContext , dbNode , null ) , factory ) ; }    @ Override public final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  S  extends Source ,  R  extends  Relation  < A , B , S ,  OneEndpoint  < B > > > R getOutgoingRelationship  (   final  Class  < R > type )  {   final  RelationshipFactory  < R >  factory =  new  RelationshipFactory  < >  ( securityContext ) ;   final R  template =  getRelationshipForType  ( type ) ;   final Relationship  relationship =   template . getTarget  ( ) . getRawSource  ( securityContext , dbNode , null ) ;  if  (  relationship != null )  {  return  factory . adapt  ( relationship ) ; }  return null ; }    @ Override public final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  S  extends Source ,  R  extends  Relation  < A , B , S ,  ManyEndpoint  < B > > >  Iterable  < R > getOutgoingRelationships  (   final  Class  < R > type )  {   final  RelationshipFactory  < R >  factory =  new  RelationshipFactory  < >  ( securityContext ) ;   final R  template =  getRelationshipForType  ( type ) ;  return  new  IterableAdapter  < >  (   template . getTarget  ( ) . getRawSource  ( securityContext , dbNode , null ) , factory ) ; }    @ Override public final  <  R  extends AbstractRelationship >  Iterable  < R > getIncomingRelationships  ( )  {  return  new  IterableAdapter  < >  (  dbNode . getRelationships  (  Direction . INCOMING ) ,  new  RelationshipFactory  < >  ( securityContext ) ) ; }    @ Override public final  <  R  extends AbstractRelationship >  Iterable  < R > getOutgoingRelationships  ( )  {  return  new  IterableAdapter  < >  (  dbNode . getRelationships  (  Direction . OUTGOING ) ,  new  RelationshipFactory  < R >  ( securityContext ) ) ; }    @ Override public final  <  R  extends AbstractRelationship >  Iterable  < R > getRelationshipsAsSuperUser  ( )  {  return  new  IterableAdapter  < >  (  dbNode . getRelationships  ( ) ,  new  RelationshipFactory  < >  (  SecurityContext . getSuperUserInstance  ( ) ) ) ; }   protected final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  T  extends Target ,  R  extends  Relation  < A , B ,  ManyStartpoint  < A > , T > >  Iterable  < R > getIncomingRelationshipsAsSuperUser  (   final  Class  < R > type )  {  return  getIncomingRelationshipsAsSuperUser  ( type , null ) ; }   protected final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  T  extends Target ,  R  extends  Relation  < A , B ,  ManyStartpoint  < A > , T > >  Iterable  < R > getIncomingRelationshipsAsSuperUser  (   final  Class  < R > type ,   final  Predicate  < GraphObject > predicate )  {   final SecurityContext  suContext =  SecurityContext . getSuperUserInstance  ( ) ;   final  RelationshipFactory  < R >  factory =  new  RelationshipFactory  < >  ( suContext ) ;   final R  template =  getRelationshipForType  ( type ) ;  return  new  IterableAdapter  < >  (   template . getSource  ( ) . getRawSource  ( suContext , dbNode , predicate ) , factory ) ; }    @ Override public  <  A  extends NodeInterface ,  B  extends NodeInterface ,  S  extends Source ,  R  extends  Relation  < A , B , S ,  OneEndpoint  < B > > > R getOutgoingRelationshipAsSuperUser  (   final  Class  < R > type )  {   final SecurityContext  suContext =  SecurityContext . getSuperUserInstance  ( ) ;   final  RelationshipFactory  < R >  factory =  new  RelationshipFactory  < >  ( suContext ) ;   final R  template =  getRelationshipForType  ( type ) ;   final Relationship  relationship =   template . getTarget  ( ) . getRawSource  ( suContext , dbNode , null ) ;  if  (  relationship != null )  {  return  factory . adapt  ( relationship ) ; }  return null ; }   protected final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  S  extends Source ,  T  extends Target ,  R  extends  Relation  < A , B , S , T > >  Iterable  < R > getRelationshipsAsSuperUser  (   final  Class  < R > type )  {   final  RelationshipFactory  < R >  factory =  new  RelationshipFactory  < >  (  SecurityContext . getSuperUserInstance  ( ) ) ;   final R  template =  getRelationshipForType  ( type ) ;   final Direction  direction =  template . getDirectionForType  ( entityType ) ;   final RelationshipType  relType = template ;  return  new  IterableAdapter  < >  (  dbNode . getRelationships  ( direction , relType ) , factory ) ; }   public final  Map  < String , Long > getRelationshipInfo  (   final Direction dir )  throws FrameworkException  {  return    StructrApp . getInstance  ( securityContext ) . command  (  NodeRelationshipStatisticsCommand . class ) . execute  ( this , dir ) ; }    @ Override public final Principal getOwnerNode  ( )  {  if  (  cachedOwnerNode == null )  {   final Ownership  ownership =  getIncomingRelationshipAsSuperUser  (  PrincipalOwnsNode . class ) ;  if  (  ownership != null )  {  Principal  principal =  ownership . getSourceNode  ( ) ;   cachedOwnerNode =  ( Principal ) principal ; } }  return cachedOwnerNode ; }   public final String getOwnerId  ( )  {  return   getOwnerNode  ( ) . getUuid  ( ) ; }   public final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  S  extends Source ,  T  extends Target > boolean hasRelationship  (   final  Class  <  ? extends  Relation  < A , B , S , T > > type )  {  return    this . getRelationships  ( type ) . iterator  ( ) . hasNext  ( ) ; }    @ Override public final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  S  extends Source ,  T  extends Target ,  R  extends  Relation  < A , B , S , T > > boolean hasIncomingRelationships  (   final  Class  < R > type )  {  return    getRelationshipForType  ( type ) . getSource  ( ) . hasElements  ( securityContext , dbNode , null ) ; }    @ Override public final  <  A  extends NodeInterface ,  B  extends NodeInterface ,  S  extends Source ,  T  extends Target ,  R  extends  Relation  < A , B , S , T > > boolean hasOutgoingRelationships  (   final  Class  < R > type )  {  return    getRelationshipForType  ( type ) . getTarget  ( ) . hasElements  ( securityContext , dbNode , null ) ; }    @ Override public boolean isGranted  (   final Permission permission ,   final SecurityContext context )  {  return  isGranted  ( permission , context , false ) ; }   private boolean isGranted  (   final Permission permission ,   final SecurityContext context ,   final boolean isCreation )  {  if  (   context != null &&  context . isSuperUser  ( ) )  {  return true ; }  Principal  accessingUser = null ;  if  (  context != null )  {   accessingUser =  context . getUser  ( false ) ; }   final String  cacheKey =      getUuid  ( ) + "." +  permission . name  ( ) + "." +  context . getCachedUserId  ( ) ;   final Boolean  cached =  isGrantedResultCache . get  ( cacheKey ) ;  if  (   cached != null &&  cached == true )  {  return true ; }   final boolean  doLog =  securityContext . hasParameter  ( "logPermissionResolution" ) ;   final boolean  result =  isGranted  ( permission , accessingUser ,  new PermissionResolutionMask  ( ) , 0 ,  new AlreadyTraversed  ( ) , true , doLog , isCreation ) ;   isGrantedResultCache . put  ( cacheKey , result ) ;  return result ; }   private boolean isGranted  (   final Permission permission ,   final Principal accessingUser ,   final PermissionResolutionMask mask ,   final  int level ,   final AlreadyTraversed alreadyTraversed ,   final boolean resolvePermissions ,   final boolean doLog ,   final boolean isCreation )  {  return  isGranted  ( permission , accessingUser , mask , level , alreadyTraversed , resolvePermissions , doLog , null , isCreation ) ; }   private boolean isGranted  (   final Permission permission ,   final Principal accessingUser ,   final PermissionResolutionMask mask ,   final  int level ,   final AlreadyTraversed alreadyTraversed ,   final boolean resolvePermissions ,   final boolean doLog ,   final  Map  < String , Security > incomingSecurityRelationships ,   final boolean isCreation )  {  if  (  level > 300 )  {   logger . warn  ( "Aborting recursive permission resolution for {} on {} because of recursion level > 300, this is quite likely an infinite loop." ,  permission . name  ( ) ,     getType  ( ) + "(" +  getUuid  ( ) + ")" ) ;  return false ; }  if  ( doLog )  {   logger . info  ( "{}{} ({}): {} check on level {} for {}" ,  StringUtils . repeat  ( "    " , level ) ,  getUuid  ( ) ,  getType  ( ) ,  permission . name  ( ) , level ,   accessingUser != null ?  accessingUser . getName  ( ) : null ) ; }  if  (  isCreation &&  (    accessingUser == null ||  accessingUser . equals  ( this ) ||  accessingUser . equals  (  getOwnerNode  ( ) ) ) )  {  return true ; }  if  (  accessingUser != null )  {  if  (  accessingUser . isAdmin  ( ) )  {  return true ; }  if  (  allowedBySchema  ( accessingUser , permission ) )  {  if  ( doLog )  {   logger . info  ( "{}{} ({}): {} allowed on level {} by schema configuration for {}" ,  StringUtils . repeat  ( "    " , level ) ,  getUuid  ( ) ,  getType  ( ) ,  permission . name  ( ) , level ,   accessingUser != null ?  accessingUser . getName  ( ) : null ) ; }  return true ; } }  if  (   this . equals  ( accessingUser ) &&  (   level == 0 ||  (   permission . equals  (  Permission . read ) &&  level > 0 ) ) )  {  return true ; }   final Principal  _owner =  getOwnerNode  ( ) ;   final boolean  hasOwner =  (  _owner != null ) ;  if  (   ! hasOwner &&   Services . getPermissionsForOwnerlessNodes  ( ) . contains  ( permission ) )  {  if  (   accessingUser != null &&  isVisibleToAuthenticatedUsers  ( ) )  {  return true ; }  if  (   accessingUser == null &&  isVisibleToPublicUsers  ( ) )  {  return true ; } }  if  (  hasOwner &&  accessingUser == null )  {  return false ; }  if  (  accessingUser != null )  {  if  (  hasOwner &&  accessingUser . equals  ( _owner ) )  {  return true ; }   final  Map  < String , Security >  localIncomingSecurityRelationships =    (  Map  < String , Security > ) incomingSecurityRelationships != null ? incomingSecurityRelationships :  mapSecurityRelationshipsMapped  (  getIncomingRelationshipsAsSuperUser  (  Security . class ) ) ;   final Security  security =  getSecurityRelationship  ( accessingUser , localIncomingSecurityRelationships ) ;  if  (   security != null &&  security . isAllowed  ( permission ) )  {  if  ( doLog )  {   logger . info  ( "{}{} ({}): {} allowed on level {} by security relationship for {}" ,  StringUtils . repeat  ( "    " , level ) ,  getUuid  ( ) ,  getType  ( ) ,  permission . name  ( ) , level ,   accessingUser != null ?  accessingUser . getName  ( ) : null ) ; }  return true ; }   final  PropertyKey  < String >  permissionPropertyKey =   StructrApp . getConfiguration  ( ) . getPropertyKeyForJSONName  (  Principal . class ,  "customPermissionQuery" +  StringUtils . capitalize  (  permission . name  ( ) ) ) ;   final String  customPermissionQuery =  accessingUser . getProperty  ( permissionPropertyKey ) ;  if  (  StringUtils . isNotEmpty  ( customPermissionQuery ) )  {   final  Map  < String , Object >  params =  new  HashMap  < >  ( ) ;   params . put  ( "principalUuid" ,  accessingUser . getUuid  ( ) ) ;   params . put  ( "principalId" ,  accessingUser . getUuid  ( ) ) ;   params . put  ( "principalType" ,  accessingUser . getType  ( ) ) ;   params . put  ( "targetNodeUuid" ,  this . getUuid  ( ) ) ;   params . put  ( "targetNodeType" ,  this . getType  ( ) ) ;  boolean  result = false ;  try  {   final DatabaseService  db =   Services . getInstance  ( ) . getDatabaseService  ( ) ;   final  NativeQuery  < Boolean >  cpq =  db . query  ( customPermissionQuery ,  Boolean . class ) ;   cpq . configure  ( params ) ;   result =  db . execute  ( cpq ) ; }  catch (   final  Exception ex )  {   logger . error  ( "Error in custom permission resolution" , ex ) ; }   logger . info  (      "CPQ (" +  permission . name  ( ) + ") '" + customPermissionQuery + "': " + result ) ;  if  ( result )  {  return true ; } }  if  ( resolvePermissions )  {   final  Queue  < BFSInfo >  bfsNodes =  new  LinkedList  < >  ( ) ;   final BFSInfo  root =  new BFSInfo  ( null , this ) ;   bfsNodes . add  ( root ) ;  do  {   final BFSInfo  info =  bfsNodes . poll  ( ) ;  if  (   info != null &&   info . level < permissionResolutionMaxLevel )  {   final Boolean  value =   info . node . getPermissionResolutionResult  (  accessingUser . getUuid  ( ) , permission ) ;  if  (  value != null )  {  if  (   Boolean . TRUE . equals  ( value ) )  {   backtrack  ( info ,  accessingUser . getUuid  ( ) , permission , true , 0 , doLog ) ;  return true ; } } else  {  if  (   info . node . hasEffectivePermissions  ( info , accessingUser , permission , mask , level , alreadyTraversed , bfsNodes , doLog , isCreation ) )  {   backtrack  ( info ,  accessingUser . getUuid  ( ) , permission , true , 0 , doLog ) ;  return true ; } } } } while  (  !  bfsNodes . isEmpty  ( ) ) ;   backtrack  ( root ,  accessingUser . getUuid  ( ) , permission , false , 0 , doLog ) ; }  for ( Principal parent :  accessingUser . getParentsPrivileged  ( ) )  {  if  (  isGranted  ( permission , parent , mask ,  level + 1 , alreadyTraversed , false , doLog , localIncomingSecurityRelationships , isCreation ) )  {  return true ; } } }  return false ; }   private void backtrack  (   final BFSInfo info ,   final String principalId ,   final Permission permission ,   final boolean value ,   final  int level ,   final boolean doLog )  {   final StringBuilder  buf =  new StringBuilder  ( ) ;  if  ( doLog )  {  if  (  level == 0 )  {  if  ( value )  {    buf . append  (  permission . name  ( ) ) . append  ( ": granted: " ) ; } else  {    buf . append  (  permission . name  ( ) ) . append  ( ": denied: " ) ; } }      buf . append  (   info . node . getType  ( ) ) . append  ( " (" ) . append  (   info . node . getUuid  ( ) ) . append  ( ") --> " ) ; }    info . node . storePermissionResolutionResult  ( principalId , permission , value ) ;  if  (   info . parent != null )  {   backtrack  (  info . parent , principalId , permission , value ,  level + 1 , doLog ) ; }  if  (  doLog &&  level == 0 )  {   logger . info  (  buf . toString  ( ) ) ; } }   private boolean hasEffectivePermissions  (   final BFSInfo parent ,   final Principal principal ,   final Permission permission ,   final PermissionResolutionMask mask ,   final  int level ,   final AlreadyTraversed alreadyTraversed ,   final  Queue  < BFSInfo > bfsNodes ,   final boolean doLog ,   final boolean isCreation )  {  if  (  alreadyTraversed . contains  ( "Node" ,  getUuid  ( ) ) )  {  return false ; }  if  ( doLog )  {   logger . info  ( "{}{} ({}): checking {} access on level {} for {}" ,  StringUtils . repeat  ( "    " , level ) ,  getUuid  ( ) ,  getType  ( ) ,  permission . name  ( ) , level ,   principal != null ?  principal . getName  ( ) : null ) ; }  for (  final  Class  < Relation > propagatingType :  SchemaRelationshipNode . getPropagatingRelationshipTypes  ( ) )  {   final  List  < Relation >  list =  Iterables . toList  (  getRelationshipsAsSuperUser  ( propagatingType ) ) ;   final  int  count =  list . size  ( ) ;   final  int  threshold = 1000 ;  if  (  count < threshold )  {  for (  final Relation source : list )  {  if  (  source instanceof PermissionPropagation )  {   final PermissionPropagation  perm =  ( PermissionPropagation ) source ;   final RelationshipInterface  rel =  ( RelationshipInterface ) source ;  if  ( doLog )  {   logger . info  ( "{}{}: checking {} access on level {} via {} for {}" ,  StringUtils . repeat  ( "    " , level ) ,  getUuid  ( ) ,  permission . name  ( ) , level ,   rel . getRelType  ( ) . name  ( ) ,   principal != null ?  principal . getName  ( ) : null ) ; }  if  (  propagationAllowed  ( this , rel ,  perm . getPropagationDirection  ( ) , doLog ) )  {   applyCurrentStep  ( perm , mask ) ;  if  (  mask . allowsPermission  ( permission ) )  {   final AbstractNode  otherNode =  ( AbstractNode )  rel . getOtherNode  ( this ) ;  if  (  otherNode . isGranted  ( permission , principal , mask ,  level + 1 , alreadyTraversed , false , doLog , isCreation ) )  {   otherNode . storePermissionResolutionResult  (  principal . getUuid  ( ) , permission , true ) ;  return true ; } else  {   bfsNodes . add  (  new BFSInfo  ( parent , otherNode ) ) ; } } } } } } else  if  ( doLog )  {   logger . warn  ( "Refusing to resolve permissions with {} because there are more than {} nodes." ,  propagatingType . getSimpleName  ( ) , threshold ) ; } }  return false ; }   private boolean propagationAllowed  (   final AbstractNode thisNode ,   final RelationshipInterface rel ,   final PropagationDirection propagationDirection ,   final boolean doLog )  {  if  (  propagationDirection . equals  (  PropagationDirection . Both ) )  {  return true ; }  if  (  propagationDirection . equals  (  PropagationDirection . None ) )  {  return false ; }   final String  sourceNodeId =   rel . getSourceNode  ( ) . getUuid  ( ) ;   final String  thisNodeId =  thisNode . getUuid  ( ) ;  if  (  sourceNodeId . equals  ( thisNodeId ) )  {  switch  ( propagationDirection )  {   case Out :  return false ;   case In :  return true ; } } else  {  switch  ( propagationDirection )  {   case Out :  return true ;   case In :  return false ; } }  return false ; }   private void applyCurrentStep  (   final PermissionPropagation rel ,  PermissionResolutionMask mask )  {  switch  (  rel . getReadPropagation  ( ) )  {   case Add :   case Keep :   mask . addRead  ( ) ;  break ;   case Remove :   mask . removeRead  ( ) ;  break ;   default :  break ; }  switch  (  rel . getWritePropagation  ( ) )  {   case Add :   case Keep :   mask . addWrite  ( ) ;  break ;   case Remove :   mask . removeWrite  ( ) ;  break ;   default :  break ; }  switch  (  rel . getDeletePropagation  ( ) )  {   case Add :   case Keep :   mask . addDelete  ( ) ;  break ;   case Remove :   mask . removeDelete  ( ) ;  break ;   default :  break ; }  switch  (  rel . getAccessControlPropagation  ( ) )  {   case Add :   case Keep :   mask . addAccessControl  ( ) ;  break ;   case Remove :   mask . removeAccessControl  ( ) ;  break ;   default :  break ; }   mask . handleProperties  (  rel . getDeltaProperties  ( ) ) ; }   private Boolean getPermissionResolutionResult  (   final String principalId ,   final Permission permission )  {   Map  < String , PermissionResolutionResult >  permissionResolutionCache =  globalPermissionResolutionCache . get  (  getUuid  ( ) ) ;  if  (  permissionResolutionCache == null )  {   permissionResolutionCache =  new  HashMap  < >  ( ) ;   globalPermissionResolutionCache . put  (  getUuid  ( ) , permissionResolutionCache ) ; }  PermissionResolutionResult  result =  permissionResolutionCache . get  ( principalId ) ;  if  (  result != null )  {  if  (  permission . equals  (  Permission . read ) )  {  return  result . read ; }  if  (  permission . equals  (  Permission . write ) )  {  return  result . write ; }  if  (  permission . equals  (  Permission . delete ) )  {  return  result . delete ; }  if  (  permission . equals  (  Permission . accessControl ) )  {  return  result . accessControl ; } }  return null ; }   private void storePermissionResolutionResult  (   final String principalId ,   final Permission permission ,   final boolean value )  {   Map  < String , PermissionResolutionResult >  permissionResolutionCache =  globalPermissionResolutionCache . get  (  getUuid  ( ) ) ;  if  (  permissionResolutionCache == null )  {   permissionResolutionCache =  new  HashMap  < >  ( ) ;   globalPermissionResolutionCache . put  (  getUuid  ( ) , permissionResolutionCache ) ; }  PermissionResolutionResult  result =  permissionResolutionCache . get  ( principalId ) ;  if  (  result == null )  {   result =  new PermissionResolutionResult  ( ) ;   permissionResolutionCache . put  ( principalId , result ) ; }  if  (   permission . equals  (  Permission . read ) &&  (    result . read == null ||   result . read == false ) )  {    result . read = value ; }  if  (   permission . equals  (  Permission . write ) &&  (    result . write == null ||   result . write == false ) )  {    result . write = value ; }  if  (   permission . equals  (  Permission . delete ) &&  (    result . delete == null ||   result . delete == false ) )  {    result . delete = value ; }  if  (   permission . equals  (  Permission . accessControl ) &&  (    result . accessControl == null ||   result . accessControl == false ) )  {    result . accessControl = value ; } }   private Security getSecurityRelationship  (   final Principal p ,   final  Map  < String , Security > securityRelationships )  {  if  (  p == null )  {  return null ; }  return  securityRelationships . get  (  p . getUuid  ( ) ) ; }    @ Override public final Security getSecurityRelationship  (   final Principal p )  {  if  (  p != null )  {   final  Predicate  < GraphObject >  principalFilter =   (  GraphObject value ) ->  {  return  (   p . getUuid  ( ) . equals  (  value . getUuid  ( ) ) ) ; } ;  return  getSecurityRelationship  ( p ,  mapSecurityRelationshipsMapped  (  getIncomingRelationshipsAsSuperUser  (  Security . class , principalFilter ) ) ) ; }  return  getSecurityRelationship  ( p ,  mapSecurityRelationshipsMapped  (  getIncomingRelationshipsAsSuperUser  (  Security . class ) ) ) ; }    @ Override public void onCreation  (  SecurityContext securityContext ,  ErrorBuffer errorBuffer )  throws FrameworkException  { }    @ Override public void onModification  (  SecurityContext securityContext ,  ErrorBuffer errorBuffer ,   final ModificationQueue modificationQueue )  throws FrameworkException  {   clearCaches  ( ) ; }    @ Override public void onDeletion  (  SecurityContext securityContext ,  ErrorBuffer errorBuffer ,  PropertyMap properties )  throws FrameworkException  {   clearCaches  ( ) ; }    @ Override public void afterCreation  (  SecurityContext securityContext )  throws FrameworkException  { }    @ Override public void afterModification  (  SecurityContext securityContext )  { }    @ Override public void afterDeletion  (  SecurityContext securityContext ,  PropertyMap properties )  { }    @ Override public void ownerModified  (  SecurityContext securityContext )  {   clearCaches  ( ) ; }    @ Override public void securityModified  (  SecurityContext securityContext )  {   clearCaches  ( ) ; }    @ Override public void locationModified  (  SecurityContext securityContext )  {   clearCaches  ( ) ; }    @ Override public void propagatedModification  (  SecurityContext securityContext )  {   clearCaches  ( ) ; }    @ Override public boolean isValid  (   final ErrorBuffer errorBuffer )  {  boolean  valid = true ;   valid &=  ValidationHelper . isValidStringNotBlank  ( this , id , errorBuffer ) ;  if  (   securityContext != null &&  securityContext . uuidWasSetManually  ( ) )  {   valid &=  ValidationHelper . isValidGloballyUniqueProperty  ( this , id , errorBuffer ) ; }   valid &=  ValidationHelper . isValidStringMatchingRegex  ( this , id , "[a-fA-F0-9]{32}" , errorBuffer ) ;   valid &=  ValidationHelper . isValidStringNotBlank  ( this , type , errorBuffer ) ;  return valid ; }    @ Override public boolean isVisibleToPublicUsers  ( )  {  return  getVisibleToPublicUsers  ( ) ; }    @ Override public boolean isVisibleToAuthenticatedUsers  ( )  {  return  getProperty  ( visibleToAuthenticatedUsers ) ; }    @ Override public final boolean isNotHidden  ( )  {  return  !  getHidden  ( ) ; }    @ Override public final boolean isHidden  ( )  {  return  getHidden  ( ) ; }    @ Override public final Date getCreatedDate  ( )  {  return  getProperty  ( createdDate ) ; }    @ Override public final Date getLastModifiedDate  ( )  {  return  getProperty  ( lastModifiedDate ) ; }    @ Override public  <  T > Object setProperty  (   final  PropertyKey  < T > key ,   final T value )  throws FrameworkException  {  return  setProperty  ( key , value , false ) ; }    @ Override public  <  T > Object setProperty  (   final  PropertyKey  < T > key ,   final T value ,   final boolean isCreation )  throws FrameworkException  {  if  (  securityContext != null )  {    securityContext . getContextStore  ( ) . clearFunctionPropertyCache  ( ) ; }  if  (  !  key . equals  (  GraphObject . id ) )  {  if  (  !  isGranted  (  Permission . write , securityContext , isCreation ) )  {   internalSystemPropertiesUnlocked = false ;   readOnlyPropertiesUnlocked = false ;   final Principal  currentUser =  securityContext . getUser  ( false ) ;  String  user = null ;  if  (  currentUser == null )  {   user =   securityContext . isSuperUser  ( ) ? "superuser" : "anonymous" ; } else  {   user =  currentUser . getProperty  (  AbstractNode . id ) ; }  throw  new FrameworkException  ( 403 ,       "Modification of node " +  this . getProperty  (  AbstractNode . id ) + " with type " +  this . getProperty  (  AbstractNode . type ) + " by user " + user + " not permitted." ) ; } }  try  {  T  oldValue =  isCreation ? null :  getProperty  ( key ) ;  if  (   isCreation ||  (   (  oldValue == null ) &&  (  value != null ) ) ||  (    (  oldValue != null ) &&  (  !  oldValue . equals  ( value ) ) ||  (  key instanceof FunctionProperty ) ) )  {  return  setPropertyInternal  ( key , value ) ; } }  finally  {   internalSystemPropertiesUnlocked = false ;   readOnlyPropertiesUnlocked = false ; }  return null ; }    @ Override public void setProperties  (   final SecurityContext securityContext ,   final PropertyMap properties )  throws FrameworkException  {   setProperties  ( securityContext , properties , false ) ; }    @ Override public void setProperties  (   final SecurityContext securityContext ,   final PropertyMap properties ,   final boolean isCreation )  throws FrameworkException  {  if  (  !  isGranted  (  Permission . write , securityContext , isCreation ) )  {   internalSystemPropertiesUnlocked = false ;   readOnlyPropertiesUnlocked = false ;   final Principal  currentUser =  securityContext . getUser  ( false ) ;  String  user = null ;  if  (  currentUser == null )  {   user =   securityContext . isSuperUser  ( ) ? "superuser" : "anonymous" ; } else  {   user =  currentUser . getProperty  (  AbstractNode . id ) ; }  throw  new FrameworkException  ( 403 ,       "Modification of node " +  this . getProperty  (  AbstractNode . id ) + " with type " +  this . getProperty  (  AbstractNode . type ) + " by user " + user + " not permitted." ) ; }  for (  final PropertyKey key :  properties . keySet  ( ) )  {   final Object  oldValue =  isCreation ? null :  getProperty  ( key ) ;   final Object  value =  properties . get  ( key ) ;  if  (   isCreation ||  (   (  oldValue == null ) &&  (  value != null ) ) ||  (    (  oldValue != null ) &&  (  !  oldValue . equals  ( value ) ) ||  (  key instanceof FunctionProperty ) ) )  {  if  (  !  key . equals  (  GraphObject . id ) )  {  if  (   key . isSystemInternal  ( ) &&  ! internalSystemPropertiesUnlocked )  {  throw  new FrameworkException  ( 422 ,   "Property " +  key . jsonName  ( ) + " is an internal system property" ,  new InternalSystemPropertyToken  (   getClass  ( ) . getSimpleName  ( ) , key ) ) ; }  if  (    (   key . isReadOnly  ( ) ||  key . isWriteOnce  ( ) ) &&  ! readOnlyPropertiesUnlocked &&  !  securityContext . isSuperUser  ( ) )  {  throw  new FrameworkException  ( 422 ,   "Property " +  key . jsonName  ( ) + " is read-only" ,  new ReadOnlyPropertyToken  (   getClass  ( ) . getSimpleName  ( ) , key ) ) ; } } } }   NodeInterface . super . setPropertiesInternal  ( securityContext , properties , isCreation ) ; }   private  <  T > Object setPropertyInternal  (   final  PropertyKey  < T > key ,   final T value )  throws FrameworkException  {  if  (  key == null )  {   logger . error  ( "Tried to set property with null key (action was denied)" ) ;  throw  new FrameworkException  ( 422 , "Tried to set property with null key (action was denied)" ,  new NullArgumentToken  (   getClass  ( ) . getSimpleName  ( ) , base ) ) ; }  try  {  if  (   key . isSystemInternal  ( ) &&  ! internalSystemPropertiesUnlocked )  {  throw  new FrameworkException  ( 422 ,   "Property " +  key . jsonName  ( ) + " is an internal system property" ,  new InternalSystemPropertyToken  (   getClass  ( ) . getSimpleName  ( ) , key ) ) ; }  if  (    (   key . isReadOnly  ( ) ||  key . isWriteOnce  ( ) ) &&  ! readOnlyPropertiesUnlocked &&  !  securityContext . isSuperUser  ( ) )  {  throw  new FrameworkException  ( 422 ,   "Property " +  key . jsonName  ( ) + " is read-only" ,  new ReadOnlyPropertyToken  (   getClass  ( ) . getSimpleName  ( ) , key ) ) ; }  return  key . setProperty  ( securityContext , this , value ) ; }  finally  {   internalSystemPropertiesUnlocked = false ;   readOnlyPropertiesUnlocked = false ; } }   public static void clearRelationshipTemplateInstanceCache  ( )  {   relationshipTemplateInstanceCache . clear  ( ) ; }   public static void clearCaches  ( )  {   globalPermissionResolutionCache . clear  ( ) ;   isGrantedResultCache . clear  ( ) ; }   public static  <  A  extends NodeInterface ,  B  extends NodeInterface ,  R  extends  Relation  < A , B ,  ? ,  ? > > R getRelationshipForType  (   final  Class  < R > type )  {  R  instance =  ( R )  relationshipTemplateInstanceCache . get  (  type . getName  ( ) ) ;  if  (  instance == null )  {  try  {   instance =  type . newInstance  ( ) ;   relationshipTemplateInstanceCache . put  (  type . getName  ( ) , instance ) ; }  catch (   Throwable t )  {   logger . warn  ( "" , t ) ; } }  return instance ; }    @ Override public final String getPropertyWithVariableReplacement  (  ActionContext renderContext ,   PropertyKey  < String > key )  throws FrameworkException  {   final Object  value =  getProperty  ( key ) ;  String  result = null ;  try  {   result =  Scripting . replaceVariables  ( renderContext , this , value , true ,  key . jsonName  ( ) ) ; }  catch (   Throwable t )  {   logger . warn  ( "Scripting error in {} {}:\n{}" ,  key . dbName  ( ) ,  getUuid  ( ) , value , t ) ; }  return result ; }   public final Object getPath  (   final SecurityContext currentSecurityContext )  {  if  (  rawPathSegmentId != null )  {   final Relationship  rel =    StructrApp . getInstance  ( currentSecurityContext ) . getDatabaseService  ( ) . getRelationshipById  ( rawPathSegmentId ) ;  if  (  rel != null )  {   final RelationshipFactory  factory =  new RelationshipFactory  ( currentSecurityContext ) ;  return  factory . instantiate  ( rel ) ; } }  return null ; }    @ Override public final Object evaluate  (   final ActionContext actionContext ,   final String key ,   final String defaultValue ,   final EvaluationHints hints ,   final  int row ,   final  int column )  throws FrameworkException  {   hints . reportUsedKey  ( key , row , column ) ;  switch  ( key )  {   case "owner" :   hints . reportExistingKey  ( key ) ;  return  getOwnerNode  ( ) ;   case "_path" :   hints . reportExistingKey  ( key ) ;  return  getPath  (  actionContext . getSecurityContext  ( ) ) ;   default :   final PropertyKey  propertyKey =   StructrApp . getConfiguration  ( ) . getPropertyKeyForJSONName  ( entityType , key , false ) ;  if  (  propertyKey != null )  {   hints . reportExistingKey  ( key ) ;   final Object  value =  getProperty  ( propertyKey ,  actionContext . getPredicate  ( ) ) ;  if  (  value != null )  {  return value ; } }   final Object  value =  invokeMethod  (  actionContext . getSecurityContext  ( ) , key ,  Collections . EMPTY_MAP , false , hints ) ;  if  (  value != null )  {  return value ; }  return  Function . numberOrString  ( defaultValue ) ; } }    @ Override public final Object invokeMethod  (   final SecurityContext securityContext ,   final String methodName ,   final  Map  < String , Object > propertySet ,   final boolean throwExceptionForUnknownMethods ,   final EvaluationHints hints )  throws FrameworkException  {   final Method  method =    StructrApp . getConfiguration  ( ) . getExportedMethodsForType  ( entityType ) . get  ( methodName ) ;  if  (  method != null )  {   hints . reportExistingKey  ( methodName ) ;  try  {  if  (      method . getParameterTypes  ( ) . length == 2 &&    method . getParameterTypes  ( ) [ 0 ] . isAssignableFrom  (  SecurityContext . class ) &&    method . getParameterTypes  ( ) [ 1 ] . equals  (  Map . class ) )  {   final  Object  [ ]  args =  new Object  [ ]  { securityContext } ;  return  method . invoke  ( this ,  ArrayUtils . add  ( args , propertySet ) ) ; }   final  Object  [ ]  args =  extractParameters  ( propertySet ,  method . getParameterTypes  ( ) ) ;  return  method . invoke  ( this ,  ArrayUtils . add  ( args , 0 , securityContext ) ) ; }  catch (   IllegalAccessException | IllegalArgumentException | InvocationTargetException t )  {  if  (  t instanceof FrameworkException )  {  throw  ( FrameworkException ) t ; } else  if  (   t . getCause  ( ) instanceof FrameworkException )  {  throw  ( FrameworkException )  t . getCause  ( ) ; } else  {   logger . debug  ( "Unable to invoke method {}: {}" ,  new Object  [ ]  { methodName ,  t . getMessage  ( ) } ) ;   logger . warn  ( "" , t ) ; } } }  if  ( throwExceptionForUnknownMethods )  {  throw  new FrameworkException  ( 400 ,    "Method " + methodName + " not found in type " +  getType  ( ) ) ; }  return null ; }   private  Object  [ ] extractParameters  (   Map  < String , Object > properties ,   Class  [ ] parameterTypes )  {   final  List  < Object >  values =  new  ArrayList  < >  (  properties . values  ( ) ) ;   final  List  < Object >  parameters =  new  ArrayList  < >  ( ) ;   int  index = 0 ;  if  (   values . size  ( ) ==  (   parameterTypes . length - 1 ) )  {  for (  final Class parameterType : parameterTypes )  {  if  (  !  parameterType . isAssignableFrom  (  SecurityContext . class ) )  {   final Object  value =  convert  (  values . get  (  index ++ ) , parameterType ) ;  if  (  value != null )  {   parameters . add  ( value ) ; } } } }  return  parameters . toArray  (  new Object  [ 0 ] ) ; }   private Object convert  (  Object value ,  Class type )  {  if  (  type . isAssignableFrom  (  value . getClass  ( ) ) )  {  return value ; }  Object  convertedObject = null ;  if  (  type . equals  (  String . class ) )  {  return  value . toString  ( ) ; } else  if  (  value instanceof Number )  {  Number  number =  ( Number ) value ;  if  (   type . equals  (  Integer . class ) ||  type . equals  (  Integer . TYPE ) )  {  return  number . intValue  ( ) ; } else  if  (   type . equals  (  Long . class ) ||  type . equals  (  Long . TYPE ) )  {  return  number . longValue  ( ) ; } else  if  (   type . equals  (  Double . class ) ||  type . equals  (  Double . TYPE ) )  {  return  number . doubleValue  ( ) ; } else  if  (   type . equals  (  Float . class ) ||  type . equals  (  Float . TYPE ) )  {  return  number . floatValue  ( ) ; } else  if  (   type . equals  (  Short . class ) ||  type . equals  (  Integer . TYPE ) )  {  return  number . shortValue  ( ) ; } else  if  (   type . equals  (  Byte . class ) ||  type . equals  (  Byte . TYPE ) )  {  return  number . byteValue  ( ) ; } } else  if  (  value instanceof List )  {  return value ; } else  if  (  value instanceof Map )  {  return value ; } else  if  (  value instanceof Boolean )  {  return value ; }  try  {  Method  valueOf =  type . getMethod  ( "valueOf" ,  String . class ) ;  if  (  valueOf != null )  {   convertedObject =  valueOf . invoke  ( null ,  value . toString  ( ) ) ; } else  {   logger . warn  ( "Unable to find static valueOf method for type {}" , type ) ; } }  catch (   Throwable t )  {   logger . warn  ( "Unable to deserialize value {} of type {}, Class has no static valueOf method." ,  new Object  [ ]  { value , type } ) ; }  return convertedObject ; }   private  Map  < String , Security > mapSecurityRelationshipsMapped  (   final  Iterable  < Security > src )  {   final  Map  < String , Security >  map =  new  HashMap  < >  ( ) ;  for (  final Security sec : src )  {   map . put  (  sec . getSourceNodeId  ( ) , sec ) ; }  return map ; }    @ Override public final void grant  (  Permission permission ,  Principal principal )  throws FrameworkException  {   grant  (  Collections . singleton  ( permission ) , principal , securityContext ) ; }    @ Override public final void grant  (   final  Set  < Permission > permissions ,  Principal principal )  throws FrameworkException  {   grant  ( permissions , principal , securityContext ) ; }    @ Override public final void grant  (   final  Set  < Permission > permissions ,  Principal principal ,  SecurityContext ctx )  throws FrameworkException  {  if  (  !  isGranted  (  Permission . accessControl , ctx ) )  {  throw  new FrameworkException  ( 403 , "Access control not permitted" ) ; }   clearCaches  ( ) ;  Security  secRel =  getSecurityRelationship  ( principal ) ;  if  (  secRel == null )  {  try  {   Set  < String >  permissionSet =  new  HashSet  < >  ( ) ;  for ( Permission permission : permissions )  {   permissionSet . add  (  permission . name  ( ) ) ; }   final SecurityContext  superUserContext =  SecurityContext . getSuperUserInstance  ( ) ;   final PropertyMap  properties =  new PropertyMap  ( ) ;   superUserContext . disablePreventDuplicateRelationships  ( ) ;   properties . put  (  Security . principalId ,  principal . getUuid  ( ) ) ;   properties . put  (  Security . accessControllableId ,  getUuid  ( ) ) ;   properties . put  (  Security . allowed ,  permissionSet . toArray  (  new String  [  permissionSet . size  ( ) ] ) ) ;    StructrApp . getInstance  ( superUserContext ) . create  ( principal ,  ( NodeInterface ) this ,  Security . class , properties ) ; }  catch (   FrameworkException ex )  {   logger . error  ( "Could not create security relationship!" , ex ) ; } } else  {   secRel . addPermissions  ( permissions ) ; } }    @ Override public final void revoke  (  Permission permission ,  Principal principal )  throws FrameworkException  {   revoke  (  Collections . singleton  ( permission ) , principal , securityContext ) ; }    @ Override public final void revoke  (   final  Set  < Permission > permissions ,  Principal principal )  throws FrameworkException  {   revoke  ( permissions , principal , securityContext ) ; }    @ Override public final void revoke  (   Set  < Permission > permissions ,  Principal principal ,  SecurityContext ctx )  throws FrameworkException  {  if  (  !  isGranted  (  Permission . accessControl , ctx ) )  {  throw  new FrameworkException  ( 403 , "Access control not permitted" ) ; }   clearCaches  ( ) ;  Security  secRel =  getSecurityRelationship  ( principal ) ;  if  (  secRel != null )  {   secRel . removePermissions  ( permissions ) ; } }    @ Override public final void setAllowed  (   Set  < Permission > permissions ,  Principal principal )  throws FrameworkException  {   setAllowed  ( permissions , principal , securityContext ) ; }    @ Override public final void setAllowed  (   Set  < Permission > permissions ,  Principal principal ,  SecurityContext ctx )  throws FrameworkException  {  if  (  !  isGranted  (  Permission . accessControl , ctx ) )  {  throw  new FrameworkException  ( 403 , "Access control not permitted" ) ; }   clearCaches  ( ) ;   final  Set  < String >  permissionSet =  new  HashSet  < >  ( ) ;  for ( Permission permission : permissions )  {   permissionSet . add  (  permission . name  ( ) ) ; }  Security  secRel =  getSecurityRelationship  ( principal ) ;  if  (  secRel == null )  {  if  (   permissions . size  ( ) > 0 )  {  try  {   final SecurityContext  superUserContext =  SecurityContext . getSuperUserInstance  ( ) ;   final PropertyMap  properties =  new PropertyMap  ( ) ;   superUserContext . disablePreventDuplicateRelationships  ( ) ;   properties . put  (  Security . principalId ,  principal . getUuid  ( ) ) ;   properties . put  (  Security . accessControllableId ,  getUuid  ( ) ) ;   properties . put  (  Security . allowed ,  permissionSet . toArray  (  new String  [  permissionSet . size  ( ) ] ) ) ;    StructrApp . getInstance  ( superUserContext ) . create  ( principal ,  ( NodeInterface ) this ,  Security . class , properties ) ; }  catch (   FrameworkException ex )  {   logger . error  ( "Could not create security relationship!" , ex ) ; } } } else  {   secRel . setAllowed  ( permissionSet ) ; } }    @ Override public final void setRawPathSegmentId  (   final Identity rawPathSegmentId )  {    this . rawPathSegmentId = rawPathSegmentId ; }   public final void revokeAll  ( )  throws FrameworkException  {  if  (  !  isGranted  (  Permission . accessControl , securityContext ) )  {  throw  new FrameworkException  ( 403 , "Access control not permitted" ) ; }   final App  app =  StructrApp . getInstance  ( ) ;  for (  final Security security :  getIncomingRelationshipsAsSuperUser  (  Security . class ) )  {   app . delete  ( security ) ; } }    @ Override public  List  < Security > getSecurityRelationships  ( )  {   final  List  < Security >  grants =  Iterables . toList  (  getIncomingRelationshipsAsSuperUser  (  Security . class ) ) ;   Collections . sort  ( grants ,   ( o1 , o2 ) ->  {   final Principal  p1 =  o1 . getSourceNode  ( ) ;   final Principal  p2 =  o2 . getSourceNode  ( ) ;   final String  n1 =   p1 != null ?  p1 . getProperty  (  AbstractNode . name ) : "empty" ;   final String  n2 =   p2 != null ?  p2 . getProperty  (  AbstractNode . name ) : "empty" ;  if  (   n1 != null &&  n2 != null )  {  return  n1 . compareTo  ( n2 ) ; } else  if  (  n1 != null )  {  return 1 ; } else  if  (  n2 != null )  {  return  - 1 ; }  return 0 ; } ) ;  return grants ; }    @ Override public boolean changelogEnabled  ( )  {  return true ; }    @ Override public  List  < GraphObject > getSyncData  ( )  throws FrameworkException  {  return  new  ArrayList  < >  ( ) ; }    @ Override public final boolean isNode  ( )  {  return true ; }    @ Override public final boolean isRelationship  ( )  {  return false ; }    @ Override public final NodeInterface getSyncNode  ( )  {  return this ; }    @ Override public final RelationshipInterface getSyncRelationship  ( )  {  throw  new ClassCastException  (   this . getClass  ( ) + " cannot be cast to org.structr.core.graph.RelationshipInterface" ) ; }    @ Override public CMISInfo getCMISInfo  ( )  {  return this ; }    @ Override public BaseTypeId getBaseTypeId  ( )  {  return  BaseTypeId . CMIS_ITEM ; }    @ Override public CMISFolderInfo getFolderInfo  ( )  {  return null ; }    @ Override public CMISDocumentInfo getDocumentInfo  ( )  {  return null ; }    @ Override public CMISItemInfo getItemInfo  ( )  {  return this ; }    @ Override public CMISRelationshipInfo getRelationshipInfo  ( )  {  return null ; }    @ Override public CMISPolicyInfo getPolicyInfo  ( )  {  return null ; }    @ Override public CMISSecondaryInfo getSecondaryInfo  ( )  {  return null ; }    @ Override public String getCreatedBy  ( )  {  return  getProperty  (  AbstractNode . createdBy ) ; }    @ Override public String getLastModifiedBy  ( )  {  return  getProperty  (  AbstractNode . lastModifiedBy ) ; }    @ Override public GregorianCalendar getLastModificationDate  ( )  {   final Date  creationDate =  getProperty  (  AbstractNode . lastModifiedDate ) ;  if  (  creationDate != null )  {   final GregorianCalendar  calendar =  new GregorianCalendar  ( ) ;   calendar . setTime  ( creationDate ) ;  return calendar ; }  return null ; }    @ Override public GregorianCalendar getCreationDate  ( )  {   final Date  creationDate =  getProperty  (  AbstractNode . createdDate ) ;  if  (  creationDate != null )  {   final GregorianCalendar  calendar =  new GregorianCalendar  ( ) ;   calendar . setTime  ( creationDate ) ;  return calendar ; }  return null ; }    @ Override public PropertyMap getDynamicProperties  ( )  {   final PropertyMap  propertyMap =  new PropertyMap  ( ) ;   final Class  type =  getClass  ( ) ;  for (  final PropertyKey key :   StructrApp . getConfiguration  ( ) . getPropertySet  ( type ,  PropertyView . All ) )  {  if  (   key . isDynamic  ( ) ||  key . isCMISProperty  ( ) )  {   final PropertyType  dataType =  key . getDataType  ( ) ;  if  (  dataType != null )  {   propertyMap . put  ( key ,  getProperty  ( key ) ) ; } } }  return propertyMap ; }    @ Override public AllowableActions getAllowableActions  ( )  {  return  new StructrItemActions  ( ) ; }    @ Override public  List  < Ace > getAccessControlEntries  ( )  {   final  List  < Ace >  entries =  new  LinkedList  < >  ( ) ;  for (  final Security security :  getIncomingRelationshipsAsSuperUser  (  Security . class ) )  {  if  (  security != null )  {   entries . add  (  new AceEntry  ( security ) ) ; } }  return entries ; }    @ Override public synchronized  Map  < String , Object > getTemporaryStorage  ( )  {  if  (  tmpStorageContainer == null )  {   tmpStorageContainer =  new  LinkedHashMap  < >  ( ) ; }  return tmpStorageContainer ; }   protected boolean isGenericNode  ( )  {  return false ; }   protected boolean allowedBySchema  (   final Principal principal ,   final Permission permission )  {  return false ; }   private static class AceEntry  extends CMISExtensionsData  implements  Ace ,       org . apache . chemistry . opencmis . commons . data . Principal  {   private final  List  < String >  permissions =  new  LinkedList  < >  ( ) ;   private String  principalId = null ;   public AceEntry  (   final Security security )  {   final Principal  principal =  security . getSourceNode  ( ) ;  if  (  principal != null )  {    this . principalId =  principal . getProperty  (  Principal . name ) ; }   permissions . addAll  (  security . getPermissions  ( ) ) ; }    @ Override public       org . apache . chemistry . opencmis . commons . data . Principal getPrincipal  ( )  {  return this ; }    @ Override public String getPrincipalId  ( )  {  return principalId ; }    @ Override public  List  < String > getPermissions  ( )  {  return permissions ; }    @ Override public boolean isDirect  ( )  {  return true ; }    @ Override public String getId  ( )  {  return  getPrincipalId  ( ) ; } }   private static class AlreadyTraversed  {   private  Map  < String ,  Set  < String > >  sets =  new  LinkedHashMap  < >  ( ) ;   public boolean contains  (   final String key ,   final String uuid )  {   Set  < String >  set =  sets . get  ( key ) ;  if  (  set == null )  {   set =  new  HashSet  < >  ( ) ;   sets . put  ( key , set ) ; }  return  !  set . add  ( uuid ) ; }   public  int size  (   final String key )  {   final  Set  < String >  set =  sets . get  ( key ) ;  if  (  set != null )  {  return  set . size  ( ) ; }  return 0 ; } }   private static class BFSInfo  {   public AbstractNode  node = null ;   public BFSInfo  parent = null ;   public  int  level = 0 ;   public BFSInfo  (   final BFSInfo parent ,   final AbstractNode node )  {    this . parent = parent ;    this . node = node ;  if  (  parent != null )  {    this . level =   parent . level + 1 ; } } }   private static class PermissionResolutionResult  {  Boolean  read = null ;  Boolean  write = null ;  Boolean  delete = null ;  Boolean  accessControl = null ; } 
<<<<<<<
=======
   @ Override public final Object invokeMethod  (   final SecurityContext securityContext ,   final String methodName ,   final  Map  < String , Object > propertySet ,   final boolean throwExceptionForUnknownMethods )  throws FrameworkException  {   final Method  method =    StructrApp . getConfiguration  ( ) . getExportedMethodsForType  ( entityType ) . get  ( methodName ) ;  if  (  method != null )  {  try  {  if  (      method . getParameterTypes  ( ) . length == 2 &&    method . getParameterTypes  ( ) [ 0 ] . isAssignableFrom  (  SecurityContext . class ) &&    method . getParameterTypes  ( ) [ 1 ] . equals  (  Map . class ) )  {   final  Object  [ ]  args =  new Object  [ ]  { securityContext } ;  return  method . invoke  ( this ,  ArrayUtils . add  ( args , propertySet ) ) ; }   final  Object  [ ]  args =  extractParameters  ( propertySet ,  method . getParameterTypes  ( ) ) ;  return  method . invoke  ( this ,  ArrayUtils . add  ( args , 0 , securityContext ) ) ; }  catch (   InvocationTargetException itex )  {   final Throwable  cause =  itex . getCause  ( ) ;  if  (  cause instanceof AssertException )  {   final AssertException  e =  ( AssertException ) cause ;  throw  new FrameworkException  (  e . getStatusCode  ( ) ,  e . getMessage  ( ) ) ; }  if  (  cause instanceof FrameworkException )  {  throw  ( FrameworkException ) cause ; } }  catch (   IllegalAccessException | IllegalArgumentException t )  {   logger . warn  ( "Unable to invoke method {}: {}" , methodName ,  t . getMessage  ( ) ) ; } }  if  ( throwExceptionForUnknownMethods )  {  throw  new FrameworkException  ( 400 ,    "Method " + methodName + " not found in type " +  getType  ( ) ) ; }  return null ; }
>>>>>>>
 }