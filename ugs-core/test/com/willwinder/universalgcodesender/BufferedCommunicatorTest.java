  package   com . willwinder . universalgcodesender ;   import     com . willwinder . universalgcodesender . connection . Connection ;  import     com . willwinder . universalgcodesender . connection . ConnectionDriver ;  import     com . willwinder . universalgcodesender . listeners . CommunicatorListener ;  import     com . willwinder . universalgcodesender . types . GcodeCommand ;  import     com . willwinder . universalgcodesender . utils . GcodeStreamReader ;  import     com . willwinder . universalgcodesender . utils . GcodeStreamTest ;  import     com . willwinder . universalgcodesender . utils . GcodeStreamWriter ;  import     com . willwinder . universalgcodesender . utils . IGcodeStreamReader ;  import     org . apache . commons . io . FileUtils ;  import   org . easymock . EasyMock ;  import   org . junit . AfterClass ;  import   org . junit . Before ;  import   org . junit . BeforeClass ;  import   org . junit . Test ;  import   org . mockito . ArgumentCaptor ;  import   java . io . File ;  import   java . io . IOException ;  import    java . lang . reflect . Field ;  import    java . util . concurrent . LinkedBlockingDeque ;  import static    org . junit . Assert . assertEquals ;  import static    org . junit . Assert . assertFalse ;  import static    org . junit . Assert . assertTrue ;  import static    org . junit . Assert . fail ;  import static    org . mockito . Mockito . doNothing ;  import static    org . mockito . Mockito . mock ;  import static    org . mockito . Mockito . times ;  import static    org . mockito . Mockito . verify ;   public class BufferedCommunicatorTest  {   private static File  tempDir ;   private final static Connection  mockConnection =  EasyMock . createMock  (  Connection . class ) ;   private final static CommunicatorListener  mockScl =  EasyMock . createMock  (  CommunicatorListener . class ) ;   private BufferedCommunicator  instance ;   private  LinkedBlockingDeque  < GcodeCommand >  cb ;   private  LinkedBlockingDeque  < GcodeCommand >  asl ;   public BufferedCommunicatorTest  ( )  { }    @ BeforeClass static public void setup  ( )  throws IOException  {   tempDir =  GcodeStreamTest . createTempDirectory  ( ) ; }    @ AfterClass static public void teardown  ( )  throws IOException  {   FileUtils . forceDeleteOnExit  ( tempDir ) ; }    @ Before public void setUp  ( )  throws IllegalArgumentException , IllegalAccessException , NoSuchFieldException  {   EasyMock . reset  ( mockConnection , mockScl ) ;   cb =  new  LinkedBlockingDeque  < >  ( ) ;   asl =  new  LinkedBlockingDeque  < >  ( ) ;   instance =  new BufferedCommunicatorImpl  ( cb , asl ) ;   instance . setConnection  ( mockConnection ) ;   instance . addListener  ( mockScl ) ;  Field  f =   AbstractCommunicator . class . getDeclaredField  ( "launchEventsInDispatchThread" ) ;   f . setAccessible  ( true ) ;   f . set  ( instance , false ) ;   EasyMock . reset  ( mockConnection , mockScl ) ; }    @ Test public void testGetBufferSize  ( )  {    System . out . println  ( "getBufferSize" ) ;   assertEquals  ( 101 ,  instance . getBufferSize  ( ) ) ; }    @ Test public void testQueueStringForComm  ( )  {    System . out . println  ( "queueStringForComm" ) ;  String  input = "input" ;   instance . queueCommand  (  new GcodeCommand  ( input ) ) ;   assertEquals  ( input ,   cb . getFirst  ( ) . getCommandString  ( ) ) ; }    @ Test public void testSimpleQueueStringsStream  ( )  throws Exception  {    System . out . println  ( "streamCommands" ) ;  String  input = "input" ;   mockConnection . sendStringToComm  (  input + "\n" ) ;    EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) . times  ( 2 ) ;   mockScl . commandSent  (  EasyMock . anyObject  (  GcodeCommand . class ) ) ;    EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) . times  ( 2 ) ;   EasyMock . replay  ( mockConnection , mockScl ) ;   instance . queueCommand  (  new GcodeCommand  ( input ) ) ;   instance . queueCommand  (  new GcodeCommand  ( input ) ) ;   instance . streamCommands  ( ) ;   EasyMock . verify  ( mockConnection , mockScl ) ; }    @ Test public void testSimpleStreamStream  ( )  throws Exception  {   String  [ ]  inputs =  { "input1" , "input2" } ;  for ( String i : inputs )  {   mockConnection . sendStringToComm  (  i + "\n" ) ;   EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) ;   mockScl . commandSent  (  EasyMock .  < GcodeCommand > anyObject  ( ) ) ;   EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) ; }   EasyMock . replay  ( mockConnection , mockScl ) ;  File  f =  new File  ( tempDir , "gcodeFile" ) ;  try  (  GcodeStreamWriter gsw =  new GcodeStreamWriter  ( f ) )  {  for ( String i : inputs )  {   gsw . addLine  ( "blah" , i , null ,  - 1 ) ; } }  IGcodeStreamReader  gsr =  new GcodeStreamReader  ( f ) ;   instance . queueStreamForComm  ( gsr ) ;   instance . streamCommands  ( ) ;   assertEquals  ( "input1, input2, 0 streaming commands." ,  instance . activeCommandSummary  ( ) ) ;   EasyMock . verify  ( mockConnection , mockScl ) ; }    @ Test public void testActiveCommands  ( )  throws Exception  {    System . out . println  ( "areActiveCommands" ) ;  String  input = "input" ;   mockConnection . sendStringToComm  (  input + "\n" ) ;    EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) . times  ( 2 ) ;   mockScl . commandSent  (  EasyMock .  < GcodeCommand > anyObject  ( ) ) ;    EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) . times  ( 2 ) ;   mockScl . rawResponseListener  ( "ok" ) ;    EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) . times  ( 2 ) ;   EasyMock . replay  ( mockConnection , mockScl ) ;   assertEquals  ( false ,  instance . areActiveCommands  ( ) ) ;   assertEquals  ( 0 ,  instance . numActiveCommands  ( ) ) ;   instance . queueCommand  (  new GcodeCommand  ( input ) ) ;   instance . queueCommand  (  new GcodeCommand  ( input ) ) ;   instance . streamCommands  ( ) ;   assertEquals  ( true ,  instance . areActiveCommands  ( ) ) ;   assertEquals  ( 2 ,  instance . numActiveCommands  ( ) ) ;   assertEquals  (   input + ", " + input ,  instance . activeCommandSummary  ( ) ) ;   instance . handleResponseMessage  ( "ok" ) ;   assertEquals  ( true ,  instance . areActiveCommands  ( ) ) ;   instance . handleResponseMessage  ( "ok" ) ;   assertEquals  ( false ,  instance . areActiveCommands  ( ) ) ;   assertEquals  ( 0 ,  instance . numActiveCommands  ( ) ) ;   EasyMock . verify  ( mockConnection , mockScl ) ; }    @ Test public void testPauseSendResume  ( )  throws Exception  {    System . out . println  ( "pauseSend" ) ;  String  input = "123456789" ;  for (   int  i = 0 ;  i < 11 ;  i ++ )  {   mockConnection . sendStringToComm  (  input + "\n" ) ;   EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) ; }   EasyMock . replay  ( mockConnection ) ;  for (   int  i = 0 ;  i < 11 ;  i ++ )  {   instance . queueCommand  (  new GcodeCommand  ( input ) ) ; }   instance . streamCommands  ( ) ;   instance . pauseSend  ( ) ;   assertEquals  ( "First 10 commands sent." , 10 ,  asl . size  ( ) ) ;  for (   int  i = 0 ;  i < 10 ;  i ++ )  {   instance . handleResponseMessage  ( "ok" ) ; }   assertEquals  ( "First 10 commands done." , 0 ,  asl . size  ( ) ) ;   instance . resumeSend  ( ) ;   assertEquals  ( "Last comamnd active." , 1 ,  asl . size  ( ) ) ;   EasyMock . verify  ( mockConnection ) ; }    @ Test public void testCancelSend  ( )  {    System . out . println  ( "cancelSend" ) ;  String  tenChar = "123456789" ;  for (   int  i = 0 ;  i < 20 ;  i ++ )  {   instance . queueCommand  (  new GcodeCommand  ( tenChar ) ) ; }   instance . streamCommands  ( ) ;   instance . cancelSend  ( ) ;  for (   int  i = 0 ;  i < 10 ;  i ++ )  {   instance . handleResponseMessage  ( "ok" ) ; }   assertEquals  ( false ,  instance . areActiveCommands  ( ) ) ; }    @ Test public void testResponseMessage  ( )  throws Exception  {    System . out . println  ( "responseMessage" ) ;  String  first = "not-handled" ;   mockScl . rawResponseListener  ( first ) ;    EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) . once  ( ) ;   mockScl . rawResponseListener  ( "ok" ) ;    EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) . once  ( ) ;   EasyMock . replay  ( mockScl ) ;   asl . add  (  new GcodeCommand  ( "command" ) ) ;   instance . handleResponseMessage  ( first ) ;   assertEquals  ( 1 ,  asl . size  ( ) ) ;   instance . handleResponseMessage  ( "ok" ) ;   assertEquals  ( 0 ,  asl . size  ( ) ) ; }    @ Test public void testOpenCommPort  ( )  throws Exception  {    System . out . println  ( "openCommPort" ) ;  String  name = "" ;   int  baud = 0 ;  boolean  expResult = true ;   mockConnection . addListener  (  EasyMock .  < AbstractCommunicator > anyObject  ( ) ) ;    EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) . once  ( ) ;     EasyMock . expect  (  mockConnection . openPort  ( ) ) . andReturn  ( true ) . once  ( ) ;   EasyMock . replay  ( mockConnection ) ;   instance . connect  (  ConnectionDriver . JSSC , name , baud ) ;   EasyMock . verify  ( mockConnection ) ; }    @ Test public void testCloseCommPort  ( )  throws Exception  {    System . out . println  ( "closeCommPort" ) ;  boolean  expResult = true ;   mockConnection . closePort  ( ) ;    EasyMock . expect  (  EasyMock . expectLastCall  ( ) ) . once  ( ) ;   EasyMock . replay  ( mockConnection ) ;   instance . disconnect  ( ) ;   EasyMock . verify  ( mockConnection ) ; }    @ Test public void testSendByteImmediately  ( )  throws Exception  {    System . out . println  ( "sendByteImmediately" ) ;   byte  b = 10 ;  String  tenChar = "123456789" ;  for (   int  i = 0 ;  i < 10 ;  i ++ )  {   mockConnection . sendStringToComm  (  tenChar + "\n" ) ; }   mockConnection . sendByteImmediately  ( b ) ;   EasyMock . replay  ( mockConnection ) ;  for (   int  i = 0 ;  i < 20 ;  i ++ )  {   instance . queueCommand  (  new GcodeCommand  ( tenChar ) ) ; }   instance . streamCommands  ( ) ;   instance . sendByteImmediately  ( b ) ;   EasyMock . verify  ( mockConnection ) ; }    @ Test public void testSendingCommand  ( )  {    System . out . println  ( "sendingCommand" ) ;    System . out . println  ( "-N/A for abstract class-" ) ; }    @ Test public void testProcessedCommand  ( )  {    System . out . println  ( "processedCommand" ) ;    System . out . println  ( "-N/A for abstract class-" ) ; }    @ Test public void testStreamCommandsOrderStringCommandsFirst  ( )  throws Exception  {  Connection  connection =  mock  (  Connection . class ) ;   instance . setConnection  ( connection ) ;   ArgumentCaptor  < String >  commandCaptor =  ArgumentCaptor . forClass  (  String . class ) ;     doNothing  ( ) . when  ( connection ) . sendStringToComm  (  commandCaptor . capture  ( ) ) ;  File  gcodeFile =  new File  ( tempDir , "gcodeFile" ) ;  GcodeStreamWriter  gcodeStreamWriter =  new GcodeStreamWriter  ( gcodeFile ) ;   gcodeStreamWriter . addLine  ( "G0" , "G0" , null , 0 ) ;   gcodeStreamWriter . close  ( ) ;   instance . queueStreamForComm  (  new GcodeStreamReader  ( gcodeFile ) ) ;   instance . queueCommand  (  new GcodeCommand  ( "G1" ) ) ;   instance . streamCommands  ( ) ;   assertEquals  ( 2 ,   commandCaptor . getAllValues  ( ) . size  ( ) ) ;   assertEquals  ( "The first command processed should be the string command" , "G1\n" ,   commandCaptor . getAllValues  ( ) . get  ( 0 ) ) ;   assertEquals  ( "The second command should be from the stream" , "G0\n" ,   commandCaptor . getAllValues  ( ) . get  ( 1 ) ) ; }    @ Test public void softResetShouldClearBuffersAndResumeOperation  ( )  {  Connection  connection =  mock  (  Connection . class ) ;   instance . setConnection  ( connection ) ;   asl . add  (  new GcodeCommand  ( "G0" ) ) ;   cb . add  (  new GcodeCommand  ( "G0" ) ) ;   instance . pauseSend  ( ) ;   assertTrue  (  instance . isPaused  ( ) ) ;   assertEquals  ( 1 ,  instance . numActiveCommands  ( ) ) ;   assertEquals  ( 1 ,  instance . numBufferedCommands  ( ) ) ;   instance . cancelSend  ( ) ;   assertFalse  ( "The communicator should resume operation after a reset" ,  instance . isPaused  ( ) ) ;   assertEquals  ( "There should be no active commands" , 0 ,  instance . numActiveCommands  ( ) ) ;   assertEquals  ( "There should be no buffered manual commands" , 0 ,  instance . numBufferedCommands  ( ) ) ; }    @ Test public void responseMessageOnErrorShouldPauseTheCommunicator  ( )  {  Connection  connection =  mock  (  Connection . class ) ;   instance . setConnection  ( connection ) ;   asl . add  (  new GcodeCommand  ( "G0" ) ) ;   asl . add  (  new GcodeCommand  ( "G0" ) ) ;   instance . streamCommands  ( ) ;   instance . handleResponseMessage  ( "error" ) ;   assertTrue  (  instance . isPaused  ( ) ) ; }    @ Test public void responseMessageOnErrorShouldDispatchPauseEvent  ( )  {  Connection  connection =  mock  (  Connection . class ) ;   instance . setConnection  ( connection ) ;  CommunicatorListener  communicatorListener =  mock  (  CommunicatorListener . class ) ;   instance . addListener  ( communicatorListener ) ;   asl . add  (  new GcodeCommand  ( "G0" ) ) ;   asl . add  (  new GcodeCommand  ( "G0" ) ) ;   instance . streamCommands  ( ) ;   instance . handleResponseMessage  ( "error" ) ;   assertTrue  (  instance . isPaused  ( ) ) ;    verify  ( communicatorListener ,  times  ( 1 ) ) . communicatorPausedOnError  ( ) ; }    @ Test public void responseMessageOnErrorOnManualCommandShouldPauseTheCommunicator  ( )  {  Connection  connection =  mock  (  Connection . class ) ;   instance . setConnection  ( connection ) ;   cb . add  (  new GcodeCommand  ( "G0" ) ) ;   cb . add  (  new GcodeCommand  ( "G0" ) ) ;   instance . streamCommands  ( ) ;   instance . handleResponseMessage  ( "error" ) ;   assertTrue  (  instance . isPaused  ( ) ) ; }    @ Test public void responseMessageOnErrorOnLastManualCommandShouldNotPauseTheCommunicator  ( )  {  Connection  connection =  mock  (  Connection . class ) ;   instance . setConnection  ( connection ) ;   cb . add  (  new GcodeCommand  ( "G0" ) ) ;   instance . streamCommands  ( ) ;   instance . handleResponseMessage  ( "error" ) ;   assertFalse  (  instance . isPaused  ( ) ) ; }    @ Test public void responseMessageOnErrorOnLastCommandShouldNotPauseTheCommunicator  ( )  {  Connection  connection =  mock  (  Connection . class ) ;   instance . setConnection  ( connection ) ;   asl . add  (  new GcodeCommand  ( "G0" ) ) ;   instance . streamCommands  ( ) ;   instance . handleResponseMessage  ( "error" ) ;   assertFalse  (  instance . isPaused  ( ) ) ; }    @ Test public void responseMessageOnErrorOnCommandStreamShouldPauseTheCommunicator  ( )  throws IOException ,  GcodeStreamReader . NotGcodeStreamFile  {  Connection  connection =  mock  (  Connection . class ) ;   instance . setConnection  ( connection ) ;  File  gcodeFile =  new File  ( tempDir , "gcodeFile" ) ;  GcodeStreamWriter  gcodeStreamWriter =  new GcodeStreamWriter  ( gcodeFile ) ;   gcodeStreamWriter . addLine  ( "G0" , "G0" , null , 0 ) ;   gcodeStreamWriter . addLine  ( "G0" , "G0" , null , 0 ) ;   gcodeStreamWriter . close  ( ) ;   instance . queueStreamForComm  (  new GcodeStreamReader  ( gcodeFile ) ) ;   instance . streamCommands  ( ) ;   instance . handleResponseMessage  ( "error" ) ;   assertTrue  (  instance . isPaused  ( ) ) ; }    @ Test public void responseMessageOnErrorOnLastCommandStreamShouldNotPauseTheCommunicator  ( )  throws IOException ,  GcodeStreamReader . NotGcodeStreamFile  {  Connection  connection =  mock  (  Connection . class ) ;   instance . setConnection  ( connection ) ;  File  gcodeFile =  new File  ( tempDir , "gcodeFile" ) ;  GcodeStreamWriter  gcodeStreamWriter =  new GcodeStreamWriter  ( gcodeFile ) ;   gcodeStreamWriter . addLine  ( "G0" , "G0" , null , 0 ) ;   gcodeStreamWriter . close  ( ) ;   instance . queueStreamForComm  (  new GcodeStreamReader  ( gcodeFile ) ) ;   instance . streamCommands  ( ) ;   instance . handleResponseMessage  ( "error" ) ;   assertFalse  (  instance . isPaused  ( ) ) ; }   public class BufferedCommunicatorImpl  extends BufferedCommunicator  {  BufferedCommunicatorImpl  (   LinkedBlockingDeque  < GcodeCommand > cb ,   LinkedBlockingDeque  < GcodeCommand > asl )  {  super  ( cb , asl ) ; }   public  int getBufferSize  ( )  {  return 101 ; }   public void sendingCommand  (  String command )  { }   public boolean processedCommand  (  String response )  {  return  (   response != null &&  (   "ok" . equals  ( response ) ||  response . startsWith  ( "error" ) ) ) ; }   public boolean processedCommandIsError  (  String response )  {  return  (   response != null &&  response . startsWith  ( "error" ) ) ; } } }