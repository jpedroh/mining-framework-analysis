  package controllers ;   import   java . io . IOException ;  import   java . io . InputStream ;  import   java . time . Instant ;  import   java . time . ZoneId ;  import    java . time . format . DateTimeFormatter ;  import    java . time . temporal . ChronoUnit ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Collections ;  import   java . util . HashMap ;  import   java . util . LinkedList ;  import   java . util . List ;  import   java . util . Map ;  import    java . util . Map . Entry ;  import   java . util . Optional ;  import    java . util . regex . Pattern ;  import    java . util . regex . PatternSyntaxException ;  import   javax . activation . DataSource ;  import    javax . mail . internet . MimeMessage ;  import     org . apache . commons . io . IOUtils ;  import      org . apache . commons . io . output . ByteArrayOutputStream ;  import     org . apache . commons . lang . StringUtils ;  import     org . apache . commons . lang3 . RandomStringUtils ;  import      org . apache . commons . mail . util . MimeMessageParser ;  import      org . apache . commons . mail . util . MimeMessageUtils ;  import      org . hibernate . validator . internal . constraintvalidators . EmailValidator ;  import    org . joda . time . DateTime ;  import   org . slf4j . Logger ;  import     com . fasterxml . jackson . databind . ObjectMapper ;  import    com . google . inject . Inject ;  import    com . google . inject . Singleton ;  import  conf . XCMailrConf ;  import  etc . HelperUtils ;  import  etc . MailboxEntry ;  import  etc . TypeRef ;  import  filters . JsonSecureFilter ;  import  filters . SecureFilter ;  import  models . MBox ;  import  models . Mail ;  import  models . User ;  import  ninja . Context ;  import  ninja . FilterWith ;  import  ninja . Ninja ;  import  ninja . Result ;  import  ninja . Results ;  import   ninja . i18n . Messages ;  import   ninja . params . Param ;  import   ninja . params . PathParam ;  import   ninja . validation . JSR303Validation ;  import   ninja . validation . Validation ;  import   io . ebean . DB ;    @ Singleton public class BoxHandler  {   private static final DateTimeFormatter  DATE_FORMAT =  DateTimeFormatter . ofPattern  ( "EEE MMM dd HH:mm:ss zzz yyyy" ) ;    @ Inject XCMailrConf  xcmConfiguration ;    @ Inject Messages  messages ;    @ Inject Logger  log ;    @ Inject ObjectMapper  objectMapper ;    @ Inject CachingSessionHandler  cachingSessionHandler ;    @ Inject Ninja  ninja ;    @ FilterWith  (  SecureFilter . class ) public Result deleteBoxDialog  ( )  {  return  Results . html  ( ) ; }    @ FilterWith  (  SecureFilter . class ) public Result editBoxDialog  ( )  {   long  nowPlusOneHour =    DateTime . now  ( ) . plusHours  ( 1 ) . getMillis  ( ) ;  return    Results . html  ( ) . render  ( "timeStamp" ,  HelperUtils . parseStringTs  ( nowPlusOneHour ) ) . render  ( "tsMillis" , nowPlusOneHour ) ; }    @ FilterWith  (  SecureFilter . class ) public Result newDateDialog  ( )  {   long  tsNew =    DateTime . now  ( ) . plusHours  ( 1 ) . getMillis  ( ) ;  return    Results . html  ( ) . render  ( "timeStampNew" ,  HelperUtils . parseStringTs  ( tsNew ) ) . render  ( "tsMillis" , tsNew ) ; }    @ FilterWith  (  SecureFilter . class ) public Result showAngularBoxOverview  (  Context context )  {  Result  result =  Results . html  ( ) ;  return   result . render  ( "ts_now" ,   DateTime . now  ( ) . getMillis  ( ) ) . render  ( "mboxes" , true ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result addBoxJsonData  (  Context context )  {  MBox  mailboxData =  new MBox  ( ) ;  String  randomName =   RandomStringUtils . randomAlphanumeric  ( 7 ) . toLowerCase  ( ) ;   mailboxData . setAddress  ( randomName ) ;   String  [ ]  domains =  xcmConfiguration . DOMAIN_LIST ;  if  (   domains . length > 0 )  {  while  (  MBox . mailExists  ( randomName ,  domains [ 0 ] ) )  {   randomName =   RandomStringUtils . randomAlphanumeric  ( 7 ) . toLowerCase  ( ) ; } }   mailboxData . setForwardEmails  ( true ) ;   long  nowPlusOneHour =    DateTime . now  ( ) . plusHours  ( 1 ) . getMillis  ( ) ;   mailboxData . setTs_Active  ( nowPlusOneHour ) ;   mailboxData . setDomain  (  domains [ 0 ] ) ;  return   Results . json  ( ) . render  ( "currentBox" , mailboxData ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result addBoxJsonProcess  (  Context context ,    @ JSR303Validation MBox addBoxDialogData ,  Validation validation )  {  String  errorMessage ;  Result  result =  Results . json  ( ) ;   result . render  ( "domain" ,  xcmConfiguration . DOMAIN_LIST ) ;  if  (   validation . hasViolations  ( ) ||  addBoxDialogData == null )  {   errorMessage =   messages . get  ( "flash_FormError" , context ,  Optional . of  ( result ) ) . get  ( ) ;   result . render  ( "currentBox" , addBoxDialogData ) ;  return   result . render  ( "success" , false ) . render  ( "statusmsg" , errorMessage ) ; }  String  completeAddress =  addBoxDialogData . getFullAddress  ( ) ;  if  (     addBoxDialogData . getAddress  ( ) . length  ( ) > 64 ||   completeAddress . length  ( ) > 254 )  {   errorMessage =   messages . get  ( "createEmail_Flash_MailTooLong" , context ,  Optional . of  ( result ) ) . get  ( ) ;   result . render  ( "currentBox" , addBoxDialogData ) ;  return   result . render  ( "success" , false ) . render  ( "statusmsg" , errorMessage ) ; }  if  (  MBox . mailExists  (  addBoxDialogData . getAddress  ( ) ,  addBoxDialogData . getDomain  ( ) ) )  {   errorMessage =   messages . get  ( "flash_MailExists" , context ,  Optional . of  ( result ) ) . get  ( ) ;   result . render  ( "currentBox" , addBoxDialogData ) ;  return   result . render  ( "success" , false ) . render  ( "statusmsg" , errorMessage ) ; }   String  [ ]  domains =  xcmConfiguration . DOMAIN_LIST ;  if  (  !   Arrays . asList  ( domains ) . contains  (  addBoxDialogData . getDomain  ( ) ) )  {   errorMessage =   messages . get  ( "editEmailDialog_JSValidation_MailInvalid" , context ,  Optional . of  ( result ) ) . get  ( ) ;   result . render  ( "currentBox" , addBoxDialogData ) ;  return   result . render  ( "success" , false ) . render  ( "statusmsg" , errorMessage ) ; }  Long  ts =  addBoxDialogData . getTs_Active  ( ) ;  if  (  ts ==  - 1L )  {   errorMessage =   messages . get  ( "flash_FormError" , context ,  Optional . of  ( result ) ) . get  ( ) ;   result . render  ( "currentBox" , addBoxDialogData ) ;  return   result . render  ( "success" , false ) . render  ( "statusmsg" , errorMessage ) ; }  if  (   (  ts != 0 ) &&  (  ts <   DateTime . now  ( ) . getMillis  ( ) ) )  {   errorMessage =   messages . get  ( "createEmail_Past_Timestamp" , context ,  Optional . of  ( result ) ) . get  ( ) ;   result . render  ( "currentBox" , addBoxDialogData ) ;  return   result . render  ( "success" , false ) . render  ( "statusmsg" , errorMessage ) ; }  User  user =  context . getAttribute  ( "user" ,  User . class ) ;   addBoxDialogData . setUsr  ( user ) ;   addBoxDialogData . resetIdAndCounterFields  ( ) ;   addBoxDialogData . save  ( ) ;   errorMessage =   messages . get  ( "flash_DataChangeSuccess" , context ,  Optional . of  ( result ) ) . get  ( ) ;   result . render  ( "currentBox" , addBoxDialogData ) ;  return   result . render  ( "success" , true ) . render  ( "statusmsg" , errorMessage ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result bulkDeleteBoxes  (  Object parameter ,  Context context )  {  if  (  !  (  parameter instanceof  Map  <  ? ,  ? > ) )  {  return  Results . badRequest  ( ) ; }   Map  < String , Boolean >  boxIdMap =  castToMapStringBoolean  ( parameter ) ;  Result  result =  Results . json  ( ) ;  if  (   boxIdMap == null ||  boxIdMap . isEmpty  ( ) )  return  result . render  ( "success" , false ) ;   List  < Long >  boxIds =  getIdListForMap  ( boxIdMap ) ;  User  user =  context . getAttribute  ( "user" ,  User . class ) ;   int  nu =  MBox . removeListOfBoxes  (  user . getId  ( ) , boxIds ) ;  return   result . render  ( "count" , nu ) . render  ( "success" ,  nu >= 0 ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result bulkDisableBoxes  (  Object parameter ,  Context context )  {  if  (  !  (  parameter instanceof  Map  <  ? ,  ? > ) )  {  return  Results . badRequest  ( ) ; }   Map  < String , Boolean >  boxIdMap =  castToMapStringBoolean  ( parameter ) ;  Result  result =  Results . json  ( ) ;  if  (   boxIdMap == null ||  boxIdMap . isEmpty  ( ) )  return  result . render  ( "success" , false ) ;   List  < Long >  boxIds =  getIdListForMap  ( boxIdMap ) ;  User  user =  context . getAttribute  ( "user" ,  User . class ) ;   int  nu =  MBox . disableListOfBoxes  (  user . getId  ( ) , boxIds ) ;  return   result . render  ( "count" , nu ) . render  ( "success" ,  nu >= 0 ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result bulkEnablePossibleBoxes  (  Object parameter ,  Context context )  {  if  (  !  (  parameter instanceof  Map  <  ? ,  ? > ) )  {  return  Results . badRequest  ( ) ; }   Map  < String , Boolean >  boxIdMap =  castToMapStringBoolean  ( parameter ) ;  Result  result =  Results . json  ( ) ;  if  (   boxIdMap == null ||  boxIdMap . isEmpty  ( ) )  return  result . render  ( "success" , false ) ;   List  < Long >  boxIds =  getIdListForMap  ( boxIdMap ) ;  User  user =  context . getAttribute  ( "user" ,  User . class ) ;   int  nu =  MBox . enableListOfBoxesIfPossible  (  user . getId  ( ) , boxIds ) ;  return   result . render  ( "count" , nu ) . render  ( "success" ,  nu >= 0 ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result bulkNewDate  (  Object parameter ,  Context context )  {  if  (  !  (  parameter instanceof  Map  <  ? ,  ? > ) )  {  return  Results . badRequest  ( ) ; }    @ SuppressWarnings  ( "unchecked" )  Map  < String , Object >  input =  (  Map  < String , Object > ) parameter ;  Result  result =  Results . json  ( ) ;  User  user =  context . getAttribute  ( "user" ,  User . class ) ;  if  (   input == null ||  input . isEmpty  ( ) )  {  return  result . render  ( "success" , false ) ; }  String  newDate =  ( String )  input . get  ( "newDateTime" ) ;   Map  < String , Boolean >  boxIds =  objectMapper . convertValue  (  input . get  ( "boxes" ) ,  TypeRef . MAP_STRING_BOOLEAN ) ;   long  dateTime =  HelperUtils . parseTimeString  ( newDate ) ;  if  (   dateTime ==  - 1 ||  boxIds == null )  return  result . render  ( "success" , false ) ;   List  < Long >  boxIdList =  getIdListForMap  ( boxIds ) ;   int  numberOfItems =  MBox . setNewDateForListOfBoxes  (  user . getId  ( ) , boxIdList , dateTime ) ;  return   result . render  ( "count" , numberOfItems ) . render  ( "success" , true ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result bulkResetBoxes  (  Object parameter ,  Context context )  {  if  (  !  (  parameter instanceof  Map  <  ? ,  ? > ) )  {  return  Results . badRequest  ( ) ; }   Map  < String , Boolean >  boxIdMap =  castToMapStringBoolean  ( parameter ) ;  Result  result =  Results . json  ( ) ;  if  (   boxIdMap == null ||  boxIdMap . isEmpty  ( ) )  return  result . render  ( "success" , false ) ;   List  < Long >  boxIds =  getIdListForMap  ( boxIdMap ) ;  User  user =  context . getAttribute  ( "user" ,  User . class ) ;   int  nu =  MBox . resetListOfBoxes  (  user . getId  ( ) , boxIds ) ;  return   result . render  ( "count" , nu ) . render  ( "success" ,  nu >= 0 ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result deleteBoxByJson  (    @ PathParam  ( "id" ) Long boxId ,  Context context )  {  Result  result =  Results . json  ( ) ;  User  user =  context . getAttribute  ( "user" ,  User . class ) ;  if  (  MBox . boxToUser  ( boxId ,  user . getId  ( ) ) )  {   MBox . delete  ( boxId ) ;  return  result . render  ( "success" , true ) ; } else  {  String  errorMessage =   messages . get  ( "flash_FormError" , context ,  Optional . of  ( result ) ) . get  ( ) ;  return   result . render  ( "success" , false ) . render  ( "statusMsg" , errorMessage ) ; } }    @ FilterWith  (  JsonSecureFilter . class ) public Result editBoxJson  (  Context context ,    @ PathParam  ( "id" ) Long boxId ,    @ JSR303Validation MBox mailboxFormData ,  Validation validation )  {  String  errorMessage ;  Result  result =  Results . json  ( ) ;   mailboxFormData . setId  ( boxId ) ;   result . render  ( "domains" ,  xcmConfiguration . DOMAIN_LIST ) ;  if  (   validation . hasViolations  ( ) ||  mailboxFormData == null )  {   errorMessage =   messages . get  ( "flash_FormError" , context ,  Optional . of  ( result ) ) . get  ( ) ;    result . render  ( "success" , false ) . render  ( "currentBox" , mailboxFormData ) ;  return  result . render  ( "error" , errorMessage ) ; }  String  completeAddress =  mailboxFormData . getFullAddress  ( ) ;  if  (     mailboxFormData . getAddress  ( ) . length  ( ) > 64 ||   completeAddress . length  ( ) >= 255 )  {   errorMessage =   messages . get  ( "editEmail_Flash_MailTooLong" , context ,  Optional . of  ( result ) ) . get  ( ) ;    result . render  ( "success" , false ) . render  ( "currentBox" , mailboxFormData ) ;  return  result . render  ( "error" , errorMessage ) ; }  MBox  mailBox =  MBox . getById  ( boxId ) ;  User  usr =  context . getAttribute  ( "user" ,  User . class ) ;  if  (   mailBox == null ||  !  mailBox . belongsTo  (  usr . getId  ( ) ) )  {   errorMessage =   messages . get  ( "flash_FormError" , context ,  Optional . of  ( result ) ) . get  ( ) ;   result . render  ( "success" , false ) ;  return  result . render  ( "statusmsg" , errorMessage ) ; }  boolean  changes = false ;  String  newLocalPartName =  mailboxFormData . getAddress  ( ) ;  String  newDomainPartName =  mailboxFormData . getDomain  ( ) ;  if  (   !   mailBox . getAddress  ( ) . equalsIgnoreCase  ( newLocalPartName ) ||  !   mailBox . getDomain  ( ) . equalsIgnoreCase  ( newDomainPartName ) )  {  if  (  MBox . mailExists  ( newLocalPartName , newDomainPartName ) )  {   errorMessage =   messages . get  ( "flash_MailExists" , context ,  Optional . of  ( result ) ) . get  ( ) ;    result . render  ( "success" , false ) . render  ( "currentBox" , mailboxFormData ) ;  return  result . render  ( "statusmsg" , errorMessage ) ; }   String  [ ]  domains =  xcmConfiguration . DOMAIN_LIST ;  if  (  !   Arrays . asList  ( domains ) . contains  ( newDomainPartName ) )  {   errorMessage = "" ;    result . render  ( "success" , false ) . render  ( "currentBox" , mailboxFormData ) ;  return  result . render  ( "error" , errorMessage ) ; }   mailBox . setAddress  ( newLocalPartName ) ;   mailBox . setDomain  ( newDomainPartName ) ;   changes = true ; }  Long  ts =  mailboxFormData . getTs_Active  ( ) ;  if  (  ts ==  - 1 )  {   errorMessage =   messages . get  ( "flash_FormError" , context ,  Optional . of  ( result ) ) . get  ( ) ;    result . render  ( "success" , false ) . render  ( "currentBox" , mailboxFormData ) ;  return  result . render  ( "statusmsg" , errorMessage ) ; }  if  (   (  ts != 0 ) &&  (  ts <   DateTime . now  ( ) . getMillis  ( ) ) )  {   errorMessage =   messages . get  ( "editEmail_Past_Timestamp" , context ,  Optional . of  ( result ) ) . get  ( ) ;    result . render  ( "success" , false ) . render  ( "currentBox" , mailboxFormData ) ;  return  result . render  ( "statusmsg" , errorMessage ) ; }  if  (   mailBox . getTs_Active  ( ) != ts )  {   mailBox . setTs_Active  ( ts ) ;   changes = true ; }  if  (   mailBox . isForwardEmails  ( ) !=  mailboxFormData . isForwardEmails  ( ) )  {   mailBox . setForwardEmails  (  mailboxFormData . isForwardEmails  ( ) ) ;   changes = true ; }  if  ( changes )  {   mailBox . setExpired  ( false ) ;   mailBox . update  ( ) ;   mailboxFormData =  MBox . getById  (  mailBox . getId  ( ) ) ;   errorMessage =   messages . get  ( "flash_DataChangeSuccess" , context ,  Optional . of  ( result ) ) . get  ( ) ;    result . render  ( "success" , true ) . render  ( "currentBox" , mailboxFormData ) ;  return  result . render  ( "statusmsg" , errorMessage ) ; }   mailboxFormData =  MBox . getById  (  mailBox . getId  ( ) ) ;  return    result . render  ( "success" , true ) . render  ( "currentBox" , mailboxFormData ) . render  ( "statusmsg" , "No changes made" ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result expireBoxJson  (    @ PathParam  ( "id" ) Long boxId ,  Context context )  {  MBox  mailBox =  MBox . getById  ( boxId ) ;  User  user =  context . getAttribute  ( "user" ,  User . class ) ;  Result  result =  Results . json  ( ) ;  String  errorMessage = "" ;  if  (  !  mailBox . belongsTo  (  user . getId  ( ) ) )  {   errorMessage =   messages . get  ( "flash_BoxToUser" , context ,  Optional . of  ( result ) ) . get  ( ) ;  return   result . render  ( "success" , false ) . render  ( "statusmsg" , errorMessage ) ; }  if  (   (   mailBox . getTs_Active  ( ) != 0 ) &&  (   mailBox . getTs_Active  ( ) <   DateTime . now  ( ) . getMillis  ( ) ) )  {   errorMessage =   messages . get  ( "expireEmail_Flash_Expired" , context ,  Optional . of  ( result ) ) . get  ( ) ;  return    Results . json  ( ) . render  ( "success" , false ) . render  ( "statusmsg" , errorMessage ) ; } else  {  if  (  mailBox . isExpired  ( ) )  {   mailBox . enable  ( ) ; } else  {   mailBox . disable  ( ) ; }  return  result . render  ( "success" , true ) ; } }    @ FilterWith  (  JsonSecureFilter . class ) public Result jsonBox  (  Context context )  {  User  user =  context . getAttribute  ( "user" ,  User . class ) ;  Result  result =  Results . json  ( ) ;  String  searchString =  context . getParameter  ( "s" , "" ) ;   List  < MBox >  boxList =  MBox . findBoxLike  ( searchString ,  user . getId  ( ) ) ;  return   result . json  ( ) . render  ( boxList ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result jsonDomainList  (  Context context )  {  return   Results . json  ( ) . render  (  xcmConfiguration . DOMAIN_LIST ) ; }    @ FilterWith  (  JsonSecureFilter . class ) public Result resetBoxCounterProcessXhr  (    @ PathParam  ( "id" ) Long boxId ,  Context context )  {  Result  result =  Results . json  ( ) ;  MBox  mailBox =  MBox . getById  ( boxId ) ;  User  user =  context . getAttribute  ( "user" ,  User . class ) ;  if  (  !  mailBox . belongsTo  (  user . getId  ( ) ) )  return  result . render  ( "success" , false ) ;   mailBox . resetForwards  ( ) ;   mailBox . resetSuppressions  ( ) ;   mailBox . update  ( ) ;  return  result . render  ( "success" , true ) ; }    @ FilterWith  (  SecureFilter . class ) public Result showMailsAsTextList  (  Context context )  {  User  user =  context . getAttribute  ( "user" ,  User . class ) ;  return   Results . text  ( ) . render  (  MBox . getMailsForTxt  (  user . getId  ( ) ) ) ; }    @ FilterWith  (  SecureFilter . class ) public Result showActiveMailsAsTextList  (  Context context )  {  User  user =  context . getAttribute  ( "user" ,  User . class ) ;  return   Results . text  ( ) . render  (  MBox . getActiveMailsForTxt  (  user . getId  ( ) ) ) ; }    @ FilterWith  (  SecureFilter . class ) public Result showSelectedMailsAsTextList  (    @ Param  ( "jsonObj" )  Optional  < String > inputList ,  Context context )  {  Result  result =  Results . text  ( ) ;  String  errorMessage =   messages . get  ( "mailbox_Flash_NoBoxSelected" , context ,  Optional . of  ( result ) ) . get  ( ) ;  if  (  inputList . isEmpty  ( ) )  return  result . render  ( errorMessage ) ;   Map  < String , Boolean >  boxIdMap =  getMapFoMaprStrings  (  inputList . get  ( ) ) ;  if  (   boxIdMap == null ||  boxIdMap . isEmpty  ( ) )  return  result . render  ( errorMessage ) ;  User  user =  context . getAttribute  ( "user" ,  User . class ) ;   List  < Long >  boxes =  getIdListForMap  ( boxIdMap ) ;  return  result . render  (  MBox . getSelectedMailsForTxt  (  user . getId  ( ) , boxes ) ) ; }   private  Map  < String , Boolean > getMapFoMaprStrings  (  String input )  {   Map  < String , Boolean >  boxIdMap = null ;  try  {   boxIdMap =  objectMapper . readValue  ( input ,  TypeRef . MAP_STRING_BOOLEAN ) ; }  catch (   IOException e )  {   log . error  (  e . getLocalizedMessage  ( ) ) ;   log . debug  (  "trace:" + e ) ; }  if  (   boxIdMap == null ||  boxIdMap . isEmpty  ( ) )  return null ;  return boxIdMap ; }   private  List  < Long > getIdListForMap  (   Map  < String , Boolean > boxIdMap )  {   List  < Long >  boxIds =  new  ArrayList  < Long >  ( ) ;  if  (   boxIdMap == null ||  boxIdMap . isEmpty  ( ) )  return boxIds ;  for (  Entry  < String , Boolean > entry :  boxIdMap . entrySet  ( ) )  {   log . debug  (    "key:" +  entry . getKey  ( ) + " value:" +  entry . getValue  ( ) ) ;  if  (  entry . getValue  ( ) )  {   long  boxId =  Long . valueOf  (  entry . getKey  ( ) ) ;   boxIds . add  ( boxId ) ; } }  return boxIds ; }   public Result createTemporaryMailAddress  (    @ PathParam  ( "token" ) String apiToken ,    @ PathParam  ( "mailAddress" ) String desiredMailAddress ,    @ PathParam  ( "validTime" ) String validTime ,  Context context )  {  if  (  !   new EmailValidator  ( ) . isValid  ( desiredMailAddress , null ) )  return  ninja . getBadRequestResult  ( context , null ) ;   final User  user =  User . findUserByToken  ( apiToken ) ;  if  (  user == null )  {   log . error  ( "Token invalid" ) ;  return  ninja . getUnauthorizedResult  ( context ) ; }   String  [ ]  mailAddressParts =  HelperUtils . splitMailAddress  ( desiredMailAddress ) ;  if  (  !  HelperUtils . checkEmailAddressValidness  ( mailAddressParts ,  xcmConfiguration . DOMAIN_LIST ) )  {   log . error  (  "Email address invalid: " + desiredMailAddress ) ;  return  ninja . getForbiddenResult  ( context ) ; }   int  parsedValidTimeMinutes ;  try  {   parsedValidTimeMinutes =  Integer . valueOf  ( validTime ) ;  if  (   parsedValidTimeMinutes < 1 ||  parsedValidTimeMinutes >  xcmConfiguration . TEMPORARY_MAIL_MAX_VALID_TIME )  {  return  ninja . getBadRequestResult  ( context , null ) ; } }  catch (   NumberFormatException e )  {   log . error  (  "Email valid time invalid: " + validTime ) ;  return  ninja . getBadRequestResult  ( context , null ) ; }   final MBox  mailbox =  MBox . getByName  (  mailAddressParts [ 0 ] ,  mailAddressParts [ 1 ] ) ;   final Instant  validUntil =   Instant . now  ( ) . plus  ( parsedValidTimeMinutes ,  ChronoUnit . MINUTES ) ;   final  long  validUntil_ts =  validUntil . toEpochMilli  ( ) ;  if  (  mailbox != null )  {  if  (    mailbox . getUsr  ( ) . getId  ( ) ==  user . getId  ( ) )  {   log . info  (  "Reactivate mailbox: " + desiredMailAddress ) ;   mailbox . enable  ( ) ;   mailbox . setTs_Active  ( validUntil_ts ) ;   mailbox . save  ( ) ; } else  {   log . info  (  "Email address is owned by user: " +   mailbox . getUsr  ( ) . getMail  ( ) ) ;  return  ninja . getForbiddenResult  ( context ) ; } } else  {   log . info  (  "Create mailbox " + desiredMailAddress ) ;    new MBox  (  mailAddressParts [ 0 ] ,  mailAddressParts [ 1 ] , validUntil_ts , false , user ) . save  ( ) ; }   final  Map  < String , Object >  data =  new  HashMap  < >  ( ) ;   data . put  ( "emailAddress" , desiredMailAddress ) ;   data . put  ( "emailValidity" ,  Integer . toString  ( parsedValidTimeMinutes ) ) ;   data . put  ( "emailValidUntil" ,  Long . toString  ( validUntil_ts ) ) ;   data . put  ( "emailValidUntilDate" ,   validUntil . atZone  (  ZoneId . of  ( "UTC" ) ) . format  ( DATE_FORMAT ) ) ;   final String  formatParameter =   context . getParameter  ( "format" , "html" ) . toLowerCase  ( ) ;  if  (  "html" . equals  ( formatParameter ) )  {  return   Results . html  ( ) . render  ( data ) ; } else  if  (  "json" . equals  ( formatParameter ) )  {  return   Results . json  ( ) . render  ( data ) ; } else  {  return  ninja . getBadRequestResult  ( context , null ) ; } }   public Result queryMailbox  (    @ PathParam  ( "token" ) String apiToken ,    @ PathParam  ( "mailAddress" ) String mailAddress ,  Context context )  throws Exception  {   log . trace  ( "passed null check" ) ;  User  user =  User . findUserByToken  ( apiToken ) ;  if  (  user == null )  {   log . error  ( "Token invalid" ) ;  return  ninja . getUnauthorizedResult  ( context ) ; }  String  sessionKey =   context . getSession  ( ) . getId  ( ) ;   cachingSessionHandler . set  ( sessionKey ,  xcmConfiguration . COOKIE_EXPIRETIME , user ) ;   cachingSessionHandler . setSessionUser  ( user , sessionKey ,  xcmConfiguration . COOKIE_EXPIRETIME ) ;    context . getSession  ( ) . put  ( "username" ,  user . getMail  ( ) ) ;   final  String  [ ]  mailAddressParts =  HelperUtils . splitMailAddress  ( mailAddress ) ;   final MBox  mailbox =   HelperUtils . checkEmailAddressValidness  ( mailAddressParts ,  xcmConfiguration . DOMAIN_LIST ) ?  MBox . getByName  (  mailAddressParts [ 0 ] ,  mailAddressParts [ 1 ] ) : null ;  if  (  mailbox == null )  {   log . info  (  "Mailbox not found: " + mailAddress ) ;  return  ninja . getNotFoundResult  ( context ) ; }  if  (  !  mailbox . belongsTo  (  user . getId  ( ) ) )  {   log . error  ( "Mailbox belongs to another user" ) ;  return  ninja . getForbiddenResult  ( context ) ; }   List  < Mail >  emails =      DB . find  (  Mail . class ) . where  ( ) . eq  ( "mailbox_id" ,  mailbox . getId  ( ) ) . order  ( "receiveTime" ) . findList  ( ) ;  String  senderRegex =  context . getParameter  ( "from" ) ;  String  subjectRegex =  context . getParameter  ( "subject" ) ;  String  plainTextRegex =  context . getParameter  ( "textContent" ) ;  String  htmlTextRegex =  context . getParameter  ( "htmlContent" ) ;  String  headerRegex =  context . getParameter  ( "mailHeader" ) ;  boolean  lastMatch =   context . getParameter  ( "lastMatch" ) != null ;   final Pattern  senderPattern ;   final Pattern  subjectPattern ;   final Pattern  plainTextPattern ;   final Pattern  htmlTextPattern ;   final Pattern  headerPattern ;  try  {   senderPattern =   senderRegex != null ?  Pattern . compile  ( senderRegex ,   Pattern . MULTILINE |  Pattern . DOTALL ) : null ;   subjectPattern =   subjectRegex != null ?  Pattern . compile  ( subjectRegex ,   Pattern . MULTILINE |  Pattern . DOTALL ) : null ;   plainTextPattern =   plainTextRegex != null ?  Pattern . compile  ( plainTextRegex ,   Pattern . MULTILINE |  Pattern . DOTALL ) : null ;   htmlTextPattern =   htmlTextRegex != null ?  Pattern . compile  ( htmlTextRegex ,   Pattern . MULTILINE |  Pattern . DOTALL ) : null ;   headerPattern =   headerRegex != null ?  Pattern . compile  ( headerRegex ,   Pattern . MULTILINE |  Pattern . DOTALL ) : null ; }  catch (   PatternSyntaxException e )  {  return  ninja . getBadRequestResult  ( context , null ) ; }   final  List  < MailboxEntry >  entries =  new  LinkedList  < >  ( ) ;  for (   int  i = 0 ;  i <  emails . size  ( ) ;  i ++ )  {   final Mail  email =  emails . get  ( i ) ;   final MailboxEntry  mailboxEntry =  new MailboxEntry  ( mailAddress , email ) ;   final  MailboxEntry . Content  mailContent =  mailboxEntry . mailContent ;  if  (      (   senderPattern == null ||   senderPattern . matcher  (  mailboxEntry . sender ) . find  ( ) ) &&  (   subjectPattern == null ||   subjectPattern . matcher  (  mailboxEntry . subject ) . find  ( ) ) &&  (   plainTextPattern == null ||  (   mailContent != null &&   plainTextPattern . matcher  (  mailContent . text ) . find  ( ) ) ) &&  (   htmlTextPattern == null ||  (   mailContent != null &&   htmlTextPattern . matcher  (  mailContent . html ) . find  ( ) ) ) &&  (   headerPattern == null ||   headerPattern . matcher  (  mailboxEntry . mailHeader ) . find  ( ) ) )  {   entries . add  ( mailboxEntry ) ; } }   final String  formatParameter =   context . getParameter  ( "format" , "html" ) . toLowerCase  ( ) ;  if  (   (    entries . size  ( ) > 1 && lastMatch ) ||  "header" . equals  ( formatParameter ) )  {  if  (   entries . size  ( ) >= 1 )  {  MailboxEntry  lastEntry =  entries . get  (   entries . size  ( ) - 1 ) ;   entries . clear  ( ) ;   entries . add  ( lastEntry ) ; } }  if  (  "html" . equals  ( formatParameter ) )  {  return    Results . html  ( ) . render  ( "accountEmails" , entries ) . render  ( "mailaddress" , mailAddress ) ; } else  if  (  "json" . equals  ( formatParameter ) )  {  return   Results . json  ( ) . render  ( entries ) ; } else  if  (  "header" . equals  ( formatParameter ) )  {  if  (    entries . size  ( ) == 0 ||   entries . size  ( ) > 1 )  {  return  ninja . getBadRequestResult  ( context , null ) ; }  return   Results . text  ( ) . render  (   entries . get  ( 0 ) . mailHeader ) ; } else  {  return  ninja . getBadRequestResult  ( context , null ) ; } }    @ FilterWith  (  SecureFilter . class ) public Result queryAllMailboxes  (  Context context ,    @ Param  ( "offset" ) final  Optional  < Integer > offset ,    @ Param  ( "limit" ) final  Optional  < Integer > limit ,    @ Param  ( "sort" ) final  Optional  < String > sort ,    @ Param  ( "order" ) final  Optional  < String > order ,    @ Param  ( "search" ) final  Optional  < String > search )  throws Exception  {   final String  formatParameter =   context . getParameter  ( "format" , "html" ) . toLowerCase  ( ) ;  if  (  "html" . equals  ( formatParameter ) )  {  return  Results . html  ( ) ; } else  if  (  "json" . equals  ( formatParameter ) )  {   final  int  iOffset =  Math . max  ( 0 ,  offset . orElse  ( 0 ) ) ;   final  int  iLimit =   limit . map  (  i ->  Math . max  ( 1 , i ) ) . orElse  ( 0 ) ;   final String  _sort =  getOrderColumn  (  sort . orElse  ( null ) ) ;   final String  _order =  getOrderDirection  (  order . orElse  ( null ) ) ;   final String  _search =  search . orElse  ( null ) ;   final User  user =  context . getAttribute  ( "user" ,  User . class ) ;   final  List  <  ? >  mailboxIds =     Ebean . find  (  MBox . class ) . where  ( ) . eq  ( "usr_id" ,  user . getId  ( ) ) . findIds  ( ) ;   final  List  < Mail >  mails =      Ebean . find  (  Mail . class ) . where  ( ) . in  ( "mailbox_id" , mailboxIds ) . orderBy  (   _sort + " " + _order ) . findList  ( ) ;   final  List  < MailboxEntry >  matches =  new  ArrayList  < >  ( ) ;  for ( Mail mail : mails )  {   final MBox  mailbox =  mail . getMailbox  ( ) ;  if  (  mailbox != null )  {   final MailboxEntry  mailboxEntry =  new MailboxEntry  (  mailbox . getFullAddress  ( ) , mail ) ;  if  (   StringUtils . isBlank  ( _search ) ||  mailboxEntry . matchesSearchPhrase  ( _search ) )  {   matches . add  ( mailboxEntry ) ; } } }   final  int  nbMatches =  matches . size  ( ) ;   final  List  < MailboxEntry >  result ;  if  (   iOffset >= nbMatches ||  iLimit == 0 )  {   result =  Collections . emptyList  ( ) ; } else  {   result =  matches . subList  ( iOffset ,  Math . min  (  iOffset + iLimit , nbMatches ) ) ; }  return    Results . json  ( ) . render  ( "rows" , result ) . render  ( "total" ,  mails . size  ( ) ) ; } else  {  return  ninja . getBadRequestResult  ( context , null ) ; } }   private String getOrderColumn  (  String orderBy )  {  return   (   "subject" . equals  ( orderBy ) ||  "sender" . equals  ( orderBy ) ) ? orderBy : "receive_time" ; }   private String getOrderDirection  (  String orderBy )  {  return   (  "asc" . equals  ( orderBy ) ) ? orderBy : "desc" ; }    @ FilterWith  (  SecureFilter . class ) public Result downloadMailAttachment  (  Context context ,    @ PathParam  ( "downloadToken" ) String downloadToken ,    @ PathParam  ( "filename" ) String filename )  throws Exception  {   List  < Mail >  foundMails =     DB . find  (  Mail . class ) . where  ( ) . eq  ( "uuid" , downloadToken ) . findList  ( ) ;  if  (  foundMails . isEmpty  ( ) )  {  return  ninja . getNotFoundResult  ( context ) ; }  Mail  mail =  foundMails . get  ( 0 ) ;  MimeMessage  mimeMessage =  MimeMessageUtils . createMimeMessage  ( null ,  mail . getMessage  ( ) ) ;  MimeMessageParser  mimeMessageParser =  new MimeMessageParser  ( mimeMessage ) ;   mimeMessageParser . parse  ( ) ;  DataSource  foundAttachment = null ;  for ( DataSource attachment :  mimeMessageParser . getAttachmentList  ( ) )  {  if  (   attachment . getName  ( ) . equals  ( filename ) )  {   foundAttachment = attachment ;  break ; } }  if  (  foundAttachment == null )  {  return  ninja . getNotFoundResult  ( context ) ; }   final ByteArrayOutputStream  baos =  new ByteArrayOutputStream  ( 4096 ) ;  try  (   final InputStream is =  foundAttachment . getInputStream  ( ) )  {   IOUtils . copy  ( is , baos ) ; }  return    Results . ok  ( ) . contentType  (  foundAttachment . getContentType  ( ) ) . renderRaw  (  baos . toByteArray  ( ) ) ; }    @ SuppressWarnings  ( "unchecked" ) private static  Map  < String , Boolean > castToMapStringBoolean  (  Object o )  {  return  (  Map  < String , Boolean > ) o ; } 
<<<<<<<
=======
   @ FilterWith  (  SecureFilter . class ) public Result queryAllMailboxes  (  Context context ,    @ Param  ( "offset" ) final Integer offset ,    @ Param  ( "limit" ) final Integer limit ,    @ Param  ( "sort" ) String sort ,    @ Param  ( "order" ) String order ,    @ Param  ( "search" ) String search )  throws Exception  {   final String  formatParameter =   context . getParameter  ( "format" , "html" ) . toLowerCase  ( ) ;  if  (  "html" . equals  ( formatParameter ) )  {  return  Results . html  ( ) ; } else  if  (  "json" . equals  ( formatParameter ) )  {   final  int  iOffset =   offset == null ? 0 :  Math . max  ( 0 , offset ) ;   final  int  iLimit =   limit == null ? 0 :  Math . max  ( limit , 1 ) ;   sort =  getOrderColumn  ( sort ) ;   order =  getOrderDirection  ( order ) ;   final User  user =  context . getAttribute  ( "user" ,  User . class ) ;   final  List  <  ? >  mailboxIds =     DB . find  (  MBox . class ) . where  ( ) . eq  ( "usr_id" ,  user . getId  ( ) ) . findIds  ( ) ;   final  List  < Mail >  mails =      DB . find  (  Mail . class ) . where  ( ) . in  ( "mailbox_id" , mailboxIds ) . orderBy  (   sort + " " + order ) . findList  ( ) ;   final  List  < MailboxEntry >  matches =  new  ArrayList  < >  ( ) ;  for ( Mail mail : mails )  {   final MBox  mailbox =  mail . getMailbox  ( ) ;  if  (  mailbox != null )  {   final MailboxEntry  mailboxEntry =  new MailboxEntry  (  mailbox . getFullAddress  ( ) , mail ) ;  if  (   StringUtils . isBlank  ( search ) ||  mailboxEntry . matchesSearchPhrase  ( search ) )  {   matches . add  ( mailboxEntry ) ; } } }   final  int  nbMatches =  matches . size  ( ) ;   final  List  < MailboxEntry >  result ;  if  (   iOffset >= nbMatches ||  iLimit == 0 )  {   result =  Collections . emptyList  ( ) ; } else  {   result =  matches . subList  ( iOffset ,  Math . min  (  iOffset + iLimit , nbMatches ) ) ; }  return    Results . json  ( ) . render  ( "rows" , result ) . render  ( "total" ,  mails . size  ( ) ) ; } else  {  return  ninja . getBadRequestResult  ( context , null ) ; } }
>>>>>>>
 }