  package   bibliothek . gui . dock ;   import   java . awt . BasicStroke ;  import   java . awt . Color ;  import   java . awt . Component ;  import   java . awt . Dimension ;  import   java . awt . Graphics ;  import   java . awt . Graphics2D ;  import   java . awt . Insets ;  import   java . awt . Point ;  import   java . awt . Rectangle ;  import    java . awt . geom . Rectangle2D ;  import   java . io . IOException ;  import   java . util . Map ;  import   javax . swing . BoxLayout ;  import   javax . swing . JPanel ;  import   javax . swing . SwingUtilities ;  import    javax . swing . border . EmptyBorder ;  import   bibliothek . gui . DockController ;  import   bibliothek . gui . DockStation ;  import   bibliothek . gui . DockUI ;  import   bibliothek . gui . Dockable ;  import   bibliothek . gui . Orientation ;  import   bibliothek . gui . Position ;  import   bibliothek . gui . ToolbarInterface ;  import     bibliothek . gui . dock . layout . DockableProperty ;  import     bibliothek . gui . dock . security . SecureContainer ;  import     bibliothek . gui . dock . station . DisplayerCollection ;  import     bibliothek . gui . dock . station . DisplayerFactory ;  import     bibliothek . gui . dock . station . DockableDisplayer ;  import     bibliothek . gui . dock . station . DockableDisplayerListener ;  import     bibliothek . gui . dock . station . OrientedDockStation ;  import     bibliothek . gui . dock . station . OverpaintablePanel ;  import     bibliothek . gui . dock . station . StationChildHandle ;  import     bibliothek . gui . dock . station . StationDropOperation ;  import      bibliothek . gui . dock . station . layer . DockStationDropLayer ;  import      bibliothek . gui . dock . station . support . ConvertedPlaceholderListItem ;  import      bibliothek . gui . dock . station . support . DockablePlaceholderList ;  import      bibliothek . gui . dock . station . support . PlaceholderList ;  import      bibliothek . gui . dock . station . support . PlaceholderListItemAdapter ;  import      bibliothek . gui . dock . station . support . PlaceholderListItemConverter ;  import      bibliothek . gui . dock . station . support . PlaceholderMap ;  import      bibliothek . gui . dock . station . support . PlaceholderStrategy ;  import      bibliothek . gui . dock . station . toolbar . ToolbarDockStationFactory ;  import      bibliothek . gui . dock . station . toolbar . ToolbarDropInfo ;  import      bibliothek . gui . dock . station . toolbar . ToolbarProperty ;  import       bibliothek . gui . dock . station . toolbar . layer . ToolbarSlimDropLayer ;  import     bibliothek . gui . dock . themes . DefaultDisplayerFactoryValue ;  import     bibliothek . gui . dock . themes . DefaultStationPaintValue ;  import     bibliothek . gui . dock . themes . ThemeManager ;  import      bibliothek . gui . dock . themes . basic . BasicDockTitleFactory ;  import     bibliothek . gui . dock . title . DockTitleFactory ;  import     bibliothek . gui . dock . title . DockTitleVersion ;  import      bibliothek . gui . dock . toolbar . expand . ExpandedState ;  import     bibliothek . gui . dock . util . DockUtilities ;  import     bibliothek . gui . dock . util . PropertyValue ;  import      bibliothek . gui . dock . util . extension . Extension ;  import   bibliothek . util . Path ;   public class ToolbarDockStation  extends AbstractToolbarDockStation  {   public static final String  TITLE_ID = "toolbar" ;   public static final String  DISPLAYER_ID = "toolbar" ;   protected  DockablePlaceholderList  < StationChildHandle >  dockables =  new  DockablePlaceholderList  < StationChildHandle >  ( ) ;   private OverpaintablePanelBase  mainPanel ;   private  int  lateralNodropZoneSize = 1 ;   private final  PropertyValue  < PlaceholderStrategy >  placeholderStrategy =  new  PropertyValue  < PlaceholderStrategy >  (  PlaceholderStrategy . PLACEHOLDER_STRATEGY )  {    @ Override protected void valueChanged  (  PlaceholderStrategy oldValue ,  PlaceholderStrategy newValue )  {   dockables . setStrategy  ( newValue ) ; } } ;   public ToolbarDockStation  ( )  {   init  ( ) ;    mainPanel . getContentPane  ( ) . setBackground  (  Color . GREEN ) ;    mainPanel . getBasePane  ( ) . setBackground  (  Color . CYAN ) ; }    @ Override protected void init  ( )  {   mainPanel =  new OverpaintablePanelBase  ( ) ;   paint =  new DefaultStationPaintValue  (   ThemeManager . STATION_PAINT + ".toolbar" , this ) ;   setOrientation  (  getOrientation  ( ) ) ;   displayerFactory =  createDisplayerFactory  ( ) ;   displayers =  new DisplayerCollection  ( this , displayerFactory ,  getDisplayerId  ( ) ) ;   displayers . addDockableDisplayerListener  (  new DockableDisplayerListener  ( )  {    @ Override public void discard  (  DockableDisplayer displayer )  {    ToolbarDockStation . this . discard  ( displayer ) ; } } ) ;   setTitleIcon  ( null ) ; }    @ Override public Component getComponent  ( )  {  return mainPanel ; }    @ Override public  int getDockableCount  ( )  {  return   dockables . dockables  ( ) . size  ( ) ; }    @ Override public Dockable getDockable  (   int index )  {  return    dockables . dockables  ( ) . get  ( index ) . getDockable  ( ) ; }    @ Override public String getFactoryID  ( )  {  return  ToolbarDockStationFactory . ID ; }   public void setLateralNodropZoneSize  (   int lateralNodropZoneSize )  {  if  (  lateralNodropZoneSize < 0 )  {  throw  new IllegalArgumentException  ( "borderSideSnapeSize must not be less than 0" ) ; }    this . lateralNodropZoneSize = lateralNodropZoneSize ; }   public  int getLateralNodropZoneSize  ( )  {  return lateralNodropZoneSize ; }    @ Override public void setController  (  DockController controller )  {  if  (   getController  ( ) != controller )  {  if  (   getController  ( ) != null )  {   dockables . unbind  ( ) ; }  for (  final StationChildHandle handle :  dockables . dockables  ( ) )  {   handle . setTitleRequest  ( null ) ; }   super . setController  ( controller ) ;  if  (  controller == null )  {   title = null ; } else  {   title =  registerTitle  ( controller ) ; }   paint . setController  ( controller ) ;   placeholderStrategy . setProperties  ( controller ) ;   displayerFactory . setController  ( controller ) ;   displayers . setController  ( controller ) ;   mainPanel . setController  ( controller ) ;  if  (  controller != null )  {   dockables . bind  ( ) ; }  for (  final StationChildHandle handle :  dockables . dockables  ( ) )  {   handle . setTitleRequest  ( title , true ) ; } } }    @ Override public void setOrientation  (  Orientation orientation )  {    this . orientation = orientation ;  for (   int  i = 0 ;  i <  getDockableCount  ( ) ;  i ++ )  {   final Dockable  d =  getDockable  ( i ) ;  if  (  d instanceof OrientedDockStation )  {   final OrientedDockStation  element =  ( OrientedDockStation ) d ;   element . setOrientation  (  getOrientation  ( ) ) ; } }   mainPanel . updateAlignment  ( ) ;   mainPanel . revalidate  ( ) ;   fireOrientingEvent  ( ) ; }    @ Override public  DockStationDropLayer  [ ] getLayers  ( )  {  return  new DockStationDropLayer  [ ]  {  new ToolbarSlimDropLayer  ( this ) } ; }    @ Override public boolean accept  (  Dockable child )  {  return   getToolbarStrategy  ( ) . isToolbarPart  ( child ) ; }    @ Override public boolean accept  (  DockStation station )  {  return   getToolbarStrategy  ( ) . isToolbarGroupPartParent  ( station , this , false ) ; }   public boolean accept  (  DockStation base ,  Dockable neighbor )  {  return false ; }    @ Override public StationDropOperation prepareDrop  (   int mouseX ,   int mouseY ,   int titleX ,   int titleY ,  Dockable dockable )  {   final DockController  controller =  getController  ( ) ;  if  (   getExpandedState  ( ) ==  ExpandedState . EXPANDED )  {  return null ; }  if  (   this . accept  ( dockable ) &  dockable . accept  ( this ) )  {  if  (  controller != null )  {  if  (  !   controller . getAcceptance  ( ) . accept  ( this , dockable ) )  {  return null ; } }  return  new  ToolbarDropInfo  < AbstractToolbarDockStation >  ( dockable , this , mouseX , mouseY )  {    @ Override public void execute  ( )  {   drop  ( this ) ; }    @ Override public void destroy  ( )  {     ToolbarDockStation . this . indexBeneathMouse =  - 1 ;     ToolbarDockStation . this . sideBeneathMouse = null ;     ToolbarDockStation . this . prepareDropDraw = false ;   mainPanel . repaint  ( ) ; }    @ Override public void draw  ( )  {     ToolbarDockStation . this . indexBeneathMouse =  indexOf  (  getDockableBeneathMouse  ( ) ) ;     ToolbarDockStation . this . prepareDropDraw = true ;     ToolbarDockStation . this . sideBeneathMouse =  getSideDockableBeneathMouse  ( ) ;   mainPanel . repaint  ( ) ; } } ; } else  {  return null ; } }    @ Override protected void drop  (  StationDropOperation dropInfo )  {    @ SuppressWarnings  ( "unchecked" ) final  ToolbarDropInfo  < ToolbarDockStation >  dropInfoToolbar =  (  ToolbarDropInfo  < ToolbarDockStation > ) dropInfo ;  if  (   dropInfoToolbar . getItemPositionVSBeneathDockable  ( ) !=  Position . CENTER )  {   int  dropIndex ;   final  int  indexBeneathMouse =  indexOf  (  dropInfoToolbar . getDockableBeneathMouse  ( ) ) ;  if  (  dropInfoToolbar . isMove  ( ) )  {   int  shift = 0 ;  if  (   (   dropInfoToolbar . getItemPositionVSBeneathDockable  ( ) ==  Position . NORTH ) ||  (   dropInfoToolbar . getItemPositionVSBeneathDockable  ( ) ==  Position . WEST ) )  {   shift =  - 1 ; }  if  (   (   dropInfoToolbar . getSideDockableBeneathMouse  ( ) ==  Position . SOUTH ) ||  (   dropInfoToolbar . getSideDockableBeneathMouse  ( ) ==  Position . EAST ) )  {   dropIndex =   indexBeneathMouse + 1 + shift ; } else  {   dropIndex =  indexBeneathMouse + shift ; }   move  (  dropInfoToolbar . getItem  ( ) , dropIndex ) ; } else  {  if  (   (   dropInfoToolbar . getSideDockableBeneathMouse  ( ) ==  Position . SOUTH ) ||  (   dropInfoToolbar . getSideDockableBeneathMouse  ( ) ==  Position . EAST ) )  {   drop  (  dropInfoToolbar . getItem  ( ) ,  indexBeneathMouse + 1 ) ; } else  {   drop  (  dropInfoToolbar . getItem  ( ) , indexBeneathMouse ) ; } } } }    @ Override public void drop  (  Dockable dockable )  {   this . drop  ( dockable ,  getDockableCount  ( ) , true ) ; }   public boolean drop  (  Dockable dockable ,   int index )  {  return  drop  ( dockable , index , false ) ; }   protected boolean drop  (  Dockable dockable ,   int index ,  boolean force )  {  if  (  force ||  this . accept  ( dockable ) )  {  if  (  ! force )  {   dockable =   getToolbarStrategy  ( ) . ensureToolbarLayer  ( this , dockable ) ;  if  (  dockable == null )  {  return false ; } }   add  ( dockable , index ) ;  return true ; }  return false ; }   protected void move  (  Dockable dockable ,   int index )  {   final DockController  controller =  getController  ( ) ;  try  {  if  (  controller != null )  {   controller . freezeLayout  ( ) ; }   this . add  ( dockable , index ) ; }  finally  {  if  (  controller != null )  {   controller . meltLayout  ( ) ; } } }   protected void add  (  Dockable dockable ,   int index )  {   add  ( dockable , index , null ) ; }   protected void add  (  Dockable dockable ,   int index ,  Path placeholder )  {   DockUtilities . ensureTreeValidity  ( this , dockable ) ;   DockUtilities . checkLayoutLocked  ( ) ;   dockable =   getToolbarStrategy  ( ) . ensureToolbarLayer  ( this , dockable ) ;   final  DockHierarchyLock . Token  token =  DockHierarchyLock . acquireLinking  ( this , dockable ) ;  try  {   listeners . fireDockableAdding  ( dockable ) ;   int  inserted =  - 1 ;   final StationChildHandle  handle =  new StationChildHandle  ( this , displayers , dockable , title ) ;   handle . updateDisplayer  ( ) ;  if  (   (  placeholder != null ) &&  (   dockables . getDockableAt  ( placeholder ) == null ) )  {   inserted =  dockables . put  ( placeholder , handle ) ; } else  if  (  placeholder != null )  {   index =  dockables . getDockableIndex  ( placeholder ) ; }  if  (  inserted ==  - 1 )  {    getDockables  ( ) . add  ( index , handle ) ; } else  {   index = inserted ; }   insertAt  ( handle , index ) ;   listeners . fireDockableAdded  ( dockable ) ;   fireDockablesRepositioned  (  index + 1 ) ; }  finally  {   token . release  ( ) ; } }   protected void insertAt  (  StationChildHandle handle ,   int index )  {   final Dockable  dockable =  handle . getDockable  ( ) ;   dockable . setDockParent  ( this ) ;  if  (  dockable instanceof OrientedDockStation )  {  if  (   getOrientation  ( ) != null )  {    (  ( OrientedDockStation ) dockable ) . setOrientation  (  getOrientation  ( ) ) ; } }    mainPanel . getContentPane  ( ) . add  (   handle . getDisplayer  ( ) . getComponent  ( ) , index ) ;    mainPanel . getContentPane  ( ) . invalidate  ( ) ;   mainPanel . revalidate  ( ) ;    mainPanel . getContentPane  ( ) . repaint  ( ) ; }    @ Override public void drag  (  Dockable dockable )  {  if  (   dockable . getDockParent  ( ) != this )  {  throw  new IllegalArgumentException  ( "The dockable cannot be dragged, it is not child of this station." ) ; }   this . remove  ( dockable ) ; }    @ Override protected void remove  (  Dockable dockable )  {   DockUtilities . checkLayoutLocked  ( ) ;   final  int  index =  indexOf  ( dockable ) ;   final StationChildHandle  handle =   dockables . dockables  ( ) . get  ( index ) ;  if  (   getFrontDockable  ( ) == dockable )  {   setFrontDockable  ( null ) ; }   final  DockHierarchyLock . Token  token =  DockHierarchyLock . acquireUnlinking  ( this , dockable ) ;  try  {   listeners . fireDockableRemoving  ( dockable ) ;   dockable . setDockParent  ( null ) ;   dockables . remove  ( index ) ;    mainPanel . getContentPane  ( ) . remove  (   handle . getDisplayer  ( ) . getComponent  ( ) ) ;   mainPanel . doLayout  ( ) ;   mainPanel . revalidate  ( ) ;   mainPanel . repaint  ( ) ;   handle . destroy  ( ) ;   listeners . fireDockableRemoved  ( dockable ) ;   fireDockablesRepositioned  ( index ) ; }  finally  {   token . release  ( ) ; } }   protected void remove  (   int index )  {   DockUtilities . checkLayoutLocked  ( ) ;   final StationChildHandle  handle =   dockables . dockables  ( ) . get  ( index ) ;   final Dockable  dockable =  getDockable  ( index ) ;  if  (   getFrontDockable  ( ) == dockable )  {   setFrontDockable  ( null ) ; }   final  DockHierarchyLock . Token  token =  DockHierarchyLock . acquireUnlinking  ( this , dockable ) ;  try  {   listeners . fireDockableRemoving  ( dockable ) ;   dockable . setDockParent  ( null ) ;   dockables . remove  ( index ) ;    mainPanel . getContentPane  ( ) . remove  (   handle . getDisplayer  ( ) . getComponent  ( ) ) ;   mainPanel . doLayout  ( ) ;    mainPanel . getContentPane  ( ) . revalidate  ( ) ;    mainPanel . getContentPane  ( ) . repaint  ( ) ;   handle . destroy  ( ) ;   listeners . fireDockableRemoved  ( dockable ) ;   fireDockablesRepositioned  ( index ) ; }  finally  {   token . release  ( ) ; } }    @ Override public void replace  (  Dockable old ,  Dockable next )  {   DockUtilities . checkLayoutLocked  ( ) ;   final DockController  controller =  getController  ( ) ;  if  (  controller != null )  {   controller . freezeLayout  ( ) ; }   final  int  index =  indexOf  ( old ) ;   remove  ( old ) ;   add  ( next , index ) ;   controller . meltLayout  ( ) ; }    @ Override protected void callDockUiUpdateTheme  ( )  throws IOException  {   DockUI . updateTheme  ( this ,  new ToolbarDockStationFactory  ( ) ) ; }    @ Override protected DefaultDisplayerFactoryValue createDisplayerFactory  ( )  {  return  new DefaultDisplayerFactoryValue  (   ThemeManager . DISPLAYER_FACTORY + ".toolbar" , this ) ; }    @ Override protected String getDisplayerId  ( )  {  return DISPLAYER_ID ; }    @ Override protected DockTitleVersion registerTitle  (  DockController controller )  {  return   controller . getDockTitleManager  ( ) . getVersion  ( TITLE_ID ,  BasicDockTitleFactory . FACTORY ) ; }    @ Override protected void discard  (  DockableDisplayer displayer )  {   final Dockable  dockable =  displayer . getDockable  ( ) ;   final  int  index =  indexOf  ( dockable ) ;  if  (  index < 0 )  {  throw  new IllegalArgumentException  (  "displayer is not a child of this station: " + displayer ) ; }   final StationChildHandle  handle =   dockables . dockables  ( ) . get  ( index ) ;    mainPanel . getContentPane  ( ) . remove  (   handle . getDisplayer  ( ) . getComponent  ( ) ) ;   handle . updateDisplayer  ( ) ;   insertAt  ( handle , index ) ; }   protected class OverpaintablePanelBase  extends SecureContainer  {   private static final  long  serialVersionUID =  - 4399008463139189130L ;   private final  int  INSETS_SIZE = 1 ;    @ SuppressWarnings  ( "serial" ) private class SizeFixedPanel  extends JPanel  {    @ Override public Dimension getPreferredSize  ( )  {   final Dimension  pref =  super . getPreferredSize  ( ) ;  return pref ; }    @ Override public Dimension getMaximumSize  ( )  {  return  getPreferredSize  ( ) ; }    @ Override public Dimension getMinimumSize  ( )  {  return  getPreferredSize  ( ) ; } }   private final JPanel  dockablePane =  new SizeFixedPanel  ( ) ;   private final JPanel  basePane =  new SizeFixedPanel  ( ) ;   public OverpaintablePanelBase  ( )  {   basePane . add  ( dockablePane ) ;   setBasePane  ( basePane ) ;   setContentPane  ( dockablePane ) ;   setSolid  ( false ) ;   dockablePane . setOpaque  ( false ) ;   basePane . setOpaque  ( false ) ; }    @ Override public Dimension getPreferredSize  ( )  {  return   getBasePane  ( ) . getPreferredSize  ( ) ; }    @ Override public Dimension getMinimumSize  ( )  {  return  getPreferredSize  ( ) ; }    @ Override public Dimension getMaximumSize  ( )  {  return  getPreferredSize  ( ) ; }   public void updateAlignment  ( )  {  if  (   getOrientation  ( ) != null )  {  switch  (  getOrientation  ( ) )  {   case HORIZONTAL :   basePane . setBorder  (  new EmptyBorder  (  new Insets  ( 0 , INSETS_SIZE , 0 ,  INSETS_SIZE + 1 ) ) ) ;   dockablePane . setLayout  (  new BoxLayout  ( dockablePane ,  BoxLayout . X_AXIS ) ) ;   basePane . setLayout  (  new BoxLayout  ( basePane ,  BoxLayout . X_AXIS ) ) ;   dockablePane . setAlignmentY  (  Component . CENTER_ALIGNMENT ) ;   basePane . setAlignmentY  (  Component . CENTER_ALIGNMENT ) ;   dockablePane . setAlignmentX  (  Component . LEFT_ALIGNMENT ) ;   basePane . setAlignmentX  (  Component . LEFT_ALIGNMENT ) ;  break ;   case VERTICAL :   basePane . setBorder  (  new EmptyBorder  (  new Insets  ( INSETS_SIZE , 0 ,  INSETS_SIZE + 1 , 0 ) ) ) ;   dockablePane . setLayout  (  new BoxLayout  ( dockablePane ,  BoxLayout . Y_AXIS ) ) ;   basePane . setLayout  (  new BoxLayout  ( basePane ,  BoxLayout . Y_AXIS ) ) ;   dockablePane . setAlignmentY  (  Component . TOP_ALIGNMENT ) ;   basePane . setAlignmentY  (  Component . TOP_ALIGNMENT ) ;   dockablePane . setAlignmentX  (  Component . CENTER_ALIGNMENT ) ;   basePane . setAlignmentX  (  Component . CENTER_ALIGNMENT ) ;  break ;   default :  throw  new IllegalArgumentException  ( ) ; } } }    @ Override protected void paintOverlay  (  Graphics g )  {   final Graphics2D  g2D =  ( Graphics2D ) g ;  if  ( prepareDropDraw )  {  if  (  indexBeneathMouse !=  - 1 )  {   final Component  componentBeneathMouse =     getDockables  ( ) . get  ( indexBeneathMouse ) . getDisplayer  ( ) . getComponent  ( ) ;  if  (  componentBeneathMouse != null )  {   final Rectangle  rectToolbar =  basePane . getBounds  ( ) ;   final Color  color =  new Color  ( 16 , 138 , 230 , 50 ) ;   final Rectangle2D  rect =  new  Rectangle2D . Double  (  rectToolbar . x ,  rectToolbar . y ,  rectToolbar . width ,  rectToolbar . height ) ;   g2D . setColor  ( color ) ;   g2D . setStroke  (  new BasicStroke  ( 2 ) ) ;   g2D . fill  ( rect ) ;   g2D . setColor  (  Color . RED ) ;   final Rectangle  rectBeneathMouse =  componentBeneathMouse . getBounds  ( ) ;   final Point  pBeneath =  rectBeneathMouse . getLocation  ( ) ;   SwingUtilities . convertPointToScreen  ( pBeneath ,  componentBeneathMouse . getParent  ( ) ) ;   SwingUtilities . convertPointFromScreen  ( pBeneath ,  getBasePane  ( ) ) ;   final Rectangle  rectangleTranslated =  new Rectangle  (  pBeneath . x ,  pBeneath . y ,  rectBeneathMouse . width ,  rectBeneathMouse . height ) ;  switch  (  getOrientation  ( ) )  {   case VERTICAL :   int  y ;  if  (  sideBeneathMouse ==  Position . NORTH )  {   y =  rectangleTranslated . y ; } else  {   y =   rectangleTranslated . y +  rectangleTranslated . height ; }   paint . drawInsertionLine  ( g ,  rectangleTranslated . x , y ,   rectangleTranslated . x +  rectangleTranslated . width , y ) ;  break ;   case HORIZONTAL :   int  x ;  if  (  sideBeneathMouse ==  Position . WEST )  {   x =  rectangleTranslated . x ; } else  {   x =   rectangleTranslated . x +  rectangleTranslated . width ; }   paint . drawInsertionLine  ( g , x ,  rectangleTranslated . y , x ,   rectangleTranslated . y +  rectangleTranslated . height ) ; } } } } }    @ Override public String toString  ( )  {  return     this . getClass  ( ) . getSimpleName  ( ) + '@' +  Integer . toHexString  (  hashCode  ( ) ) ; } }   protected DockableProperty getDockableProperty  (  Dockable child ,  Dockable target ,   int index ,  Path placeholder )  {  return  new ToolbarProperty  ( index , placeholder ) ; }   protected boolean isValidProperty  (  DockableProperty property )  {  return  property instanceof ToolbarProperty ; }   protected  int getIndex  (  DockableProperty property )  {  return   (  ( ToolbarProperty ) property ) . getIndex  ( ) ; }   protected Path getPlaceholder  (  DockableProperty property )  {  return   (  ( ToolbarProperty ) property ) . getPlaceholder  ( ) ; }   protected   PlaceholderList . Filter  < StationChildHandle > getDockables  ( )  {  return  dockables . dockables  ( ) ; }   public PlaceholderMap getPlaceholders  (   final  Map  < Dockable , Integer > children )  {   final PlaceholderStrategy  strategy =  getPlaceholderStrategy  ( ) ;  return  dockables . toMap  (  new  PlaceholderListItemAdapter  < Dockable , StationChildHandle >  ( )  {    @ Override public ConvertedPlaceholderListItem convert  (   int index ,  StationChildHandle handle )  {   final Dockable  dockable =  handle . getDockable  ( ) ;   final Integer  id =  children . get  ( dockable ) ;  if  (  id == null )  {  return null ; }   final ConvertedPlaceholderListItem  item =  new ConvertedPlaceholderListItem  ( ) ;   item . putInt  ( "id" , id ) ;   item . putInt  ( "index" , index ) ;  if  (  strategy != null )  {   final Path  placeholder =  strategy . getPlaceholderFor  ( dockable ) ;  if  (  placeholder != null )  {   item . putString  ( "placeholder" ,  placeholder . toString  ( ) ) ;   item . setPlaceholder  ( placeholder ) ; } }  return item ; } } ) ; }   public void setPlaceholders  (  PlaceholderMap map ,   final  Map  < Integer , Dockable > children )  {   DockUtilities . checkLayoutLocked  ( ) ;  if  (   getDockableCount  ( ) > 0 )  {  throw  new IllegalStateException  ( "must not have any children" ) ; }   final DockController  controller =  getController  ( ) ;  try  {  if  (  controller != null )  {   controller . freezeLayout  ( ) ; }   final  DockablePlaceholderList  < StationChildHandle >  next =  new  DockablePlaceholderList  < StationChildHandle >  ( ) ;  if  (   getController  ( ) != null )  {   dockables . setStrategy  ( null ) ;   dockables . unbind  ( ) ;   dockables = next ; } else  {   dockables = next ; }   next . read  ( map ,  new  PlaceholderListItemAdapter  < Dockable , StationChildHandle >  ( )  {   private  DockHierarchyLock . Token  token ;   private  int  index = 0 ;    @ Override public StationChildHandle convert  (  ConvertedPlaceholderListItem item )  {   final  int  id =  item . getInt  ( "id" ) ;   final Dockable  dockable =  children . get  ( id ) ;  if  (  dockable != null )  {   DockUtilities . ensureTreeValidity  (  ToolbarDockStation . this , dockable ) ;   token =  DockHierarchyLock . acquireLinking  (  ToolbarDockStation . this , dockable ) ;   listeners . fireDockableAdding  ( dockable ) ;  return  new StationChildHandle  (  ToolbarDockStation . this , displayers , dockable , title ) ; }  return null ; }    @ Override public void added  (  StationChildHandle handle )  {  try  {   handle . updateDisplayer  ( ) ;   insertAt  ( handle ,  index ++ ) ;   listeners . fireDockableAdded  (  handle . getDockable  ( ) ) ; }  finally  {   token . release  ( ) ; } } } ) ;  if  (   getController  ( ) != null )  {   dockables . bind  ( ) ;   dockables . setStrategy  (  getPlaceholderStrategy  ( ) ) ; } }  finally  {  if  (  controller != null )  {   controller . meltLayout  ( ) ; } } }    @ Override public PlaceholderMap getPlaceholders  ( )  {  return  dockables . toMap  ( ) ; }    @ Override public void setPlaceholders  (  PlaceholderMap placeholders )  {  if  (   getDockableCount  ( ) > 0 )  {  throw  new IllegalStateException  ( "only allowed if there are not children present" ) ; }  try  {   final  DockablePlaceholderList  < StationChildHandle >  next =  new  DockablePlaceholderList  < StationChildHandle >  ( placeholders ) ;  if  (   getController  ( ) != null )  {   dockables . setStrategy  ( null ) ;   dockables . unbind  ( ) ;   dockables = next ;   dockables . bind  ( ) ;   dockables . setStrategy  (  getPlaceholderStrategy  ( ) ) ; } else  {   dockables = next ; } }  catch (   final  IllegalArgumentException ex )  { } }   public PlaceholderStrategy getPlaceholderStrategy  ( )  {  return  placeholderStrategy . getValue  ( ) ; }   public void setPlaceholderStrategy  (  PlaceholderStrategy strategy )  {   placeholderStrategy . setValue  ( strategy ) ; }    @ Override public DockableProperty getDockableProperty  (  Dockable child ,  Dockable target )  {   final  int  index =  indexOf  ( child ) ;  Path  placeholder = null ;   final PlaceholderStrategy  strategy =  getPlaceholderStrategy  ( ) ;  if  (  strategy != null )  {   placeholder =  strategy . getPlaceholderFor  (   target == null ? child : target ) ;  if  (  placeholder != null )  {    dockables . dockables  ( ) . addPlaceholder  ( index , placeholder ) ; } }  return  getDockableProperty  ( child , target , index , placeholder ) ; }    @ Override public boolean drop  (  Dockable dockable ,  DockableProperty property )  {  if  (  isValidProperty  ( property ) )  {   final boolean  acceptable =  acceptable  ( dockable ) ;  boolean  result = false ;   final  int  index =  Math . min  (  getDockableCount  ( ) ,  getIndex  ( property ) ) ;   final Path  placeholder =  getPlaceholder  ( property ) ;  if  (   (  placeholder != null ) &&  (   property . getSuccessor  ( ) != null ) )  {   final StationChildHandle  preset =  dockables . getDockableAt  ( placeholder ) ;  if  (  preset != null )  {   final DockStation  station =   preset . getDockable  ( ) . asDockStation  ( ) ;  if  (  station != null )  {  if  (  station . drop  ( dockable ,  property . getSuccessor  ( ) ) )  {   dockables . removeAll  ( placeholder ) ;   result = true ; } } } }  if  (   ! result &&  (  placeholder != null ) )  {  if  (  acceptable &&  dockables . hasPlaceholder  ( placeholder ) )  {   add  ( dockable , index , placeholder ) ;   result = true ; } }  if  (   ! result &&  (    dockables . dockables  ( ) . size  ( ) == 0 ) )  {  if  ( acceptable )  {   drop  ( dockable ) ;   result = true ; } }  if  (  ! result )  {  if  (   (  index <   dockables . dockables  ( ) . size  ( ) ) &&  (   property . getSuccessor  ( ) != null ) )  {   final DockStation  child =   getDockable  ( index ) . asDockStation  ( ) ;  if  (  child != null )  {   result =  child . drop  ( dockable ,  property . getSuccessor  ( ) ) ; } } }  if  (   ! result && acceptable )  {   result =  drop  ( dockable , index ) ; }  return result ; }  return false ; }    @ Override public void move  (  Dockable dockable ,  DockableProperty property )  { } }