  package   bibliothek . gui . dock ;   import   java . awt . Component ;  import   java . awt . Dimension ;  import   java . awt . Graphics ;  import   java . awt . Rectangle ;  import   java . io . IOException ;  import   java . util . Map ;  import   javax . swing . BoxLayout ;  import   javax . swing . JPanel ;  import   bibliothek . gui . DockController ;  import   bibliothek . gui . DockStation ;  import   bibliothek . gui . Dockable ;  import   bibliothek . gui . OrientedDockStation ;  import   bibliothek . gui . ToolbarElementInterface ;  import   bibliothek . gui . ToolbarInterface ;  import     bibliothek . gui . dock . layout . DockableProperty ;  import     bibliothek . gui . dock . station . AbstractDockableStation ;  import     bibliothek . gui . dock . station . OverpaintablePanel ;  import     bibliothek . gui . dock . station . StationDropOperation ;  import     bibliothek . gui . dock . station . StationPaint ;  import      bibliothek . gui . dock . station . support . ConvertedPlaceholderListItem ;  import      bibliothek . gui . dock . station . support . DockablePlaceholderList ;  import      bibliothek . gui . dock . station . support . PlaceholderList ;  import      bibliothek . gui . dock . station . support . PlaceholderListItemAdapter ;  import      bibliothek . gui . dock . station . support . PlaceholderListItemConverter ;  import      bibliothek . gui . dock . station . support . PlaceholderMap ;  import      bibliothek . gui . dock . station . support . PlaceholderStrategy ;  import      bibliothek . gui . dock . station . toolbar . ToolbarDockStationFactory ;  import      bibliothek . gui . dock . station . toolbar . ToolbarDropInfo ;  import      bibliothek . gui . dock . station . toolbar . ToolbarProperty ;  import      bibliothek . gui . dock . station . toolbar . ToolbarStrategy ;  import     bibliothek . gui . dock . themes . DefaultStationPaintValue ;  import     bibliothek . gui . dock . themes . ThemeManager ;  import     bibliothek . gui . dock . util . DockUtilities ;  import     bibliothek . gui . dock . util . PropertyValue ;  import     bibliothek . gui . dock . util . SilentPropertyValue ;  import   bibliothek . util . Path ;  import   java . awt . Color ;  import   java . awt . Insets ;  import   javax . swing . JLabel ;  import    javax . swing . border . CompoundBorder ;  import    javax . swing . border . EmptyBorder ;  import    javax . swing . border . EtchedBorder ;  import   bibliothek . gui . Orientation ;  import   bibliothek . gui . Position ;  import   bibliothek . gui . PositionedDockStation ;  import      bibliothek . gui . dock . station . toolbar . ToolbarDockTitleRequest ;  import     bibliothek . gui . dock . title . DockTitle ;  import     bibliothek . gui . dock . title . DockTitleRequest ;   public class ToolbarDockStation  extends AbstractDockableStation  implements  PositionedDockStation , OrientedDockStation , ToolbarInterface , ToolbarElementInterface  {   private  DockablePlaceholderList  < Dockable >  dockables =  new  DockablePlaceholderList  < Dockable >  ( ) ;   private DefaultStationPaintValue  paint ;   private Integer  indexBeneathMouse = null ;   private Position  sideBeneathMouse = null ;   private  PropertyValue  < PlaceholderStrategy >  placeholderStrategy =  new  PropertyValue  < PlaceholderStrategy >  (  PlaceholderStrategy . PLACEHOLDER_STRATEGY )  {    @ Override protected void valueChanged  (  PlaceholderStrategy oldValue ,  PlaceholderStrategy newValue )  {   dockables . setStrategy  ( newValue ) ; } } ;   public ToolbarDockStation  ( )  {   mainPanel =  new OverpaintablePanelBase  ( ) ;   paint =  new DefaultStationPaintValue  (   ThemeManager . STATION_PAINT + ".toolbar" , this ) ;   setPosition  (  this . position ) ; }    @ Override public  int getDockableCount  ( )  {  return   dockables . dockables  ( ) . size  ( ) ; }    @ Override public Dockable getDockable  (   int index )  {  return   dockables . dockables  ( ) . get  ( index ) ; }   protected   PlaceholderList . Filter  < Dockable > getDockables  ( )  {  return  dockables . dockables  ( ) ; }    @ Override public Dockable getFrontDockable  ( )  {  return null ; }    @ Override public void setFrontDockable  (  Dockable dockable )  { }   public PlaceholderMap getPlaceholders  (   final  Map  < Dockable , Integer > children )  {   final PlaceholderStrategy  strategy =  getPlaceholderStrategy  ( ) ;  return  dockables . toMap  (  new  PlaceholderListItemAdapter  < Dockable , Dockable >  ( )  {    @ Override public ConvertedPlaceholderListItem convert  (   int index ,  Dockable dockable )  {  Integer  id =  children . get  ( dockable ) ;  if  (  id == null )  {  return null ; }  ConvertedPlaceholderListItem  item =  new ConvertedPlaceholderListItem  ( ) ;   item . putInt  ( "id" , id ) ;   item . putInt  ( "index" , index ) ;  if  (  strategy != null )  {  Path  placeholder =  strategy . getPlaceholderFor  ( dockable ) ;  if  (  placeholder != null )  {   item . putString  ( "placeholder" ,  placeholder . toString  ( ) ) ;   item . setPlaceholder  ( placeholder ) ; } }  return item ; } } ) ; }   public void setPlaceholders  (  PlaceholderMap map ,   final  Map  < Integer , Dockable > children )  {   DockUtilities . checkLayoutLocked  ( ) ;  if  (   getDockableCount  ( ) > 0 )  {  throw  new IllegalStateException  ( "must not have any children" ) ; }  DockController  controller =  getController  ( ) ;  try  {  if  (  controller != null )  {   controller . freezeLayout  ( ) ; }   DockablePlaceholderList  < Dockable >  next =  new  DockablePlaceholderList  < Dockable >  ( ) ;  if  (   getController  ( ) != null )  {   dockables . setStrategy  ( null ) ;   dockables . unbind  ( ) ;   dockables = next ; } else  {   dockables = next ; }   next . read  ( map ,  new  PlaceholderListItemAdapter  < Dockable , Dockable >  ( )  {   private  DockHierarchyLock . Token  token ;   private  int  index = 0 ;    @ Override public Dockable convert  (  ConvertedPlaceholderListItem item )  {   int  id =  item . getInt  ( "id" ) ;  Dockable  dockable =  children . get  ( id ) ;  if  (  dockable != null )  {   DockUtilities . ensureTreeValidity  (  ToolbarDockStation . this , dockable ) ;   token =  DockHierarchyLock . acquireLinking  (  ToolbarDockStation . this , dockable ) ;   listeners . fireDockableAdding  ( dockable ) ;  return dockable ; }  return null ; }    @ Override public void added  (  Dockable dockable )  {  try  {   insertAt  ( dockable ,  index ++ ) ;   listeners . fireDockableAdded  ( dockable ) ; }  finally  {   token . release  ( ) ; } } } ) ;  if  (   getController  ( ) != null )  {   dockables . bind  ( ) ;   dockables . setStrategy  (  getPlaceholderStrategy  ( ) ) ; } }  finally  {  if  (  controller != null )  {   controller . meltLayout  ( ) ; } } }    @ Override public PlaceholderMap getPlaceholders  ( )  {  return  dockables . toMap  ( ) ; }    @ Override public void setPlaceholders  (  PlaceholderMap placeholders )  {  if  (   getDockableCount  ( ) > 0 )  {  throw  new IllegalStateException  ( "only allowed if there are not children present" ) ; }  try  {   DockablePlaceholderList  < Dockable >  next =  new  DockablePlaceholderList  < Dockable >  ( placeholders ) ;  if  (   getController  ( ) != null )  {   dockables . setStrategy  ( null ) ;   dockables . unbind  ( ) ;   dockables = next ;   dockables . bind  ( ) ;   dockables . setStrategy  (  getPlaceholderStrategy  ( ) ) ; } else  {   dockables = next ; } }  catch (   IllegalArgumentException ex )  { } }   public PlaceholderStrategy getPlaceholderStrategy  ( )  {  return  placeholderStrategy . getValue  ( ) ; }   public void setPlaceholderStrategy  (  PlaceholderStrategy strategy )  {   placeholderStrategy . setValue  ( strategy ) ; }    @ Override public DockableProperty getDockableProperty  (  Dockable child ,  Dockable target )  {   int  index =  indexOf  ( child ) ;  Path  placeholder = null ;  PlaceholderStrategy  strategy =  getPlaceholderStrategy  ( ) ;  if  (  strategy != null )  {   placeholder =  strategy . getPlaceholderFor  (   target == null ? child : target ) ;  if  (  placeholder != null )  {    dockables . dockables  ( ) . addPlaceholder  ( index , placeholder ) ; } }  return  new ToolbarProperty  ( index , placeholder ) ; }    @ Override public StationDropOperation prepareDrop  (   int mouseX ,   int mouseY ,   int titleX ,   int titleY ,  boolean checkOverrideZone ,  Dockable dockable )  {    System . out . println  (   this . toString  ( ) + "## prepareDrop(...) ##" ) ;  DockController  controller =  getController  ( ) ;  if  (  checkOverrideZone &   this . getDockParent  ( ) != null )  {  if  (   this . getDockParent  ( ) . isInOverrideZone  ( mouseX , mouseY , this , dockable ) )  {  return null ; } }  if  (   this . accept  ( dockable ) &  dockable . accept  ( this ) )  {  if  (  controller != null )  {  if  (  !   controller . getAcceptance  ( ) . accept  ( this , dockable ) )  {  return null ; } }  return  new  ToolbarDropInfo  < ToolbarDockStation >  ( dockable , this , mouseX , mouseY )  {    @ Override public void execute  ( )  {   drop  ( this ) ; }    @ Override public void destroy  ( )  {     ToolbarDockStation . this . indexBeneathMouse = null ;     ToolbarDockStation . this . sideBeneathMouse = null ;     ToolbarDockStation . this . mainPanel . repaint  ( ) ; }    @ Override public void draw  ( )  {     ToolbarDockStation . this . indexBeneathMouse =  indexOf  (  getDockableBeneathMouse  ( ) ) ;     ToolbarDockStation . this . sideBeneathMouse =  this . getSideDockableBeneathMouse  ( ) ;     ToolbarDockStation . this . mainPanel . repaint  ( ) ; } } ; } else  {  return null ; } }   private void drop  (   ToolbarDropInfo  <  ? > dropInfo )  {  if  (   dropInfo . getItemPositionVSBeneathDockable  ( ) !=  Position . CENTER )  {   int  dropIndex ;   int  indexBeneathMouse =  indexOf  (  dropInfo . getDockableBeneathMouse  ( ) ) ;  if  (  dropInfo . isMove  ( ) )  {  switch  (  this . getOrientation  ( ) )  {   case VERTICAL :  if  (   dropInfo . getItemPositionVSBeneathDockable  ( ) ==  Position . SOUTH )  {  if  (   dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . SOUTH )  {   dropIndex =  indexBeneathMouse + 1 ; } else  {   dropIndex = indexBeneathMouse ; } } else  {  if  (   dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . SOUTH )  {   dropIndex = indexBeneathMouse ; } else  {   dropIndex =  indexBeneathMouse - 1 ; } }   move  (  dropInfo . getItem  ( ) , dropIndex ) ;  break ;   case HORIZONTAL :  if  (   dropInfo . getItemPositionVSBeneathDockable  ( ) ==  Position . EAST )  {  if  (   dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . EAST )  {   dropIndex =  indexBeneathMouse + 1 ; } else  {   dropIndex = indexBeneathMouse ; } } else  {  if  (   dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . EAST )  {   dropIndex = indexBeneathMouse ; } else  {   dropIndex =  indexBeneathMouse - 1 ; } }   move  (  dropInfo . getItem  ( ) , dropIndex ) ;  break ; } } else  {   int  increment = 0 ;  if  (    dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . SOUTH ||   dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . EAST )  {   increment ++ ; }   dropIndex =  indexBeneathMouse + increment ;   drop  (  dropInfo . getItem  ( ) , dropIndex ) ; } } }    @ Override public void drop  (  Dockable dockable )  {    System . out . println  (   this . toString  ( ) + "## drop(Dockable dockable)##" ) ;   this . drop  ( dockable ,  getDockableCount  ( ) ) ; }    @ Override public boolean drop  (  Dockable dockable ,  DockableProperty property )  {  if  (  property instanceof ToolbarProperty )  {  ToolbarProperty  toolbar =  ( ToolbarProperty ) property ;  boolean  acceptable =  acceptable  ( dockable ) ;  boolean  result = false ;   int  index =  Math . min  (  getDockableCount  ( ) ,  toolbar . getIndex  ( ) ) ;  Path  placeholder =  toolbar . getPlaceholder  ( ) ;  if  (   placeholder != null &&   toolbar . getSuccessor  ( ) != null )  {  Dockable  preset =  dockables . getDockableAt  ( placeholder ) ;  if  (  preset != null )  {  DockStation  station =  preset . asDockStation  ( ) ;  if  (  station != null )  {  if  (  station . drop  ( dockable ,  toolbar . getSuccessor  ( ) ) )  {   dockables . removeAll  ( placeholder ) ;   result = true ; } } } }  if  (   ! result &&  placeholder != null )  {  if  (  acceptable &&  dockables . hasPlaceholder  ( placeholder ) )  {   add  ( dockable , index , placeholder ) ;   result = true ; } }  if  (   ! result &&    dockables . dockables  ( ) . size  ( ) == 0 )  {  if  ( acceptable )  {   drop  ( dockable ) ;   result = true ; } }  if  (  ! result )  {  if  (   index <   dockables . dockables  ( ) . size  ( ) &&   toolbar . getSuccessor  ( ) != null )  {  DockStation  child =   getDockable  ( index ) . asDockStation  ( ) ;  if  (  child != null )  {   result =  child . drop  ( dockable ,  toolbar . getSuccessor  ( ) ) ; } } }  if  (   ! result && acceptable )  {   result =  drop  ( dockable , index ) ; }  return result ; }  return false ; }   public boolean drop  (  Dockable dockable ,   int index )  {    System . out . println  (   this . toString  ( ) + "## drop(Dockable dockable, int index)##" ) ;  if  (  this . accept  ( dockable ) )  {   dockable =   getToolbarStrategy  ( ) . ensureToolbarLayer  ( this , dockable ) ;  if  (  dockable == null )  {  return false ; }   add  ( dockable , index ) ;  return true ; }  return false ; }   private void move  (  Dockable dockable ,   int indexWhereInsert )  {    System . out . println  (    this . toString  ( ) + "## move() ## ==> Index: " + indexWhereInsert ) ;  DockController  controller =  getController  ( ) ;  try  {  if  (  controller != null )  {   controller . freezeLayout  ( ) ; }   this . add  ( dockable , indexWhereInsert ) ; }  finally  {  if  (  controller != null )  {   controller . meltLayout  ( ) ; } } }    @ Override public void move  (  Dockable dockable ,  DockableProperty property )  { }    @ Override public  <  D  extends Dockable & DockStation > boolean isInOverrideZone  (   int x ,   int y ,  D invoker ,  Dockable drop )  {  return false ; }    @ Override public boolean canDrag  (  Dockable dockable )  {    System . out . println  (   this . toString  ( ) + "## canDrag(Dockable dockable) ## " ) ;  return true ; }    @ Override public void drag  (  Dockable dockable )  {    System . out . println  (   this . toString  ( ) + "## drag(Dockable dockable) ##" ) ;  if  (   dockable . getDockParent  ( ) != this )  throw  new IllegalArgumentException  ( "The dockable cannot be dragged, it is not child of this station." ) ;   int  index =  this . indexOf  ( dockable ) ;  if  (  index >= 0 )  {   this . remove  ( index ) ; } }    @ Override public boolean canReplace  (  Dockable old ,  Dockable next )  {    System . out . println  (   this . toString  ( ) + "## canReplace(Dockable old, Dockable next) ## " ) ;  if  (   old . getClass  ( ) ==  next . getClass  ( ) )  {  return true ; } else  {  return false ; } }    @ Override public void replace  (  Dockable old ,  Dockable next )  {    System . out . println  (   this . toString  ( ) + "## replace(Dockable old, Dockable next) ## " ) ;   DockUtilities . checkLayoutLocked  ( ) ;  DockController  controller =  getController  ( ) ;  if  (  controller != null )   controller . freezeLayout  ( ) ;   int  index =  indexOf  ( old ) ;   remove  ( old ) ;   add  ( next , index ) ;   controller . meltLayout  ( ) ; }    @ Override public void replace  (  DockStation old ,  Dockable next )  {    System . out . println  (   this . toString  ( ) + "## replace(DockStation old, Dockable next) ## " ) ;   replace  (  old . asDockable  ( ) , next ) ; }    @ Override public String getFactoryID  ( )  {  return  ToolbarDockStationFactory . ID ; }    @ Override public Component getComponent  ( )  {  return mainPanel ; }    @ Override protected void callDockUiUpdateTheme  ( )  throws IOException  { }   public ToolbarStrategy getToolbarStrategy  ( )  {   SilentPropertyValue  < ToolbarStrategy >  value =  new  SilentPropertyValue  < ToolbarStrategy >  (  ToolbarStrategy . STRATEGY ,  getController  ( ) ) ;  ToolbarStrategy  result =  value . getValue  ( ) ;   value . setProperties  (  ( DockController ) null ) ;  return result ; }    @ Override public boolean accept  (  Dockable child )  {    System . out . println  (   this . toString  ( ) + "## accept(Dockable child) ##" ) ;  return   getToolbarStrategy  ( ) . isToolbarPart  ( child ) ; }    @ Override public boolean accept  (  DockStation station )  {    System . out . println  (   this . toString  ( ) + "## accept(DockStation station) ##" ) ;  return   getToolbarStrategy  ( ) . isToolbarGroupPartParent  ( station , this ) ; }    @ Override public String toString  ( )  {  return     this . getClass  ( ) . getSimpleName  ( ) + '@' +  Integer . toHexString  (  this . hashCode  ( ) ) ; }   public  int indexOf  (  Dockable dockable )  {   int  index = 0 ;  for ( Dockable currentDockable :  dockables . dockables  ( ) )  {  if  (  currentDockable == dockable )  {  return index ; }   index ++ ; }  return  - 1 ; }   private void add  (  Dockable dockable ,   int index )  {    System . out . println  (   this . toString  ( ) + "## add(Dockable dockable, int index)##" ) ;   add  ( dockable , index , null ) ; 
<<<<<<<
=======
 try  {   listeners . fireDockableAdding  ( dockable ) ;   insertAt  ( dockable , index ) ;    dockables . dockables  ( ) . add  ( index , dockable ) ;   listeners . fireDockableAdded  ( dockable ) ;   fireDockablesRepositioned  (  index + 1 ) ; }  finally  {   token . release  ( ) ; }
>>>>>>>
 }   private void add  (  Dockable dockable ,   int index ,  Path placeholder )  {   DockUtilities . ensureTreeValidity  ( this , dockable ) ;   DockUtilities . checkLayoutLocked  ( ) ;   dockable =   getToolbarStrategy  ( ) . ensureToolbarLayer  ( this , dockable ) ;   DockHierarchyLock . Token  token =  DockHierarchyLock . acquireLinking  ( this , dockable ) ;  try  {   listeners . fireDockableAdding  ( dockable ) ;   int  inserted =  - 1 ;  if  (   placeholder != null &&   dockables . getDockableAt  ( placeholder ) == null )  {   inserted =  dockables . put  ( placeholder , dockable ) ; } else  if  (  placeholder != null )  {   index =  dockables . getDockableIndex  ( placeholder ) ; }  if  (  inserted ==  - 1 )  {    dockables . dockables  ( ) . add  ( index , dockable ) ; } else  {   index = inserted ; }   insertAt  ( dockable , index ) ;   listeners . fireDockableAdded  ( dockable ) ;   fireDockablesRepositioned  (  index + 1 ) ; }  finally  {   token . release  ( ) ; } }   private void insertAt  (  Dockable dockable ,   int index )  {   dockable . setDockParent  ( this ) ;  if  (  dockable instanceof PositionedDockStation )  {  if  (   getPosition  ( ) != null )  {    (  ( PositionedDockStation ) dockable ) . setPosition  (  getPosition  ( ) ) ; } }    mainPanel . getContentPane  ( ) . add  (  dockable . getComponent  ( ) , index ) ;    mainPanel . getContentPane  ( ) . setBounds  ( 0 , 0 ,    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . width ,    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . height ) ;   mainPanel . setPreferredSize  (  new Dimension  (    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . width ,    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . height ) ) ;   mainPanel . doLayout  ( ) ;    mainPanel . getContentPane  ( ) . revalidate  ( ) ;    mainPanel . getContentPane  ( ) . repaint  ( ) ; }   private void remove  (  Dockable dockable )  {   int  index =  this . indexOf  ( dockable ) ;  if  (  index >= 0 )   this . remove  ( index ) ; }   private void remove  (   int index )  {   DockUtilities . checkLayoutLocked  ( ) ;  Dockable  dockable =  this . getDockable  ( index ) ;  if  (   getFrontDockable  ( ) == dockable )   setFrontDockable  ( null ) ;   DockHierarchyLock . Token  token =  DockHierarchyLock . acquireUnlinking  ( this , dockable ) ;  try  {   listeners . fireDockableRemoving  ( dockable ) ;   dockable . setDockParent  ( null ) ;   dockables . remove  ( index ) ;    mainPanel . getContentPane  ( ) . remove  (  dockable . getComponent  ( ) ) ;   mainPanel . doLayout  ( ) ;    mainPanel . getContentPane  ( ) . revalidate  ( ) ;    mainPanel . getContentPane  ( ) . repaint  ( ) ;   listeners . fireDockableRemoved  ( dockable ) ;   fireDockablesRepositioned  ( index ) ; }  finally  {   token . release  ( ) ; } }    @ Override public void setOrientation  (  Orientation orientation )  { }    @ Override public Orientation getOrientation  ( )  {  switch  ( position )  {   case NORTH :   case SOUTH :  return  Orientation . HORIZONTAL ;   case WEST :   case EAST :  return  Orientation . VERTICAL ;   case CENTER :  return null ; }  throw  new IllegalStateException  ( ) ; }   protected class OverpaintablePanelBase  extends OverpaintablePanel  {   private static final  long  serialVersionUID =  - 4399008463139189130L ;   public OverpaintablePanelBase  ( )  {   basePane . setBorder  (  new CompoundBorder  (  new EtchedBorder  ( ) ,  new EmptyBorder  (  new Insets  ( 5 , 5 , 5 , 5 ) ) ) ) ;  if  (    ToolbarDockStation . this . getClass  ( ) ==  ToolbarGroupDockStation . class )  {  JLabel  label =  new JLabel  ( "**" ) ;   titlePane . add  ( label ) ;   titlePane . setBackground  (  Color . YELLOW ) ; }   basePane . add  ( titlePane ) ;   basePane . setBackground  (  Color . GREEN ) ;   contentPane . setBackground  (  Color . RED ) ;   basePane . add  ( contentPane ) ;   setBasePane  ( basePane ) ;   setContentPane  ( contentPane ) ; }    @ Override protected void paintOverlay  (  Graphics g )  {  DefaultStationPaintValue  paint =  getPaint  ( ) ;  if  (  indexBeneathMouse != null )  {  Rectangle  rect =     dockables . dockables  ( ) . get  ( indexBeneathMouse ) . getComponent  ( ) . getBounds  ( ) ;  if  (  rect != null )  {  switch  (   ToolbarDockStation . this . getOrientation  ( ) )  {   case VERTICAL :   int  y ;  if  (  sideBeneathMouse ==  Position . NORTH )  {   y =  rect . y ; } else  {   y =   rect . y +  rect . height ; }   paint . drawInsertionLine  ( g ,  rect . x , y ,   rect . x +  rect . width , y ) ;  break ;   case HORIZONTAL :   int  x ;  if  (  sideBeneathMouse ==  Position . WEST )  {   x =  rect . x ; } else  {   x =   rect . x +  rect . width ; }   paint . drawInsertionLine  ( g , x ,  rect . y , x ,   rect . y +  rect . height ) ;  break ; } } } }    @ Override public String toString  ( )  {  return     this . getClass  ( ) . getSimpleName  ( ) + '@' +  Integer . toHexString  (  this . hashCode  ( ) ) ; }    @ SuppressWarnings  ( "serial" ) private class SizeFixedPanel  extends JPanel  {    @ Override public Dimension getPreferredSize  ( )  {  Dimension  pref =  super . getPreferredSize  ( ) ;  Insets  insets =  getInsets  ( ) ;    pref . height +=   insets . top +  insets . bottom ;    pref . width +=   insets . left +  insets . right ;  return pref ; }    @ Override public Dimension getMaximumSize  ( )  {  return  getPreferredSize  ( ) ; }    @ Override public Dimension getMinimumSize  ( )  {  return  getPreferredSize  ( ) ; } }   private JPanel  contentPane =  new SizeFixedPanel  ( ) ;   private JPanel  titlePane =  new SizeFixedPanel  ( ) ;    @ SuppressWarnings  ( "serial" ) private JPanel  basePane =  new SizeFixedPanel  ( )  {    @ Override public Dimension getPreferredSize  ( )  {  Dimension  titlePreferredSize =   getTitlePane  ( ) . getPreferredSize  ( ) ;  Dimension  contentPreferredSize =   getContentPane  ( ) . getPreferredSize  ( ) ;  Dimension  basePreferredSize = null ;  switch  (   ToolbarDockStation . this . getPosition  ( ) )  {   case NORTH :   case SOUTH :   basePreferredSize =  new Dimension  (   contentPreferredSize . width +  titlePreferredSize . width ,  contentPreferredSize . height ) ;  break ;   case WEST :   case EAST :   basePreferredSize =  new Dimension  (  contentPreferredSize . width ,   titlePreferredSize . height +  contentPreferredSize . height ) ;  break ;   case CENTER :   basePreferredSize =  this . getPreferredSize  ( ) ; }  Insets  insets =  basePane . getInsets  ( ) ;    basePreferredSize . height +=   insets . top +  insets . bottom ;    basePreferredSize . width +=   insets . left +  insets . right ;  return basePreferredSize ; } ; } ;   public JPanel getTitlePane  ( )  {  return  this . titlePane ; }    @ Override public void doLayout  ( )  {    System . out . println  (   this . toString  ( ) + "## doLayout() ##" ) ;   updateAlignment  ( ) ;   super . doLayout  ( ) ; }    @ Override public Dimension getPreferredSize  ( )  {  return   getBasePane  ( ) . getPreferredSize  ( ) ; }    @ Override public Dimension getMinimumSize  ( )  {  return  this . getPreferredSize  ( ) ; }    @ Override public Dimension getMaximumSize  ( )  {  return  this . getPreferredSize  ( ) ; }   private void updateAlignment  ( )  {  if  (    ToolbarDockStation . this . getPosition  ( ) != null )  {  switch  (   ToolbarDockStation . this . getPosition  ( ) )  {   case NORTH :   case SOUTH :   titlePane . setLayout  (  new BoxLayout  ( titlePane ,  BoxLayout . X_AXIS ) ) ;   contentPane . setLayout  (  new BoxLayout  ( contentPane ,  BoxLayout . X_AXIS ) ) ;   basePane . setLayout  (  new BoxLayout  ( basePane ,  BoxLayout . X_AXIS ) ) ;   titlePane . setAlignmentY  (  Component . CENTER_ALIGNMENT ) ;   contentPane . setAlignmentY  (  Component . CENTER_ALIGNMENT ) ;   basePane . setAlignmentY  (  Component . CENTER_ALIGNMENT ) ;   titlePane . setAlignmentX  (  Component . LEFT_ALIGNMENT ) ;   contentPane . setAlignmentX  (  Component . LEFT_ALIGNMENT ) ;   basePane . setAlignmentX  (  Component . LEFT_ALIGNMENT ) ;  break ;   case WEST :   case EAST :   titlePane . setLayout  (  new BoxLayout  ( titlePane ,  BoxLayout . Y_AXIS ) ) ;   contentPane . setLayout  (  new BoxLayout  ( contentPane ,  BoxLayout . Y_AXIS ) ) ;   basePane . setLayout  (  new BoxLayout  ( basePane ,  BoxLayout . Y_AXIS ) ) ;   titlePane . setAlignmentY  (  Component . TOP_ALIGNMENT ) ;   contentPane . setAlignmentY  (  Component . TOP_ALIGNMENT ) ;   basePane . setAlignmentY  (  Component . TOP_ALIGNMENT ) ;   titlePane . setAlignmentX  (  Component . CENTER_ALIGNMENT ) ;   contentPane . setAlignmentX  (  Component . CENTER_ALIGNMENT ) ;   basePane . setAlignmentX  (  Component . CENTER_ALIGNMENT ) ;  break ;   case CENTER :  break ;   default :  throw  new IllegalArgumentException  ( ) ; } } } }   public DefaultStationPaintValue getPaint  ( )  {  return paint ; }    @ Override public void setController  (  DockController controller )  {  if  (   getController  ( ) != controller )  {  if  (   getController  ( ) != null )  {   dockables . unbind  ( ) ; }   super . setController  ( controller ) ;   paint . setController  ( controller ) ;   placeholderStrategy . setProperties  ( controller ) ;  if  (  controller != null )  {   dockables . bind  ( ) ; } } }   protected OverpaintablePanelBase  mainPanel =  new OverpaintablePanelBase  ( ) ;   private Position  position =  Position . NORTH ;   private ToolbarDockTitleRequest  titleRequest = null ;   public void setTitleRequest  (  ToolbarDockTitleRequest titleRequest )  {    this . titleRequest = titleRequest ; }   public ToolbarDockTitleRequest getTitleRequest  ( )  {  return  this . titleRequest ; }    @ Override public void setPosition  (  Position position )  {    System . out . println  (    this . toString  ( ) + "## setPosition( Position position ) ## ==> " + position ) ;    this . position = position ;  for ( Dockable d :  dockables . dockables  ( ) )  {  if  (  d instanceof PositionedDockStation )  {  PositionedDockStation  group =  ( PositionedDockStation ) d ;   group . setPosition  (  this . getPosition  ( ) ) ; } }    this . mainPanel . doLayout  ( ) ; }    @ Override public Position getPosition  ( )  {  return  this . position ; }   public JPanel getTitlePane  ( )  {  return   this . mainPanel . getTitlePane  ( ) ; } }