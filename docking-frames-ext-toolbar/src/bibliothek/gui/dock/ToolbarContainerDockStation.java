  package   bibliothek . gui . dock ;   import   java . awt . BorderLayout ;  import   java . awt . Component ;  import   java . awt . Dimension ;  import   java . awt . Graphics ;  import   java . awt . GridLayout ;  import   java . awt . Insets ;  import   java . awt . Point ;  import   java . awt . Rectangle ;  import   java . io . IOException ;  import   java . util . ArrayList ;  import   java . util . Map ;  import   javax . swing . JPanel ;  import   javax . swing . SwingUtilities ;  import    javax . swing . border . CompoundBorder ;  import    javax . swing . border . EmptyBorder ;  import    javax . swing . border . EtchedBorder ;  import   bibliothek . gui . DockController ;  import   bibliothek . gui . DockStation ;  import   bibliothek . gui . Dockable ;  import   bibliothek . gui . ToolbarElementInterface ;  import   bibliothek . gui . ToolbarInterface ;  import     bibliothek . gui . dock . layout . DockableProperty ;  import     bibliothek . gui . dock . station . AbstractDockableStation ;  import     bibliothek . gui . dock . station . OverpaintablePanel ;  import     bibliothek . gui . dock . station . StationDropOperation ;  import     bibliothek . gui . dock . station . StationPaint ;  import      bibliothek . gui . dock . station . support . DockablePlaceholderList ;  import      bibliothek . gui . dock . station . support . PlaceholderMap ;  import      bibliothek . gui . dock . station . support . PlaceholderStrategy ;  import      bibliothek . gui . dock . station . toolbar . DefaultToolbarContainerConverter ;  import      bibliothek . gui . dock . station . toolbar . ToolbarContainerConverter ;  import      bibliothek . gui . dock . station . toolbar . ToolbarContainerConverterCallback ;  import      bibliothek . gui . dock . station . toolbar . ToolbarContainerDockStationFactory ;  import      bibliothek . gui . dock . station . toolbar . ToolbarContainerDropInfo ;  import      bibliothek . gui . dock . station . toolbar . ToolbarContainerProperty ;  import      bibliothek . gui . dock . station . toolbar . ToolbarStrategy ;  import     bibliothek . gui . dock . themes . DefaultStationPaintValue ;  import     bibliothek . gui . dock . themes . ThemeManager ;  import     bibliothek . gui . dock . util . DockUtilities ;  import     bibliothek . gui . dock . util . PropertyValue ;  import     bibliothek . gui . dock . util . SilentPropertyValue ;  import   java . awt . Color ;  import   javax . swing . BoxLayout ;  import   bibliothek . gui . Position ;  import   bibliothek . gui . Orientation ;  import   bibliothek . gui . PositionedDockStation ;  import      bibliothek . gui . dock . station . toolbar . ToolbarDockTitleRequest ;  import      bibliothek . gui . dock . themes . basic . BasicDockTitle ;  import     bibliothek . gui . dock . title . DockTitle ;  import     bibliothek . gui . dock . title . DockTitleManager ;  import     bibliothek . gui . dock . title . DockTitleRequest ;  import     bibliothek . gui . dock . title . DockTitleVersion ;   public class ToolbarContainerDockStation  extends AbstractDockableStation  implements  ToolbarInterface  {   private JPanel  westPanel ;   private JPanel  eastPanel ;   private JPanel  northPanel ;   private JPanel  southPanel ;   private JPanel  centerPanel =  new JPanel  (  new GridLayout  ( 1 , 1 ) ) ;   private  DockablePlaceholderList  < Dockable >  westDockables =  new  DockablePlaceholderList  < Dockable >  ( ) ;   private  DockablePlaceholderList  < Dockable >  eastDockables =  new  DockablePlaceholderList  < Dockable >  ( ) ;   private  DockablePlaceholderList  < Dockable >  northDockables =  new  DockablePlaceholderList  < Dockable >  ( ) ;   private  DockablePlaceholderList  < Dockable >  southDockables =  new  DockablePlaceholderList  < Dockable >  ( ) ;   private  ArrayList  < Dockable >  allDockables =  new  ArrayList  < Dockable >  ( ) ;   private  DockablePlaceholderList  < Dockable >  centerDockable =  new  DockablePlaceholderList  < Dockable >  ( ) ;   private DefaultStationPaintValue  paint ;   private Integer  indexBeneathMouse = null ;   private Position  sideAboveMouse = null ;   private Position  areaBeneathMouse = null ;   private  PropertyValue  < PlaceholderStrategy >  placeholderStrategy =  new  PropertyValue  < PlaceholderStrategy >  (  PlaceholderStrategy . PLACEHOLDER_STRATEGY )  {    @ Override protected void valueChanged  (  PlaceholderStrategy oldValue ,  PlaceholderStrategy newValue )  {   westDockables . setStrategy  ( newValue ) ;   eastDockables . setStrategy  ( newValue ) ;   southDockables . setStrategy  ( newValue ) ;   northDockables . setStrategy  ( newValue ) ;   centerDockable . setStrategy  ( newValue ) ; } } ;   public ToolbarContainerDockStation  ( )  {   mainPanel =  new OverpaintablePanelBase  ( ) ;   paint =  new DefaultStationPaintValue  (   ThemeManager . STATION_PAINT + ".toolbar" , this ) ; }    @ Override public  int getDockableCount  ( )  {  return  allDockables . size  ( ) ; }    @ Override public Dockable getDockable  (   int index )  {  return  allDockables . get  ( index ) ; }    @ Override public Dockable getFrontDockable  ( )  {  return null ; }    @ Override public void setFrontDockable  (  Dockable dockable )  { }    @ Override public PlaceholderMap getPlaceholders  ( )  {  return   createConverter  ( ) . getPlaceholders  ( this ) ; }   public PlaceholderMap getPlaceholders  (   Map  < Dockable , Integer > children )  {  return   createConverter  ( ) . getPlaceholders  ( this , children ) ; }    @ Override public void setPlaceholders  (  PlaceholderMap placeholders )  {    createConverter  ( ) . setPlaceholders  ( this , placeholders ) ; }   public void setPlaceholders  (  PlaceholderMap placeholders ,   Map  < Integer , Dockable > children )  {    createConverter  ( ) . setPlaceholders  ( this ,  new ToolbarContainerConverterCallback  ( )  {   final   int  [ ]  index =  new  int  [   Position . values  ( ) . length ] ;    @ Override public void adding  (  Position area ,  Dockable dockable )  {   listeners . fireDockableAdding  ( dockable ) ; }    @ Override public void added  (  Position area ,  Dockable dockable )  {  if  (  area ==  Position . CENTER )  {   centerPanel . add  (  dockable . getComponent  ( ) ) ; } else  {   insertAt  ( area , dockable ,   index [  area . ordinal  ( ) ] ++ ) ; }   dockable . setDockParent  (  ToolbarContainerDockStation . this ) ;   listeners . fireDockableAdded  ( dockable ) ; }    @ Override public void setDockables  (  Position area ,   DockablePlaceholderList  < Dockable > list )  {    ToolbarContainerDockStation . this . setDockables  ( area , list , false ) ; }   public void finished  (   DockablePlaceholderList  < Dockable > list )  {  if  (   getController  ( ) != null )  {   list . bind  ( ) ;   list . setStrategy  (  getPlaceholderStrategy  ( ) ) ; } } } , placeholders , children ) ; }   public void setPlaceholders  (  Position position ,  PlaceholderMap map )  {  if  (   getDockableCount  ( ) > 0 )  {  throw  new IllegalStateException  ( "there are children on this station" ) ; }  try  {   DockablePlaceholderList  < Dockable >  next =  new  DockablePlaceholderList  < Dockable >  ( map ) ;   setDockables  ( position , next , true ) ; }  catch (   IllegalArgumentException ex )  { } }   protected ToolbarContainerConverter createConverter  ( )  {  return  new DefaultToolbarContainerConverter  ( ) ; }   public PlaceholderStrategy getPlaceholderStrategy  ( )  {  return  placeholderStrategy . getValue  ( ) ; }   public void setPlaceholderStrategy  (  PlaceholderStrategy strategy )  {   placeholderStrategy . setValue  ( strategy ) ; }    @ Override public DockableProperty getDockableProperty  (  Dockable child ,  Dockable target )  {  for ( Position position :  Position . values  ( ) )  {   int  index =  indexOf  ( position , child ) ;  if  (  index >= 0 )  {  return  new ToolbarContainerProperty  ( index , position , null ) ; } }  return  new ToolbarContainerProperty  ( 0 ,  Position . CENTER , null ) ; }   public StationDropOperation prepareDrop  (   int mouseX ,   int mouseY ,   int titleX ,   int titleY ,  boolean checkOverrideZone ,  Dockable dockable )  {    System . out . println  (   this . toString  ( ) + "## prepareDrop(...) ##" ) ;  DockController  controller =  getController  ( ) ;  if  (  checkOverrideZone &   this . getDockParent  ( ) != null )  {  if  (   this . getDockParent  ( ) . isInOverrideZone  ( mouseX , mouseY , this , dockable ) )  {  return null ; } }  if  (   this . accept  ( dockable ) &  dockable . accept  ( this ) )  {  if  (  controller != null )  {  if  (  !   controller . getAcceptance  ( ) . accept  ( this , dockable ) )  {  return null ; } }   DockablePlaceholderList  < Dockable >  associateToolbars ;  Position  area ;  Point  mousePoint =  new Point  ( mouseX , mouseY ) ;   SwingUtilities . convertPointFromScreen  ( mousePoint ,  mainPanel . getContentPane  ( ) ) ;    System . out . println  (    "		==> MOUSE: " + mouseX + "/" + mouseY ) ;  if  (   westPanel . getBounds  ( ) . contains  ( mousePoint ) )  {   associateToolbars = westDockables ;   area =  Position . WEST ; } else  if  (   eastPanel . getBounds  ( ) . contains  ( mousePoint ) )  {   associateToolbars = eastDockables ;   area =  Position . EAST ; } else  if  (   northPanel . getBounds  ( ) . contains  ( mousePoint ) )  {   associateToolbars = northDockables ;   area =  Position . NORTH ; } else  if  (   southPanel . getBounds  ( ) . contains  ( mousePoint ) )  {   associateToolbars = southDockables ;   area =  Position . SOUTH ; } else  {  return null ; }  if  (  !   getToolbarStrategy  ( ) . isToolbarPart  ( dockable ) )  {  return null ; }    System . out . println  (  "		==> AREA: " + area ) ;  return  new ToolbarContainerDropInfo  ( dockable , this , associateToolbars , area , mouseX , mouseY )  {    @ Override public void execute  ( )  {   drop  ( this ) ; }    @ Override public void destroy  ( )  {     ToolbarContainerDockStation . this . indexBeneathMouse = null ;     ToolbarContainerDockStation . this . sideAboveMouse = null ;     ToolbarContainerDockStation . this . mainPanel . repaint  ( ) ; }    @ Override public void draw  ( )  {     ToolbarContainerDockStation . this . indexBeneathMouse =  indexOf  (  getArea  ( ) ,  getDockableBeneathMouse  ( ) ) ;     ToolbarContainerDockStation . this . sideAboveMouse =  this . getSideDockableBeneathMouse  ( ) ;     ToolbarContainerDockStation . this . areaBeneathMouse =  this . getArea  ( ) ;     ToolbarContainerDockStation . this . mainPanel . repaint  ( ) ; } } ; } else  {  return null ; } }   private void drop  (  ToolbarContainerDropInfo dropInfo )  {  Position  area =  dropInfo . getArea  ( ) ;  if  (     this . getDockables  ( area ) . dockables  ( ) . size  ( ) == 0 )  {   drop  (  dropInfo . getItem  ( ) , 0 , area ) ; }  if  (   dropInfo . getItemPositionVSBeneathDockable  ( ) !=  Position . CENTER )  {   int  indexBeneathMouse =  indexOf  ( area ,  dropInfo . getDockableBeneathMouse  ( ) ) ;   int  dropIndex ;  boolean  isMove = false ;  if  (  dropInfo . isMove  ( ) )  {  if  (   dropInfo . getArea  ( ) ==  this . getArea  (  dropInfo . getItem  ( ) ) )  {   isMove = true ; } }  if  ( isMove )  {  switch  (  this . getOrientation  ( area ) )  {   case VERTICAL :  if  (   dropInfo . getItemPositionVSBeneathDockable  ( ) ==  Position . SOUTH )  {  if  (   dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . SOUTH )  {   dropIndex =  indexBeneathMouse + 1 ; } else  {   dropIndex = indexBeneathMouse ; } } else  {  if  (   dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . SOUTH )  {   dropIndex = indexBeneathMouse ; } else  {   dropIndex =  indexBeneathMouse - 1 ; } }   move  (  dropInfo . getItem  ( ) , dropIndex , area ) ;  break ;   case HORIZONTAL :  if  (   dropInfo . getItemPositionVSBeneathDockable  ( ) ==  Position . EAST )  {  if  (   dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . EAST )  {   dropIndex =  indexBeneathMouse + 1 ; } else  {   dropIndex = indexBeneathMouse ; } } else  {  if  (   dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . EAST )  {   dropIndex = indexBeneathMouse ; } else  {   dropIndex =  indexBeneathMouse - 1 ; } }   move  (  dropInfo . getItem  ( ) , dropIndex , area ) ;  break ; } } else  {   int  increment = 0 ;  if  (    dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . SOUTH ||   dropInfo . getSideDockableBeneathMouse  ( ) ==  Position . EAST )  {   increment ++ ; }   dropIndex =  indexBeneathMouse + increment ;   drop  (  dropInfo . getItem  ( ) , dropIndex , area ) ; } } }    @ Override public void drop  (  Dockable dockable )  {    System . out . println  (   this . toString  ( ) + "## drop(Dockable dockable)##" ) ;  if  (   getToolbarStrategy  ( ) . isToolbarPart  ( dockable ) )  {   this . drop  ( dockable ,    getDockables  (  Position . NORTH ) . dockables  ( ) . size  ( ) ,  Position . NORTH ) ; } else  {   this . drop  ( dockable ,  - 1 ,  Position . CENTER ) ; } }    @ Override public boolean drop  (  Dockable dockable ,  DockableProperty property )  {  if  (  property instanceof ToolbarContainerProperty )  {  ToolbarContainerProperty  toolbar =  ( ToolbarContainerProperty ) property ;  if  (   toolbar . getSuccessor  ( ) != null )  {  Dockable  preset = null ;  if  (   toolbar . getArea  ( ) ==  Position . CENTER )  {   preset =  getCenterDockable  ( ) ; } else  {   DockablePlaceholderList  < Dockable >  list =  getDockables  (  toolbar . getArea  ( ) ) ;  if  (   toolbar . getIndex  ( ) <   list . dockables  ( ) . size  ( ) )  {   preset =   list . dockables  ( ) . get  (  toolbar . getIndex  ( ) ) ; } }  if  (   preset != null &&   preset . asDockStation  ( ) != null )  {  return   preset . asDockStation  ( ) . drop  ( dockable ,  property . getSuccessor  ( ) ) ; } }  if  (   toolbar . getArea  ( ) ==  Position . CENTER )  {  return  drop  ( dockable ,  Position . CENTER ) ; } else  {   int  max =    getDockables  (  toolbar . getArea  ( ) ) . dockables  ( ) . size  ( ) ;  return  drop  ( dockable ,  Math . min  ( max ,  toolbar . getIndex  ( ) ) ,  toolbar . getArea  ( ) ) ; } }  return false ; }   public boolean drop  (  Dockable dockable ,  Position area )  {    System . out . println  (   this . toString  ( ) + "## drop(Dockable dockable, Position area)##" ) ;  return  this . drop  ( dockable ,    getDockables  ( area ) . dockables  ( ) . size  ( ) , area ) ; }   private boolean drop  (  Dockable dockable ,   int index ,  Position area )  {    System . out . println  (   this . toString  ( ) + "## drop(Dockable dockable, int index, Position area)##" ) ;  return  this . add  ( dockable , index , area ) ; }   private void move  (  Dockable dockable ,   int indexWhereInsert ,  Position area )  {    System . out . println  (    this . toString  ( ) + "## move() ## ==> " + area ) ;  switch  ( area )  {   case CENTER :  break ;   case NORTH :   case SOUTH :   case WEST :   case EAST :  if  (   getToolbarStrategy  ( ) . isToolbarPart  ( dockable ) )  {  DockController  controller =  getController  ( ) ;  try  {  if  (  controller != null )  {   controller . freezeLayout  ( ) ; }   this . add  ( dockable , indexWhereInsert , area ) ; }  finally  {  if  (  controller != null )  {   controller . meltLayout  ( ) ; } } }  break ;   default :  throw  new NullPointerException  ( ) ; } }    @ Override public void move  (  Dockable dockable ,  DockableProperty property )  {    System . out . println  (    this . toString  ( ) + "## move(Dockable dockable, DockableProperty property) ## " +  this . toString  ( ) ) ; }    @ Override public  <  D  extends Dockable & DockStation > boolean isInOverrideZone  (   int x ,   int y ,  D invoker ,  Dockable drop )  {  return false ; }    @ Override public boolean canDrag  (  Dockable dockable )  {    System . out . println  (    this . toString  ( ) + "## canDrag(Dockable dockable) ## " +  this . toString  ( ) ) ;  return true ; }    @ Override public void drag  (  Dockable dockable )  {    System . out . println  (   this . toString  ( ) + "## drag(Dockable dockable) ##" ) ;  if  (   dockable . getDockParent  ( ) != this )  throw  new IllegalArgumentException  ( "The dockable cannot be dragged, it is not child of this station." ) ;   this . remove  ( dockable ) ; }    @ Override public boolean canReplace  (  Dockable old ,  Dockable next )  {    System . out . println  (    this . toString  ( ) + "## canReplace(Dockable old, Dockable next) ## " +  this . toString  ( ) ) ;  if  (   old . getClass  ( ) ==  next . getClass  ( ) )  {  return true ; } else  {  return false ; } }    @ Override public void replace  (  Dockable old ,  Dockable next )  {    System . out . println  (    this . toString  ( ) + "## replace(Dockable old, Dockable next) ## " +  this . toString  ( ) ) ;   DockUtilities . checkLayoutLocked  ( ) ;  DockController  controller =  getController  ( ) ;  if  (  controller != null )   controller . freezeLayout  ( ) ;  Position  area =  getArea  ( old ) ;   int  index =  areaIndexOf  (  ( Dockable ) old ) ;   this . remove  ( old ) ;   add  (  ( ToolbarGroupDockStation ) next , index , area ) ;   controller . meltLayout  ( ) ; }    @ Override public void replace  (  DockStation old ,  Dockable next )  {    System . out . println  (    this . toString  ( ) + "## replace(DockStation old, Dockable next) ## " +  this . toString  ( ) ) ;   replace  (  old . asDockable  ( ) , next ) ; }    @ Override public String getFactoryID  ( )  {  return  ToolbarContainerDockStationFactory . ID ; }    @ Override public Component getComponent  ( )  {  return mainPanel ; }    @ Override protected void callDockUiUpdateTheme  ( )  throws IOException  { }   public ToolbarStrategy getToolbarStrategy  ( )  {   SilentPropertyValue  < ToolbarStrategy >  value =  new  SilentPropertyValue  < ToolbarStrategy >  (  ToolbarStrategy . STRATEGY ,  getController  ( ) ) ;  ToolbarStrategy  result =  value . getValue  ( ) ;   value . setProperties  (  ( DockController ) null ) ;  return result ; }    @ Override public boolean accept  (  Dockable child )  {    System . out . println  (   this . toString  ( ) + "## accept(Dockable child) ##" ) ;  return true ; }    @ Override public boolean accept  (  DockStation station )  {    System . out . println  (   this . toString  ( ) + "## accept(DockStation station) ##" ) ;  return true ; }    @ Override public String toString  ( )  {  return     this . getClass  ( ) . getSimpleName  ( ) + '@' +  Integer . toHexString  (  this . hashCode  ( ) ) ; }   public Dockable getCenterDockable  ( )  {     DockablePlaceholderList . Filter < Dockable >  filter =  centerDockable . dockables  ( ) ;  if  (   filter . size  ( ) == 0 )  {  return null ; } else  {  return  filter . get  ( 0 ) ; } }   private void setCenterDockable  (  Dockable dockable )  {     DockablePlaceholderList . Filter < Dockable >  filter =  centerDockable . dockables  ( ) ;  if  (  dockable == null )  {  if  (   filter . size  ( ) > 0 )  {   filter . remove  ( 0 ) ; } } else  {  if  (   filter . size  ( ) >= 1 )  {   filter . set  ( 0 , dockable ) ; } else  {   filter . add  ( dockable ) ; } } }   private void setDockables  (  Position area ,   DockablePlaceholderList  < Dockable > list ,  boolean bind )  {  if  (   getController  ( ) != null )  {   DockablePlaceholderList  < Dockable >  oldList =  getDockables  ( area ) ;   oldList . setStrategy  ( null ) ;   oldList . unbind  ( ) ; }  switch  ( area )  {   case EAST :   eastDockables = list ;  break ;   case WEST :   westDockables = list ;  break ;   case NORTH :   northDockables = list ;  break ;   case SOUTH :   southDockables = list ;  break ;   case CENTER :   centerDockable = list ;  break ;   default :  throw  new IllegalArgumentException  (  "invalid area: " + area ) ; }  if  (    getController  ( ) != null && bind )  {   list . bind  ( ) ;   list . setStrategy  (  getPlaceholderStrategy  ( ) ) ; } }   public  DockablePlaceholderList  < Dockable > getDockables  (  Position area )  {  switch  ( area )  {   case CENTER :  return centerDockable ;   case EAST :  return eastDockables ;   case WEST :  return westDockables ;   case NORTH :  return northDockables ;   case SOUTH :  return southDockables ;   default :  throw  new IllegalArgumentException  (  "unknown area: " + area ) ; } }   public JPanel getPanel  (  Position area )  {  switch  ( area )  {   case NORTH :  return  this . northPanel ;   case SOUTH :  return  this . southPanel ;   case WEST :  return  this . westPanel ;   case EAST :  return  this . eastPanel ;   case CENTER :  return  this . centerPanel ; }  throw  new IllegalArgumentException  ( ) ; }   public Position getArea  (  Dockable dockable )  {  for ( Position position :  Position . values  ( ) )  {  if  (   indexOf  ( position , dockable ) >= 0 )  {  return position ; } }  return null ; }   public Orientation getOrientation  (  Position area )  {  switch  ( area )  {   case NORTH :   case SOUTH :  return  Orientation . HORIZONTAL ;   case WEST :   case EAST :  return  Orientation . VERTICAL ;   case CENTER :  return null ;   default :  throw  new IllegalArgumentException  (  "unknown area: " + area ) ; } }   private  int indexOf  (  Position position ,  Dockable child )  {   DockablePlaceholderList  < Dockable >  list =  getDockables  ( position ) ;   int  index = 0 ;  for ( Dockable handle :  list . dockables  ( ) )  {  if  (  handle == child )  {  return index ; }   index ++ ; }  return  - 1 ; }   private  int globalIndexOf  (  Dockable dockable )  {   int  index = 0 ;  for ( Dockable d : allDockables )  {  if  (  d == dockable )  {  return index ; }   index ++ ; }  return  - 1 ; }   private  int areaIndexOf  (  Dockable dockable )  {  Position  area =  getArea  ( dockable ) ;  if  (  area == null )  {  return  - 1 ; }  return  indexOf  ( area , dockable ) ; }   private void remove  (  Dockable dockable )  {   DockUtilities . checkLayoutLocked  ( ) ;  Position  area =  getArea  ( dockable ) ;   DockHierarchyLock . Token  token =  DockHierarchyLock . acquireUnlinking  ( this , dockable ) ;  try  {   int  globalIndex =  globalIndexOf  ( dockable ) ;  switch  ( area )  {   case CENTER :   listeners . fireDockableRemoving  ( dockable ) ;   dockable . setDockParent  ( null ) ;   centerDockable = null ;   allDockables . remove  ( globalIndex ) ;   centerPanel . remove  (  dockable . getComponent  ( ) ) ;   centerPanel . revalidate  ( ) ;   listeners . fireDockableRemoved  ( dockable ) ;   fireDockablesRepositioned  ( globalIndex ) ;  break ;   case NORTH :   case SOUTH :   case WEST :   case EAST :  JPanel  panel =  getPanel  ( area ) ;     DockablePlaceholderList . Filter < Dockable >  dockables =   getDockables  ( area ) . dockables  ( ) ;   listeners . fireDockableRemoving  ( dockable ) ;   dockable . setDockParent  ( null ) ;   dockables . remove  ( dockable ) ;   allDockables . remove  ( globalIndex ) ;   panel . remove  (  dockable . getComponent  ( ) ) ;    mainPanel . getContentPane  ( ) . setBounds  ( 0 , 0 ,    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . width ,    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . height ) ;   mainPanel . setPreferredSize  (  new Dimension  (    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . width ,    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . height ) ) ;    mainPanel . getContentPane  ( ) . revalidate  ( ) ;    mainPanel . getContentPane  ( ) . repaint  ( ) ;   listeners . fireDockableRemoved  ( dockable ) ;   fireDockablesRepositioned  ( globalIndex ) ;  break ;   default :  throw  new NullPointerException  ( ) ; } }  finally  {   token . release  ( ) ; } }   private void addAll  (   DockablePlaceholderList  < Dockable > list )  {  for ( Dockable dockable :  list . dockables  ( ) )  {   allDockables . add  ( dockable ) ; } }   protected boolean add  (  Dockable dockable ,   int index ,  Position area )  {   DockUtilities . ensureTreeValidity  ( this , dockable ) ;   DockUtilities . checkLayoutLocked  ( ) ;  ToolbarStrategy  strategy =  getToolbarStrategy  ( ) ;  switch  ( area )  {   case CENTER :  if  (  !  strategy . isToolbarPart  ( dockable ) )  {   DockHierarchyLock . Token  token =  DockHierarchyLock . acquireLinking  ( this , dockable ) ;  try  {  if  (   getCenterDockable  ( ) != null )  {   remove  ( dockable ) ; }   dockable . setDockParent  ( this ) ;   listeners . fireDockableAdding  ( dockable ) ;   centerPanel . add  (  dockable . getComponent  ( ) , index ) ;   setCenterDockable  ( dockable ) ;   updateListOfDockables  ( ) ;   centerPanel . revalidate  ( ) ;   centerPanel . repaint  ( ) ;   listeners . fireDockableAdded  ( dockable ) ;   fireDockablesRepositioned  (  index + 1 ) ; }  finally  {   token . release  ( ) ; }  return true ; }  break ;   case NORTH :   case SOUTH :   case WEST :   case EAST :  if  (  strategy . isToolbarPart  ( dockable ) )  {   dockable =  strategy . ensureToolbarLayer  ( this , dockable ) ;   DockHierarchyLock . Token  token =  DockHierarchyLock . acquireLinking  ( this , dockable ) ;  try  {   dockable . setDockParent  ( this ) ;   listeners . fireDockableAdding  ( dockable ) ;     DockablePlaceholderList . Filter < Dockable >  dockables =   getDockables  ( area ) . dockables  ( ) ;  if  (  dockable instanceof PositionedDockStation )  {    (  ( PositionedDockStation ) dockable ) . setPosition  ( area ) ; }    System . out . println  (  "		==> INDEX: " + index ) ;  if  (   dockable . getClass  ( ) ==  ToolbarDockStation . class )  {  ToolbarDockStation  dockableToolbar =  ( ToolbarDockStation ) dockable ;  ToolbarDockTitleRequest  titleRequest =   (   dockableToolbar . getTitleRequest  ( ) != null ) ?  dockableToolbar . getTitleRequest  ( ) :  new ToolbarDockTitleRequest  ( this , dockable ,  this . titleVersion ) ;   titleRequest . setPosition  ( area ) ;   dockableToolbar . setTitleRequest  ( titleRequest ) ;   titleRequest . request  ( ) ; }   dockables . add  ( index , dockable ) ;   insertAt  ( area , dockable , index ) ;   listeners . fireDockableAdded  ( dockable ) ;   fireDockablesRepositioned  (  index + 1 ) ; }  finally  {   token . release  ( ) ; }   mainPanel . revalidate  ( ) ;  return true ; }  break ;   default :  throw  new IllegalStateException  (  "Unknown area: " + area ) ; }  return false ; }   private void insertAt  (  Position area ,  Dockable dockable ,   int index )  {  JPanel  panel =  getPanel  ( area ) ;  if  (  dockable instanceof PositionedDockStation )  {    (  ( PositionedDockStation ) dockable ) . setPosition  ( area ) ; }   dockable . setDockParent  ( this ) ;   updateListOfDockables  ( ) ;   panel . add  (  dockable . getComponent  ( ) , index ) ;    mainPanel . getContentPane  ( ) . setBounds  ( 0 , 0 ,    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . width ,    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . height ) ;   mainPanel . setPreferredSize  (  new Dimension  (    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . width ,    mainPanel . getContentPane  ( ) . getPreferredSize  ( ) . height ) ) ;    mainPanel . getContentPane  ( ) . revalidate  ( ) ;    mainPanel . getContentPane  ( ) . repaint  ( ) ; }   protected class OverpaintablePanelBase  extends OverpaintablePanel  {   private JPanel  content =  new JPanel  (  new BorderLayout  ( ) ) ;   public OverpaintablePanelBase  ( )  {   westPanel =  createSidePanel  (  Position . WEST ) ;   eastPanel =  createSidePanel  (  Position . EAST ) ;   northPanel =  createSidePanel  (  Position . NORTH ) ;   southPanel =  createSidePanel  (  Position . SOUTH ) ;   content . add  ( westPanel ,  BorderLayout . WEST ) ;   content . add  ( eastPanel ,  BorderLayout . EAST ) ;   content . add  ( northPanel ,  BorderLayout . NORTH ) ;   content . add  ( southPanel ,  BorderLayout . SOUTH ) ;   content . add  ( centerPanel ,  BorderLayout . CENTER ) ;   content . setBounds  ( 0 , 0 ,   content . getPreferredSize  ( ) . width ,   content . getPreferredSize  ( ) . height ) ;   this . setPreferredSize  (  new Dimension  (   content . getPreferredSize  ( ) . width ,   content . getPreferredSize  ( ) . height ) ) ;   setBasePane  ( content ) ;   setContentPane  ( content ) ;    this . getContentPane  ( ) . revalidate  ( ) ;    this . getContentPane  ( ) . repaint  ( ) ; }    @ Override protected void paintOverlay  (  Graphics g )  {  DefaultStationPaintValue  paint =  getPaint  ( ) ;  if  (  indexBeneathMouse != null )  {  Rectangle  rectangleAreaBeneathMouse =   getPanel  ( areaBeneathMouse ) . getBounds  ( ) ;  if  (  indexBeneathMouse ==  - 1 )  {   paint . drawDivider  ( g , rectangleAreaBeneathMouse ) ; } else  {  Rectangle  rectComponentBeneathMouse =      getDockables  ( areaBeneathMouse ) . dockables  ( ) . get  ( indexBeneathMouse ) . getComponent  ( ) . getBounds  ( ) ;   rectComponentBeneathMouse . translate  (  rectangleAreaBeneathMouse . x ,  rectangleAreaBeneathMouse . y ) ;   paint . drawDivider  ( g , rectComponentBeneathMouse ) ;  if  (  rectComponentBeneathMouse != null )  {  switch  (   ToolbarContainerDockStation . this . getOrientation  ( areaBeneathMouse ) )  {   case VERTICAL :   int  y ;  if  (  sideAboveMouse ==  Position . NORTH )  {   y =  rectComponentBeneathMouse . y ; } else  {   y =   rectComponentBeneathMouse . y +  rectComponentBeneathMouse . height ; }   paint . drawInsertionLine  ( g ,  rectComponentBeneathMouse . x , y ,   rectComponentBeneathMouse . x +  rectComponentBeneathMouse . width , y ) ;  break ;   case HORIZONTAL :   int  x ;  if  (  sideAboveMouse ==  Position . WEST )  {   x =  rectComponentBeneathMouse . x ; } else  {   x =   rectComponentBeneathMouse . x +  rectComponentBeneathMouse . width ; }   paint . drawInsertionLine  ( g , x ,  rectComponentBeneathMouse . y , x ,   rectComponentBeneathMouse . y +  rectComponentBeneathMouse . height ) ;  break ; } } } } }    @ Override public String toString  ( )  {  return     this . getClass  ( ) . getSimpleName  ( ) + '@' +  Integer . toHexString  (  this . hashCode  ( ) ) ; } }   public DefaultStationPaintValue getPaint  ( )  {  return paint ; }    @ Override public void setController  (  DockController controller )  {  if  (   getController  ( ) != controller )  {  if  (   getController  ( ) != null )  {   westDockables . unbind  ( ) ;   eastDockables . unbind  ( ) ;   southDockables . unbind  ( ) ;   northDockables . unbind  ( ) ;   centerDockable . unbind  ( ) ; }   super . setController  ( controller ) ;   paint . setController  ( controller ) ;  DockTitleManager  titleManager =  controller . getDockTitleManager  ( ) ;    this . titleVersion =  titleManager . getVersion  ( TITLE_ID ,  BasicDockTitle . FACTORY ) ;   placeholderStrategy . setProperties  ( controller ) ;  if  (  controller != null )  {   westDockables . bind  ( ) ;   eastDockables . bind  ( ) ;   southDockables . bind  ( ) ;   northDockables . bind  ( ) ;   centerDockable . bind  ( ) ; } } }   public static final String  TITLE_ID = "toolbar" ;   protected OverpaintablePanelBase  mainPanel =  new OverpaintablePanelBase  ( ) ;   private DockTitleVersion  titleVersion ;   private JPanel createSidePanel  (  Position orientation )  {  JPanel  panel =  new JPanel  ( ) ;  switch  ( orientation )  {   case NORTH :   case SOUTH :   panel . setLayout  (  new BoxLayout  ( panel ,  BoxLayout . X_AXIS ) ) ;   panel . setAlignmentX  (  Component . LEFT_ALIGNMENT ) ;  break ;   case WEST :   case EAST :   panel . setLayout  (  new BoxLayout  ( panel ,  BoxLayout . Y_AXIS ) ) ;  break ;   case CENTER :  throw  new IllegalArgumentException  ( ) ; }   panel . setBorder  (  new CompoundBorder  (  new EtchedBorder  ( ) ,  new EmptyBorder  (  new Insets  ( 5 , 5 , 5 , 5 ) ) ) ) ;   panel . setBackground  (  new Color  ( 31 , 73 , 125 ) ) ;  return panel ; }   public void updateListOfDockables  ( )  {   allDockables . clear  ( ) ;   addAll  ( westDockables ) ;   addAll  ( northDockables ) ;   addAll  ( eastDockables ) ;   addAll  ( southDockables ) ;   addAll  ( centerDockable ) ; } }