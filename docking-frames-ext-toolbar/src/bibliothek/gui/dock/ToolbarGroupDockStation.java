  package   bibliothek . gui . dock ;   import   java . awt . BasicStroke ;  import   java . awt . BorderLayout ;  import   java . awt . Color ;  import   java . awt . Component ;  import   java . awt . Container ;  import   java . awt . Dimension ;  import   java . awt . Graphics ;  import   java . awt . Graphics2D ;  import   java . awt . Insets ;  import   java . awt . Point ;  import   java . awt . Rectangle ;  import   java . io . IOException ;  import   java . util . ArrayList ;  import   java . util . Iterator ;  import   java . util . List ;  import   java . util . Map ;  import   javax . swing . JPanel ;  import   javax . swing . SwingUtilities ;  import   bibliothek . gui . DockController ;  import   bibliothek . gui . DockStation ;  import   bibliothek . gui . DockUI ;  import   bibliothek . gui . Dockable ;  import   bibliothek . gui . Orientation ;  import   bibliothek . gui . Position ;  import   bibliothek . gui . ToolbarElementInterface ;  import   bibliothek . gui . ToolbarInterface ;  import     bibliothek . gui . dock . event . DockStationListener ;  import     bibliothek . gui . dock . layout . DockableProperty ;  import     bibliothek . gui . dock . security . SecureContainer ;  import     bibliothek . gui . dock . station . DisplayerCollection ;  import     bibliothek . gui . dock . station . DisplayerFactory ;  import     bibliothek . gui . dock . station . DockableDisplayer ;  import     bibliothek . gui . dock . station . DockableDisplayerListener ;  import     bibliothek . gui . dock . station . OrientedDockStation ;  import     bibliothek . gui . dock . station . OverpaintablePanel ;  import     bibliothek . gui . dock . station . StationChildHandle ;  import     bibliothek . gui . dock . station . StationDropOperation ;  import      bibliothek . gui . dock . station . layer . DefaultDropLayer ;  import      bibliothek . gui . dock . station . layer . DockStationDropLayer ;  import      bibliothek . gui . dock . station . support . ConvertedPlaceholderListItem ;  import       bibliothek . gui . dock . station . support . PlaceholderList . Level ;  import      bibliothek . gui . dock . station . support . PlaceholderMap ;  import      bibliothek . gui . dock . station . support . PlaceholderStrategy ;  import      bibliothek . gui . dock . station . toolbar . ToolbarComplexDropInfo ;  import      bibliothek . gui . dock . station . toolbar . ToolbarDockStationFactory ;  import      bibliothek . gui . dock . station . toolbar . ToolbarGroupDockStationFactory ;  import      bibliothek . gui . dock . station . toolbar . ToolbarStrategy ;  import       bibliothek . gui . dock . station . toolbar . group . ToolbarGroupProperty ;  import       bibliothek . gui . dock . station . toolbar . layer . SideSnapDropLayer ;  import       bibliothek . gui . dock . station . toolbar . layout . DockablePlaceholderToolbarGrid ;  import       bibliothek . gui . dock . station . toolbar . layout . PlaceholderToolbarGridConverter ;  import       bibliothek . gui . dock . station . toolbar . layout . ToolbarGridLayoutManager ;  import     bibliothek . gui . dock . themes . DefaultDisplayerFactoryValue ;  import     bibliothek . gui . dock . themes . DefaultStationPaintValue ;  import     bibliothek . gui . dock . themes . ThemeManager ;  import      bibliothek . gui . dock . themes . basic . BasicDockTitleFactory ;  import     bibliothek . gui . dock . title . DockTitleFactory ;  import     bibliothek . gui . dock . title . DockTitleVersion ;  import      bibliothek . gui . dock . toolbar . expand . ExpandedState ;  import     bibliothek . gui . dock . util . DockUtilities ;  import     bibliothek . gui . dock . util . PropertyValue ;  import     bibliothek . gui . dock . util . SilentPropertyValue ;  import      bibliothek . gui . dock . util . extension . Extension ;  import   bibliothek . util . Path ;   public class ToolbarGroupDockStation  extends AbstractToolbarDockStation  {   public static final String  TITLE_ID = "toolbar.group" ;   public static final String  DISPLAYER_ID = "toolbar.group" ;   private final  DockablePlaceholderToolbarGrid  < StationChildHandle >  dockables =  new  DockablePlaceholderToolbarGrid  < StationChildHandle >  ( ) ;   private final  PropertyValue  < PlaceholderStrategy >  placeholderStrategy =  new  PropertyValue  < PlaceholderStrategy >  (  PlaceholderStrategy . PLACEHOLDER_STRATEGY )  {    @ Override protected void valueChanged  (  PlaceholderStrategy oldValue ,  PlaceholderStrategy newValue )  {   dockables . setStrategy  ( newValue ) ; } } ;   private OverpaintablePanelBase  mainPanel ;   private  int  borderSideSnapSize = 10 ;   private boolean  allowSideSnap = true ;   public ToolbarGroupDockStation  ( )  {   init  ( ) ;    mainPanel . getContentPane  ( ) . setBackground  (  Color . YELLOW ) ;    mainPanel . getBasePane  ( ) . setBackground  (  Color . ORANGE ) ; }    @ Override protected void init  ( )  {   mainPanel =  new OverpaintablePanelBase  ( ) ;   paint =  new DefaultStationPaintValue  (   ThemeManager . STATION_PAINT + ".toolbar" , this ) ;   setOrientation  (  getOrientation  ( ) ) ;   displayerFactory =  createDisplayerFactory  ( ) ;   displayers =  new DisplayerCollection  ( this , displayerFactory ,  getDisplayerId  ( ) ) ;   displayers . addDockableDisplayerListener  (  new DockableDisplayerListener  ( )  {    @ Override public void discard  (  DockableDisplayer displayer )  {    ToolbarGroupDockStation . this . discard  ( displayer ) ; } } ) ;   setTitleIcon  ( null ) ; }   public  int column  (  Dockable dockable )  {  return  dockables . getColumn  ( dockable ) ; }   public  int line  (  Dockable dockable )  {  return  dockables . getLine  ( dockable ) ; }    @ Override public ToolbarStrategy getToolbarStrategy  ( )  {   final  SilentPropertyValue  < ToolbarStrategy >  value =  new  SilentPropertyValue  < ToolbarStrategy >  (  ToolbarStrategy . STRATEGY ,  getController  ( ) ) ;   final ToolbarStrategy  result =  value . getValue  ( ) ;   value . setProperties  (  ( DockController ) null ) ;  return result ; }    @ Override public Component getComponent  ( )  {  return mainPanel ; }    @ Override public  int getDockableCount  ( )  {  return  dockables . size  ( ) ; }    @ Override public Dockable getDockable  (   int index )  {  return   dockables . get  ( index ) . asDockable  ( ) ; }    @ Override public String getFactoryID  ( )  {  return  ToolbarDockStationFactory . ID ; }    @ Override protected String getDisplayerId  ( )  {  return DISPLAYER_ID ; }   public void setAllowSideSnap  (  boolean allowSideSnap )  {    this . allowSideSnap = allowSideSnap ; }   public boolean isAllowSideSnap  ( )  {  return allowSideSnap ; }   public void setBorderSideSnapSize  (   int borderSideSnapSize )  {  if  (  borderSideSnapSize < 0 )  {  throw  new IllegalArgumentException  ( "borderSideSnapeSize must not be less than 0" ) ; }    this . borderSideSnapSize = borderSideSnapSize ; }   public  int getBorderSideSnapSize  ( )  {  return borderSideSnapSize ; }    @ Override public void setController  (  DockController controller )  {  if  (   getController  ( ) != controller )  {  if  (   getController  ( ) != null )  {   dockables . unbind  ( ) ; }   Iterator  < StationChildHandle >  iter =  dockables . items  ( ) ;  while  (  iter . hasNext  ( ) )  {    iter . next  ( ) . setTitleRequest  ( null ) ; }   super . setController  ( controller ) ;  if  (  controller == null )  {   title = null ; } else  {   title =  registerTitle  ( controller ) ; }   paint . setController  ( controller ) ;   placeholderStrategy . setProperties  ( controller ) ;   displayerFactory . setController  ( controller ) ;   displayers . setController  ( controller ) ;   mainPanel . setController  ( controller ) ;  if  (   getController  ( ) != null )  {   dockables . bind  ( ) ; }   iter =  dockables . items  ( ) ;  while  (  iter . hasNext  ( ) )  {    iter . next  ( ) . setTitleRequest  ( title , true ) ; } } }    @ Override public void setOrientation  (  Orientation orientation )  {    this . orientation = orientation ;  for (   int  i = 0 ;  i <  getDockableCount  ( ) ;  i ++ )  {   final Dockable  d =  getDockable  ( i ) ;  if  (  d instanceof OrientedDockStation )  {   final OrientedDockStation  element =  ( OrientedDockStation ) d ;   element . setOrientation  (  getOrientation  ( ) ) ; } }   mainPanel . updateAlignment  ( ) ;   mainPanel . revalidate  ( ) ;   fireOrientingEvent  ( ) ; }    @ Override public  DockStationDropLayer  [ ] getLayers  ( )  {  return  new DockStationDropLayer  [ ]  {  new DefaultDropLayer  ( this ) ,  new SideSnapDropLayer  ( this ) , } ; }    @ Override public boolean accept  (  Dockable child )  {  return   getToolbarStrategy  ( ) . isToolbarGroupPart  ( child ) ; }    @ Override public boolean accept  (  DockStation station )  {  return   getToolbarStrategy  ( ) . isToolbarGroupPartParent  ( station , this , false ) ; }   public boolean accept  (  DockStation base ,  Dockable neighbor )  {  return false ; }    @ Override public StationDropOperation prepareDrop  (   int mouseX ,   int mouseY ,   int titleX ,   int titleY ,  Dockable dockable )  {   final DockController  controller =  getController  ( ) ;  if  (   getExpandedState  ( ) ==  ExpandedState . EXPANDED )  {  return null ; }  if  (   this . accept  ( dockable ) &  dockable . accept  ( this ) )  {  if  (  controller != null )  {  if  (  !   controller . getAcceptance  ( ) . accept  ( this , dockable ) )  {  return null ; } }  return  new ToolbarComplexDropInfo  ( dockable , this , mouseX , mouseY )  {    @ Override public void execute  ( )  {   drop  ( this ) ; }    @ Override public void destroy  ( )  {     ToolbarGroupDockStation . this . indexBeneathMouse =  - 1 ;     ToolbarGroupDockStation . this . sideBeneathMouse = null ;     ToolbarGroupDockStation . this . prepareDropDraw = false ;   mainPanel . repaint  ( ) ; }    @ Override public void draw  ( )  {     ToolbarGroupDockStation . this . indexBeneathMouse =  indexOf  (  getDockableBeneathMouse  ( ) ) ;     ToolbarGroupDockStation . this . prepareDropDraw = true ;     ToolbarGroupDockStation . this . sideBeneathMouse =  getSideDockableBeneathMouse  ( ) ;   mainPanel . repaint  ( ) ; } } ; } else  {  return null ; } }    @ Override protected void drop  (  StationDropOperation dropInfo )  {   final ToolbarComplexDropInfo  dropInfoGroup =  ( ToolbarComplexDropInfo ) dropInfo ;    System . out . println  (  "Summarize Info: " +  dropInfoGroup . toSummaryString  ( ) ) ;  if  (   dropInfoGroup . getItemPositionVSBeneathDockable  ( ) !=  Position . CENTER )  {  if  (  dropInfoGroup . isMove  ( ) )  {   int  column ,  topShift = 0 ,  lateralShift = 0 ;  if  (   getOrientation  ( ) ==  Orientation . VERTICAL )  {   column =  column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ;  if  (   dropInfoGroup . getItemPositionVSBeneathDockable  ( ) ==  Position . NORTH )  {   topShift =  - 1 ; }  if  (   dropInfoGroup . getItemPositionVSBeneathDockable  ( ) ==  Position . WEST )  {   lateralShift =  - 1 ; }  switch  (  dropInfoGroup . getSideDockableBeneathMouse  ( ) )  {   case NORTH :   drop  (  dropInfoGroup . getItem  ( ) , column ,  indexBeneathMouse + topShift ) ;  break ;   case EAST :   drop  (  dropInfoGroup . getItem  ( ) ,   indexBeneathMouse + 1 + lateralShift ) ;  break ;   case SOUTH :   drop  (  dropInfoGroup . getItem  ( ) , column ,   indexBeneathMouse + 1 + topShift ) ;  break ;   case WEST :   drop  (  dropInfoGroup . getItem  ( ) ,  indexBeneathMouse + lateralShift ) ;  break ; } } else  { } } else  {  if  (   getOrientation  ( ) ==  Orientation . VERTICAL )  {  switch  (  dropInfoGroup . getSideDockableBeneathMouse  ( ) )  {   case NORTH :   drop  (  dropInfoGroup . getItem  ( ) ,  column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ,  line  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ) ;  break ;   case EAST :    System . out . println  (  column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ) ;   drop  (  dropInfoGroup . getItem  ( ) ,   column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) + 1 ) ;  break ;   case SOUTH :   drop  (  dropInfoGroup . getItem  ( ) ,  column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ,   line  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) + 1 ) ;  break ;   case WEST :   drop  (  dropInfoGroup . getItem  ( ) ,  column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ) ;  break ; } } else  {  switch  (  dropInfoGroup . getSideDockableBeneathMouse  ( ) )  {   case NORTH :   drop  (  dropInfoGroup . getItem  ( ) ,  column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ) ;  break ;   case EAST :   drop  (  dropInfoGroup . getItem  ( ) ,  column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ,   line  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) + 1 ) ;  break ;   case SOUTH :    System . out . println  (  column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ) ;   drop  (  dropInfoGroup . getItem  ( ) ,   column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) + 1 ) ;  break ;   case WEST :   drop  (  dropInfoGroup . getItem  ( ) ,  column  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ,  line  (  dropInfoGroup . getDockableBeneathMouse  ( ) ) ) ;  break ; } } } } }    @ Override public void drop  (  Dockable dockable )  {   drop  ( dockable , 0 , 0 ) ; }   public boolean drop  (  Dockable dockable ,   int column ,   int line )  {  return  drop  ( dockable , column , line , false ) ; }   public boolean drop  (  Dockable dockable ,   int column ,   int line ,  boolean force )  {  if  (  force ||  this . accept  ( dockable ) )  {  if  (  ! force )  {   dockable =   getToolbarStrategy  ( ) . ensureToolbarLayer  ( this , dockable ) ;  if  (  dockable == null )  {  return false ; } }   add  ( dockable , column , line ) ;  return true ; }  return false ; }   private void add  (  Dockable dockable ,   int column ,   int line )  {   DockUtilities . ensureTreeValidity  ( this , dockable ) ;   DockUtilities . checkLayoutLocked  ( ) ;   dockable =   getToolbarStrategy  ( ) . ensureToolbarLayer  ( this , dockable ) ;   final  DockHierarchyLock . Token  token =  DockHierarchyLock . acquireLinking  ( this , dockable ) ;  try  {   listeners . fireDockableAdding  ( dockable ) ;   dockable . setDockParent  ( this ) ;   final StationChildHandle  handle =  createHandle  ( dockable ) ;   final  int  before =  dockables . getColumnCount  ( ) ;   dockables . insert  ( column , line , handle ) ;  if  (  dockable instanceof OrientedDockStation )  {    (  ( OrientedDockStation ) dockable ) . setOrientation  (  getOrientation  ( ) ) ; }   addComponent  ( handle ) ;   listeners . fireDockableAdded  ( dockable ) ;   fireDockablesRepositioned  ( dockable ,  before !=  dockables . getColumnCount  ( ) ) ; }  finally  {   token . release  ( ) ; } }   private StationChildHandle createHandle  (  Dockable dockable )  {   final StationChildHandle  handle =  new StationChildHandle  ( this , displayers , dockable , title ) ;   handle . updateDisplayer  ( ) ;  return handle ; }   private void addComponent  (  StationChildHandle handle )  {    mainPanel . getContentPane  ( ) . add  (   handle . getDisplayer  ( ) . getComponent  ( ) ) ;    mainPanel . getContentPane  ( ) . revalidate  ( ) ; }   private void removeComponent  (  StationChildHandle handle )  {    mainPanel . getContentPane  ( ) . remove  (   handle . getDisplayer  ( ) . getComponent  ( ) ) ;    mainPanel . getContentPane  ( ) . revalidate  ( ) ; }   public boolean drop  (  Dockable dockable ,   int column )  {  return  drop  ( dockable , column , false ) ; }   public boolean drop  (  Dockable dockable ,   int column ,  boolean force )  {  if  (  force ||  this . accept  ( dockable ) )  {  if  (  ! force )  {   dockable =   getToolbarStrategy  ( ) . ensureToolbarLayer  ( this , dockable ) ;  if  (  dockable == null )  {  return false ; } }   add  ( dockable , column ) ;  return true ; }  return false ; }   private void add  (  Dockable dockable ,   int column )  {   DockUtilities . ensureTreeValidity  ( this , dockable ) ;   DockUtilities . checkLayoutLocked  ( ) ;   dockable =   getToolbarStrategy  ( ) . ensureToolbarLayer  ( this , dockable ) ;   final  DockHierarchyLock . Token  token =  DockHierarchyLock . acquireLinking  ( this , dockable ) ;  try  {   listeners . fireDockableAdding  ( dockable ) ;   dockable . setDockParent  ( this ) ;   final StationChildHandle  handle =  createHandle  ( dockable ) ;   final  int  before =  dockables . getColumnCount  ( ) ;   dockables . insert  ( column , handle , false ) ;  if  (  dockable instanceof OrientedDockStation )  {    (  ( OrientedDockStation ) dockable ) . setOrientation  (  getOrientation  ( ) ) ; }   addComponent  ( handle ) ;   listeners . fireDockableAdded  ( dockable ) ;   fireDockablesRepositioned  ( dockable ,  before !=  dockables . getColumnCount  ( ) ) ; }  finally  {   token . release  ( ) ; } }    @ Override public void drag  (  Dockable dockable )  {  if  (   dockable . getDockParent  ( ) != this )  {  throw  new IllegalArgumentException  (  "not a child of this station: " + dockable ) ; }   remove  ( dockable ) ; }    @ Override protected void remove  (  Dockable dockable )  {   DockUtilities . checkLayoutLocked  ( ) ;   final  int  column =  column  ( dockable ) ;   final  int  before =  dockables . getColumnCount  ( ) ;   final StationChildHandle  handle =  dockables . get  ( dockable ) ;   final  DockHierarchyLock . Token  token =  DockHierarchyLock . acquireUnlinking  ( this , dockable ) ;  try  {   listeners . fireDockableRemoving  ( dockable ) ;   dockables . remove  ( handle ) ;   removeComponent  ( handle ) ;   dockable . setDockParent  ( null ) ;   listeners . fireDockableRemoved  ( dockable ) ;   fireColumnRepositioned  ( column ,  before !=  dockables . getColumnCount  ( ) ) ;   mainPanel . repaint  ( ) ; }  finally  {   token . release  ( ) ; } }    @ Override public void replace  (  Dockable old ,  Dockable next )  {   DockUtilities . checkLayoutLocked  ( ) ;   final DockController  controller =  getController  ( ) ;  if  (  controller != null )  {   controller . freezeLayout  ( ) ; }   final  int  column =  dockables . getColumn  ( old ) ;   final  int  line =  dockables . getLine  ( old ) ;   final  int  beforeCount =  dockables . getColumnCount  ( ) ;   remove  ( old ) ;  if  (  beforeCount !=  dockables . getColumnCount  ( ) )  {   add  ( next , column ) ; } else  {   add  ( next , column , line ) ; }   controller . meltLayout  ( ) ; }    @ Override public boolean canReplace  (  Dockable old ,  Dockable next )  {  return   acceptable  ( next ) &&   getToolbarStrategy  ( ) . isToolbarGroupPartParent  ( this , next , true ) ; }   protected void fireDockablesRepositioned  (  Dockable dockable )  {   fireDockablesRepositioned  ( dockable , false ) ; }   protected void fireDockablesRepositioned  (  Dockable dockable ,  boolean all )  {   fireColumnRepositioned  (  column  ( dockable ) , all ) ; }   protected void fireColumnRepositioned  (   int column ,  boolean all )  {   final  List  < Dockable >  list =  new  ArrayList  < Dockable >  ( ) ;   final  int  end =  all ?  dockables . getColumnCount  ( ) :  column + 1 ;  for (   int  i = column ;  i < end ;  i ++ )  {   final  Iterator  < StationChildHandle >  items =  dockables . getColumnContent  ( i ) ;  while  (  items . hasNext  ( ) )  {   list . add  (   items . next  ( ) . getDockable  ( ) ) ; } }  if  (   list . size  ( ) > 0 )  {   listeners . fireDockablesRepositioned  (  list . toArray  (  new Dockable  [  list . size  ( ) ] ) ) ; } }    @ Override protected void callDockUiUpdateTheme  ( )  throws IOException  {   DockUI . updateTheme  ( this ,  new ToolbarGroupDockStationFactory  ( ) ) ; }    @ Override protected DefaultDisplayerFactoryValue createDisplayerFactory  ( )  {  return  new DefaultDisplayerFactoryValue  (   ThemeManager . DISPLAYER_FACTORY + ".toolbar.group" , this ) ; }    @ Override protected DockTitleVersion registerTitle  (  DockController controller )  {  return   controller . getDockTitleManager  ( ) . getVersion  ( TITLE_ID ,  BasicDockTitleFactory . FACTORY ) ; }    @ Override protected void discard  (  DockableDisplayer displayer )  {   final Dockable  dockable =  displayer . getDockable  ( ) ;   final StationChildHandle  handle =  dockables . get  ( dockable ) ;  if  (  handle == null )  {  throw  new IllegalArgumentException  (  "displayer is not child of this station: " + displayer ) ; }   removeComponent  ( handle ) ;   handle . updateDisplayer  ( ) ;   addComponent  ( handle ) ; }   protected class OverpaintablePanelBase  extends SecureContainer  {   private static final  long  serialVersionUID =  - 4399008463139189130L ;   private final  int  INSETS_SIZE = 1 ;    @ SuppressWarnings  ( "serial" ) private class SizeFixedPanel  extends JPanel  {    @ Override public Dimension getPreferredSize  ( )  {   final Dimension  pref =  super . getPreferredSize  ( ) ;   final Insets  insets =  getInsets  ( ) ;    pref . height +=   insets . top +  insets . bottom ;    pref . width +=   insets . left +  insets . right ;  return pref ; }    @ Override public Dimension getMaximumSize  ( )  {  return  getPreferredSize  ( ) ; }    @ Override public Dimension getMinimumSize  ( )  {  return  getPreferredSize  ( ) ; } }   private final JPanel  dockablePane =  new SizeFixedPanel  ( ) ;   private final JPanel  basePane =  new SizeFixedPanel  ( ) ;   public OverpaintablePanelBase  ( )  {   basePane . setLayout  (  new BorderLayout  ( ) ) ;   basePane . add  ( dockablePane ,  BorderLayout . CENTER ) ;   setBasePane  ( basePane ) ;   setContentPane  ( dockablePane ) ;   setSolid  ( false ) ;   dockablePane . setOpaque  ( false ) ;   basePane . setOpaque  ( false ) ; }    @ Override public Dimension getPreferredSize  ( )  {  return   getBasePane  ( ) . getPreferredSize  ( ) ; }    @ Override public Dimension getMinimumSize  ( )  {  return   getBasePane  ( ) . getPreferredSize  ( ) ; }    @ Override public Dimension getMaximumSize  ( )  {  return   getBasePane  ( ) . getPreferredSize  ( ) ; }   public void updateAlignment  ( )  {   final Orientation  orientation =  getOrientation  ( ) ;  if  (  orientation != null )  {   dockablePane . setLayout  (  new  ToolbarGridLayoutManager  < StationChildHandle >  ( orientation , dockables )  {    @ Override protected Component toComponent  (  StationChildHandle item )  {  return   item . getDisplayer  ( ) . getComponent  ( ) ; } } ) ; }   mainPanel . revalidate  ( ) ; }    @ Override protected void paintOverlay  (  Graphics g )  {   final Graphics2D  g2D =  ( Graphics2D ) g ;   g2D . setStroke  (  new BasicStroke  ( 2 ) ) ;   final DefaultStationPaintValue  paint =  getPaint  ( ) ;  if  ( prepareDropDraw )  {  if  (  indexBeneathMouse !=  - 1 )  {   final Component  componentBeneathMouse =    dockables . get  ( indexBeneathMouse ) . getDisplayer  ( ) . getComponent  ( ) ;  if  (  componentBeneathMouse != null )  {   final Rectangle  rectToolbar =  basePane . getBounds  ( ) ;   g2D . setColor  (  Color . BLUE ) ;   final Rectangle  rectBeneathMouse =  componentBeneathMouse . getBounds  ( ) ;   final Point  pBeneath =  rectBeneathMouse . getLocation  ( ) ;   SwingUtilities . convertPointToScreen  ( pBeneath ,  componentBeneathMouse . getParent  ( ) ) ;   SwingUtilities . convertPointFromScreen  ( pBeneath ,  getBasePane  ( ) ) ;   final Rectangle  rectangleBeneathMouseTranslated =  new Rectangle  (  pBeneath . x ,  pBeneath . y ,  rectBeneathMouse . width ,  rectBeneathMouse . height ) ;   int  x1 = 0 ,  y1 = 0 ,  x2 = 0 ,  y2 = 0 ;  switch  (  getOrientation  ( ) )  {   case VERTICAL :  switch  ( sideBeneathMouse )  {   case NORTH :   x1 =  rectangleBeneathMouseTranslated . x ;   x2 =   rectangleBeneathMouseTranslated . x +  rectangleBeneathMouseTranslated . width ;   y1 =  y2 =  rectangleBeneathMouseTranslated . y ;  break ;   case EAST :   x1 =  x2 =   rectangleBeneathMouseTranslated . x +  rectangleBeneathMouseTranslated . width ;   y1 =  rectToolbar . y ;   y2 =   rectToolbar . y +  rectToolbar . height ;  break ;   case SOUTH :   x1 =  rectangleBeneathMouseTranslated . x ;   x2 =   rectangleBeneathMouseTranslated . x +  rectangleBeneathMouseTranslated . width ;   y1 =  y2 =   rectangleBeneathMouseTranslated . y +  rectangleBeneathMouseTranslated . height ;  break ;   case WEST :   x1 =  x2 =  rectangleBeneathMouseTranslated . x ;   y1 =  rectToolbar . y ;   y2 =   rectToolbar . y +  rectToolbar . height ;  break ;   default :   x1 =  x2 =  y1 =  y2 = 0 ; }  break ;   case HORIZONTAL :  switch  ( sideBeneathMouse )  {   case NORTH :   x1 =  rectToolbar . x ;   x2 =   rectToolbar . x +  rectToolbar . width ;   y1 =  y2 =  rectangleBeneathMouseTranslated . y ;  break ;   case EAST :   x1 =  x2 =   rectangleBeneathMouseTranslated . x +  rectangleBeneathMouseTranslated . width ;   y1 =  rectangleBeneathMouseTranslated . y ;   y2 =   rectangleBeneathMouseTranslated . y +  rectangleBeneathMouseTranslated . height ;  break ;   case SOUTH :   x1 =  rectToolbar . x ;   x2 =   rectToolbar . x +  rectToolbar . width ;   y1 =  y2 =   rectangleBeneathMouseTranslated . y +  rectangleBeneathMouseTranslated . height ;  break ;   case WEST :   x1 =  x2 =  rectangleBeneathMouseTranslated . x ;   y1 =  rectangleBeneathMouseTranslated . y ;   y2 =   rectangleBeneathMouseTranslated . y +  rectangleBeneathMouseTranslated . height ;  break ;   default :   x1 =  x2 =  y1 =  y2 = 0 ; }  break ; }   paint . drawInsertionLine  ( g , x1 , y1 , x2 , y2 ) ; } } } }    @ Override public String toString  ( )  {  return     this . getClass  ( ) . getSimpleName  ( ) + '@' +  Integer . toHexString  (  hashCode  ( ) ) ; } }    @ Override public PlaceholderMap getPlaceholders  ( )  {  return  dockables . toMap  ( ) ; }   public PlaceholderMap getPlaceholders  (   Map  < Dockable , Integer > identifiers )  {  return  dockables . toMap  ( identifiers ) ; }    @ Override public void setPlaceholders  (  PlaceholderMap placeholders )  {   dockables . fromMap  ( placeholders ) ; }   public void setPlaceholders  (  PlaceholderMap placeholders ,   Map  < Integer , Dockable > children )  {   DockUtilities . checkLayoutLocked  ( ) ;  if  (   getDockableCount  ( ) > 0 )  {  throw  new IllegalStateException  ( "this station still has children" ) ; }   final DockController  controller =  getController  ( ) ;  try  {  if  (  controller != null )  {   controller . freezeLayout  ( ) ; }   dockables . setStrategy  ( null ) ;   dockables . unbind  ( ) ;   dockables . fromMap  ( placeholders , children ,  new  PlaceholderToolbarGridConverter  < Dockable , StationChildHandle >  ( )  {    @ Override public StationChildHandle convert  (  Dockable dockable ,  ConvertedPlaceholderListItem item )  {   listeners . fireDockableAdding  ( dockable ) ;   dockable . setDockParent  (  ToolbarGroupDockStation . this ) ;   final StationChildHandle  handle =  createHandle  ( dockable ) ;   addComponent  ( handle ) ;  return handle ; }    @ Override public void added  (  StationChildHandle item )  {   listeners . fireDockableAdded  (  item . getDockable  ( ) ) ; } } ) ;  if  (  controller != null )  {   dockables . bind  ( ) ; }   dockables . setStrategy  (  placeholderStrategy . getValue  ( ) ) ; }  finally  {  if  (  controller != null )  {   controller . meltLayout  ( ) ; } } }    @ Override public DockableProperty getDockableProperty  (  Dockable child ,  Dockable target )  {   final  int  column =  column  ( child ) ;   final  int  line =  line  ( child ) ;  if  (  target == null )  {   target = child ; }   final PlaceholderStrategy  strategy =  placeholderStrategy . getValue  ( ) ;  Path  placeholder = null ;  if  (  strategy != null )  {   placeholder =  strategy . getPlaceholderFor  ( target ) ;  if  (    (  placeholder != null ) &&  (  column >= 0 ) &&  (  line >= 0 ) )  {   dockables . insertPlaceholder  ( column , line , placeholder ) ; } }  return  new ToolbarGroupProperty  ( column , line , placeholder ) ; }    @ Override public boolean drop  (  Dockable dockable ,  DockableProperty property )  {  if  (  property instanceof ToolbarGroupProperty )  {  return  drop  ( dockable ,  ( ToolbarGroupProperty ) property ) ; }  return false ; }   public boolean drop  (  Dockable dockable ,  ToolbarGroupProperty property )  {   final Path  placeholder =  property . getPlaceholder  ( ) ;   int  column =  property . getColumn  ( ) ;   int  line =  property . getLine  ( ) ;  if  (  placeholder != null )  {  if  (  dockables . hasPlaceholder  ( placeholder ) )  {   final StationChildHandle  child =  dockables . get  ( placeholder ) ;  if  (  child == null )  {  if  (  acceptable  ( dockable ) )  {   DockUtilities . checkLayoutLocked  ( ) ;   final  DockHierarchyLock . Token  token =  DockHierarchyLock . acquireLinking  ( this , dockable ) ;  try  {   DockUtilities . ensureTreeValidity  ( this , dockable ) ;   listeners . fireDockableAdding  ( dockable ) ;   final  int  before =  dockables . getColumnCount  ( ) ;   dockable . setDockParent  ( this ) ;   final StationChildHandle  handle =  createHandle  ( dockable ) ;   dockables . put  ( placeholder , handle ) ;   addComponent  ( handle ) ;   listeners . fireDockableAdded  ( dockable ) ;   fireDockablesRepositioned  ( dockable ,  before !=  dockables . getColumnCount  ( ) ) ; }  finally  {   token . release  ( ) ; }  return true ; } } else  {  if  (  drop  ( child , dockable , property ) )  {  return true ; }   column =  dockables . getColumn  (  child . getDockable  ( ) ) ;   line =   dockables . getLine  ( column ,  child . getDockable  ( ) ) + 1 ; } } }  if  (  !  acceptable  ( dockable ) )  {  return false ; }  return  drop  ( dockable , column , line ) ; }    @ SuppressWarnings  ( "static-method" ) private boolean drop  (  StationChildHandle parent ,  Dockable child ,  ToolbarGroupProperty property )  {  if  (   property . getSuccessor  ( ) == null )  {  return false ; }   final DockStation  station =   parent . getDockable  ( ) . asDockStation  ( ) ;  if  (  station == null )  {  return false ; }  return  station . drop  ( child ,  property . getSuccessor  ( ) ) ; }    @ Override public void move  (  Dockable dockable ,  DockableProperty property )  {  if  (  property instanceof ToolbarGroupProperty )  {   move  ( dockable ,  ( ToolbarGroupProperty ) property ) ; } }   private void move  (  Dockable dockable ,  ToolbarGroupProperty property )  {   final  int  sourceColumn =  column  ( dockable ) ;   final  int  sourceLine =  line  ( dockable ) ;  boolean  empty = false ;   int  destinationColumn =  property . getColumn  ( ) ;   int  destinationLine =  property . getLine  ( ) ;   final Path  placeholder =  property . getPlaceholder  ( ) ;  if  (  placeholder != null )  {   final  int  column =  dockables . getColumn  ( placeholder ) ;  if  (  column !=  - 1 )  {   final  int  line =  dockables . getLine  ( column , placeholder ) ;  if  (  line !=  - 1 )  {   empty = true ;   destinationColumn = column ;   destinationLine = line ; } } }  if  (  ! empty )  {   destinationColumn =  Math . min  ( destinationColumn ,  dockables . getColumnCount  ( ) ) ;  if  (   (  destinationColumn ==  dockables . getColumnCount  ( ) ) ||  (  destinationColumn ==  - 1 ) )  {   destinationLine = 0 ; } else  {   destinationLine =  Math . min  ( destinationLine ,  dockables . getLineCount  ( destinationColumn ) ) ; } }  Level  level ;  if  ( empty )  {   level =  Level . BASE ; } else  {   level =  Level . DOCKABLE ; }   dockables . move  ( sourceColumn , sourceLine , destinationColumn , destinationLine , level ) ;    mainPanel . getContentPane  ( ) . revalidate  ( ) ; } }