  package     org . imixs . workflow . engine . lucene ;   import   java . io . IOException ;  import   java . text . NumberFormat ;  import   java . text . SimpleDateFormat ;  import   java . util . ArrayList ;  import   java . util . List ;  import    java . util . logging . Level ;  import    java . util . logging . Logger ;  import    jakarta . annotation . security . DeclareRoles ;  import    jakarta . annotation . security . RolesAllowed ;  import   jakarta . inject . Inject ;  import      org . apache . lucene . analysis . core . KeywordAnalyzer ;  import     org . apache . lucene . document . Document ;  import     org . apache . lucene . facet . FacetResult ;  import     org . apache . lucene . facet . Facets ;  import     org . apache . lucene . facet . FacetsCollector ;  import     org . apache . lucene . facet . FacetsConfig ;  import     org . apache . lucene . facet . LabelAndValue ;  import      org . apache . lucene . facet . taxonomy . FastTaxonomyFacetCounts ;  import      org . apache . lucene . facet . taxonomy . TaxonomyReader ;  import       org . apache . lucene . facet . taxonomy . directory . DirectoryTaxonomyReader ;  import     org . apache . lucene . index . DirectoryReader ;  import     org . apache . lucene . index . IndexReader ;  import     org . apache . lucene . index . IndexableField ;  import      org . apache . lucene . queryparser . classic . ParseException ;  import      org . apache . lucene . queryparser . classic . QueryParser ;  import     org . apache . lucene . search . IndexSearcher ;  import     org . apache . lucene . search . MatchAllDocsQuery ;  import     org . apache . lucene . search . Query ;  import     org . apache . lucene . search . ScoreDoc ;  import     org . apache . lucene . search . Sort ;  import     org . apache . lucene . search . SortField ;  import     org . apache . lucene . search . TopDocs ;  import     org . apache . lucene . search . TopDocsCollector ;  import     org . apache . lucene . search . TopFieldCollector ;  import     org . apache . lucene . search . TopScoreDocCollector ;  import     org . apache . lucene . store . Directory ;  import    org . imixs . workflow . ItemCollection ;  import    org . imixs . workflow . WorkflowKernel ;  import     org . imixs . workflow . engine . DocumentService ;  import      org . imixs . workflow . engine . index . Category ;  import      org . imixs . workflow . engine . index . DefaultOperator ;  import      org . imixs . workflow . engine . index . SchemaService ;  import      org . imixs . workflow . engine . index . SearchService ;  import     org . imixs . workflow . exceptions . InvalidAccessException ;  import     org . imixs . workflow . exceptions . QueryException ;  import   jakarta . ejb . Stateless ;    @ DeclareRoles  (  { "org.imixs.ACCESSLEVEL.NOACCESS" , "org.imixs.ACCESSLEVEL.READERACCESS" , "org.imixs.ACCESSLEVEL.AUTHORACCESS" , "org.imixs.ACCESSLEVEL.EDITORACCESS" , "org.imixs.ACCESSLEVEL.MANAGERACCESS" } )  @ RolesAllowed  (  { "org.imixs.ACCESSLEVEL.NOACCESS" , "org.imixs.ACCESSLEVEL.READERACCESS" , "org.imixs.ACCESSLEVEL.AUTHORACCESS" , "org.imixs.ACCESSLEVEL.EDITORACCESS" , "org.imixs.ACCESSLEVEL.MANAGERACCESS" } )  @ Stateless public class LuceneSearchService  implements  SearchService  {   public static final  int  DEFAULT_MAX_SEARCH_RESULT = 9999 ;   public static final  int  DEFAULT_PAGE_SIZE = 100 ;    @ Inject private LuceneIndexService  luceneIndexService ;    @ Inject private DocumentService  documentService ;    @ Inject private SchemaService  schemaService ;   private static Logger  logger =  Logger . getLogger  (   LuceneSearchService . class . getName  ( ) ) ;    @ Override public  List  < ItemCollection > search  (  String searchTerm ,   int pageSize ,   int pageIndex ,       org . imixs . workflow . engine . index . SortOrder sortOrder ,  DefaultOperator defaultOperator ,  boolean loadStubs )  throws QueryException  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;   long  ltime =  System . currentTimeMillis  ( ) ;  if  (  pageSize <= 0 )  {   pageSize = DEFAULT_PAGE_SIZE ; }  if  (  pageIndex < 0 )  {   pageIndex = 0 ; }  if  ( debug )  {   logger . finest  (    "......lucene search: pageNumber=" + pageIndex + " pageSize=" + pageSize ) ; }   ArrayList  < ItemCollection >  workitems =  new  ArrayList  < ItemCollection >  ( ) ;   searchTerm =  schemaService . getExtendedSearchTerm  ( searchTerm ) ;  if  (   searchTerm == null ||  "" . equals  ( searchTerm ) )  {  return workitems ; }  try  {  IndexSearcher  searcher =  createIndexSearcher  ( ) ;  QueryParser  parser =  createQueryParser  ( defaultOperator ) ;   parser . setAllowLeadingWildcard  ( true ) ;  if  (  defaultOperator ==  DefaultOperator . OR )  {   parser . setDefaultOperator  (        org . apache . lucene . queryparser . classic . QueryParser . Operator . OR ) ; } else  {   parser . setDefaultOperator  (        org . apache . lucene . queryparser . classic . QueryParser . Operator . AND ) ; }   long  lsearchtime =  System . currentTimeMillis  ( ) ;  TopDocs  topDocs = null ;   TopDocsCollector  <  ? >  collector = null ;   int  startIndex =  pageIndex * pageSize ;   int  maxSearchResult = DEFAULT_MAX_SEARCH_RESULT ;  if  (   (  startIndex + pageSize ) > DEFAULT_MAX_SEARCH_RESULT )  {   maxSearchResult =  startIndex +  (  3 * pageSize ) ;   logger . warning  (        "PageIndex (" + pageSize + "x" + pageIndex + ") exeeded DEFAULT_MAX_SEARCH_RESULT(" + DEFAULT_MAX_SEARCH_RESULT + ") -> new MAX_SEARCH_RESULT is set to " + maxSearchResult ) ; }  Query  query =  parser . parse  ( searchTerm ) ;  if  (  sortOrder != null )  {  if  ( debug )  {   logger . finest  (   "......lucene result sorted by sortOrder= '" + sortOrder + "' " ) ; }   collector =  TopFieldCollector . create  (  buildLuceneSort  ( sortOrder ) , maxSearchResult , false , false , false , false ) ; } else  {  if  ( debug )  {   logger . finest  ( "......lucene result sorted by score " ) ; }   collector =  TopScoreDocCollector . create  ( maxSearchResult ) ; }   searcher . search  ( query , collector ) ;   topDocs =  collector . topDocs  ( startIndex , pageSize ) ;   ScoreDoc  [ ]  scoreDosArray =  topDocs . scoreDocs ;  if  ( debug )  {   logger . finest  (      "...returned " +  scoreDosArray . length + " documents in " +  (   System . currentTimeMillis  ( ) - lsearchtime ) + " ms - total hits=" +  topDocs . totalHits ) ; }  SimpleDateFormat  luceneDateformat =  new SimpleDateFormat  ( "yyyyMMddHHmmss" ) ;  for ( ScoreDoc scoredoc : scoreDosArray )  {  Document  luceneDoc =  searcher . doc  (  scoredoc . doc ) ;  String  sID =  luceneDoc . get  (  WorkflowKernel . UNIQUEID ) ;  ItemCollection  imixsDoc = null ;  if  ( loadStubs )  {   imixsDoc =  convertLuceneDocument  ( luceneDoc , luceneDateformat ) ;   imixsDoc . replaceItemValue  (  WorkflowKernel . UNIQUEID , sID ) ; } else  {   logger . finest  (  "......lucene lookup $uniqueid=" + sID ) ;   imixsDoc =  documentService . load  ( sID ) ; }  if  (  imixsDoc != null )  {   workitems . add  ( imixsDoc ) ; } else  {   logger . warning  (  "lucene index returned unreadable workitem : " + sID ) ;   documentService . removeDocumentFromIndex  ( sID ) ; } }    searcher . getIndexReader  ( ) . close  ( ) ;  if  ( debug )  {   logger . fine  (    "...search result computed in " +  (   System . currentTimeMillis  ( ) - ltime ) + " ms - loadStubs=" + loadStubs ) ; } }  catch (   IOException e )  {   logger . severe  (  "Lucene index error: " +  e . getMessage  ( ) ) ;  throw  new InvalidAccessException  (  InvalidAccessException . INVALID_INDEX ,  e . getMessage  ( ) , e ) ; }  catch (   ParseException e )  {   logger . severe  (  "Lucene search error: " +  e . getMessage  ( ) ) ;  throw  new QueryException  (  QueryException . QUERY_NOT_UNDERSTANDABLE ,  e . getMessage  ( ) , e ) ; }  return workitems ; }    @ Override public  List  < Category > getTaxonomy  (  String ...  categories )  {  return  getTaxonomyByQuery  ( null , categories ) ; }    @ Override public  int getTotalHits  (   final String _searchTerm ,   final  int _maxResult ,   final DefaultOperator defaultOperator )  throws QueryException  {   int  result ;   int  maxResult = _maxResult ;  if  (  maxResult <= 0 )  {   maxResult = DEFAULT_MAX_SEARCH_RESULT ; }  String  sSearchTerm =  schemaService . getExtendedSearchTerm  ( _searchTerm ) ;  if  (   sSearchTerm == null ||  "" . equals  ( sSearchTerm ) )  {  return 0 ; }  try  {  IndexSearcher  searcher =  createIndexSearcher  ( ) ;  QueryParser  parser =  createQueryParser  ( defaultOperator ) ;   parser . setAllowLeadingWildcard  ( true ) ;  if  (  defaultOperator ==  DefaultOperator . OR )  {   parser . setDefaultOperator  (        org . apache . lucene . queryparser . classic . QueryParser . Operator . OR ) ; } else  {   parser . setDefaultOperator  (        org . apache . lucene . queryparser . classic . QueryParser . Operator . AND ) ; }   TopDocsCollector  <  ? >  collector = null ;  Query  query =  parser . parse  ( sSearchTerm ) ;   collector =  TopScoreDocCollector . create  ( maxResult ) ;   searcher . search  ( query , collector ) ;   result =  collector . getTotalHits  ( ) ;   logger . finest  (  "......lucene count result = " + result ) ; }  catch (   IOException e )  {   logger . severe  (  "Lucene index error: " +  e . getMessage  ( ) ) ;  throw  new InvalidAccessException  (  InvalidAccessException . INVALID_INDEX ,  e . getMessage  ( ) , e ) ; }  catch (   ParseException e )  {   logger . severe  (  "Lucene search error: " +  e . getMessage  ( ) ) ;  throw  new QueryException  (  QueryException . QUERY_NOT_UNDERSTANDABLE ,  e . getMessage  ( ) , e ) ; }  return result ; }  IndexSearcher createIndexSearcher  ( )  throws IOException  {  IndexReader  reader = null ;   logger . finest  ( "......createIndexSearcher..." ) ;  Directory  indexDir =  luceneIndexService . createIndexDirectory  ( ) ;  try  {   reader =  DirectoryReader . open  ( indexDir ) ; }  catch (   IOException ioe )  {   logger . warning  (  "lucene index can not be opened: " +  ioe . getMessage  ( ) ) ;  throw ioe ; }  IndexSearcher  searcher =  new IndexSearcher  ( reader ) ;  return searcher ; }  TaxonomyReader createTaxonomyReader  ( )  throws IOException  {   logger . finest  ( "......createTaxonomyReader..." ) ;  Directory  taxoDir =  luceneIndexService . createTaxonomyDirectory  ( ) ;  TaxonomyReader  taxoReader =  new DirectoryTaxonomyReader  ( taxoDir ) ;  return taxoReader ; }  QueryParser createQueryParser  (  DefaultOperator defaultOperator )  {  QueryParser  parser =  new QueryParser  ( "content" ,  new KeywordAnalyzer  ( ) ) ;  if  (  defaultOperator ==  DefaultOperator . OR )  {   logger . finest  ( "......DefaultOperator: OR" ) ;   parser . setDefaultOperator  (        org . apache . lucene . queryparser . classic . QueryParser . Operator . OR ) ; } else  {   logger . finest  ( "......DefaultOperator: AND" ) ;   parser . setDefaultOperator  (        org . apache . lucene . queryparser . classic . QueryParser . Operator . AND ) ; }   parser . setSplitOnWhitespace  ( true ) ;  return parser ; }  ItemCollection convertLuceneDocument  (  Document luceneDoc ,  SimpleDateFormat luceneDateformat )  {  ItemCollection  imixsDoc =  new ItemCollection  ( ) ;   List  < IndexableField >  fields =  luceneDoc . getFields  ( ) ;  for ( IndexableField indexableField : fields )  {  Object  objectValue = null ;  String  stringValue =  indexableField . stringValue  ( ) ;  if  (  isNumeric  ( stringValue ) )  {  if  (    stringValue . length  ( ) == 14 &&  !  stringValue . contains  ( "." ) )  {  try  {   objectValue =  luceneDateformat . parse  ( stringValue ) ; }  catch (     java . text . ParseException e )  { } }  if  (  objectValue == null )  {  try  {  Number  number =   NumberFormat . getInstance  ( ) . parse  ( stringValue ) ;   objectValue = number ; }  catch (     java . text . ParseException e )  { } } }  if  (  objectValue == null )  {   objectValue = stringValue ; }   logger . finest  (    ".........append " +  indexableField . name  ( ) + " = " + objectValue ) ;   imixsDoc . appendItemValue  (  indexableField . name  ( ) , objectValue ) ; }   imixsDoc . replaceItemValue  (  DocumentService . ISAUTHOR ,  documentService . isAuthor  ( imixsDoc ) ) ;  return imixsDoc ; }   private Sort buildLuceneSort  (       org . imixs . workflow . engine . index . SortOrder sortOrder )  {  Sort  sort = null ;   sort =  new Sort  (  new SortField  [ ]  {  new SortField  (  sortOrder . getField  ( ) ,   SortField . Type . STRING ,  sortOrder . isReverse  ( ) ) } ) ;  return sort ; }   private static boolean isNumeric  (  String str )  {  boolean  dot = false ;  if  (   str == null ||  str . isEmpty  ( ) )  {  return false ; }  for (  char c :  str . toCharArray  ( ) )  {  if  (   c == '.' &&  dot == false )  {   dot = true ;  continue ; }  if  (   c < '0' ||  c > '9' )  {  return false ; } }  return true ; }    @ Override public  List  < Category > getTaxonomyByQuery  (  String searchTerm ,  String ...  categories )  {   List  < Category >  results =  new  ArrayList  < >  ( ) ;  try  {  IndexSearcher  searcher =  createIndexSearcher  ( ) ;  TaxonomyReader  taxoReader =  createTaxonomyReader  ( ) ;  FacetsConfig  config =  luceneIndexService . getFacetsConfig  ( ) ;  FacetsCollector  fc =  new FacetsCollector  ( ) ;  if  (   searchTerm == null ||  searchTerm . isEmpty  ( ) )  {   searcher . search  (  new MatchAllDocsQuery  ( ) , fc ) ; } else  {   searchTerm =  schemaService . getExtendedSearchTerm  ( searchTerm ) ;  QueryParser  parser =  createQueryParser  (  DefaultOperator . OR ) ;  Query  query =  parser . parse  ( searchTerm ) ;   searcher . search  ( query , fc ) ; }  Facets  facets =  new FastTaxonomyFacetCounts  ( taxoReader , config , fc ) ;  for ( String cat : categories )  {  FacetResult  facetResult =  facets . getTopChildren  ( 10 ,  cat +  LuceneIndexService . TAXONOMY_INDEXFIELD_PRAFIX ) ;  if  (  facetResult != null )  {  Category  category =  new Category  ( cat ,  facetResult . childCount ) ;  for ( LabelAndValue lav :  facetResult . labelValues )  {   category . setLabel  (  lav . label ,   lav . value . intValue  ( ) ) ; }   results . add  ( category ) ; } }    searcher . getIndexReader  ( ) . close  ( ) ;   taxoReader . close  ( ) ; }  catch (   IOException | QueryException | ParseException e )  {   logger . severe  (  "Lucene index error: " +  e . getMessage  ( ) ) ;  throw  new InvalidAccessException  (  InvalidAccessException . INVALID_INDEX ,  e . getMessage  ( ) , e ) ; }  return results ; } }