  package      org . onebusaway . transit_data_federation . impl . realtime . gtfs_realtime ;   import   java . text . ParseException ;  import   java . text . SimpleDateFormat ;  import  java . util .  * ;  import    java . util . Map . Entry ;  import    java . util . concurrent . TimeUnit ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import     com . google . transit . realtime . GtfsRealtimeMTARR ;  import     com . google . transit . realtime . GtfsRealtimeNYCT ;  import     org . apache . commons . lang . StringUtils ;  import    org . onebusaway . collections . MappingLibrary ;  import    org . onebusaway . collections . Min ;  import     org . onebusaway . geospatial . model . CoordinatePoint ;  import     org . onebusaway . gtfs . model . AgencyAndId ;  import      org . onebusaway . gtfs . model . calendar . ServiceDate ;  import      org . onebusaway . gtfs . serialization . mappings . InvalidStopTimeException ;  import      org . onebusaway . gtfs . serialization . mappings . StopTimeFieldMappingFactory ;  import     org . onebusaway . realtime . api . OccupancyStatus ;  import     org . onebusaway . realtime . api . TimepointPredictionRecord ;  import     org . onebusaway . realtime . api . VehicleLocationRecord ;  import     org . onebusaway . realtime . api . VehicleOccupancyRecord ;  import     org . onebusaway . transit_data . model . TransitDataConstants ;  import      org . onebusaway . transit_data_federation . services . blocks . BlockCalendarService ;  import      org . onebusaway . transit_data_federation . services . blocks . BlockGeospatialService ;  import      org . onebusaway . transit_data_federation . services . blocks . BlockInstance ;  import      org . onebusaway . transit_data_federation . services . blocks . ScheduledBlockLocation ;  import      org . onebusaway . transit_data_federation . services . transit_graph . BlockConfigurationEntry ;  import      org . onebusaway . transit_data_federation . services . transit_graph . BlockEntry ;  import      org . onebusaway . transit_data_federation . services . transit_graph . BlockStopTimeEntry ;  import      org . onebusaway . transit_data_federation . services . transit_graph . BlockTripEntry ;  import      org . onebusaway . transit_data_federation . services . transit_graph . StopTimeEntry ;  import      org . onebusaway . transit_data_federation . services . transit_graph . TripEntry ;  import       org . onebusaway . transit_data_federation . services . transit_graph . dynamic . DynamicTripEntryImpl ;  import    org . onebusaway . util . AgencyAndIdLibrary ;  import    org . onebusaway . util . SystemTime ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     com . google . common . collect . ArrayListMultimap ;  import     com . google . common . collect . ListMultimap ;  import      com . google . transit . realtime . GtfsRealtime . FeedEntity ;  import      com . google . transit . realtime . GtfsRealtime . FeedMessage ;  import      com . google . transit . realtime . GtfsRealtime . Position ;  import      com . google . transit . realtime . GtfsRealtime . TripDescriptor ;  import      com . google . transit . realtime . GtfsRealtime . TripUpdate ;  import       com . google . transit . realtime . GtfsRealtime . TripUpdate . StopTimeEvent ;  import       com . google . transit . realtime . GtfsRealtime . TripUpdate . StopTimeUpdate ;  import      com . google . transit . realtime . GtfsRealtime . VehiclePosition ;   public class GtfsRealtimeTripLibrary  {   private static final Logger  _log =  LoggerFactory . getLogger  (  GtfsRealtimeTripLibrary . class ) ;   private static Pattern  _pattern =  Pattern . compile  ( "^(-{0,1}\\d+):(\\d{2}):(\\d{2})$" ) ;   private GtfsRealtimeEntitySource  _entitySource ;   private  long  _currentTime = 0 ;   private boolean  _validateCurrentTime = true ;   public void setValidateCurrentTime  (  boolean validate )  {   _validateCurrentTime = validate ; }   private boolean validateCurrentTime  ( )  {  return _validateCurrentTime ; }   private boolean  _hackServiceDate = false ;   public void setHackServiceDate  (  boolean flag )  {   _hackServiceDate = flag ; }   private StopModificationStrategy  _stopModificationStrategy = null ;   private boolean  _scheduleAdherenceFromLocation = false ;   private boolean  _useLabelAsVehicleId = false ;   private boolean  _filterUnassigned = false ;   public void setEntitySource  (  GtfsRealtimeEntitySource entitySource )  {   _entitySource = entitySource ; }   public  long getCurrentTime  ( )  {  return _currentTime ; }   public void setCurrentTime  (   long currentTime )  {   setCurrentTime  ( currentTime , 0 ) ; }   public void setCurrentTime  (   long currentTime ,   int originOffsetHours )  {  if  (  originOffsetHours != 0 )  {  Calendar  c =  Calendar . getInstance  ( ) ;   c . setTime  (  new Date  ( currentTime ) ) ;   c . roll  (  Calendar . HOUR , originOffsetHours ) ;   _currentTime =  c . getTimeInMillis  ( ) ;   _log . info  (    "currentTime set to " +  new Date  ( _currentTime ) + " from offset " + originOffsetHours ) ; } else  {   _currentTime = currentTime ; } }   public void setStopModificationStrategy  (  StopModificationStrategy strategy )  {   _stopModificationStrategy = strategy ; }   public void setScheduleAdherenceFromLocation  (  boolean scheduleAdherenceFromLocation )  {   _scheduleAdherenceFromLocation = scheduleAdherenceFromLocation ; }   public void setUseLabelAsVehicleId  (  boolean useLabelAsVehicleId )  {   _useLabelAsVehicleId = useLabelAsVehicleId ; }   public void setFilterUnassigned  (  boolean flag )  {   _filterUnassigned = flag ; }   public  List  < CombinedTripUpdatesAndVehiclePosition > groupTripUpdatesAndVehiclePositions  (  FeedMessage tripUpdateMessage ,  FeedMessage vehiclePositionsMessage )  {  return  groupTripUpdatesAndVehiclePositions  ( null , tripUpdateMessage , vehiclePositionsMessage ) ; }   public  List  < CombinedTripUpdatesAndVehiclePosition > groupTripUpdatesAndVehiclePositions  (  MonitoredResult result ,  FeedMessage tripUpdateMessage ,  FeedMessage vehiclePositionsMessage )  {  try  {  return  groupTripUpdatesAndVehiclePositionsInternal  ( result , tripUpdateMessage , vehiclePositionsMessage ) ; }  catch (   Throwable t )  {   _log . error  ( "source-exception {}" , t , t ) ;  return  new  ArrayList  < >  ( ) ; } }   private BlockDescriptor handleDynamicTripUpdate  (  TripUpdate tu )  {  try  {  TripDescriptor  td =  tu . getTrip  ( ) ;  if  (  td . hasExtension  (  GtfsRealtimeNYCT . nyctTripDescriptor ) )  {   GtfsRealtimeNYCT . NyctTripDescriptor  nyctTripDescriptor =  td . getExtension  (  GtfsRealtimeNYCT . nyctTripDescriptor ) ;   _log . debug  ( "parsing trip {}" ,  td . getTripId  ( ) ) ;  AddedTripInfo  addedTripInfo =   _serviceSource . getAddedTripService  ( ) . handleNyctDescriptor  ( _serviceSource , tu , nyctTripDescriptor , _currentTime ) ;  if  (  addedTripInfo == null )  return null ;   long  tripStartTimeMillis =   addedTripInfo . getServiceDate  ( ) +  (   addedTripInfo . getTripStartTime  ( ) * 1000 ) ;  if  (   _filterUnassigned &&  nyctTripDescriptor . hasIsAssigned  ( ) &&  !  nyctTripDescriptor . getIsAssigned  ( ) )  {  return null ; }  if  (    nyctTripDescriptor . hasIsAssigned  ( ) &&  !  nyctTripDescriptor . getIsAssigned  ( ) &&  tripStartTimeMillis < _currentTime )  {  return null ; }  return   _serviceSource . getDynamicTripBuilder  ( ) . createBlockDescriptor  ( addedTripInfo ) ; } else  {  if  (   td . getScheduleRelationship  ( ) . equals  (   TripDescriptor . ScheduleRelationship . ADDED ) )  {  AddedTripInfo  addedTripInfo =   _serviceSource . getAddedTripService  ( ) . handleAddedDescriptor  ( _serviceSource ,   _entitySource . getAgencyIds  ( ) . get  ( 0 ) , tu , _currentTime ) ;  if  (  addedTripInfo != null )  {  return   _serviceSource . getDynamicTripBuilder  ( ) . createBlockDescriptor  ( addedTripInfo ) ; } } }  return null ; }  catch (   Throwable t )  {   _log . error  ( "source-exception {}" , t , t ) ;  return null ; } }   private TripUpdate addStartDateTime  (  TripUpdate tu )  {  if  (   !  tu . hasTrip  ( ) ||  !   tu . getTrip  ( ) . hasTripId  ( ) )  {  throw  new IllegalStateException  (  "unidentifiable trip " + tu ) ; }  if  (   tu . getTrip  ( ) . hasStartTime  ( ) )  {  return tu ; }  if  (  isNycDynamicTrip  ( tu ) )  {  return tu ; }  TripEntry  trip =  _entitySource . getTrip  (   tu . getTrip  ( ) . getTripId  ( ) ) ;  if  (    trip == null ||   trip . getStopTimes  ( ) == null ||   trip . getStopTimes  ( ) . isEmpty  ( ) )  {   _log . error  ( "no stoptimes for trip {} on agencies {}, cannot determine start time" ,   tu . getTrip  ( ) . getTripId  ( ) ,  _entitySource . getAgencyIds  ( ) ) ;  return tu ; }  StopTimeEntry  stopTimeEntry =   trip . getStopTimes  ( ) . get  ( 0 ) ;   int  arrivalTime =  stopTimeEntry . getArrivalTime  ( ) ;  ServiceDate  serviceDate = null ;  String  dateString = null ;  if  (   tu . getTrip  ( ) . hasStartDate  ( ) )   dateString =   tu . getTrip  ( ) . getStartDate  ( ) ;  if  (   dateString == null ||   dateString . length  ( ) == 0 )   dateString = "00000000" ;  try  {   serviceDate =  ServiceDate . parseString  ( dateString ) ; }  catch (   ParseException e )  {   _log . error  (     "invalid date format |" +   tu . getTrip  ( ) . getStartDate  ( ) + "| for trip |" +   tu . getTrip  ( ) . getTripId  ( ) + "|" ) ;  return tu ; }  Date  startTime =  new Date  (    serviceDate . getAsDate  ( ) . getTime  ( ) +  (  arrivalTime * 1000 ) ) ;  SimpleDateFormat  sdfTime =  new SimpleDateFormat  ( "hh:mm:ss" ) ;   TripDescriptor . Builder  tdBuilder =   tu . getTrip  ( ) . toBuilder  ( ) ;   tdBuilder . setStartTime  (  sdfTime . format  ( startTime ) ) ;   TripUpdate . Builder  builder =  tu . toBuilder  ( ) ;  return   builder . setTrip  (  tdBuilder . build  ( ) ) . build  ( ) ; }   private AssignmentInfo getAssignmentInfo  (  FeedMessage tripUpdateMessage ,  FeedMessage vehiclePositionsMessage )  {   Map  < String , String >  preferredTripByVehicleId =  new  HashMap  < >  ( ) ;   Map  < String , String >  preferredVehicleByBlockId =  new  HashMap  < >  ( ) ;  if  (  vehiclePositionsMessage != null )  {  for ( FeedEntity fe :  vehiclePositionsMessage . getEntityList  ( ) )  {  if  (  !  fe . hasVehicle  ( ) )  {  continue ; }  if  (     fe . hasVehicle  ( ) &&   fe . getVehicle  ( ) . hasVehicle  ( ) &&    fe . getVehicle  ( ) . getVehicle  ( ) . hasId  ( ) &&   fe . getVehicle  ( ) . hasTrip  ( ) )  {  String  vehicleId =    fe . getVehicle  ( ) . getVehicle  ( ) . getId  ( ) ;  String  tripId =    fe . getVehicle  ( ) . getTrip  ( ) . getTripId  ( ) ;  if  (  preferredTripByVehicleId . containsKey  ( vehicleId ) )  {   _log . warn  (      "vehicle " + vehicleId + " on trip " + tripId + " already reported on" +  preferredTripByVehicleId . get  ( vehicleId ) ) ;  continue ; }   preferredTripByVehicleId . put  ( vehicleId , tripId ) ;  TripEntry  tripEntry =  _entitySource . getTrip  ( tripId ) ;  if  (  tripEntry != null )  {  if  (   tripEntry . getBlock  ( ) != null )  {  String  blockId =    tripEntry . getBlock  ( ) . getId  ( ) . toString  ( ) ;   preferredVehicleByBlockId . put  ( blockId , vehicleId ) ; } } } } }  return  new AssignmentInfo  ( preferredTripByVehicleId , preferredVehicleByBlockId ) ; }   public VehicleLocationRecord createVehicleLocationRecordForUpdate  (  CombinedTripUpdatesAndVehiclePosition update )  {  return  createVehicleLocationRecordForUpdate  ( null , update ) ; }   public VehicleLocationRecord createVehicleLocationRecordForUpdate  (  MonitoredResult result ,  CombinedTripUpdatesAndVehiclePosition update )  {  VehicleLocationRecord  record =  new VehicleLocationRecord  ( ) ;   record . setTimeOfRecord  (  currentTime  ( ) ) ;  BlockDescriptor  blockDescriptor =  update . block ;  if  (   update . block == null )  return null ;  String  vehicleId =   update . block . getVehicleId  ( ) ;   record . setBlockId  (     blockDescriptor . getBlockInstance  ( ) . getBlock  ( ) . getBlock  ( ) . getId  ( ) ) ;   record . setStatus  (   blockDescriptor . getScheduleRelationship  ( ) . toString  ( ) ) ;  if  (     TransitDataConstants . STATUS_ADDED . equals  (    update . block . getScheduleRelationship  ( ) . toString  ( ) ) ||   TransitDataConstants . STATUS_DUPLICATED . equals  (    update . block . getScheduleRelationship  ( ) . toString  ( ) ) ||  isNycDynamicTrip  ( update ) )  {   applyDynamicTripUpdatesToRecord  ( result , blockDescriptor ,  update . getTripUpdates  ( ) , record , vehicleId ) ; } else  {   applyTripUpdatesToRecord  ( result , blockDescriptor ,  update . getTripUpdates  ( ) , record , vehicleId ) ; }  if  (   update . vehiclePosition != null )  {   applyVehiclePositionToRecord  ( result , blockDescriptor ,  update . vehiclePosition , record ) ; }   record . setVehicleId  (  record . getBlockId  ( ) ) ;  if  (  result != null )  {  if  (   record . getTripId  ( ) != null )  {  if  (   record . getStatus  ( ) . equals  (  TransitDataConstants . STATUS_ADDED ) )  {   result . addAddedTripId  (   record . getTripId  ( ) . toString  ( ) ) ; } else  if  (   record . getStatus  ( ) . equals  (  TransitDataConstants . STATUS_DUPLICATED ) )  {   result . addDuplicatedTripId  (   record . getTripId  ( ) . toString  ( ) ) ; } else  if  (   record . getStatus  ( ) . equals  (  TransitDataConstants . STATUS_CANCELED ) )  {   result . addCancelledTripId  (   record . getTripId  ( ) . toString  ( ) ) ; } else  {   result . addMatchedTripId  (   record . getTripId  ( ) . toString  ( ) ) ; } } else  if  (   record . getBlockId  ( ) != null )  {   result . addMatchedTripId  (   record . getBlockId  ( ) . toString  ( ) ) ; } else  {   result . addMatchedTripId  (   record . getBlockId  ( ) . toString  ( ) ) ; } }  if  (   blockDescriptor . getVehicleId  ( ) != null )  {  String  agencyId =   record . getBlockId  ( ) . getAgencyId  ( ) ;  try  {  AgencyAndId  vehicleAgencyAndId =  AgencyAndIdLibrary . convertFromString  (  blockDescriptor . getVehicleId  ( ) ) ;   record . setVehicleId  ( vehicleAgencyAndId ) ; }  catch (   IllegalStateException ise )  {   record . setVehicleId  (  new AgencyAndId  ( agencyId ,  blockDescriptor . getVehicleId  ( ) ) ) ; } }  return record ; }   private boolean isNycDynamicTrip  (  CombinedTripUpdatesAndVehiclePosition update )  {  if  (  !   update . getTripUpdates  ( ) . isEmpty  ( ) )  if  (    update . getTripUpdates  ( ) . get  ( 0 ) . hasTrip  ( ) )  return  isNycDynamicTrip  (   update . getTripUpdates  ( ) . get  ( 0 ) ) ;  return false ; }   private boolean isNycDynamicTrip  (  TripUpdate tu )  {  if  (  tu . hasTrip  ( ) )  {  if  (   tu . getTrip  ( ) . hasScheduleRelationship  ( ) )  {  return     tu . getTrip  ( ) . getScheduleRelationship  ( ) . equals  (   TripDescriptor . ScheduleRelationship . ADDED ) ||    tu . getTrip  ( ) . getScheduleRelationship  ( ) . equals  (   TripDescriptor . ScheduleRelationship . DUPLICATED ) ; }  return   tu . getTrip  ( ) . hasExtension  (  GtfsRealtimeNYCT . nyctTripDescriptor ) ; }  return false ; }   private void applyDynamicTripUpdatesToRecord  (  MonitoredResult result ,  BlockDescriptor blockDescriptor ,   List  < TripUpdate > tripUpdates ,  VehicleLocationRecord record ,  String vehicleId )  {  try  {  boolean  isDuplicated =   blockDescriptor . getScheduleRelationship  ( ) . equals  (   BlockDescriptor . ScheduleRelationship . DUPLICATED ) ;  String  agencyId =      blockDescriptor . getBlockInstance  ( ) . getBlock  ( ) . getBlock  ( ) . getId  ( ) . getAgencyId  ( ) ;   record . setStatus  (   blockDescriptor . getScheduleRelationship  ( ) . toString  ( ) ) ;   record . setServiceDate  (   blockDescriptor . getBlockInstance  ( ) . getServiceDate  ( ) ) ;   record . setTimeOfRecord  (  currentTime  ( ) ) ;  if  (   blockDescriptor . getStartTime  ( ) != null )  {   record . setBlockStartTime  (  blockDescriptor . getStartTime  ( ) ) ; } else  {   record . setBlockStartTime  (  getFirstStpTime  ( blockDescriptor ) ) ; }   List  < TimepointPredictionRecord >  timepointPredictions =  new  ArrayList  < TimepointPredictionRecord >  ( ) ;  for ( TripUpdate tripUpdate : tripUpdates )  {  if  (   record . getTripId  ( ) == null )  {  if  ( isDuplicated )  {   record . setTripId  (  new AgencyAndId  ( agencyId ,  markDuplicated  (   tripUpdate . getTrip  ( ) . getTripId  ( ) ) ) ) ; } else  {   record . setTripId  (  new AgencyAndId  ( agencyId ,   tripUpdate . getTrip  ( ) . getTripId  ( ) ) ) ; } }   int  sequence = 0 ;  for ( StopTimeUpdate stu :  tripUpdate . getStopTimeUpdateList  ( ) )  {  TimepointPredictionRecord  tpr =  new TimepointPredictionRecord  ( ) ;   tpr . setTimepointId  (  new AgencyAndId  ( agencyId ,  stu . getStopId  ( ) ) ) ;  if  ( isDuplicated )  {   tpr . setTripId  (  new AgencyAndId  ( agencyId ,  markDuplicated  (   tripUpdate . getTrip  ( ) . getTripId  ( ) ) ) ) ; } else  {   tpr . setTripId  (  new AgencyAndId  ( agencyId ,   tripUpdate . getTrip  ( ) . getTripId  ( ) ) ) ; }   tpr . setStopSequence  ( sequence ) ;   sequence ++ ;  switch  (  stu . getScheduleRelationship  ( ) )  {   case SCHEDULED :   tpr . setScheduleRealtionship  (    TimepointPredictionRecord . ScheduleRelationship . SCHEDULED . getValue  ( ) ) ;  break ;   case SKIPPED :   tpr . setScheduleRealtionship  (    TimepointPredictionRecord . ScheduleRelationship . SKIPPED . getValue  ( ) ) ;  break ;   default :   tpr . setScheduleRealtionship  (    TimepointPredictionRecord . ScheduleRelationship . SCHEDULED . getValue  ( ) ) ; }  if  (   stu . hasArrival  ( ) &&   stu . getArrival  ( ) . hasTime  ( ) )   tpr . setTimepointPredictedArrivalTime  (    stu . getArrival  ( ) . getTime  ( ) * 1000 ) ;  if  (   stu . hasDeparture  ( ) &&   stu . getDeparture  ( ) . hasTime  ( ) )   tpr . setTimepointPredictedDepartureTime  (    stu . getDeparture  ( ) . getTime  ( ) * 1000 ) ;  if  (  stu . hasExtension  (  GtfsRealtimeNYCT . nyctStopTimeUpdate ) )  {   GtfsRealtimeNYCT . NyctStopTimeUpdate  ext =  stu . getExtension  (  GtfsRealtimeNYCT . nyctStopTimeUpdate ) ;  if  (  ext . hasScheduledTrack  ( ) )  {   tpr . setScheduledTrack  (  ext . getScheduledTrack  ( ) ) ; }  if  (  ext . hasActualTrack  ( ) )  {   tpr . setActualTrack  (  ext . getActualTrack  ( ) ) ; } }  if  (  stu . hasExtension  (  GtfsRealtimeMTARR . mtaRailroadStopTimeUpdate ) )  {   GtfsRealtimeMTARR . MtaRailroadStopTimeUpdate  ext =  stu . getExtension  (  GtfsRealtimeMTARR . mtaRailroadStopTimeUpdate ) ;  if  (  ext . hasTrack  ( ) )  {   tpr . setActualTrack  (  ext . getTrack  ( ) ) ; }  if  (  ext . hasTrainStatus  ( ) )  {   tpr . setStatus  (  ext . getTrainStatus  ( ) ) ; } }   timepointPredictions . add  ( tpr ) ; }   record . setTimepointPredictions  ( timepointPredictions ) ;   record . setScheduleDeviation  (  calculateScheduleDeviation  (  blockDescriptor . getBlockInstance  ( ) , timepointPredictions ) ) ; } }  catch (   Throwable t )  {   _log . error  ( "source-exception {}" , t , t ) ; } }   private String markDuplicated  (  String tripId )  {  return  tripId + "_Dup" ; }   private  int getFirstStpTime  (  BlockDescriptor blockDescriptor )  {  if  (   blockDescriptor . getBlockInstance  ( ) != null )  if  (  !     blockDescriptor . getBlockInstance  ( ) . getBlock  ( ) . getTrips  ( ) . isEmpty  ( ) )  if  (  !       blockDescriptor . getBlockInstance  ( ) . getBlock  ( ) . getTrips  ( ) . get  ( 0 ) . getStopTimes  ( ) . isEmpty  ( ) )  return         blockDescriptor . getBlockInstance  ( ) . getBlock  ( ) . getTrips  ( ) . get  ( 0 ) . getStopTimes  ( ) . get  ( 0 ) . getStopTime  ( ) . getDepartureTime  ( ) ;  return  - 1 ; }   private  double calculateScheduleDeviation  (  BlockInstance blockInstance ,   List  < TimepointPredictionRecord > timepointPredictions )  {   int  predictionSize =  timepointPredictions . size  ( ) ;   int  stopTimesSize =      blockInstance . getBlock  ( ) . getTrips  ( ) . get  ( 0 ) . getStopTimes  ( ) . size  ( ) ;  if  (  predictionSize < 1 )  {   _log . debug  ( "not enough data to calculate deviation" ) ;  return 0.0 ; }  TimepointPredictionRecord  timepointPredictionRecord =  timepointPredictions . get  (  predictionSize - 1 ) ;  BlockStopTimeEntry  blockStopTimeEntry =      blockInstance . getBlock  ( ) . getTrips  ( ) . get  ( 0 ) . getStopTimes  ( ) . get  (  stopTimesSize - 1 ) ;  AgencyAndId  predictionStopId =  timepointPredictionRecord . getTimepointId  ( ) ;  AgencyAndId  stopTimeStopId =    blockStopTimeEntry . getStopTime  ( ) . getStop  ( ) . getId  ( ) ;  if  (  predictionStopId . equals  ( stopTimeStopId ) )  {  if  (   timepointPredictionRecord . getTimepointPredictedArrivalTime  ( ) > 0 )  return  calculateScheduleDeviation  (  blockInstance . getServiceDate  ( ) ,  timepointPredictionRecord . getTimepointPredictedArrivalTime  ( ) ,   blockStopTimeEntry . getStopTime  ( ) . getArrivalTime  ( ) ) ;  if  (   timepointPredictionRecord . getTimepointPredictedDepartureTime  ( ) > 0 )  return  calculateScheduleDeviation  (  blockInstance . getServiceDate  ( ) ,  timepointPredictionRecord . getTimepointPredictedDepartureTime  ( ) ,   blockStopTimeEntry . getStopTime  ( ) . getDepartureTime  ( ) ) ; }  for ( BlockStopTimeEntry stopTime :     blockInstance . getBlock  ( ) . getTrips  ( ) . get  ( 0 ) . getStopTimes  ( ) )  {   stopTimeStopId =    stopTime . getStopTime  ( ) . getStop  ( ) . getId  ( ) ;  for ( TimepointPredictionRecord timepointPrediction : timepointPredictions )  {   predictionStopId =  timepointPrediction . getTimepointId  ( ) ;  if  (  stopTimeStopId . equals  ( predictionStopId ) )  {  if  (   timepointPrediction . getTimepointPredictedArrivalTime  ( ) > 0 )  {  return  calculateScheduleDeviation  (  blockInstance . getServiceDate  ( ) ,  timepointPredictionRecord . getTimepointPredictedArrivalTime  ( ) ,   blockStopTimeEntry . getStopTime  ( ) . getArrivalTime  ( ) ) ; }  if  (   timepointPrediction . getTimepointPredictedDepartureTime  ( ) > 0 )  {  return  calculateScheduleDeviation  (  blockInstance . getServiceDate  ( ) ,  timepointPredictionRecord . getTimepointPredictedDepartureTime  ( ) ,   blockStopTimeEntry . getStopTime  ( ) . getDepartureTime  ( ) ) ; } } } }  return 0 ; }   private  double calculateScheduleDeviation  (   long serviceDate ,   long predictionMillis ,   int stopTimeSeconds )  {   long  stopTime =  serviceDate +  (  stopTimeSeconds * 1000 ) ;   double  deviation =   (  predictionMillis / 1000 ) -  (  stopTime / 1000 ) ;  return deviation ; }   private  int getBlockStartTimeForTripStartTime  (  BlockInstance instance ,  AgencyAndId tripId ,   int tripStartTime )  {  BlockConfigurationEntry  block =  instance . getBlock  ( ) ;  if  (    block . getTrips  ( ) == null ||   block . getTrips  ( ) . isEmpty  ( ) )  {   _log . debug  ( "no trips for trip start time on block {}" ,   block . getBlock  ( ) . getId  ( ) ) ;  return  - 1 ; }   Map  < AgencyAndId , BlockTripEntry >  blockTripsById = null ;  try  {   blockTripsById =  MappingLibrary . mapToValue  (  block . getTrips  ( ) , "trip.id" ) ; }  catch (   IllegalStateException ise )  {   _log . debug  ( "invalid block {}" ,   block . getBlock  ( ) . getId  ( ) ) ;  return  - 1 ; }   int  rawBlockStartTime =  block . getDepartureTimeForIndex  ( 0 ) ;  if  (  !  blockTripsById . containsKey  ( tripId ) )  {   _log . debug  (       "getBlockStartTimeForTripStartTime(" + instance + ", " + tripId + ", " + tripStartTime + ") did not find matching trip; aborting" ) ;  return  - 1 ; }   int  rawTripStartTime =   blockTripsById . get  ( tripId ) . getDepartureTimeForIndex  ( 0 ) ;   int  adjustedBlockStartTime =  rawBlockStartTime +  (  tripStartTime - rawTripStartTime ) ;  if  (  adjustedBlockStartTime < 0 )  {  return rawBlockStartTime ; }  return adjustedBlockStartTime ; }   private BlockDescriptor getTripDescriptorAsBlockDescriptor  (  MonitoredResult result ,  TripDescriptor trip ,   long currentTime )  {  try  {  if  (  !  trip . hasTripId  ( ) )  {  return null ; }  TripEntry  tripEntry =  _entitySource . getTrip  (  trip . getTripId  ( ) ) ;  if  (  tripEntry == null )  {  if  (  result != null )  {   _log . debug  (  "discarding: reporting unmatched trip with id=" +  trip . getTripId  ( ) ) ;   result . addUnmatchedTripId  (  trip . getTripId  ( ) ) ; } else  {   _log . debug  (  "discarding: no trip found with id=" +  trip . getTripId  ( ) ) ; }  return null ; }  ServiceDate  serviceDate = null ;  BlockInstance  instance ;  BlockEntry  block =  tripEntry . getBlock  ( ) ;  if  (   trip . hasStartDate  ( ) &&  !  "0" . equals  (  trip . getStartDate  ( ) ) )  {  try  {   serviceDate =  ServiceDate . parseString  (  trip . getStartDate  ( ) ) ; }  catch (   ParseException ex )  {   _log . debug  (  "Could not parse service date " +  trip . getStartDate  ( ) , ex ) ; } }  if  (  serviceDate != null )  {   instance =   _serviceSource . getBlockCalendarService  ( ) . getBlockInstance  (  block . getId  ( ) ,   serviceDate . getAsDate  ( ) . getTime  ( ) ) ;  if  (  instance == null )  {   _log . debug  (    "block " +  block . getId  ( ) + " does not exist on service date " + serviceDate ) ;  return null ; } } else  {   long  timeFrom =  currentTime -   30 * 60 * 1000 ;   long  timeTo =  currentTime +   30 * 60 * 1000 ;   List  < BlockInstance >  instances =   _serviceSource . getBlockCalendarService  ( ) . getActiveBlocks  (  block . getId  ( ) , timeFrom , timeTo ) ;  if  (  instances . isEmpty  ( ) )  {   instances =   _serviceSource . getBlockCalendarService  ( ) . getClosestActiveBlocks  (  block . getId  ( ) , currentTime ) ; }  if  (  instances . isEmpty  ( ) )  {   _log . debug  (    "could not find any active instances for the specified block=" +  block . getId  ( ) + " trip=" + trip ) ;  return null ; }   instance =  instances . get  ( 0 ) ; }  if  (  serviceDate == null )  {   serviceDate =  new ServiceDate  (  new Date  (  instance . getServiceDate  ( ) ) ) ; }  BlockDescriptor  blockDescriptor =  new BlockDescriptor  ( ) ;   blockDescriptor . setBlockInstance  ( instance ) ;   blockDescriptor . setStartDate  ( serviceDate ) ;  if  (  trip . hasScheduleRelationship  ( ) )  {  if  (  isDynamicTrip  ( tripEntry ) )  {   blockDescriptor . setScheduleRelationship  (   BlockDescriptor . ScheduleRelationship . ADDED ) ; } else  {   blockDescriptor . setScheduleRelationshipValue  (   trip . getScheduleRelationship  ( ) . toString  ( ) ) ; } } else  {  if  (  isDynamicTrip  ( tripEntry ) )  {   blockDescriptor . setScheduleRelationship  (   BlockDescriptor . ScheduleRelationship . ADDED ) ; } }   int  tripStartTime = 0 ;   int  blockStartTime = 0 ;  if  (   trip . hasStartTime  ( ) &&  !  "0" . equals  (  trip . getStartTime  ( ) ) )  {  try  {  Matcher  m =  _pattern . matcher  (  trip . getStartTime  ( ) ) ;  if  (  !  m . matches  ( ) )  {   long  timeInMil =   serviceDate . getAsDate  ( ) . getTime  ( ) ;   long  epochTime =  Long . parseLong  (  trip . getStartTime  ( ) ) ;   long  startTime =   (  epochTime - timeInMil ) / 1000 ;   tripStartTime =  (  int ) startTime ; } else   tripStartTime =  StopTimeFieldMappingFactory . getStringAsSeconds  (  trip . getStartTime  ( ) ) ; }  catch (   InvalidStopTimeException iste )  {   _log . debug  (    "invalid stopTime of " +  trip . getStartTime  ( ) + " for trip " + trip ) ;  return null ; }   blockStartTime =  getBlockStartTimeForTripStartTime  ( instance ,  tripEntry . getId  ( ) , tripStartTime ) ;  if  (  blockStartTime < 0 )  {   _log . debug  (    "invalid blockStartTime for trip " + trip + " for instance=" + instance ) ;  return null ; }   blockDescriptor . setStartTime  ( blockStartTime ) ; }  return blockDescriptor ; }  catch (   Throwable t )  {   _log . error  ( "source-exception {}" , t , t ) ;  return null ; }  if  (   serviceDate != null && _hackServiceDate )  {  Calendar  cal =  Calendar . getInstance  ( ) ;   cal . setTimeInMillis  (  getCurrentTime  ( ) ) ;  if  (   cal . get  (  Calendar . HOUR_OF_DAY ) < 3 )  {  if  (   serviceDate . getDay  ( ) ==  cal . get  (  Calendar . DAY_OF_MONTH ) )  {   cal . add  (  Calendar . DAY_OF_MONTH ,  - 1 ) ;   serviceDate =  new ServiceDate  ( cal ) ; } } } }   private boolean isDynamicTrip  (  TripEntry trip )  {  return  trip instanceof DynamicTripEntryImpl ; }   private void applyTripUpdatesToRecord  (  MonitoredResult result ,  BlockDescriptor blockDescriptor ,   List  < TripUpdate > tripUpdates ,  VehicleLocationRecord record ,  String vehicleId )  {  try  {  BlockInstance  instance =  blockDescriptor . getBlockInstance  ( ) ;  BlockConfigurationEntry  blockConfiguration =  instance . getBlock  ( ) ;   List  < BlockTripEntry >  blockTrips =  blockConfiguration . getTrips  ( ) ;   Map  < String ,  List  < TripUpdate > >  tripUpdatesByTripId =  MappingLibrary . mapToValueList  ( tripUpdates , "trip.tripId" ) ;   long  t =  currentTime  ( ) ;   int  currentTime =  (  int )  (   (  t -  instance . getServiceDate  ( ) ) / 1000 ) ;  BestScheduleDeviation  best =  new BestScheduleDeviation  ( ) ;   long  lastStopScheduleTime =  Long . MIN_VALUE ;  boolean  singleTimepointRecord = false ;   List  < TimepointPredictionRecord >  timepointPredictions =  new  ArrayList  < TimepointPredictionRecord >  ( ) ;  for ( BlockTripEntry blockTrip : blockTrips )  {  TripEntry  trip =  blockTrip . getTrip  ( ) ;  AgencyAndId  tripId =  trip . getId  ( ) ;   List  < TripUpdate >  updatesForTrip =  tripUpdatesByTripId . get  (  tripId . getId  ( ) ) ;  if  (  updatesForTrip != null )  {  for ( TripUpdate tripUpdate : updatesForTrip )  {  if  (  tripUpdate . hasDelay  ( ) )  {    best . delta = 0 ;    best . isInPast = false ;    best . scheduleDeviation =  tripUpdate . getDelay  ( ) ;    best . tripId = tripId ;    best . tripUpdateHasDelay = true ; }  if  (  tripUpdate . hasTimestamp  ( ) )  {    best . timestamp =   tripUpdate . getTimestamp  ( ) * 1000 ; }  if  (  tripId != null )  {    best . isCanceled =    tripUpdate . getTrip  ( ) . getScheduleRelationship  ( ) . equals  (   TripDescriptor . ScheduleRelationship . CANCELED ) ;  if  (  best . isCanceled )   result . addCancelledTripId  (   tripUpdate . getTrip  ( ) . getTripId  ( ) ) ;   record . setStatus  (    tripUpdate . getTrip  ( ) . getScheduleRelationship  ( ) . toString  ( ) ) ;   _log . debug  (    "schedule=" +   tripUpdate . getTrip  ( ) . getScheduleRelationship  ( ) + "; isCanceled=" +  best . isCanceled ) ; }  for ( StopTimeUpdate stopTimeUpdate :  tripUpdate . getStopTimeUpdateList  ( ) )  {  BlockStopTimeEntry  blockStopTime =  getBlockStopTimeForStopTimeUpdate  ( result , tripUpdate , stopTimeUpdate ,  blockTrip . getStopTimes  ( ) ,  instance . getServiceDate  ( ) ) ;   List  < BlockStopTimeEntry >  stopTimes =  blockTrip . getStopTimes  ( ) ;  for ( BlockStopTimeEntry bste : stopTimes )  {   long  scheduleTime =   instance . getServiceDate  ( ) +    bste . getStopTime  ( ) . getArrivalTime  ( ) * 1000 ;  if  (  scheduleTime > lastStopScheduleTime )  {   lastStopScheduleTime = scheduleTime ; } }  if  (  blockStopTime == null )  continue ;  StopTimeEntry  stopTime =  blockStopTime . getStopTime  ( ) ;  TimepointPredictionRecord  tpr =  new TimepointPredictionRecord  ( ) ;   tpr . setTimepointId  (   stopTime . getStop  ( ) . getId  ( ) ) ;   tpr . setTripId  (   stopTime . getTrip  ( ) . getId  ( ) ) ;  if  (  !   stopTimeUpdate . getScheduleRelationship  ( ) . equals  (   StopTimeUpdate . ScheduleRelationship . SKIPPED ) )  {   tpr . setTimepointScheduledTime  (   instance . getServiceDate  ( ) +   stopTime . getArrivalTime  ( ) * 1000 ) ; }  if  (  stopTimeUpdate . hasStopSequence  ( ) )  {   tpr . setStopSequence  (  stopTimeUpdate . getStopSequence  ( ) ) ; }  if  (   stopTimeUpdate . getScheduleRelationship  ( ) . equals  (   StopTimeUpdate . ScheduleRelationship . SKIPPED ) )  {   tpr . setScheduleRealtionship  (   StopTimeUpdate . ScheduleRelationship . SKIPPED_VALUE ) ;   timepointPredictions . add  ( tpr ) ;   _log . debug  (      "SKIPPED stop:" +  tpr . getTimepointId  ( ) + "  seq: " +  tpr . getStopSequence  ( ) + " trip: " +  tpr . getTripId  ( ) ) ; } else  {   tpr . setScheduleRealtionship  (   StopTimeUpdate . ScheduleRelationship . SCHEDULED_VALUE ) ; }  if  (  !   stopTimeUpdate . getScheduleRelationship  ( ) . equals  (   StopTimeUpdate . ScheduleRelationship . SKIPPED ) )  {   int  currentArrivalTime =  computeArrivalTime  ( stopTime , stopTimeUpdate ,  instance . getServiceDate  ( ) ) ;   int  currentDepartureTime =  computeDepartureTime  ( stopTime , stopTimeUpdate ,  instance . getServiceDate  ( ) ) ;  if  (  currentArrivalTime >= 0 )  {   updateBestScheduleDeviation  ( currentTime ,  stopTime . getArrivalTime  ( ) , currentArrivalTime , best , tripId , vehicleId ) ;   long  timepointPredictedTime =   instance . getServiceDate  ( ) +  (  currentArrivalTime * 1000L ) ;   tpr . setTimepointPredictedArrivalTime  ( timepointPredictedTime ) ; }  if  (  currentDepartureTime >= 0 )  {   updateBestScheduleDeviation  ( currentTime ,  stopTime . getDepartureTime  ( ) , currentDepartureTime , best , tripId , vehicleId ) ;   long  timepointPredictedTime =   instance . getServiceDate  ( ) +  (  currentDepartureTime * 1000L ) ;   tpr . setTimepointPredictedDepartureTime  ( timepointPredictedTime ) ; }  if  (    tpr . getTimepointPredictedArrivalTime  ( ) !=  - 1 ||   tpr . getTimepointPredictedDepartureTime  ( ) !=  - 1 )  {   timepointPredictions . add  ( tpr ) ; }  if  (  stopTimeUpdate . hasExtension  (  GtfsRealtimeNYCT . nyctStopTimeUpdate ) )  {   GtfsRealtimeNYCT . NyctStopTimeUpdate  ext =  stopTimeUpdate . getExtension  (  GtfsRealtimeNYCT . nyctStopTimeUpdate ) ;  if  (  ext . hasScheduledTrack  ( ) )  {   tpr . setScheduledTrack  (  ext . getScheduledTrack  ( ) ) ; }  if  (  ext . hasActualTrack  ( ) )  {   tpr . setActualTrack  (  ext . getActualTrack  ( ) ) ; } }  if  (  stopTimeUpdate . hasExtension  (  GtfsRealtimeMTARR . mtaRailroadStopTimeUpdate ) )  {   GtfsRealtimeMTARR . MtaRailroadStopTimeUpdate  ext =  stopTimeUpdate . getExtension  (  GtfsRealtimeMTARR . mtaRailroadStopTimeUpdate ) ;  if  (  ext . hasTrack  ( ) )  {   tpr . setActualTrack  (  ext . getTrack  ( ) ) ; }  if  (  ext . hasTrainStatus  ( ) )  {   tpr . setStatus  (  ext . getTrainStatus  ( ) ) ; } } } } } }  if  (    timepointPredictions . size  ( ) == 1 &&     tripUpdates . get  ( 0 ) . getStopTimeUpdateList  ( ) . size  ( ) == 1 )  {   singleTimepointRecord = true ; }  if  (   (    timepointPredictions . size  ( ) > 0 &&  best . tripUpdateHasDelay ) || singleTimepointRecord )  {   Set  < AgencyAndId >  records =  new  HashSet  < AgencyAndId >  ( ) ;  for ( TimepointPredictionRecord tpr : timepointPredictions )  {   records . add  (  tpr . getTimepointId  ( ) ) ; }   long  tprStartTime =  getEarliestTimeInRecords  ( timepointPredictions ) ;  for ( StopTimeEntry stopTime :  trip . getStopTimes  ( ) )  {  if  (  records . contains  (   stopTime . getStop  ( ) . getId  ( ) ) )  {  continue ; }   long  predictionOffset =   instance . getServiceDate  ( ) +  (   best . scheduleDeviation * 1000L ) ;   long  predictedDepartureTime =   (   stopTime . getDepartureTime  ( ) * 1000L ) + predictionOffset ;   long  predictedArrivalTime =   (   stopTime . getArrivalTime  ( ) * 1000L ) + predictionOffset ;   long  scheduledArrivalTime =   instance . getServiceDate  ( ) +   stopTime . getArrivalTime  ( ) * 1000 ;   long  time =    best . timestamp != 0 ?  best . timestamp :  currentTime  ( ) ;  if  (   (   predictedDepartureTime > time &&  predictedDepartureTime < tprStartTime ) ||  (  singleTimepointRecord &&  (   predictedDepartureTime > time &&  scheduledArrivalTime <= lastStopScheduleTime ) ) )  {  TimepointPredictionRecord  tpr =  new TimepointPredictionRecord  ( ) ;   tpr . setTimepointId  (   stopTime . getStop  ( ) . getId  ( ) ) ;   tpr . setTripId  (   stopTime . getTrip  ( ) . getId  ( ) ) ;   tpr . setStopSequence  (  stopTime . getGtfsSequence  ( ) ) ;   tpr . setTimepointPredictedArrivalTime  ( predictedArrivalTime ) ;   tpr . setTimepointPredictedDepartureTime  ( predictedDepartureTime ) ;   tpr . setTimepointScheduledTime  ( scheduledArrivalTime ) ;   tpr . setScheduleRealtionship  (   StopTimeUpdate . ScheduleRelationship . SCHEDULED_VALUE ) ;   timepointPredictions . add  ( tpr ) ; } } } }   record . setServiceDate  (  instance . getServiceDate  ( ) ) ;  if  (   blockDescriptor . getStartTime  ( ) != null )  {   record . setBlockStartTime  (  blockDescriptor . getStartTime  ( ) ) ; }  if  (   blockDescriptor . getScheduleRelationship  ( ) != null )   record . setStatus  (   blockDescriptor . getScheduleRelationship  ( ) . toString  ( ) ) ;  if  (  !  best . isCanceled )   record . setScheduleDeviation  (  best . scheduleDeviation ) ;  if  (   best . timestamp != 0 )  {   record . setTimeOfRecord  (  best . timestamp ) ; }   record . setTimepointPredictions  ( timepointPredictions ) ; }  catch (   Throwable t )  {   _log . error  ( "source-exception {}" , t , t ) ; } }   private BlockStopTimeEntry getBlockStopTimeForStopTimeUpdate  (  MonitoredResult result ,  TripUpdate tripUpdate ,  StopTimeUpdate stopTimeUpdate ,   List  < BlockStopTimeEntry > stopTimes ,   long serviceDate )  {  if  (  stopTimeUpdate . hasStopSequence  ( ) )  {   int  stopSequence =  stopTimeUpdate . getStopSequence  ( ) ;   Map  < Integer , BlockStopTimeEntry >  sequenceToStopTime =  MappingLibrary . mapToValue  ( stopTimes , "stopTime.gtfsSequence" ) ;  if  (  sequenceToStopTime . containsKey  ( stopSequence ) )  {  BlockStopTimeEntry  blockStopTime =  sequenceToStopTime . get  ( stopSequence ) ;  if  (  !  stopTimeUpdate . hasStopId  ( ) )  {  if  (  result != null )  {   result . addMatchedStopId  (     blockStopTime . getStopTime  ( ) . getStop  ( ) . getId  ( ) . getId  ( ) ) ; }  return blockStopTime ; }  String  stopTimeUpdateStopId =  convertStopId  (  stopTimeUpdate . getStopId  ( ) ) ;  if  (      blockStopTime . getStopTime  ( ) . getStop  ( ) . getId  ( ) . getId  ( ) . equals  ( stopTimeUpdateStopId ) )  {  if  (  result != null )  {   result . addMatchedStopId  (     blockStopTime . getStopTime  ( ) . getStop  ( ) . getId  ( ) . getId  ( ) ) ; }  return blockStopTime ; } } else  {   _log . debug  (    "StopTimeSequence is out of bounds: stopSequence=" + stopSequence + " tripUpdate=\n" + tripUpdate ) ; } }  if  (  stopTimeUpdate . hasStopId  ( ) )  {   int  time =  getTimeForStopTimeUpdate  ( stopTimeUpdate , serviceDate ) ;  String  stopId =  convertStopId  (  stopTimeUpdate . getStopId  ( ) ) ;   Min  < BlockStopTimeEntry >  bestMatches =  new  Min  < BlockStopTimeEntry >  ( ) ;  for ( BlockStopTimeEntry blockStopTime : stopTimes )  {  if  (      blockStopTime . getStopTime  ( ) . getStop  ( ) . getId  ( ) . getId  ( ) . equals  ( stopId ) )  {  StopTimeEntry  stopTime =  blockStopTime . getStopTime  ( ) ;   int  departureDelta =  Math . abs  (   stopTime . getDepartureTime  ( ) - time ) ;   int  arrivalDelta =  Math . abs  (   stopTime . getArrivalTime  ( ) - time ) ;   bestMatches . add  ( departureDelta , blockStopTime ) ;   bestMatches . add  ( arrivalDelta , blockStopTime ) ; } }  if  (  !  bestMatches . isEmpty  ( ) )  {  if  (  result != null )  {   result . addMatchedStopId  (  convertStopId  ( stopId ) ) ; }  return  bestMatches . getMinElement  ( ) ; } }  if  (  result != null )  {   result . addUnmatchedStopId  (  convertStopId  (  stopTimeUpdate . getStopId  ( ) ) ) ; }  return null ; }   private String convertStopId  (  String stopId )  {  if  (   this . _stopModificationStrategy == null )  {  return stopId ; }  return  _stopModificationStrategy . convertStopId  ( stopId ) ; }   private  int getTimeForStopTimeUpdate  (  StopTimeUpdate stopTimeUpdate ,   long serviceDate )  {   long  t =  currentTime  ( ) ;  if  (  stopTimeUpdate . hasArrival  ( ) )  {  StopTimeEvent  arrival =  stopTimeUpdate . getArrival  ( ) ;  if  (  arrival . hasTime  ( ) )  {  return  (  int )  (   arrival . getTime  ( ) -  serviceDate / 1000 ) ; }  if  (  arrival . hasDelay  ( ) )  {  return  (  int )  (    (  t - serviceDate ) / 1000 -  arrival . getDelay  ( ) ) ; } }  if  (  stopTimeUpdate . hasDeparture  ( ) )  {  StopTimeEvent  departure =  stopTimeUpdate . getDeparture  ( ) ;  if  (  departure . hasTime  ( ) )  return  (  int )  (   departure . getTime  ( ) -  serviceDate / 1000 ) ;  if  (  departure . hasDelay  ( ) )  {  return  (  int )  (    (  t - serviceDate ) / 1000 -  departure . getDelay  ( ) ) ; } }   _log . debug  (  "expected at least an arrival or departure time or delay for update: " + stopTimeUpdate ) ;  return  - 1 ; }   private  int computeArrivalTime  (  StopTimeEntry stopTime ,  StopTimeUpdate stopTimeUpdate ,   long serviceDate )  {  if  (  !  stopTimeUpdate . hasArrival  ( ) )  return  - 1 ;  StopTimeEvent  arrival =  stopTimeUpdate . getArrival  ( ) ;  if  (  arrival . hasTime  ( ) )  return  (  int )  (   arrival . getTime  ( ) -  serviceDate / 1000 ) ;  if  (  arrival . hasDelay  ( ) )  return   stopTime . getArrivalTime  ( ) +  arrival . getDelay  ( ) ;  return  - 1 ; }   private  int computeDepartureTime  (  StopTimeEntry stopTime ,  StopTimeUpdate stopTimeUpdate ,   long serviceDate )  {  if  (  !  stopTimeUpdate . hasDeparture  ( ) )  return  - 1 ;  StopTimeEvent  departure =  stopTimeUpdate . getDeparture  ( ) ;  if  (  departure . hasTime  ( ) )  return  (  int )  (   departure . getTime  ( ) -  serviceDate / 1000 ) ;  if  (  departure . hasDelay  ( ) )  return   stopTime . getDepartureTime  ( ) +  departure . getDelay  ( ) ;  return  - 1 ; }   private void updateBestScheduleDeviation  (   int currentTime ,   int expectedStopTime ,   int actualStopTime ,  BestScheduleDeviation best ,  AgencyAndId tripId ,  String vehicleId )  {  if  (  best . tripUpdateHasDelay )  return ;   int  delta =  Math . abs  (  currentTime - actualStopTime ) ;  boolean  isInPast =  currentTime > actualStopTime ;   int  scheduleDeviation =  actualStopTime - expectedStopTime ;  if  (   delta <  best . delta ||  (   ! isInPast &&  best . isInPast ) )  {    best . delta = delta ;    best . isInPast = isInPast ;    best . scheduleDeviation = scheduleDeviation ;    best . tripId = tripId ; } }   private void applyVehiclePositionToRecord  (  MonitoredResult result ,  BlockDescriptor blockDescriptor ,  VehiclePosition vehiclePosition ,  VehicleLocationRecord record )  {  Position  position =  vehiclePosition . getPosition  ( ) ;  if  (  vehiclePosition . hasTimestamp  ( ) )  {   record . setTimeOfLocationUpdate  (   TimeUnit . SECONDS . toMillis  (  vehiclePosition . getTimestamp  ( ) ) ) ; }   record . setCurrentLocationLat  (  position . getLatitude  ( ) ) ;   record . setCurrentLocationLon  (  position . getLongitude  ( ) ) ;  if  (  result != null )  {   result . addLatLon  (  position . getLatitude  ( ) ,  position . getLongitude  ( ) ) ; }  if  ( _scheduleAdherenceFromLocation )  {  CoordinatePoint  location =  new CoordinatePoint  (  position . getLatitude  ( ) ,  position . getLongitude  ( ) ) ;   double  totalDistance =    blockDescriptor . getBlockInstance  ( ) . getBlock  ( ) . getTotalBlockDistance  ( ) ;   long  timestamp =   vehiclePosition . hasTimestamp  ( ) ?  record . getTimeOfLocationUpdate  ( ) :  record . getTimeOfRecord  ( ) ;  ScheduledBlockLocation  loc =   _serviceSource . getBlockGeospatialService  ( ) . getBestScheduledBlockLocationForLocation  (  blockDescriptor . getBlockInstance  ( ) , location , timestamp , 0 , totalDistance ) ;   long  serviceDateTime =  record . getServiceDate  ( ) ;   long  effectiveScheduleTime =   loc . getScheduledTime  ( ) +  (  serviceDateTime / 1000 ) ;   double  deviation =   timestamp / 1000 - effectiveScheduleTime ;   double  oldDeviation =  record . getScheduleDeviation  ( ) ;   record . setScheduleDeviation  ( deviation ) ;   _log . debug  ( "deviation reset to {} from {} for vehicle {}" , deviation , oldDeviation ,   vehiclePosition . getVehicle  ( ) . getId  ( ) ) ; } }   private static  long getEarliestTimeInRecords  (   Collection  < TimepointPredictionRecord > records )  {   long  min =  Long . MAX_VALUE ;  for ( TimepointPredictionRecord tpr : records )  {  if  (   tpr . getTimepointPredictedArrivalTime  ( ) !=  - 1 )  {   min =  Math . min  ( min ,  tpr . getTimepointPredictedArrivalTime  ( ) ) ; } else  if  (   tpr . getTimepointPredictedDepartureTime  ( ) !=  - 1 )  {   min =  Math . min  ( min ,  tpr . getTimepointPredictedDepartureTime  ( ) ) ; } }  return min ; }   private  long currentTime  ( )  {  if  (  _currentTime != 0 )  {  if  (   validateCurrentTime  ( ) &&   Math . abs  (  _currentTime -  SystemTime . currentTimeMillis  ( ) ) >   60 * 60 * 1000 )  {   _log . error  (   "timestamp invalid at " +  new Date  ( _currentTime ) + ", overriding with system time" ) ;   _currentTime =  SystemTime . currentTimeMillis  ( ) ; }  return _currentTime ; }  return  SystemTime . currentTimeMillis  ( ) ; }   private String getVehicleId  (  TripUpdate tu )  {  if  (   _useLabelAsVehicleId &&  tu . hasVehicle  ( ) &&   tu . getVehicle  ( ) . hasLabel  ( ) )  return   tu . getVehicle  ( ) . getLabel  ( ) ;  return   tu . getVehicle  ( ) . getId  ( ) ; }   private String getVehicleId  (  VehiclePosition vp )  {  if  (   _useLabelAsVehicleId &&  vp . hasVehicle  ( ) &&   vp . getVehicle  ( ) . hasLabel  ( ) )  return   vp . getVehicle  ( ) . getLabel  ( ) ;  return   vp . getVehicle  ( ) . getId  ( ) ; }   public VehicleOccupancyRecord createVehicleOccupancyRecordForUpdate  (  MonitoredResult result ,  CombinedTripUpdatesAndVehiclePosition update )  {  if  (  update == null )  return null ;  if  (   update . vehiclePosition == null )  return null ;  if  (   update . vehiclePosition . hasOccupancyStatus  ( ) )  {  VehicleOccupancyRecord  vor =  new VehicleOccupancyRecord  ( ) ;   vor . setVehicleId  (  new AgencyAndId  (       update . block . getBlockInstance  ( ) . getBlock  ( ) . getBlock  ( ) . getId  ( ) . getAgencyId  ( ) ,   update . block . getVehicleId  ( ) ) ) ;  try  {   vor . setOccupancyStatus  (  OccupancyStatus . valueOf  (    update . vehiclePosition . getOccupancyStatus  ( ) . name  ( ) ) ) ; }  catch (   IllegalArgumentException iae )  {   _log . debug  (  "unknown occupancy value: " + iae ) ; }  TripEntry  firstTrip = null ;  if  (    update . vehiclePosition . hasTrip  ( ) &&    update . vehiclePosition . getTrip  ( ) . hasTripId  ( ) )  {   firstTrip =  _entitySource . getTrip  (    update . vehiclePosition . getTrip  ( ) . getTripId  ( ) ) ; }  if  (  firstTrip == null )  {   firstTrip =  _entitySource . getTrip  (     update . getTripUpdates  ( ) . get  ( 0 ) . getTrip  ( ) . getTripId  ( ) ) ; }  if  (   firstTrip != null &&   firstTrip . getRoute  ( ) != null )  {   vor . setRouteId  (  AgencyAndIdLibrary . convertToString  (   firstTrip . getRoute  ( ) . getId  ( ) ) ) ;   vor . setDirectionId  (  firstTrip . getDirectionId  ( ) ) ; }  if  (   vor . getOccupancyStatus  ( ) == null )  {   _log . warn  (  "unmatched occupancy status " +    update . vehiclePosition . getOccupancyStatus  ( ) . name  ( ) ) ;  return null ; }  return vor ; }  return null ; }   private static class BestScheduleDeviation  {   public  int  delta =  Integer . MAX_VALUE ;   public  int  scheduleDeviation = 0 ;   public boolean  isInPast = true ;   public boolean  tripUpdateHasDelay = false ;   public  long  timestamp = 0 ;   public AgencyAndId  tripId = null ;   public boolean  isCanceled = false ; }   private static class AssignmentInfo  {   private  Map  < String , String >  preferredTripByVehicleId ;   private  Map  < String , String >  preferredVehicleByBlockId ;   public AssignmentInfo  (   Map  < String , String > preferredTripByVehicleId ,   Map  < String , String > preferredVehicleByBlockId )  {    this . preferredTripByVehicleId = preferredTripByVehicleId ;    this . preferredVehicleByBlockId = preferredVehicleByBlockId ; } }   private GtfsRealtimeServiceSource  _serviceSource ;   public void setServiceSource  (  GtfsRealtimeServiceSource serviceSource )  {   _serviceSource = serviceSource ; }   public  List  < CombinedTripUpdatesAndVehiclePosition > groupTripUpdatesAndVehiclePositionsInternal  (  MonitoredResult result ,  FeedMessage tripUpdateMessage ,  FeedMessage vehiclePositionsMessage )  {   List  < CombinedTripUpdatesAndVehiclePosition >  updates =  new  ArrayList  < CombinedTripUpdatesAndVehiclePosition >  ( ) ;   ListMultimap  < String , TripUpdate >  tripUpdatesByVehicleId =  ArrayListMultimap . create  ( ) ;   Map  < String , VehiclePosition >  vehiclePositionsByVehicleId =  new  HashMap  < String , VehiclePosition >  ( ) ;  AssignmentInfo  assignmentInfo =  getAssignmentInfo  ( tripUpdateMessage , vehiclePositionsMessage ) ;   ListMultimap  < BlockDescriptor , TripUpdate >  anonymousTripUpdatesByBlock =  ArrayListMultimap .  < BlockDescriptor , TripUpdate > create  ( ) ;   Map  < BlockDescriptor , VehiclePosition >  anonymousVehiclePositionsByBlock =  new  HashMap  < BlockDescriptor , VehiclePosition >  ( ) ;   Set  < BlockDescriptor >  badAnonymousVehiclePositions =  new  HashSet  < BlockDescriptor >  ( ) ;  for ( FeedEntity fe :  tripUpdateMessage . getEntityList  ( ) )  {  if  (  !  fe . hasTripUpdate  ( ) )  {  continue ; }  TripUpdate  tu =  fe . getTripUpdate  ( ) ;  BlockDescriptor  bd = null ;  if  (   tu . hasTrip  ( ) &&  (    TransitDataConstants . STATUS_ADDED . equals  (    tu . getTrip  ( ) . getScheduleRelationship  ( ) . toString  ( ) ) ||   TransitDataConstants . STATUS_DUPLICATED . equals  (    tu . getTrip  ( ) . getScheduleRelationship  ( ) . toString  ( ) ) ) )  {   result . addAddedTripId  (   tu . getTrip  ( ) . getTripId  ( ) ) ; }  if  (   tu . hasTrip  ( ) &&   TransitDataConstants . STATUS_DUPLICATED . equals  (    tu . getTrip  ( ) . getScheduleRelationship  ( ) . toString  ( ) ) )  {   result . addAddedTripId  (   tu . getTrip  ( ) . getTripId  ( ) ) ;  AddedTripInfo  addedTripInfo =   _serviceSource . getDuplicatedTripService  ( ) . handleDuplicatedDescriptor  ( tu ) ;   bd =   _serviceSource . getDynamicTripBuilder  ( ) . createBlockDescriptor  ( addedTripInfo ) ;  if  (  bd == null )  continue ;   anonymousTripUpdatesByBlock . put  ( bd , tu ) ;  continue ; }  if  (    tu . hasVehicle  ( ) &&   tu . getVehicle  ( ) . hasId  ( ) &&  StringUtils . isNotBlank  (   tu . getVehicle  ( ) . getId  ( ) ) )  {  String  vehicleId =  getVehicleId  ( tu ) ;   tripUpdatesByVehicleId . put  ( vehicleId ,  addStartDateTime  ( tu ) ) ; } else  {  TripDescriptor  td =  tu . getTrip  ( ) ;   long  time =   tu . hasTimestamp  ( ) ?   tu . getTimestamp  ( ) * 1000 :  currentTime  ( ) ;  if  (  bd == null )  {   bd =  getTripDescriptorAsBlockDescriptor  ( result , td , time ) ; }  if  (  bd == null )  {   bd =  handleDynamicTripUpdate  ( tu ) ;  if  (  bd == null )  continue ;   result . addAddedTripId  (  td . getTripId  ( ) ) ;   anonymousTripUpdatesByBlock . put  ( bd , tu ) ; }  TripEntry  tripEntry =  _entitySource . getTrip  (  td . getTripId  ( ) ) ;  if  (   tripEntry != null &&   tripEntry . getBlock  ( ) != null )  {  String  blockId =    tripEntry . getBlock  ( ) . getId  ( ) . toString  ( ) ;  if  (   assignmentInfo . preferredVehicleByBlockId . containsKey  ( blockId ) )  {  String  preferredVehicleId =   assignmentInfo . preferredVehicleByBlockId . get  ( blockId ) ;   _log . debug  ( "adding anonymous trip update {} into vehicle {}" ,  td . getTripId  ( ) , preferredVehicleId ) ;   tripUpdatesByVehicleId . put  ( preferredVehicleId , tu ) ; } else  {   anonymousTripUpdatesByBlock . put  ( bd , tu ) ; } } else  {   anonymousTripUpdatesByBlock . put  ( bd , tu ) ; } } }  for ( FeedEntity fe :  vehiclePositionsMessage . getEntityList  ( ) )  {  if  (  !  fe . hasVehicle  ( ) )  {  continue ; }  VehiclePosition  vp =  fe . getVehicle  ( ) ;  if  (   vp . hasVehicle  ( ) &&   vp . getVehicle  ( ) . hasId  ( ) )  {  String  vehicleId =  getVehicleId  ( vp ) ;  if  (  !  vehiclePositionsByVehicleId . containsKey  ( vehicleId ) )  {   vehiclePositionsByVehicleId . put  ( vehicleId , vp ) ; } else  {   _log . warn  ( "Multiple updates for vehicle {}; taking newest." , vehicleId ) ;  VehiclePosition  otherUpdate =  vehiclePositionsByVehicleId . get  ( vehicleId ) ;   long  otherTimestamp =  otherUpdate . getTimestamp  ( ) ;  if  (   vp . getTimestamp  ( ) > otherTimestamp )  {   vehiclePositionsByVehicleId . put  ( vehicleId , vp ) ; } } } else  if  (  vp . hasTrip  ( ) )  {  TripDescriptor  td =  vp . getTrip  ( ) ;   long  time =   vp . hasTimestamp  ( ) ?   vp . getTimestamp  ( ) * 1000 :  currentTime  ( ) ;  BlockDescriptor  bd =  getTripDescriptorAsBlockDescriptor  ( result , td , time ) ;  if  (  bd == null )  {  continue ; }  if  (  !  anonymousVehiclePositionsByBlock . containsKey  ( bd ) )  {   anonymousVehiclePositionsByBlock . put  ( bd , vp ) ; } else  {   _log . debug  ( "Multiple anonymous VehiclePositions for trip {}; giving up." ,  td . getTripId  ( ) ) ;   badAnonymousVehiclePositions . add  ( bd ) ; } } else  {  continue ; } }  for ( BlockDescriptor bd : badAnonymousVehiclePositions )  {   anonymousVehiclePositionsByBlock . remove  ( bd ) ; }  for (   Map . Entry  < String ,  Collection  < TripUpdate > > e :   tripUpdatesByVehicleId . asMap  ( ) . entrySet  ( ) )  {  CombinedTripUpdatesAndVehiclePosition  update =  new CombinedTripUpdatesAndVehiclePosition  ( ) ;  String  vehicleId =  e . getKey  ( ) ;   Collection  < TripUpdate >  tripUpdates =  e . getValue  ( ) ;  TripUpdate  firstTrip =   tripUpdates . iterator  ( ) . next  ( ) ;   long  time =   firstTrip . hasTimestamp  ( ) ?   firstTrip . getTimestamp  ( ) * 1000 :  currentTime  ( ) ;    update . block =  getTripDescriptorAsBlockDescriptor  ( result ,  firstTrip . getTrip  ( ) , time ) ;  if  (    update . block == null &&  isNycDynamicTrip  ( firstTrip ) )  {    update . block =  handleDynamicTripUpdate  ( firstTrip ) ; }   update . setTripUpdates  (  new  ArrayList  < >  ( tripUpdates ) ) ;  if  (  vehiclePositionsByVehicleId . containsKey  ( vehicleId ) )  {    update . vehiclePosition =  vehiclePositionsByVehicleId . get  ( vehicleId ) ; }   updates . add  ( update ) ; }  for (  Entry  < BlockDescriptor ,  Collection  < TripUpdate > > e :   anonymousTripUpdatesByBlock . asMap  ( ) . entrySet  ( ) )  {  CombinedTripUpdatesAndVehiclePosition  update =  new CombinedTripUpdatesAndVehiclePosition  ( ) ;  BlockDescriptor  bd =  e . getKey  ( ) ;    update . block = bd ;   update . setTripUpdates  (  new  ArrayList  < TripUpdate >  (  e . getValue  ( ) ) ) ;  if  (    update . getTripUpdatesSize  ( ) == 1 &&  anonymousVehiclePositionsByBlock . containsKey  ( bd ) )  {    update . vehiclePosition =  anonymousVehiclePositionsByBlock . get  ( bd ) ; }   updates . add  ( update ) ; }  for ( CombinedTripUpdatesAndVehiclePosition update : updates )  {  String  vehicleId = null ;  for ( TripUpdate tu :  update . getTripUpdates  ( ) )  {  if  (   tu . hasVehicle  ( ) &&   tu . getVehicle  ( ) . hasId  ( ) )  {   vehicleId =  getVehicleId  ( tu ) ;  break ; } }  if  (     vehicleId == null &&   update . vehiclePosition != null &&   update . vehiclePosition . hasVehicle  ( ) &&    update . vehiclePosition . getVehicle  ( ) . hasId  ( ) )  {   vehicleId =  getVehicleId  (  update . vehiclePosition ) ; }  if  (    vehicleId != null &&   update . block != null &&    update . block . getVehicleId  ( ) == null )  {    update . block . setVehicleId  ( vehicleId ) ; } }  return updates ; } }