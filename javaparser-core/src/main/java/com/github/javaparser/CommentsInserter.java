  package   com . github . javaparser ;   import     com . github . javaparser . ast . CompilationUnit ;  import     com . github . javaparser . ast . Node ;  import      com . github . javaparser . ast . comments . Comment ;  import      com . github . javaparser . ast . comments . LineComment ;  import     com . github . javaparser . utils . PositionUtils ;  import   java . util . Collections ;  import   java . util . LinkedList ;  import   java . util . List ;  import   java . util . TreeSet ;  import    java . util . stream . Collectors ;  import static      com . github . javaparser . ast . Node . NODE_BY_BEGIN_POSITION ;  class CommentsInserter  {   private final ParserConfiguration  configuration ;  CommentsInserter  (  ParserConfiguration configuration )  {    this . configuration = configuration ; }   private void insertComments  (  CompilationUnit cu ,   TreeSet  < Comment > comments )  {  if  (  comments . isEmpty  ( ) )  return ;   List  < Node >  children =  cu . getChildNodes  ( ) ;  Comment  firstComment =   comments . iterator  ( ) . next  ( ) ;  if  (    cu . getPackageDeclaration  ( ) . isPresent  ( ) &&  (   children . isEmpty  ( ) ||  PositionUtils . areInOrder  ( firstComment ,   cu . getPackageDeclaration  ( ) . get  ( ) ) ) )  {   cu . setComment  ( firstComment ) ;   comments . remove  ( firstComment ) ; } }  void insertComments  (  Node node ,   TreeSet  < Comment > commentsToAttribute )  {  if  (  commentsToAttribute . isEmpty  ( ) )  return ;  if  (  node instanceof CompilationUnit )  {   insertComments  (  ( CompilationUnit ) node , commentsToAttribute ) ; }   List  < Node >  children =  node . getChildNodes  ( ) ;  for ( Node child : children )  {   TreeSet  < Comment >  commentsInsideChild =  new  TreeSet  < >  ( NODE_BY_BEGIN_POSITION ) ;   commentsInsideChild . addAll  (     commentsToAttribute . stream  ( ) . filter  (  c ->   c . getRange  ( ) . isPresent  ( ) ) . filter  (  c ->  PositionUtils . nodeContains  ( child , c ,  configuration . isDoNotConsiderAnnotationsAsNodeStartForCodeAttribution  ( ) ) ) . collect  (  Collectors . toList  ( ) ) ) ;   commentsToAttribute . removeAll  ( commentsInsideChild ) ;   insertComments  ( child , commentsInsideChild ) ; }   attributeLineCommentsOnSameLine  ( commentsToAttribute , children ) ;  Comment  previousComment = null ;   final  List  < Comment >  attributedComments =  new  LinkedList  < >  ( ) ;   List  < Node >  childrenAndComments =  new  LinkedList  < >  ( ) ;   childrenAndComments . addAll  ( children ) ;   commentsToAttribute . removeAll  ( attributedComments ) ;   childrenAndComments . addAll  ( commentsToAttribute ) ;   PositionUtils . sortByBeginPosition  ( childrenAndComments ,  configuration . isDoNotConsiderAnnotationsAsNodeStartForCodeAttribution  ( ) ) ;  for ( Node thing : childrenAndComments )  {  if  (  thing instanceof Comment )  {   previousComment =  ( Comment ) thing ;  if  (  !  previousComment . isOrphan  ( ) )  {   previousComment = null ; } } else  {  if  (   previousComment != null &&  !  thing . hasComment  ( ) )  {  if  (   !  configuration . isDoNotAssignCommentsPrecedingEmptyLines  ( ) ||  !  thereAreLinesBetween  ( previousComment , thing ) )  {   thing . setComment  ( previousComment ) ;   attributedComments . add  ( previousComment ) ;   previousComment = null ; } } } }   commentsToAttribute . removeAll  ( attributedComments ) ;  for ( Comment c : commentsToAttribute )  {  if  (  c . isOrphan  ( ) )  {   node . addOrphanComment  ( c ) ; } } }   private void attributeLineCommentsOnSameLine  (   TreeSet  < Comment > commentsToAttribute ,   List  < Node > children )  {   List  < Comment >  attributedComments =  new  LinkedList  < >  ( ) ;      commentsToAttribute . stream  ( ) . filter  (  comment ->   comment . getRange  ( ) . isPresent  ( ) ) . filter  (  Comment :: isLineComment ) . forEach  (  comment ->    children . stream  ( ) . filter  (  child ->   child . getRange  ( ) . isPresent  ( ) ) . forEach  (  child ->  {  Range  commentRange =   comment . getRange  ( ) . get  ( ) ;  Range  childRange =   child . getRange  ( ) . get  ( ) ;  if  (     childRange . end . line ==   commentRange . begin . line &&  attributeLineCommentToNodeOrChild  ( child ,  comment . asLineComment  ( ) ) )  {   attributedComments . add  ( comment ) ; } } ) ) ;   commentsToAttribute . removeAll  ( attributedComments ) ; }   private boolean attributeLineCommentToNodeOrChild  (  Node node ,  LineComment lineComment )  {  if  (   !   node . getRange  ( ) . isPresent  ( ) ||  !   lineComment . getRange  ( ) . isPresent  ( ) )  {  return false ; }  if  (      node . getBegin  ( ) . get  ( ) . line ==    lineComment . getBegin  ( ) . get  ( ) . line &&  !  node . hasComment  ( ) )  {  if  (  !  (  node instanceof Comment ) )  {   node . setComment  ( lineComment ) ; }  return true ; } else  {   List  < Node >  children =  new  LinkedList  < >  ( ) ;   children . addAll  (  node . getChildNodes  ( ) ) ;   PositionUtils . sortByBeginPosition  ( children ) ;   Collections . reverse  ( children ) ;  for ( Node child : children )  {  if  (  attributeLineCommentToNodeOrChild  ( child , lineComment ) )  {  return true ; } }  return false ; } }   private boolean thereAreLinesBetween  (  Node a ,  Node b )  {  if  (   !   a . getRange  ( ) . isPresent  ( ) ||  !   b . getRange  ( ) . isPresent  ( ) )  {  return true ; }  if  (  !  PositionUtils . areInOrder  ( a , b ) )  {  return  thereAreLinesBetween  ( b , a ) ; }   int  endOfA =    a . getEnd  ( ) . get  ( ) . line ;  return     b . getBegin  ( ) . get  ( ) . line >  endOfA + 1 ; } }