  package     com . github . javaparser . ast . type ;   import    com . github . javaparser . Range ;  import     com . github . javaparser . ast . AllFieldsConstructor ;  import     com . github . javaparser . ast . Node ;  import     com . github . javaparser . ast . NodeList ;  import      com . github . javaparser . ast . expr . AnnotationExpr ;  import      com . github . javaparser . ast . nodeTypes . NodeWithAnnotations ;  import      com . github . javaparser . ast . observer . ObservableProperty ;  import      com . github . javaparser . ast . visitor . CloneVisitor ;  import      com . github . javaparser . ast . visitor . GenericVisitor ;  import      com . github . javaparser . ast . visitor . VoidVisitor ;  import     com . github . javaparser . metamodel . IntersectionTypeMetaModel ;  import     com . github . javaparser . metamodel . JavaParserMetaModel ;  import     com . github . javaparser . metamodel . NonEmptyProperty ;  import   java . util . Arrays ;  import   java . util . List ;  import static      com . github . javaparser . utils . Utils . assertNotNull ;  import static     java . util . stream . Collectors . joining ;  import   javax . annotation . Generated ;   public class IntersectionType  extends Type  implements   NodeWithAnnotations  < IntersectionType >  {    @ NonEmptyProperty private  NodeList  < ReferenceType >  elements ;    @ Override public  <  R ,  A > R accept  (   GenericVisitor  < R , A > v ,  A arg )  {  return  v . visit  ( this , arg ) ; }    @ Override public  <  A > void accept  (   VoidVisitor  < A > v ,  A arg )  {   v . visit  ( this , arg ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" )  NodeList  < ReferenceType > getElements  ( )  {  return elements ; }    @ Override public IntersectionType setAnnotations  (   NodeList  < AnnotationExpr > annotations )  {  return  ( IntersectionType )  super . setAnnotations  ( annotations ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.GetNodeListsGenerator" )  List  <  NodeList  <  ? > > getNodeLists  ( )  {  return  Arrays . asList  (  getElements  ( ) ,  getAnnotations  ( ) ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.RemoveMethodGenerator" ) boolean remove  (  Node node )  {  if  (  node == null )  return false ;  for (   int  i = 0 ;  i <  elements . size  ( ) ;  i ++ )  {  if  (   elements . get  ( i ) == node )  {   elements . remove  ( i ) ;  return true ; } }  return  super . remove  ( node ) ; }    @ Override public String asString  ( )  {  return    elements . stream  ( ) . map  (  Type :: asString ) . collect  (  joining  ( "&" ) ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.CloneGenerator" ) IntersectionType clone  ( )  {  return  ( IntersectionType )  accept  (  new CloneVisitor  ( ) , null ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.GetMetaModelGenerator" ) IntersectionTypeMetaModel getMetaModel  ( )  {  return  JavaParserMetaModel . intersectionTypeMetaModel ; }    @ AllFieldsConstructor public IntersectionType  (   NodeList  < ReferenceType > elements )  {  this  ( null , elements ) ; }    @ Generated  ( "com.github.javaparser.generator.core.node.MainConstructorGenerator" ) public IntersectionType  (  Range range ,   NodeList  < ReferenceType > elements )  {  super  ( range ) ;   setElements  ( elements ) ;   customInitialization  ( ) ; }    @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" ) public IntersectionType setElements  (   final  NodeList  < ReferenceType > elements )  {   assertNotNull  ( elements ) ;  if  (  elements ==  this . elements )  {  return  ( IntersectionType ) this ; }   notifyPropertyChange  (  ObservableProperty . ELEMENTS ,  this . elements , elements ) ;  if  (   this . elements != null )    this . elements . setParentNode  ( null ) ;    this . elements = elements ;   setAsParentNodeOf  ( elements ) ;  return this ; } }