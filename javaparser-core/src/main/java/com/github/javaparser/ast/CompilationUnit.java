  package    com . github . javaparser . ast ;   import   com . github . javaparser .  * ;  import      com . github . javaparser . ast . body . AnnotationDeclaration ;  import      com . github . javaparser . ast . body . ClassOrInterfaceDeclaration ;  import      com . github . javaparser . ast . body . EnumDeclaration ;  import      com . github . javaparser . ast . body . TypeDeclaration ;  import      com . github . javaparser . ast . comments . Comment ;  import      com . github . javaparser . ast . comments . JavadocComment ;  import      com . github . javaparser . ast . expr . Name ;  import      com . github . javaparser . ast . modules . ModuleDeclaration ;  import      com . github . javaparser . ast . observer . ObservableProperty ;  import      com . github . javaparser . ast . validator . Java9Validator ;  import      com . github . javaparser . ast . visitor . CloneVisitor ;  import      com . github . javaparser . ast . visitor . GenericVisitor ;  import      com . github . javaparser . ast . visitor . VoidVisitor ;  import     com . github . javaparser . metamodel . CompilationUnitMetaModel ;  import     com . github . javaparser . metamodel . InternalProperty ;  import     com . github . javaparser . metamodel . JavaParserMetaModel ;  import     com . github . javaparser . printer . PrettyPrinter ;  import     com . github . javaparser . utils . ClassUtils ;  import   java . io . IOException ;  import    java . nio . file . Files ;  import    java . nio . file . Path ;  import   java . util . Arrays ;  import   java . util . EnumSet ;  import   java . util . List ;  import   java . util . Optional ;  import    java . util . function . Function ;  import    java . util . stream . Collectors ;  import static     com . github . javaparser . JavaParser . parseName ;  import static     com . github . javaparser . Providers . UTF8 ;  import static     com . github . javaparser . Providers . provider ;  import static      com . github . javaparser . utils . Utils . assertNotNull ;  import   javax . annotation . Generated ;  import     com . github . javaparser . ast . Node ;   public final class CompilationUnit  extends Node  {   private PackageDeclaration  packageDeclaration ;   private  NodeList  < ImportDeclaration >  imports ;   private  NodeList  <  TypeDeclaration  <  ? > >  types ;   private ModuleDeclaration  module ;    @ InternalProperty private Storage  storage ;   public CompilationUnit  ( )  {  this  ( null , null ,  new  NodeList  < >  ( ) ,  new  NodeList  < >  ( ) , null ) ; }   public CompilationUnit  (  String packageDeclaration )  {  this  ( null ,  new PackageDeclaration  (  new Name  ( packageDeclaration ) ) ,  new  NodeList  < >  ( ) ,  new  NodeList  < >  ( ) , null ) ; }    @ AllFieldsConstructor public CompilationUnit  (  PackageDeclaration packageDeclaration ,   NodeList  < ImportDeclaration > imports ,   NodeList  <  TypeDeclaration  <  ? > > types ,  ModuleDeclaration module )  {  this  ( null , packageDeclaration , imports , types , module ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.MainConstructorGenerator" ) CompilationUnit  (  Range range ,  PackageDeclaration packageDeclaration ,   NodeList  < ImportDeclaration > imports ,   NodeList  <  TypeDeclaration  <  ? > > types ,  ModuleDeclaration module )  {  super  ( range ) ;   setPackageDeclaration  ( packageDeclaration ) ;   setImports  ( imports ) ;   setTypes  ( types ) ;   setModule  ( module ) ;   customInitialization  ( ) ; }    @ Override public  <  R ,  A > R accept  (   GenericVisitor  < R , A > v ,  A arg )  {  return  v . visit  ( this , arg ) ; }    @ Override public  <  A > void accept  (   VoidVisitor  < A > v ,  A arg )  {   v . visit  ( this , arg ) ; }   public  List  < Comment > getComments  ( )  {  return  this . getAllContainedComments  ( ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" )  NodeList  < ImportDeclaration > getImports  ( )  {  return imports ; }   public ImportDeclaration getImport  (   int i )  {  return   getImports  ( ) . get  ( i ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" )  Optional  < PackageDeclaration > getPackageDeclaration  ( )  {  return  Optional . ofNullable  ( packageDeclaration ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" )  NodeList  <  TypeDeclaration  <  ? > > getTypes  ( )  {  return types ; }   public  TypeDeclaration  <  ? > getType  (   int i )  {  return   getTypes  ( ) . get  ( i ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" ) CompilationUnit setImports  (   final  NodeList  < ImportDeclaration > imports )  {   assertNotNull  ( imports ) ;  if  (  imports ==  this . imports )  {  return  ( CompilationUnit ) this ; }   notifyPropertyChange  (  ObservableProperty . IMPORTS ,  this . imports , imports ) ;  if  (   this . imports != null )    this . imports . setParentNode  ( null ) ;    this . imports = imports ;   setAsParentNodeOf  ( imports ) ;  return this ; }   public CompilationUnit setImport  (   int i ,  ImportDeclaration imports )  {    getImports  ( ) . set  ( i , imports ) ;  return this ; }   public CompilationUnit addImport  (  ImportDeclaration imports )  {    getImports  ( ) . add  ( imports ) ;  return this ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" ) CompilationUnit setPackageDeclaration  (   final PackageDeclaration packageDeclaration )  {  if  (  packageDeclaration ==  this . packageDeclaration )  {  return  ( CompilationUnit ) this ; }   notifyPropertyChange  (  ObservableProperty . PACKAGE_DECLARATION ,  this . packageDeclaration , packageDeclaration ) ;  if  (   this . packageDeclaration != null )    this . packageDeclaration . setParentNode  ( null ) ;    this . packageDeclaration = packageDeclaration ;   setAsParentNodeOf  ( packageDeclaration ) ;  return this ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" ) CompilationUnit setTypes  (   final  NodeList  <  TypeDeclaration  <  ? > > types )  {   assertNotNull  ( types ) ;  if  (  types ==  this . types )  {  return  ( CompilationUnit ) this ; }   notifyPropertyChange  (  ObservableProperty . TYPES ,  this . types , types ) ;  if  (   this . types != null )    this . types . setParentNode  ( null ) ;    this . types = types ;   setAsParentNodeOf  ( types ) ;  return this ; }   public CompilationUnit setType  (   int i ,   TypeDeclaration  <  ? > type )  {   NodeList  <  TypeDeclaration  <  ? > >  copy =  new  NodeList  < >  ( ) ;   copy . addAll  (  getTypes  ( ) ) ;    getTypes  ( ) . set  ( i , type ) ;   notifyPropertyChange  (  ObservableProperty . TYPES , copy , types ) ;  return this ; }   public CompilationUnit addType  (   TypeDeclaration  <  ? > type )  {   NodeList  <  TypeDeclaration  <  ? > >  copy =  new  NodeList  < >  ( ) ;   copy . addAll  (  getTypes  ( ) ) ;    getTypes  ( ) . add  ( type ) ;   notifyPropertyChange  (  ObservableProperty . TYPES , copy , types ) ;  return this ; }   public CompilationUnit setPackageDeclaration  (  String name )  {   setPackageDeclaration  (  new PackageDeclaration  (  parseName  ( name ) ) ) ;  return this ; }   public CompilationUnit addImport  (  String name )  {  return  addImport  ( name , false , false ) ; }   public CompilationUnit addImport  (   Class  <  ? > clazz )  {  if  (   ClassUtils . isPrimitiveOrWrapper  ( clazz ) ||   clazz . getName  ( ) . startsWith  ( "java.lang" ) )  return this ; else  if  (  clazz . isMemberClass  ( ) )  return  addImport  (   clazz . getName  ( ) . replace  ( "$" , "." ) ) ; else  if  (    clazz . isArray  ( ) &&  !  ClassUtils . isPrimitiveOrWrapper  (  clazz . getComponentType  ( ) ) &&  !    clazz . getComponentType  ( ) . getName  ( ) . startsWith  ( "java.lang" ) )  return  addImport  (   clazz . getComponentType  ( ) . getName  ( ) ) ; else  if  (   clazz . isAnonymousClass  ( ) ||  clazz . isLocalClass  ( ) )  throw  new RuntimeException  (   clazz . getName  ( ) + " is an anonymous or local class therefore it can't be added with addImport" ) ;  return  addImport  (  clazz . getName  ( ) ) ; }   public CompilationUnit addImport  (  String name ,  boolean isStatic ,  boolean isAsterisk )  {   final StringBuilder  i =  new StringBuilder  ( "import " ) ;  if  ( isStatic )  {   i . append  ( "static " ) ; }   i . append  ( name ) ;  if  ( isAsterisk )  {   i . append  ( ".*" ) ; }   i . append  ( ";" ) ;  ImportDeclaration  importDeclaration =  JavaParser . parseImport  (  i . toString  ( ) ) ;  if  (    getImports  ( ) . stream  ( ) . anyMatch  (  im ->   im . toString  ( ) . equals  (  importDeclaration . toString  ( ) ) ) )  return this ; else  {    getImports  ( ) . add  ( importDeclaration ) ;  return this ; } }   public ClassOrInterfaceDeclaration addClass  (  String name )  {  return  addClass  ( name ,  Modifier . PUBLIC ) ; }   public ClassOrInterfaceDeclaration addClass  (  String name ,  Modifier ...  modifiers )  {  ClassOrInterfaceDeclaration  classOrInterfaceDeclaration =  new ClassOrInterfaceDeclaration  (   Arrays . stream  ( modifiers ) . collect  (  Collectors . toCollection  (   ( ) ->  EnumSet . noneOf  (  Modifier . class ) ) ) , false , name ) ;    getTypes  ( ) . add  ( classOrInterfaceDeclaration ) ;  return classOrInterfaceDeclaration ; }   public ClassOrInterfaceDeclaration addInterface  (  String name )  {  return  addInterface  ( name ,  Modifier . PUBLIC ) ; }   public ClassOrInterfaceDeclaration addInterface  (  String name ,  Modifier ...  modifiers )  {  ClassOrInterfaceDeclaration  classOrInterfaceDeclaration =  new ClassOrInterfaceDeclaration  (   Arrays . stream  ( modifiers ) . collect  (  Collectors . toCollection  (   ( ) ->  EnumSet . noneOf  (  Modifier . class ) ) ) , true , name ) ;    getTypes  ( ) . add  ( classOrInterfaceDeclaration ) ;  return classOrInterfaceDeclaration ; }   public EnumDeclaration addEnum  (  String name )  {  return  addEnum  ( name ,  Modifier . PUBLIC ) ; }   public EnumDeclaration addEnum  (  String name ,  Modifier ...  modifiers )  {  EnumDeclaration  enumDeclaration =  new EnumDeclaration  (   Arrays . stream  ( modifiers ) . collect  (  Collectors . toCollection  (   ( ) ->  EnumSet . noneOf  (  Modifier . class ) ) ) , name ) ;    getTypes  ( ) . add  ( enumDeclaration ) ;  return enumDeclaration ; }   public AnnotationDeclaration addAnnotationDeclaration  (  String name )  {  return  addAnnotationDeclaration  ( name ,  Modifier . PUBLIC ) ; }   public AnnotationDeclaration addAnnotationDeclaration  (  String name ,  Modifier ...  modifiers )  {  AnnotationDeclaration  annotationDeclaration =  new AnnotationDeclaration  (   Arrays . stream  ( modifiers ) . collect  (  Collectors . toCollection  (   ( ) ->  EnumSet . noneOf  (  Modifier . class ) ) ) , name ) ;    getTypes  ( ) . add  ( annotationDeclaration ) ;  return annotationDeclaration ; }   public  Optional  < ClassOrInterfaceDeclaration > getClassByName  (  String className )  {  return      getTypes  ( ) . stream  ( ) . filter  (  type ->     type . getNameAsString  ( ) . equals  ( className ) &&  type instanceof ClassOrInterfaceDeclaration &&  !   (  ( ClassOrInterfaceDeclaration ) type ) . isInterface  ( ) ) . findFirst  ( ) . map  (  t ->  ( ClassOrInterfaceDeclaration ) t ) ; }   public  Optional  < ClassOrInterfaceDeclaration > getInterfaceByName  (  String interfaceName )  {  return      getTypes  ( ) . stream  ( ) . filter  (  type ->     type . getNameAsString  ( ) . equals  ( interfaceName ) &&  type instanceof ClassOrInterfaceDeclaration &&   (  ( ClassOrInterfaceDeclaration ) type ) . isInterface  ( ) ) . findFirst  ( ) . map  (  t ->  ( ClassOrInterfaceDeclaration ) t ) ; }   public  Optional  < EnumDeclaration > getEnumByName  (  String enumName )  {  return      getTypes  ( ) . stream  ( ) . filter  (  type ->    type . getNameAsString  ( ) . equals  ( enumName ) &&  type instanceof EnumDeclaration ) . findFirst  ( ) . map  (  t ->  ( EnumDeclaration ) t ) ; }   public  Optional  < AnnotationDeclaration > getAnnotationDeclarationByName  (  String annotationName )  {  return      getTypes  ( ) . stream  ( ) . filter  (  type ->    type . getNameAsString  ( ) . equals  ( annotationName ) &&  type instanceof AnnotationDeclaration ) . findFirst  ( ) . map  (  t ->  ( AnnotationDeclaration ) t ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.GetNodeListsGenerator" )  List  <  NodeList  <  ? > > getNodeLists  ( )  {  return  Arrays . asList  (  getImports  ( ) ,  getTypes  ( ) ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.RemoveMethodGenerator" ) boolean remove  (  Node node )  {  if  (  node == null )  return false ;  for (   int  i = 0 ;  i <  imports . size  ( ) ;  i ++ )  {  if  (   imports . get  ( i ) == node )  {   imports . remove  ( i ) ;  return true ; } }  if  (  module != null )  {  if  (  node == module )  {   removeModule  ( ) ;  return true ; } }  if  (  packageDeclaration != null )  {  if  (  node == packageDeclaration )  {   removePackageDeclaration  ( ) ;  return true ; } }  for (   int  i = 0 ;  i <  types . size  ( ) ;  i ++ )  {  if  (   types . get  ( i ) == node )  {   types . remove  ( i ) ;  return true ; } }  return  super . remove  ( node ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.RemoveMethodGenerator" ) CompilationUnit removePackageDeclaration  ( )  {  return  setPackageDeclaration  (  ( PackageDeclaration ) null ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" )  Optional  < ModuleDeclaration > getModule  ( )  {  return  Optional . ofNullable  ( module ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" ) CompilationUnit setModule  (   final ModuleDeclaration module )  {  if  (  module ==  this . module )  {  return  ( CompilationUnit ) this ; }   notifyPropertyChange  (  ObservableProperty . MODULE ,  this . module , module ) ;  if  (   this . module != null )    this . module . setParentNode  ( null ) ;    this . module = module ;   setAsParentNodeOf  ( module ) ;  return this ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.RemoveMethodGenerator" ) CompilationUnit removeModule  ( )  {  return  setModule  (  ( ModuleDeclaration ) null ) ; }   public  Optional  < Storage > getStorage  ( )  {  return  Optional . ofNullable  ( storage ) ; }   public CompilationUnit setStorage  (  Path path )  {    this . storage =  new Storage  ( this , path ) ;  return this ; }   public static class Storage  {   private final CompilationUnit  compilationUnit ;   private final Path  path ;   private Storage  (  CompilationUnit compilationUnit ,  Path path )  {    this . compilationUnit = compilationUnit ;    this . path =  path . toAbsolutePath  ( ) ; }   public Path getPath  ( )  {  return path ; }   public CompilationUnit getCompilationUnit  ( )  {  return compilationUnit ; }   public void save  ( )  {   save  (  cu ->   new PrettyPrinter  ( ) . print  (  getCompilationUnit  ( ) ) ) ; }   public void save  (   Function  < CompilationUnit , String > makeOutput )  {  try  {   Files . createDirectories  (  path . getParent  ( ) ) ;   final String  code =  makeOutput . apply  (  getCompilationUnit  ( ) ) ;   Files . write  ( path ,  code . getBytes  ( UTF8 ) ) ; }  catch (   IOException e )  {  throw  new RuntimeException  ( e ) ; } }   public  ParseResult  < CompilationUnit > reparse  (  JavaParser javaParser )  {  try  {  return  javaParser . parse  (  ParseStart . COMPILATION_UNIT ,  provider  (  getPath  ( ) ) ) ; }  catch (   IOException e )  {  throw  new RuntimeException  ( e ) ; } } }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.CloneGenerator" ) CompilationUnit clone  ( )  {  return  ( CompilationUnit )  accept  (  new CloneVisitor  ( ) , null ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.GetMetaModelGenerator" ) CompilationUnitMetaModel getMetaModel  ( )  {  return  JavaParserMetaModel . compilationUnitMetaModel ; } }