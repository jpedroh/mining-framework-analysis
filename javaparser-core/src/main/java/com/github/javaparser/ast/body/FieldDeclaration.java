  package     com . github . javaparser . ast . body ;   import    com . github . javaparser . Range ;  import     com . github . javaparser . ast . AllFieldsConstructor ;  import     com . github . javaparser . ast . Modifier ;  import     com . github . javaparser . ast . Node ;  import     com . github . javaparser . ast . NodeList ;  import      com . github . javaparser . ast . expr . AnnotationExpr ;  import      com . github . javaparser . ast . expr . AssignExpr ;  import       com . github . javaparser . ast . expr . AssignExpr . Operator ;  import      com . github . javaparser . ast . expr . NameExpr ;  import      com . github . javaparser . ast . nodeTypes . NodeWithJavadoc ;  import      com . github . javaparser . ast . nodeTypes . NodeWithVariables ;  import       com . github . javaparser . ast . nodeTypes . modifiers . NodeWithAccessModifiers ;  import       com . github . javaparser . ast . nodeTypes . modifiers . NodeWithFinalModifier ;  import       com . github . javaparser . ast . nodeTypes . modifiers . NodeWithStaticModifier ;  import      com . github . javaparser . ast . observer . ObservableProperty ;  import      com . github . javaparser . ast . stmt . BlockStmt ;  import      com . github . javaparser . ast . stmt . ReturnStmt ;  import      com . github . javaparser . ast . type . Type ;  import      com . github . javaparser . ast . type . VoidType ;  import      com . github . javaparser . ast . visitor . CloneVisitor ;  import      com . github . javaparser . ast . visitor . GenericVisitor ;  import      com . github . javaparser . ast . visitor . VoidVisitor ;  import     com . github . javaparser . metamodel . FieldDeclarationMetaModel ;  import     com . github . javaparser . metamodel . JavaParserMetaModel ;  import     com . github . javaparser . metamodel . NonEmptyProperty ;  import   java . util . Arrays ;  import   java . util . EnumSet ;  import   java . util . List ;  import   java . util . Optional ;  import static     com . github . javaparser . ast . Modifier .  * ;  import static      com . github . javaparser . ast . NodeList . nodeList ;  import static      com . github . javaparser . utils . Utils . assertNotNull ;  import   javax . annotation . Generated ;   public final class FieldDeclaration  extends  BodyDeclaration  < FieldDeclaration >  implements   NodeWithJavadoc  < FieldDeclaration > ,  NodeWithVariables  < FieldDeclaration > ,  NodeWithAccessModifiers  < FieldDeclaration > ,  NodeWithStaticModifier  < FieldDeclaration > ,  NodeWithFinalModifier  < FieldDeclaration >  {   private  EnumSet  < Modifier >  modifiers ;    @ NonEmptyProperty private  NodeList  < VariableDeclarator >  variables ;   public FieldDeclaration  ( )  {  this  ( null ,  EnumSet . noneOf  (  Modifier . class ) ,  new  NodeList  < >  ( ) ,  new  NodeList  < >  ( ) ) ; }   public FieldDeclaration  (   EnumSet  < Modifier > modifiers ,  VariableDeclarator variable )  {  this  ( null , modifiers ,  new  NodeList  < >  ( ) ,  nodeList  ( variable ) ) ; }   public FieldDeclaration  (   EnumSet  < Modifier > modifiers ,   NodeList  < VariableDeclarator > variables )  {  this  ( null , modifiers ,  new  NodeList  < >  ( ) , variables ) ; }    @ AllFieldsConstructor public FieldDeclaration  (   EnumSet  < Modifier > modifiers ,   NodeList  < AnnotationExpr > annotations ,   NodeList  < VariableDeclarator > variables )  {  this  ( null , modifiers , annotations , variables ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.MainConstructorGenerator" ) FieldDeclaration  (  Range range ,   EnumSet  < Modifier > modifiers ,   NodeList  < AnnotationExpr > annotations ,   NodeList  < VariableDeclarator > variables )  {  super  ( range , annotations ) ;   setModifiers  ( modifiers ) ;   setVariables  ( variables ) ;   customInitialization  ( ) ; }   public FieldDeclaration  (   EnumSet  < Modifier > modifiers ,  Type type ,  String name )  {  this  (  assertNotNull  ( modifiers ) ,  new VariableDeclarator  ( type ,  assertNotNull  ( name ) ) ) ; }    @ Override public  <  R ,  A > R accept  (   GenericVisitor  < R , A > v ,  A arg )  {  return  v . visit  ( this , arg ) ; }    @ Override public  <  A > void accept  (   VoidVisitor  < A > v ,  A arg )  {   v . visit  ( this , arg ) ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" )  EnumSet  < Modifier > getModifiers  ( )  {  return modifiers ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" )  NodeList  < VariableDeclarator > getVariables  ( )  {  return variables ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" ) FieldDeclaration setModifiers  (   final  EnumSet  < Modifier > modifiers )  {   assertNotNull  ( modifiers ) ;  if  (  modifiers ==  this . modifiers )  {  return  ( FieldDeclaration ) this ; }   notifyPropertyChange  (  ObservableProperty . MODIFIERS ,  this . modifiers , modifiers ) ;    this . modifiers = modifiers ;  return this ; }   public  @ Generated  ( "com.github.javaparser.generator.core.node.PropertyGenerator" ) FieldDeclaration setVariables  (   final  NodeList  < VariableDeclarator > variables )  {   assertNotNull  ( variables ) ;  if  (  variables ==  this . variables )  {  return  ( FieldDeclaration ) this ; }   notifyPropertyChange  (  ObservableProperty . VARIABLES ,  this . variables , variables ) ;  if  (   this . variables != null )    this . variables . setParentNode  ( null ) ;    this . variables = variables ;   setAsParentNodeOf  ( variables ) ;  return this ; }   public MethodDeclaration createGetter  ( )  {  if  (    getVariables  ( ) . size  ( ) != 1 )  throw  new IllegalStateException  ( "You can use this only when the field declares only 1 variable name" ) ;   Optional  < ClassOrInterfaceDeclaration >  parentClass =  getAncestorOfType  (  ClassOrInterfaceDeclaration . class ) ;   Optional  < EnumDeclaration >  parentEnum =  getAncestorOfType  (  EnumDeclaration . class ) ;  if  (   !  (   parentClass . isPresent  ( ) ||  parentEnum . isPresent  ( ) ) ||  (   parentClass . isPresent  ( ) &&   parentClass . get  ( ) . isInterface  ( ) ) )  throw  new IllegalStateException  ( "You can use this only when the field is attached to a class or an enum" ) ;  VariableDeclarator  variable =  getVariable  ( 0 ) ;  String  fieldName =  variable . getNameAsString  ( ) ;  String  fieldNameUpper =    fieldName . toUpperCase  ( ) . substring  ( 0 , 1 ) +  fieldName . substring  ( 1 ,  fieldName . length  ( ) ) ;   final MethodDeclaration  getter ;   getter =   parentClass . map  (  clazz ->  clazz . addMethod  (  "get" + fieldNameUpper , PUBLIC ) ) . orElseGet  (   ( ) ->   parentEnum . get  ( ) . addMethod  (  "get" + fieldNameUpper , PUBLIC ) ) ;   getter . setType  (  variable . getType  ( ) ) ;  BlockStmt  blockStmt =  new BlockStmt  ( ) ;   getter . setBody  ( blockStmt ) ;   blockStmt . addStatement  (  new ReturnStmt  ( fieldName ) ) ;  return getter ; }   public MethodDeclaration createSetter  ( )  {  if  (    getVariables  ( ) . size  ( ) != 1 )  throw  new IllegalStateException  ( "You can use this only when the field declares only 1 variable name" ) ;   Optional  < ClassOrInterfaceDeclaration >  parentClass =  getAncestorOfType  (  ClassOrInterfaceDeclaration . class ) ;   Optional  < EnumDeclaration >  parentEnum =  getAncestorOfType  (  EnumDeclaration . class ) ;  if  (   !  (   parentClass . isPresent  ( ) ||  parentEnum . isPresent  ( ) ) ||  (   parentClass . isPresent  ( ) &&   parentClass . get  ( ) . isInterface  ( ) ) )  throw  new IllegalStateException  ( "You can use this only when the field is attached to a class or an enum" ) ;  VariableDeclarator  variable =  getVariable  ( 0 ) ;  String  fieldName =  variable . getNameAsString  ( ) ;  String  fieldNameUpper =    fieldName . toUpperCase  ( ) . substring  ( 0 , 1 ) +  fieldName . substring  ( 1 ,  fieldName . length  ( ) ) ;   final MethodDeclaration  setter ;   setter =   parentClass . map  (  clazz ->  clazz . addMethod  (  "set" + fieldNameUpper , PUBLIC ) ) . orElseGet  (   ( ) ->   parentEnum . get  ( ) . addMethod  (  "set" + fieldNameUpper , PUBLIC ) ) ;   setter . setType  (  new VoidType  ( ) ) ;    setter . getParameters  ( ) . add  (  new Parameter  (  variable . getType  ( ) , fieldName ) ) ;  BlockStmt  blockStmt2 =  new BlockStmt  ( ) ;   setter . setBody  ( blockStmt2 ) ;   blockStmt2 . addStatement  (  new AssignExpr  (  new NameExpr  (  "this." + fieldName ) ,  new NameExpr  ( fieldName ) ,  Operator . ASSIGN ) ) ;  return setter ; }   public boolean isTransient  ( )  {  return   getModifiers  ( ) . contains  ( TRANSIENT ) ; }   public boolean isVolatile  ( )  {  return   getModifiers  ( ) . contains  ( VOLATILE ) ; }   public FieldDeclaration setTransient  (  boolean set )  {  return  setModifier  ( TRANSIENT , set ) ; }   public FieldDeclaration setVolatile  (  boolean set )  {  return  setModifier  ( VOLATILE , set ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.GetNodeListsGenerator" )  List  <  NodeList  <  ? > > getNodeLists  ( )  {  return  Arrays . asList  (  getVariables  ( ) ,  getAnnotations  ( ) ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.RemoveMethodGenerator" ) boolean remove  (  Node node )  {  if  (  node == null )  return false ;  for (   int  i = 0 ;  i <  variables . size  ( ) ;  i ++ )  {  if  (   variables . get  ( i ) == node )  {   variables . remove  ( i ) ;  return true ; } }  return  super . remove  ( node ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.CloneGenerator" ) FieldDeclaration clone  ( )  {  return  ( FieldDeclaration )  accept  (  new CloneVisitor  ( ) , null ) ; }    @ Override public  @ Generated  ( "com.github.javaparser.generator.core.node.GetMetaModelGenerator" ) FieldDeclarationMetaModel getMetaModel  ( )  {  return  JavaParserMetaModel . fieldDeclarationMetaModel ; } }