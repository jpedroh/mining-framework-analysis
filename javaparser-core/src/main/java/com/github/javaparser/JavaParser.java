  package   com . github . javaparser ;   import     com . github . javaparser . ast . CompilationUnit ;  import     com . github . javaparser . ast . ImportDeclaration ;  import     com . github . javaparser . ast . Node ;  import      com . github . javaparser . ast . body . BodyDeclaration ;  import      com . github . javaparser . ast . body . Parameter ;  import      com . github . javaparser . ast . comments . CommentsCollection ;  import      com . github . javaparser . ast . expr . AnnotationExpr ;  import      com . github . javaparser . ast . expr . Expression ;  import      com . github . javaparser . ast . expr . Name ;  import      com . github . javaparser . ast . expr . VariableDeclarationExpr ;  import      com . github . javaparser . ast . stmt . BlockStmt ;  import      com . github . javaparser . ast . stmt . ExplicitConstructorInvocationStmt ;  import      com . github . javaparser . ast . stmt . Statement ;  import      com . github . javaparser . ast . type . ClassOrInterfaceType ;  import      com . github . javaparser . ast . validator . ProblemReporter ;  import     com . github . javaparser . javadoc . Javadoc ;  import  java . io .  * ;  import    java . nio . charset . Charset ;  import    java . nio . file . Path ;  import   java . util . TreeSet ;  import static    com . github . javaparser . ParseStart .  * ;  import static     com . github . javaparser . Problem . PROBLEM_BY_BEGIN_POSITION ;  import static    com . github . javaparser . Providers .  * ;  import static     com . github . javaparser . Range . range ;  import static      com . github . javaparser . utils . Utils . assertNotNull ;  import      com . github . javaparser . ast . type . Type ;   public final class JavaParser  {   private final CommentsInserter  commentsInserter ;   private final ParserConfiguration  configuration ;   private GeneratedJavaParser  astParser = null ;   private static ParserConfiguration  staticConfiguration =  new ParserConfiguration  ( ) ;   public JavaParser  ( )  {  this  (  new ParserConfiguration  ( ) ) ; }   public JavaParser  (  ParserConfiguration configuration )  {    this . configuration = configuration ;   commentsInserter =  new CommentsInserter  ( configuration ) ; }   public static ParserConfiguration getStaticConfiguration  ( )  {  return staticConfiguration ; }   public static void setStaticConfiguration  (  ParserConfiguration staticConfiguration )  {    JavaParser . staticConfiguration = staticConfiguration ; }   private GeneratedJavaParser getParserForProvider  (  Provider provider )  {  if  (  astParser == null )  {   astParser =  new GeneratedJavaParser  ( provider ) ; } else  {   astParser . reset  ( provider ) ; }   astParser . setTabSize  (  configuration . getTabSize  ( ) ) ;  return astParser ; }   public  <  N  extends Node >  ParseResult  < N > parse  (   ParseStart  < N > start ,  Provider provider )  {   assertNotNull  ( start ) ;   assertNotNull  ( provider ) ;   final GeneratedJavaParser  parser =  getParserForProvider  ( provider ) ;  try  {  N  resultNode =  start . parse  ( parser ) ;  if  (  configuration . isAttributeComments  ( ) )  {   final CommentsCollection  comments =  parser . getCommentsCollection  ( ) ;   commentsInserter . insertComments  ( resultNode ,   comments . copy  ( ) . getComments  ( ) ) ; }    configuration . getValidator  ( ) . accept  ( resultNode ,  new ProblemReporter  (  parser . problems ) ) ;    parser . problems . sort  ( PROBLEM_BY_BEGIN_POSITION ) ;  return  new  ParseResult  < >  ( resultNode ,  parser . problems ,  parser . getTokens  ( ) ,  parser . getCommentsCollection  ( ) ) ; }  catch (   ParseException p )  {   final Token  token =  p . currentToken ;   final Range  range =  range  (  token . beginLine ,  token . beginColumn ,  token . endLine ,  token . endColumn ) ;    parser . problems . add  (  new Problem  (  makeMessageForParseException  ( p ) , range , p ) ) ;  return  new  ParseResult  < >  ( null ,  parser . problems ,  parser . getTokens  ( ) ,  parser . getCommentsCollection  ( ) ) ; }  catch (   Exception e )  {   final String  message =    e . getMessage  ( ) == null ? "Unknown error" :  e . getMessage  ( ) ;    parser . problems . add  (  new Problem  ( message , null , e ) ) ;  return  new  ParseResult  < >  ( null ,  parser . problems ,  parser . getTokens  ( ) ,  parser . getCommentsCollection  ( ) ) ; }  finally  {  try  {   provider . close  ( ) ; }  catch (   IOException e )  { } } }   private String makeMessageForParseException  (  ParseException exception )  {   final StringBuilder  sb =  new StringBuilder  ( "Parse error. Found " ) ;   final StringBuilder  expected =  new StringBuilder  ( ) ;   int  maxExpectedTokenSequenceLength = 0 ;   TreeSet  < String >  sortedOptions =  new  TreeSet  < >  ( ) ;  for (   int  i = 0 ;  i <   exception . expectedTokenSequences . length ;  i ++ )  {  if  (  maxExpectedTokenSequenceLength <    exception . expectedTokenSequences [ i ] . length )  {   maxExpectedTokenSequenceLength =    exception . expectedTokenSequences [ i ] . length ; }  for (   int  j = 0 ;  j <    exception . expectedTokenSequences [ i ] . length ;  j ++ )  {   sortedOptions . add  (   exception . tokenImage [    exception . expectedTokenSequences [ i ] [ j ] ] ) ; } }  for ( String option : sortedOptions )  {    expected . append  ( " " ) . append  ( option ) ; }   sb . append  ( "" ) ;  Token  token =   exception . currentToken . next ;  for (   int  i = 0 ;  i < maxExpectedTokenSequenceLength ;  i ++ )  {  String  tokenText =  token . image ;  String  escapedTokenText =  ParseException . add_escapes  ( tokenText ) ;  if  (  i != 0 )  {   sb . append  ( " " ) ; }  if  (   token . kind == 0 )  {   sb . append  (   exception . tokenImage [ 0 ] ) ;  break ; }   escapedTokenText =   "\"" + escapedTokenText + "\"" ;  String  image =   exception . tokenImage [  token . kind ] ;  if  (  image . equals  ( escapedTokenText ) )  {   sb . append  ( image ) ; } else  {      sb . append  ( " " ) . append  ( escapedTokenText ) . append  ( " " ) . append  ( image ) ; }   token =  token . next ; }  if  (    exception . expectedTokenSequences . length != 0 )  {   int  numExpectedTokens =   exception . expectedTokenSequences . length ;     sb . append  ( ", expected" ) . append  (   numExpectedTokens == 1 ? "" : " one of " ) . append  (  expected . toString  ( ) ) ; }  return  sb . toString  ( ) ; }   public static CompilationUnit parse  (   final InputStream in ,  Charset encoding )  {  return  simplifiedParse  ( COMPILATION_UNIT ,  provider  ( in , encoding ) ) ; }   public static CompilationUnit parse  (   final InputStream in )  {  return  parse  ( in , UTF8 ) ; }   public static CompilationUnit parse  (   final File file ,   final Charset encoding )  throws FileNotFoundException  {  return   simplifiedParse  ( COMPILATION_UNIT ,  provider  ( file , encoding ) ) . setStorage  (  file . toPath  ( ) ) ; }   public static CompilationUnit parse  (   final File file )  throws FileNotFoundException  {  return   simplifiedParse  ( COMPILATION_UNIT ,  provider  ( file ) ) . setStorage  (  file . toPath  ( ) ) ; }   public static CompilationUnit parse  (   final Path path ,   final Charset encoding )  throws IOException  {  return   simplifiedParse  ( COMPILATION_UNIT ,  provider  ( path , encoding ) ) . setStorage  ( path ) ; }   public static CompilationUnit parse  (   final Path path )  throws IOException  {  return   simplifiedParse  ( COMPILATION_UNIT ,  provider  ( path ) ) . setStorage  ( path ) ; }   public static CompilationUnit parseResource  (   final String path )  throws IOException  {  return  simplifiedParse  ( COMPILATION_UNIT ,  resourceProvider  ( path ) ) ; }   public static CompilationUnit parseResource  (   final String path ,  Charset encoding )  throws IOException  {  return  simplifiedParse  ( COMPILATION_UNIT ,  resourceProvider  ( path , encoding ) ) ; }   public static CompilationUnit parseResource  (   final ClassLoader classLoader ,   final String path ,  Charset encoding )  throws IOException  {  return  simplifiedParse  ( COMPILATION_UNIT ,  resourceProvider  ( classLoader , path , encoding ) ) ; }   public static CompilationUnit parse  (   final Reader reader )  {  return  simplifiedParse  ( COMPILATION_UNIT ,  provider  ( reader ) ) ; }   public static CompilationUnit parse  (  String code )  {  return  simplifiedParse  ( COMPILATION_UNIT ,  provider  ( code ) ) ; }   public static BlockStmt parseBlock  (   final String blockStatement )  {  return  simplifiedParse  ( BLOCK ,  provider  ( blockStatement ) ) ; }   public static Statement parseStatement  (   final String statement )  {  return  simplifiedParse  ( STATEMENT ,  provider  ( statement ) ) ; }   private static  <  T  extends Node > T simplifiedParse  (   ParseStart  < T > context ,  Provider provider )  {   ParseResult  < T >  result =   new JavaParser  ( staticConfiguration ) . parse  ( context , provider ) ;  if  (  result . isSuccessful  ( ) )  {  return   result . getResult  ( ) . get  ( ) ; }  throw  new ParseProblemException  (  result . getProblems  ( ) ) ; }   public static ImportDeclaration parseImport  (   final String importDeclaration )  {  return  simplifiedParse  ( IMPORT_DECLARATION ,  provider  ( importDeclaration ) ) ; }    @ SuppressWarnings  ( "unchecked" ) public static  <  T  extends Expression > T parseExpression  (   final String expression )  {  return  ( T )  simplifiedParse  ( EXPRESSION ,  provider  ( expression ) ) ; }   public static AnnotationExpr parseAnnotation  (   final String annotation )  {  return  simplifiedParse  ( ANNOTATION ,  provider  ( annotation ) ) ; }   public static  BodyDeclaration  <  ? > parseAnnotationBodyDeclaration  (   final String body )  {  return  simplifiedParse  ( ANNOTATION_BODY ,  provider  ( body ) ) ; }   public static  BodyDeclaration  <  ? > parseClassBodyDeclaration  (  String body )  {  return  simplifiedParse  ( CLASS_BODY ,  provider  ( body ) ) ; }   public static BodyDeclaration parseInterfaceBodyDeclaration  (  String body )  {  return  simplifiedParse  ( INTERFACE_BODY ,  provider  ( body ) ) ; }   public static ClassOrInterfaceType parseClassOrInterfaceType  (  String type )  {  return  simplifiedParse  ( CLASS_OR_INTERFACE_TYPE ,  provider  ( type ) ) ; }   public static VariableDeclarationExpr parseVariableDeclarationExpr  (  String declaration )  {  return  simplifiedParse  ( VARIABLE_DECLARATION_EXPR ,  provider  ( declaration ) ) ; }   public static Javadoc parseJavadoc  (  String content )  {  return  JavadocParser . parse  ( content ) ; }   public static ExplicitConstructorInvocationStmt parseExplicitConstructorInvocationStmt  (  String statement )  {  return  simplifiedParse  ( EXPLICIT_CONSTRUCTOR_INVOCATION_STMT ,  provider  ( statement ) ) ; }   public static Name parseName  (  String qualifiedName )  {  return  simplifiedParse  ( NAME ,  provider  ( qualifiedName ) ) ; }   public static Parameter parseParameter  (  String parameter )  {  return  simplifiedParse  ( PARAMETER ,  provider  ( parameter ) ) ; }   public static Type parseType  (  String type )  {  return  simplifiedParse  ( TYPE ,  provider  ( type ) ) ; } }