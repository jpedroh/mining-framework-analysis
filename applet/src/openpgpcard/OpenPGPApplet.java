  package openpgpcard ;   import  javacard . framework .  * ;  import  javacard . security .  * ;  import  javacardx . crypto .  * ;   public class OpenPGPApplet  extends Applet  implements  ISO7816  {   private static final  short  _0 = 0 ;   private static final boolean  FORCE_SM_GET_CHALLENGE = true ;   private static final   byte  [ ]  HISTORICAL =  { 0x00 , 0x73 , 0x00 , 0x00 ,  (  byte ) 0x80 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ;   private static final   byte  [ ]  VERSION =  { 0x01 , 0x00 , 0x11 } ;   private static final  short  SW_AUTHENTICATION_BLOCKED = 0x6983 ;   private static final   byte  [ ]  EXTENDED_CAP =  {  (  byte ) 0xF0 , 0x00 , 0x00 ,  (  byte ) 0xFF , 0x04 ,  (  byte ) 0xC0 , 0x00 ,  (  byte ) 0xFF , 0x00 ,  (  byte ) 0xFF } ;   private static  short  RESPONSE_MAX_LENGTH = 255 ;   private static  short  RESPONSE_SM_MAX_LENGTH = 231 ;   private static  short  CHALLENGES_MAX_LENGTH = 255 ;   private static  short  BUFFER_MAX_LENGTH = 1221 ;   private static  short  LOGINDATA_MAX_LENGTH = 254 ;   private static  short  URL_MAX_LENGTH = 254 ;   private static  short  NAME_MAX_LENGTH = 39 ;   private static  short  LANG_MAX_LENGTH = 8 ;   private static  short  CERT_MAX_LENGTH = 1216 ;   private static  short  FP_LENGTH = 20 ;   private static  byte  PW1_MIN_LENGTH = 6 ;   private static  byte  PW1_MAX_LENGTH = 127 ;   private static   byte  [ ]  PW1_DEFAULT =  { 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 } ;   private static  byte  PW1_MODE_NO81 = 0 ;   private static  byte  PW1_MODE_NO82 = 1 ;   private static final  byte  RC_MIN_LENGTH = 8 ;   private static final  byte  RC_MAX_LENGTH = 127 ;   private static final  byte  PW3_MIN_LENGTH = 8 ;   private static final  byte  PW3_MAX_LENGTH = 127 ;   private static final   byte  [ ]  PW3_DEFAULT =  { 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 , 0x38 } ;   private   byte  [ ]  loginData ;   private  short  loginData_length ;   private   byte  [ ]  url ;   private  short  url_length ;   private   byte  [ ]  name ;   private  short  name_length ;   private   byte  [ ]  lang ;   private  short  lang_length ;   private   byte  [ ]  cert ;   private  short  cert_length ;   private  byte  sex ;   private OwnerPIN  pw1 ;   private  byte  pw1_length ;   private  byte  pw1_status ;   private  boolean  [ ]  pw1_modes ;   private OwnerPIN  rc ;   private  byte  rc_length ;   private OwnerPIN  pw3 ;   private  byte  pw3_length ;   private   byte  [ ]  ds_counter ;   private PGPKey  sig_key ;   private PGPKey  dec_key ;   private PGPKey  auth_key ;   private   byte  [ ]  ca1_fp ;   private   byte  [ ]  ca2_fp ;   private   byte  [ ]  ca3_fp ;   private Cipher  cipher ;   private RandomData  random ;   private   byte  [ ]  buffer ;   private  short  out_left = 0 ;   private  short  out_sent = 0 ;   private  short  in_received = 0 ;   private boolean  chain = false ;   private  byte  chain_ins = 0 ;   private  short  chain_p1p2 = 0 ;   private OpenPGPSecureMessaging  sm ;   private boolean  sm_success = false ;   private boolean  terminated = false ;   public static void install  (    byte  [ ] bArray ,   short bOffset ,   byte bLength )  {    new OpenPGPApplet  ( ) . register  ( bArray ,  (  short )  (  bOffset + 1 ) ,  bArray [ bOffset ] ) ; }   private void initialize  ( )  {   pw1 =  new OwnerPIN  (  (  byte ) 3 , PW1_MAX_LENGTH ) ;   pw1 . update  ( PW1_DEFAULT , _0 ,  (  byte )  PW1_DEFAULT . length ) ;   pw1_length =  (  byte )  PW1_DEFAULT . length ;   pw1_status = 0x00 ;   rc =  new OwnerPIN  (  (  byte ) 3 , RC_MAX_LENGTH ) ;   rc_length = 0 ;   pw3 =  new OwnerPIN  (  (  byte ) 3 , PW3_MAX_LENGTH ) ;   pw3 . update  ( PW3_DEFAULT , _0 ,  (  byte )  PW3_DEFAULT . length ) ;   pw3_length =  (  byte )  PW3_DEFAULT . length ;   sig_key =  new PGPKey  ( ) ;   dec_key =  new PGPKey  ( ) ;   auth_key =  new PGPKey  ( ) ;   sm . init  ( ) ;   loginData =  new  byte  [ LOGINDATA_MAX_LENGTH ] ;   loginData_length = 0 ;   url =  new  byte  [ URL_MAX_LENGTH ] ;   url_length = 0 ;   name =  new  byte  [ NAME_MAX_LENGTH ] ;   name_length = 0 ;   lang =  new  byte  [ LANG_MAX_LENGTH ] ;   lang_length = 0 ;   cert = null ;   cert_length = 0 ;   sex = 0x39 ;   ds_counter =  new  byte  [ 3 ] ;   ca1_fp =  new  byte  [ FP_LENGTH ] ;   ca2_fp =  new  byte  [ FP_LENGTH ] ;   ca3_fp =  new  byte  [ FP_LENGTH ] ; }   public OpenPGPApplet  ( )  {   buffer =  JCSystem . makeTransientByteArray  ( BUFFER_MAX_LENGTH ,  JCSystem . CLEAR_ON_DESELECT ) ;   pw1_modes =  JCSystem . makeTransientBooleanArray  (  (  short ) 2 ,  JCSystem . CLEAR_ON_DESELECT ) ;   cipher =  Cipher . getInstance  (  Cipher . ALG_RSA_PKCS1 , false ) ;   random =  RandomData . getInstance  (  RandomData . ALG_SECURE_RANDOM ) ;   sm =  new OpenPGPSecureMessaging  ( ) ;   initialize  ( ) ; }   public void process  (  APDU apdu )  {  if  (  selectingApplet  ( ) )  {    pw1_modes [ PW1_MODE_NO81 ] = false ;    pw1_modes [ PW1_MODE_NO82 ] = false ;  return ; }    byte  [ ]  buf =  apdu . getBuffer  ( ) ;   byte  cla =  buf [ OFFSET_CLA ] ;   byte  ins =  buf [ OFFSET_INS ] ;   byte  p1 =  buf [ OFFSET_P1 ] ;   byte  p2 =  buf [ OFFSET_P2 ] ;   short  p1p2 =  Util . makeShort  ( p1 , p2 ) ;   short  lc =  (  short )  (   buf [ OFFSET_LC ] & 0xFF ) ;   sm_success = false ;  if  (   (  byte )  (  cla &  (  byte ) 0x0C ) ==  (  byte ) 0x0C )  {  if  (   FORCE_SM_GET_CHALLENGE &&  !  sm . isSetSSC  ( ) &&  (  ins !=  (  byte ) 0x84 ) )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ;   lc =  sm . unwrapCommandAPDU  ( ) ;   sm_success = true ; }   short  status = SW_NO_ERROR ;   short  le = 0 ;  try  {   commandChaining  ( apdu ) ;  if  (  ins !=  (  byte ) 0xC0 )  {   out_sent = 0 ;   out_left = 0 ; }  if  (   terminated == true &&  ins != 0x44 )  {   ISOException . throwIt  (  ISO7816 . SW_CONDITIONS_NOT_SATISFIED ) ; }  switch  ( ins )  {   case  (  byte ) 0xC0 :  break ;   case  (  byte ) 0x20 :   verify  ( apdu , p2 ) ;  break ;   case  (  byte ) 0x24 :   changeReferenceData  ( apdu , p2 ) ;  break ;   case  (  byte ) 0x2C :  if  (  p2 !=  (  byte ) 0x81 )   ISOException . throwIt  ( SW_INCORRECT_P1P2 ) ;   resetRetryCounter  ( apdu , p1 ) ;  break ;   case  (  byte ) 0x2A :  if  (  p1p2 ==  (  short ) 0x9E9A )  {   le =  computeDigitalSignature  ( apdu ) ; } else  if  (  p1p2 ==  (  short ) 0x8086 )  {   le =  decipher  ( apdu ) ; } else  {   ISOException . throwIt  ( SW_WRONG_P1P2 ) ; }  break ;   case  (  byte ) 0x88 :   le =  internalAuthenticate  ( apdu ) ;  break ;   case  (  byte ) 0x47 :   le =  genAsymKey  ( apdu , p1 ) ;  break ;   case  (  byte ) 0x84 :   le =  getChallenge  ( apdu , lc ) ;  break ;   case  (  byte ) 0xCA :   le =  getData  ( p1p2 ) ;  break ;   case  (  byte ) 0xDA :   putData  ( p1p2 ) ;  break ;   case  (  byte ) 0xDB :  if  (  p1p2 ==  (  short ) 0x3FFF )  {   importKey  ( apdu ) ; } else  {   ISOException . throwIt  ( SW_RECORD_NOT_FOUND ) ; }  break ;   case  (  byte ) 0xE6 :  if  (    pw1 . getTriesRemaining  ( ) == 0 &&   pw3 . getTriesRemaining  ( ) == 0 )  {   terminated = true ; } else  {   ISOException . throwIt  (  ISO7816 . SW_CONDITIONS_NOT_SATISFIED ) ; }  break ;   case  (  byte ) 0x44 :  if  (  terminated == true )  {   initialize  ( ) ;   terminated = false ;   JCSystem . requestObjectDeletion  ( ) ; } else  {   ISOException . throwIt  (  ISO7816 . SW_CONDITIONS_NOT_SATISFIED ) ; }  break ;   case  (  byte ) 0xF1 :   le =  Util . arrayCopy  ( VERSION , _0 , buffer , _0 ,  (  short )  VERSION . length ) ;  break ;   case  (  byte ) 0xF2 :  if  (  lc != 3 )  {   ISOException . throwIt  (  ISO7816 . SW_WRONG_DATA ) ; }   short  offs =  ISO7816 . OFFSET_CDATA ;   setPinRetries  (  buf [  offs ++ ] ,  buf [  offs ++ ] ,  buf [  offs ++ ] ) ;  break ;   default :   ISOException . throwIt  ( SW_INS_NOT_SUPPORTED ) ; } }  catch (   ISOException e )  {   status =  e . getReason  ( ) ; }  finally  {  if  (  status !=  (  short ) 0x9000 )  {   sendException  ( apdu , status ) ; } else  {  if  (  ins ==  (  byte ) 0xC0 )  {   sendNext  ( apdu ) ; } else  {   sendBuffer  ( apdu , le ) ; } } } }   private void setPinRetries  (   byte pin_retries ,   byte reset_retries ,   byte admin_retries )  {  if  (  !  pw3 . isValidated  ( ) )  {   ISOException . throwIt  (  ISO7816 . SW_CONDITIONS_NOT_SATISFIED ) ; }  if  (  pin_retries != 0 )  {   pw1 =  new OwnerPIN  ( pin_retries , PW1_MAX_LENGTH ) ;   pw1 . update  ( PW1_DEFAULT , _0 ,  (  byte )  PW1_DEFAULT . length ) ;   pw1_length =  (  byte )  PW1_DEFAULT . length ;   pw1_status = 0x00 ; }  if  (  reset_retries != 0 )  {   rc =  new OwnerPIN  ( reset_retries , RC_MAX_LENGTH ) ;   rc_length = 0 ; }  if  (  admin_retries != 0 )  {   pw3 =  new OwnerPIN  ( admin_retries , PW3_MAX_LENGTH ) ;   pw3 . update  ( PW3_DEFAULT , _0 ,  (  byte )  PW3_DEFAULT . length ) ;   pw3_length =  (  byte )  PW3_DEFAULT . length ; }   JCSystem . requestObjectDeletion  ( ) ; }   private void commandChaining  (  APDU apdu )  {    byte  [ ]  buf =  apdu . getBuffer  ( ) ;   short  p1p2 =  Util . makeShort  (  buf [ OFFSET_P1 ] ,  buf [ OFFSET_P2 ] ) ;   short  len =  (  short )  (   buf [ OFFSET_LC ] & 0xFF ) ;  if  (  ! chain )  {   resetChaining  ( ) ; }  if  (   (  byte )  (   buf [ OFFSET_CLA ] &  (  byte ) 0x10 ) ==  (  byte ) 0x10 )  {  if  (  chain &&  (    buf [ OFFSET_INS ] != chain_ins &&  p1p2 != chain_p1p2 ) )  {   resetChaining  ( ) ;   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ; }  if  (   (  short )  (  in_received + len ) > BUFFER_MAX_LENGTH )  {   resetChaining  ( ) ;   ISOException . throwIt  ( SW_WRONG_DATA ) ; }   in_received =  Util . arrayCopyNonAtomic  ( buf , OFFSET_CDATA , buffer , in_received , len ) ;   chain = true ;   chain_ins =  buf [ OFFSET_INS ] ;   chain_p1p2 = p1p2 ;   ISOException . throwIt  ( SW_NO_ERROR ) ; }  if  (   chain &&   buf [ OFFSET_INS ] == chain_ins &&  p1p2 == chain_p1p2 )  {   chain = false ;  if  (   (  short )  (  in_received + len ) > BUFFER_MAX_LENGTH )  {   resetChaining  ( ) ;   ISOException . throwIt  ( SW_WRONG_DATA ) ; }   in_received =  Util . arrayCopyNonAtomic  ( buf , OFFSET_CDATA , buffer , in_received , len ) ; } else  if  ( chain )  {   resetChaining  ( ) ;   ISOException . throwIt  ( SW_UNKNOWN ) ; } else  {   in_received =  Util . arrayCopyNonAtomic  ( buf , OFFSET_CDATA , buffer , _0 , len ) ; } }   private void resetChaining  ( )  {   chain = false ;   in_received = 0 ; }   private void verify  (  APDU apdu ,   byte mode )  {  if  (   mode ==  (  byte ) 0x81 ||  mode ==  (  byte ) 0x82 )  {  if  (   in_received < PW1_MIN_LENGTH ||  in_received > PW1_MAX_LENGTH )   ISOException . throwIt  ( SW_WRONG_DATA ) ;  if  (   pw1 . getTriesRemaining  ( ) == 0 ) 
<<<<<<<
=======
 {  if  (  mode ==  (  byte ) 0x81 )  {    pw1_modes [ PW1_MODE_NO81 ] = true ; } else  {    pw1_modes [ PW1_MODE_NO82 ] = true ; } }
>>>>>>>
  {   ISOException . throwIt  ( SW_AUTHENTICATION_BLOCKED ) ; } else  if  (  pw1 . check  ( buffer , _0 ,  (  byte ) in_received ) )  {  if  (  mode ==  (  byte ) 0x81 )    pw1_modes [ PW1_MODE_NO81 ] = true ; else    pw1_modes [ PW1_MODE_NO82 ] = true ; } else  {   ISOException . throwIt  ( SW_SECURITY_STATUS_NOT_SATISFIED ) ; } } else  if  (  mode ==  (  byte ) 0x83 )  {  if  (   in_received < PW3_MIN_LENGTH ||  in_received > PW3_MAX_LENGTH )   ISOException . throwIt  ( SW_WRONG_DATA ) ;  if  (   pw3 . getTriesRemaining  ( ) == 0 )  {   ISOException . throwIt  ( SW_AUTHENTICATION_BLOCKED ) ; } else  if  (  !  pw3 . check  ( buffer , _0 ,  (  byte ) in_received ) )  {   ISOException . throwIt  ( SW_SECURITY_STATUS_NOT_SATISFIED ) ; } } else  {   ISOException . throwIt  ( SW_INCORRECT_P1P2 ) ; } }   private void changeReferenceData  (  APDU apdu ,   byte mode )  {  if  (  mode ==  (  byte ) 0x81 )  {   short  new_length =  (  short )  (  in_received - pw1_length ) ;  if  (   new_length < PW1_MIN_LENGTH ||  new_length > PW1_MAX_LENGTH )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ;  if  (  !  pw1 . check  ( buffer , _0 , pw1_length ) )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ;   JCSystem . beginTransaction  ( ) ;   pw1 . update  ( buffer , pw1_length ,  (  byte ) new_length ) ;   pw1_length =  (  byte ) new_length ;    pw1_modes [ PW1_MODE_NO81 ] = false ;    pw1_modes [ PW1_MODE_NO82 ] = false ;   JCSystem . commitTransaction  ( ) ; } else  if  (  mode ==  (  byte ) 0x83 )  {   short  new_length =  (  short )  (  in_received - pw3_length ) ;  if  (   new_length < PW3_MIN_LENGTH ||  new_length > PW3_MAX_LENGTH )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ;  if  (  !  pw3 . check  ( buffer , _0 , pw3_length ) )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ;   JCSystem . beginTransaction  ( ) ;   pw3 . update  ( buffer , pw3_length ,  (  byte ) new_length ) ;   pw3_length =  (  byte ) new_length ;   JCSystem . commitTransaction  ( ) ; } }   private void resetRetryCounter  (  APDU apdu ,   byte mode )  {   short  new_length = 0 ;   short  offs = 0 ;  if  (  mode ==  (  byte ) 0x00 )  {  if  (  rc_length == 0 )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ;   new_length =  (  short )  (  in_received - rc_length ) ;   offs = rc_length ;  if  (  !  rc . check  ( buffer , _0 , rc_length ) )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ; } else  if  (  mode ==  (  byte ) 0x02 )  {  if  (  !  pw3 . isValidated  ( ) )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ;   new_length = in_received ; } else  {   ISOException . throwIt  ( SW_WRONG_P1P2 ) ; }  if  (   new_length < PW1_MIN_LENGTH ||  new_length > PW1_MAX_LENGTH )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   JCSystem . beginTransaction  ( ) ;   pw1 . update  ( buffer , offs ,  (  byte ) new_length ) ;   pw1_length =  (  byte ) new_length ;   pw1 . resetAndUnblock  ( ) ;   JCSystem . commitTransaction  ( ) ; }   private  short computeDigitalSignature  (  APDU apdu )  {  if  (  !  (   pw1 . isValidated  ( ) &&  pw1_modes [ PW1_MODE_NO81 ] ) )   ISOException . throwIt  ( SW_SECURITY_STATUS_NOT_SATISFIED ) ;  if  (  pw1_status ==  (  byte ) 0x00 )    pw1_modes [ PW1_MODE_NO81 ] = false ;  if  (  !   sig_key . getPrivate  ( ) . isInitialized  ( ) )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ;   cipher . init  (  sig_key . getPrivate  ( ) ,  Cipher . MODE_ENCRYPT ) ;   increaseDSCounter  ( ) ;   short  length =  cipher . doFinal  ( buffer , _0 , in_received , buffer , in_received ) ;   Util . arrayCopyNonAtomic  ( buffer , in_received , buffer , _0 , length ) ;  return length ; }   private  short decipher  (  APDU apdu )  {  if  (  !  (   pw1 . isValidated  ( ) &&  pw1_modes [ PW1_MODE_NO82 ] ) )   ISOException . throwIt  ( SW_SECURITY_STATUS_NOT_SATISFIED ) ;  if  (  !   dec_key . getPrivate  ( ) . isInitialized  ( ) )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ;   cipher . init  (  dec_key . getPrivate  ( ) ,  Cipher . MODE_DECRYPT ) ;   short  length =  cipher . doFinal  ( buffer ,  (  short ) 1 ,  (  short )  (  in_received - 1 ) , buffer , in_received ) ;   Util . arrayCopyNonAtomic  ( buffer , in_received , buffer , _0 , length ) ;  return length ; }   private  short internalAuthenticate  (  APDU apdu )  {  if  (  !  (   pw1 . isValidated  ( ) &&  pw1_modes [ PW1_MODE_NO82 ] ) )   ISOException . throwIt  ( SW_SECURITY_STATUS_NOT_SATISFIED ) ;  if  (  !   auth_key . getPrivate  ( ) . isInitialized  ( ) )   ISOException . throwIt  ( SW_CONDITIONS_NOT_SATISFIED ) ;   cipher . init  (  auth_key . getPrivate  ( ) ,  Cipher . MODE_ENCRYPT ) ;   short  length =  cipher . doFinal  ( buffer , _0 , in_received , buffer , in_received ) ;   Util . arrayCopyNonAtomic  ( buffer , in_received , buffer , _0 , length ) ;  return length ; }   private  short genAsymKey  (  APDU apdu ,   byte mode )  {  PGPKey  key =  getKey  (  buffer [ 0 ] ) ;  if  (  mode ==  (  byte ) 0x80 )  {  if  (  !  pw3 . isValidated  ( ) )   ISOException . throwIt  ( SW_SECURITY_STATUS_NOT_SATISFIED ) ;   key . genKeyPair  ( ) ;  if  (   buffer [ 0 ] ==  (  byte ) 0xB6 )  {   Util . arrayFillNonAtomic  ( ds_counter , _0 ,  (  short ) 3 ,  (  byte ) 0 ) ; } }  return  sendPublicKey  ( key ) ; }   private  short getChallenge  (  APDU apdu ,   short len )  {  if  (  len > CHALLENGES_MAX_LENGTH )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   random . generateData  ( buffer , _0 , len ) ;  if  (  len ==  sm . getSSCSize  ( ) )  {   sm . setSSC  ( buffer , _0 ) ; }  return len ; }   private  short getData  (   short tag )  {   short  offset = 0 ;  switch  ( tag )  {   case  (  short ) 0x004F :  return   JCSystem . getAID  ( ) . getBytes  ( buffer , _0 ) ;   case  (  short ) 0x005E :  return  Util . arrayCopyNonAtomic  ( loginData , _0 , buffer , _0 , loginData_length ) ;   case  (  short ) 0x5F50 :  return  Util . arrayCopyNonAtomic  ( url , _0 , buffer , _0 , url_length ) ;   case  (  short ) 0x5F52 :  return  Util . arrayCopyNonAtomic  ( HISTORICAL , _0 , buffer , _0 ,  (  short )  HISTORICAL . length ) ;   case  (  short ) 0x0065 :    buffer [  offset ++ ] = 0x65 ;    buffer [  offset ++ ] = 0x00 ;    buffer [  offset ++ ] = 0x5B ;    buffer [  offset ++ ] =  (  byte ) name_length ;   offset =  Util . arrayCopyNonAtomic  ( name , _0 , buffer , offset , name_length ) ;    buffer [  offset ++ ] = 0x5F ;    buffer [  offset ++ ] = 0x2D ;    buffer [  offset ++ ] =  (  byte ) lang_length ;   offset =  Util . arrayCopyNonAtomic  ( lang , _0 , buffer , offset , lang_length ) ;    buffer [  offset ++ ] = 0x5F ;    buffer [  offset ++ ] = 0x35 ;    buffer [  offset ++ ] = 0x01 ;    buffer [  offset ++ ] = sex ;    buffer [ 1 ] =  (  byte )  (  offset - 2 ) ;  return offset ;   case  (  short ) 0x006E :    buffer [  offset ++ ] = 0x6E ;    buffer [  offset ++ ] =  (  byte ) 0x81 ;    buffer [  offset ++ ] = 0 ;    buffer [  offset ++ ] = 0x4F ;   byte  len =   JCSystem . getAID  ( ) . getBytes  ( buffer ,  (  short )  (  offset + 1 ) ) ;    buffer [  offset ++ ] = len ;   offset += len ;    buffer [  offset ++ ] = 0x5F ;    buffer [  offset ++ ] = 0x52 ;    buffer [  offset ++ ] =  (  byte )  HISTORICAL . length ;   offset =  Util . arrayCopyNonAtomic  ( HISTORICAL , _0 , buffer , offset ,  (  short )  HISTORICAL . length ) ;    buffer [  offset ++ ] = 0x73 ;    buffer [  offset ++ ] =  (  byte ) 0x81 ;   short  ddoLengthOffset = offset ;    buffer [  offset ++ ] = 0x00 ;    buffer [  offset ++ ] =  (  byte ) 0xC0 ;    buffer [  offset ++ ] =  (  byte )  EXTENDED_CAP . length ;   offset =  Util . arrayCopyNonAtomic  ( EXTENDED_CAP , _0 , buffer , offset ,  (  short )  EXTENDED_CAP . length ) ;    buffer [  offset ++ ] =  (  byte ) 0xC1 ;    buffer [  offset ++ ] =  (  byte ) 0x06 ;   offset =  sig_key . getAttributes  ( buffer , offset ) ;    buffer [  offset ++ ] =  (  byte ) 0xC2 ;    buffer [  offset ++ ] =  (  byte ) 0x06 ;   offset =  dec_key . getAttributes  ( buffer , offset ) ;    buffer [  offset ++ ] =  (  byte ) 0xC3 ;    buffer [  offset ++ ] =  (  byte ) 0x06 ;   offset =  auth_key . getAttributes  ( buffer , offset ) ;    buffer [  offset ++ ] =  (  byte ) 0xC4 ;    buffer [  offset ++ ] = 0x07 ;    buffer [  offset ++ ] = pw1_status ;    buffer [  offset ++ ] = PW1_MAX_LENGTH ;    buffer [  offset ++ ] = RC_MAX_LENGTH ;    buffer [  offset ++ ] = PW3_MAX_LENGTH ;    buffer [  offset ++ ] =  pw1 . getTriesRemaining  ( ) ;    buffer [  offset ++ ] =  rc . getTriesRemaining  ( ) ;    buffer [  offset ++ ] =  pw3 . getTriesRemaining  ( ) ;    buffer [  offset ++ ] =  (  byte ) 0xC5 ;    buffer [  offset ++ ] =  (  short ) 60 ;   offset =  sig_key . getFingerprint  ( buffer , offset ) ;   offset =  dec_key . getFingerprint  ( buffer , offset ) ;   offset =  auth_key . getFingerprint  ( buffer , offset ) ;    buffer [  offset ++ ] =  (  byte ) 0xC6 ;    buffer [  offset ++ ] =  (  short ) 60 ;   offset =  Util . arrayCopyNonAtomic  ( ca1_fp , _0 , buffer , offset , FP_LENGTH ) ;   offset =  Util . arrayCopyNonAtomic  ( ca2_fp , _0 , buffer , offset , FP_LENGTH ) ;   offset =  Util . arrayCopyNonAtomic  ( ca3_fp , _0 , buffer , offset , FP_LENGTH ) ;    buffer [  offset ++ ] =  (  byte ) 0xCD ;    buffer [  offset ++ ] =  (  short ) 12 ;   offset =  sig_key . getTime  ( buffer , offset ) ;   offset =  dec_key . getTime  ( buffer , offset ) ;   offset =  auth_key . getTime  ( buffer , offset ) ;    buffer [ ddoLengthOffset ] =  (  byte )  (   offset - ddoLengthOffset - 1 ) ;    buffer [ 2 ] =  (  byte )  (  offset - 3 ) ;  return offset ;   case  (  short ) 0x007A :    buffer [  offset ++ ] = 0x7A ;    buffer [  offset ++ ] =  (  byte ) 0x05 ;    buffer [  offset ++ ] =  (  byte ) 0x93 ;    buffer [  offset ++ ] = 0x03 ;   offset =  Util . arrayCopyNonAtomic  ( ds_counter , _0 , buffer , offset ,  (  short ) 3 ) ;  return offset ;   case  (  short ) 0x7F21 :    buffer [  offset ++ ] = 0x7F ;    buffer [  offset ++ ] = 0x21 ;  if  (  cert_length < 128 )  {    buffer [  offset ++ ] =  (  byte ) cert_length ; } else  if  (  cert_length < 256 )  {    buffer [  offset ++ ] =  (  byte ) 0x81 ;    buffer [  offset ++ ] =  (  byte ) cert_length ; } else  {    buffer [  offset ++ ] =  (  byte ) 0x82 ;   offset =  Util . setShort  ( buffer , offset , cert_length ) ; }  if  (  cert_length > 0 )  {   offset =  Util . arrayCopyNonAtomic  ( cert , _0 , buffer , offset , cert_length ) ; }  return offset ;   case  (  short ) 0x00C4 :    buffer [  offset ++ ] = pw1_status ;    buffer [  offset ++ ] = PW1_MAX_LENGTH ;    buffer [  offset ++ ] = RC_MAX_LENGTH ;    buffer [  offset ++ ] = PW3_MAX_LENGTH ;    buffer [  offset ++ ] =  pw1 . getTriesRemaining  ( ) ;    buffer [  offset ++ ] =  rc . getTriesRemaining  ( ) ;    buffer [  offset ++ ] =  pw3 . getTriesRemaining  ( ) ;  return offset ;   default :   ISOException . throwIt  ( SW_RECORD_NOT_FOUND ) ; }  return offset ; }   private void putData  (   short tag )  {  if  (  !  pw3 . isValidated  ( ) )   ISOException . throwIt  ( SW_SECURITY_STATUS_NOT_SATISFIED ) ;  switch  ( tag )  {   case  (  short ) 0x005B :  if  (  in_received >  name . length )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   JCSystem . beginTransaction  ( ) ;   name_length =  Util . arrayCopy  ( buffer , _0 , name , _0 , in_received ) ;   JCSystem . commitTransaction  ( ) ;  break ;   case  (  short ) 0x005E :  if  (  in_received >  loginData . length )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   JCSystem . beginTransaction  ( ) ;   loginData_length =  Util . arrayCopy  ( buffer , _0 , loginData , _0 , in_received ) ;   JCSystem . commitTransaction  ( ) ;  break ;   case  (  short ) 0x5F2D :  if  (  in_received >  lang . length )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   JCSystem . beginTransaction  ( ) ;   lang_length =  Util . arrayCopy  ( buffer , _0 , lang , _0 , in_received ) ;   JCSystem . commitTransaction  ( ) ;  break ;   case  (  short ) 0x5F35 :  if  (  in_received != 1 )   ISOException . throwIt  ( SW_WRONG_DATA ) ;  if  (     buffer [ 0 ] !=  (  byte ) 0x31 &&   buffer [ 0 ] !=  (  byte ) 0x32 &&   buffer [ 0 ] !=  (  byte ) 0x39 )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   sex =  buffer [ 0 ] ;  break ;   case  (  short ) 0x5F50 :  if  (  in_received >  url . length )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   JCSystem . beginTransaction  ( ) ;   url_length =  Util . arrayCopy  ( buffer , _0 , url , _0 , in_received ) ;   JCSystem . commitTransaction  ( ) ;  break ;   case  (  short ) 0x7F21 :  if  (  in_received > CERT_MAX_LENGTH )   ISOException . throwIt  ( SW_WRONG_DATA ) ;  if  (  cert == null )  {   cert =  new  byte  [ CERT_MAX_LENGTH ] ; }   cert_length =  Util . arrayCopyNonAtomic  ( buffer , _0 , cert , _0 , in_received ) ;  break ;   case  (  short ) 0x00C4 :  if  (  in_received != 1 )   ISOException . throwIt  ( SW_WRONG_DATA ) ;  if  (    buffer [ 0 ] !=  (  byte ) 0x00 &&   buffer [ 0 ] !=  (  byte ) 0x01 )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   pw1_status =  buffer [ 0 ] ;  break ;   case  (  short ) 0x00C7 :  if  (  in_received !=  PGPKey . FP_SIZE )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   sig_key . setFingerprint  ( buffer , _0 ) ;  break ;   case  (  short ) 0x00C8 :  if  (  in_received !=  PGPKey . FP_SIZE )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   dec_key . setFingerprint  ( buffer , _0 ) ;  break ;   case  (  short ) 0x00C9 :  if  (  in_received !=  PGPKey . FP_SIZE )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   auth_key . setFingerprint  ( buffer , _0 ) ;  break ;   case  (  short ) 0x00CA :  if  (  in_received != FP_LENGTH )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   Util . arrayCopy  ( buffer , _0 , ca1_fp , _0 , in_received ) ;  break ;   case  (  short ) 0x00CB :  if  (  in_received != FP_LENGTH )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   Util . arrayCopy  ( buffer , _0 , ca2_fp , _0 , in_received ) ;  break ;   case  (  short ) 0x00CC :  if  (  in_received != FP_LENGTH )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   Util . arrayCopy  ( buffer , _0 , ca3_fp , _0 , in_received ) ;  break ;   case  (  short ) 0x00CE :  if  (  in_received != 4 )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   sig_key . setTime  ( buffer , _0 ) ;  break ;   case  (  short ) 0x00CF :  if  (  in_received != 4 )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   dec_key . setTime  ( buffer , _0 ) ;  break ;   case  (  short ) 0x00D0 :  if  (  in_received != 4 )   ISOException . throwIt  ( SW_WRONG_DATA ) ;   auth_key . setTime  ( buffer , _0 ) ;  break ;   case  (  short ) 0x00D3 :  if  (  in_received == 0 )  {   rc_length = 0 ; } else  if  (   in_received >= RC_MIN_LENGTH &&  in_received <= RC_MAX_LENGTH )  {   JCSystem . beginTransaction  ( ) ;   rc . update  ( buffer , _0 ,  (  byte ) in_received ) ;   rc_length =  (  byte ) in_received ;   rc . resetAndUnblock  ( ) ;   JCSystem . commitTransaction  ( ) ; } else  {   ISOException . throwIt  ( SW_WRONG_DATA ) ; }  break ;   case  (  short ) 0x00D1 :   sm . setSessionKeyEncryption  ( buffer , _0 ) ;  break ;   case  (  short ) 0x00D2 :   sm . setSessionKeyMAC  ( buffer , _0 ) ;  break ;   case  (  short ) 0x00F4 :   short  offset = 0 ;   short  key_len = 0 ;  if  (   buffer [  offset ++ ] ==  (  byte ) 0xD1 )  {   key_len =  (  short )  (   buffer [  offset ++ ] & 0x7F ) ;   sm . setSessionKeyEncryption  ( buffer , offset ) ;   offset += key_len ; }  if  (   buffer [  offset ++ ] ==  (  byte ) 0xD2 )  {   key_len =  (  short )  (   buffer [  offset ++ ] & 0x7F ) ;   sm . setSessionKeyMAC  ( buffer , offset ) ;   offset += key_len ; }  break ;   default :   ISOException . throwIt  ( SW_RECORD_NOT_FOUND ) ;  break ; } }   private void importKey  (  APDU apdu )  {   short  offset = 0 ;  if  (  !  pw3 . isValidated  ( ) )   ISOException . throwIt  ( SW_SECURITY_STATUS_NOT_SATISFIED ) ;  if  (   buffer [  offset ++ ] != 0x4D )   ISOException . throwIt  ( SW_DATA_INVALID ) ;   offset +=  getLengthBytes  (  getLength  ( buffer , offset ) ) ;  PGPKey  key =  getKey  (  buffer [  offset ++ ] ) ;   offset ++ ;  if  (    buffer [  offset ++ ] != 0x7F ||   buffer [  offset ++ ] != 0x48 )   ISOException . throwIt  ( SW_DATA_INVALID ) ;   short  len_template =  getLength  ( buffer , offset ) ;   offset +=  getLengthBytes  ( len_template ) ;   short  offset_data =  (  short )  (  offset + len_template ) ;  if  (   buffer [  offset ++ ] !=  (  byte ) 0x91 )   ISOException . throwIt  ( SW_DATA_INVALID ) ;   short  len_e =  getLength  ( buffer , offset ) ;   offset +=  getLengthBytes  ( len_e ) ;  if  (   buffer [  offset ++ ] !=  (  byte ) 0x92 )   ISOException . throwIt  ( SW_DATA_INVALID ) ;   short  len_p =  getLength  ( buffer , offset ) ;   offset +=  getLengthBytes  ( len_p ) ;  if  (   buffer [  offset ++ ] !=  (  byte ) 0x93 )   ISOException . throwIt  ( SW_DATA_INVALID ) ;   short  len_q =  getLength  ( buffer , offset ) ;   offset +=  getLengthBytes  ( len_q ) ;  if  (   buffer [  offset ++ ] !=  (  byte ) 0x94 )   ISOException . throwIt  ( SW_DATA_INVALID ) ;   short  len_pq =  getLength  ( buffer , offset ) ;   offset +=  getLengthBytes  ( len_pq ) ;  if  (   buffer [  offset ++ ] !=  (  byte ) 0x95 )   ISOException . throwIt  ( SW_DATA_INVALID ) ;   short  len_dp1 =  getLength  ( buffer , offset ) ;   offset +=  getLengthBytes  ( len_dp1 ) ;  if  (   buffer [  offset ++ ] !=  (  byte ) 0x96 )   ISOException . throwIt  ( SW_DATA_INVALID ) ;   short  len_dq1 =  getLength  ( buffer , offset ) ;   offset +=  getLengthBytes  ( len_dq1 ) ;  if  (   buffer [  offset ++ ] !=  (  byte ) 0x97 )   ISOException . throwIt  ( SW_DATA_INVALID ) ;   short  len_modulus =  getLength  ( buffer , offset ) ;   offset +=  getLengthBytes  ( len_modulus ) ;  if  (    buffer [  offset_data ++ ] != 0x5F ||   buffer [  offset_data ++ ] != 0x48 )   ISOException . throwIt  ( SW_DATA_INVALID ) ;   offset_data +=  getLengthBytes  (  getLength  ( buffer , offset_data ) ) ;   key . setExponent  ( buffer , offset_data , len_e ) ;   offset_data += len_e ;   key . setP  ( buffer , offset_data , len_p ) ;   offset_data += len_p ;   key . setQ  ( buffer , offset_data , len_q ) ;   offset_data += len_q ;   key . setPQ  ( buffer , offset_data , len_pq ) ;   offset_data += len_pq ;   key . setDP1  ( buffer , offset_data , len_dp1 ) ;   offset_data += len_dp1 ;   key . setDQ1  ( buffer , offset_data , len_dq1 ) ;   offset_data += len_dq1 ;   key . setModulus  ( buffer , offset_data , len_modulus ) ;   offset_data += len_modulus ; }   private  short sendPublicKey  (  PGPKey key )  {  RSAPublicKey  pubkey =  key . getPublic  ( ) ;   short  offset = 0 ;    buffer [  offset ++ ] = 0x7F ;    buffer [  offset ++ ] = 0x49 ;    buffer [  offset ++ ] =  (  byte ) 0x82 ;   short  offsetForLength = offset ;   offset += 2 ;    buffer [  offset ++ ] =  (  byte ) 0x81 ;  if  (   key . getModulusLength  ( ) < 256 )  {    buffer [  offset ++ ] =  (  byte ) 0x81 ;    buffer [  offset ++ ] =  (  byte )  key . getModulusLength  ( ) ; } else  {    buffer [  offset ++ ] =  (  byte ) 0x82 ;   offset =  Util . setShort  ( buffer , offset ,  key . getModulusLength  ( ) ) ; }   pubkey . getModulus  ( buffer , offset ) ;   offset +=  key . getModulusLength  ( ) ;    buffer [  offset ++ ] =  (  byte ) 0x82 ;    buffer [  offset ++ ] =  (  byte )  key . getExponentLength  ( ) ;   pubkey . getExponent  ( buffer , offset ) ;   offset +=  key . getExponentLength  ( ) ;   Util . setShort  ( buffer , offsetForLength ,  (  short )  (   offset - offsetForLength - 2 ) ) ;  return offset ; }   private void sendBuffer  (  APDU apdu ,   short len )  {   out_sent = 0 ;   out_left = len ;   sendNext  ( apdu ) ; }   private void sendException  (  APDU apdu ,   short status )  {   out_sent = 0 ;   out_left = 0 ;   sendNext  ( apdu , status ) ; }   private void sendNext  (  APDU apdu )  {   sendNext  ( apdu , SW_NO_ERROR ) ; }   private void sendNext  (  APDU apdu ,   short status )  {    byte  [ ]  buf =  APDU . getCurrentAPDUBuffer  ( ) ;   apdu . setOutgoing  ( ) ;   short  max_length ;  if  ( sm_success )  {   max_length = RESPONSE_SM_MAX_LENGTH ; } else  {   max_length = RESPONSE_MAX_LENGTH ; }  if  (  max_length > out_left )  {   max_length = out_left ; }   Util . arrayCopyNonAtomic  ( buffer , out_sent , buf , _0 , max_length ) ;   short  len = 0 ;  if  (  out_left > max_length )  {   len = max_length ;   out_left -= max_length ;   out_sent += max_length ;  if  (  out_left > max_length )  {   status =  (  short )  (  SW_BYTES_REMAINING_00 | max_length ) ; } else  {   status =  (  short )  (  SW_BYTES_REMAINING_00 | out_left ) ; } } else  {   len = out_left ;   out_sent = 0 ;   out_left = 0 ; }  if  ( sm_success )  {   len =  sm . wrapResponseAPDU  ( buf , _0 , len , status ) ; }   apdu . setOutgoingLength  ( len ) ;   apdu . sendBytes  ( _0 , len ) ;  if  (  status != SW_NO_ERROR )   ISOException . throwIt  ( status ) ; }   private  short getLength  (    byte  [ ] data ,   short offset )  {   short  len = 0 ;  if  (   (   data [ offset ] &  (  byte ) 0x80 ) ==  (  byte ) 0x00 )  {   len =  data [ offset ] ; } else  if  (   (   data [ offset ] &  (  byte ) 0x7F ) ==  (  byte ) 0x01 )  {   len =  data [  (  short )  (  offset + 1 ) ] ;   len &= 0x00ff ; } else  if  (   (   data [ offset ] &  (  byte ) 0x7F ) ==  (  byte ) 0x02 )  {   len =  Util . makeShort  (  data [  (  short )  (  offset + 1 ) ] ,  data [  (  short )  (  offset + 2 ) ] ) ; } else  {   ISOException . throwIt  ( SW_UNKNOWN ) ; }  return len ; }   private  short getLengthBytes  (   short length )  {  if  (  length <= 127 )  {  return 1 ; } else  if  (  length <= 255 )  {  return 2 ; } else  {  return 3 ; } }   private PGPKey getKey  (   byte type )  {  PGPKey  key = sig_key ;  if  (  type ==  (  byte ) 0xB6 )  {   key = sig_key ; } else  if  (  type ==  (  byte ) 0xB8 )  {   key = dec_key ; } else  if  (  type ==  (  byte ) 0xA4 )  {   key = auth_key ; } else  {   ISOException . throwIt  ( SW_UNKNOWN ) ; }  return key ; }   private void increaseDSCounter  ( )  {  for (   short  i =  (  short )  (   ds_counter . length - 1 ) ;  i >= 0 ;  i -- )  {  if  (   (  short )  (   ds_counter [ i ] & 0xFF ) >= 0xFF )  {  if  (  i == 0 )  {   ISOException . throwIt  ( SW_WARNING_STATE_UNCHANGED ) ; } else  {    ds_counter [ i ] = 0 ; } } else  {    ds_counter [ i ] ++ ;  break ; } } } }