  package      com . citytechinc . cq . component . maven . util ;   import   java . io . File ;  import   java . io . FileInputStream ;  import   java . io . IOException ;  import    java . lang . annotation . Annotation ;  import    java . lang . reflect . InvocationTargetException ;  import   java . net . MalformedURLException ;  import   java . net . URL ;  import   java . net . URLClassLoader ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Set ;  import  javassist . CannotCompileException ;  import  javassist . ClassPool ;  import  javassist . CtClass ;  import  javassist . CtField ;  import  javassist . CtMethod ;  import  javassist . NotFoundException ;  import    javax . xml . parsers . ParserConfigurationException ;  import    javax . xml . transform . TransformerException ;  import       org . apache . commons . compress . archivers . zip . ZipArchiveEntry ;  import       org . apache . commons . compress . archivers . zip . ZipArchiveInputStream ;  import       org . apache . commons . compress . archivers . zip . ZipArchiveOutputStream ;  import     org . apache . commons . io . FileUtils ;  import     org . apache . commons . io . IOUtils ;  import     org . apache . maven . project . MavenProject ;  import     org . codehaus . plexus . util . StringUtils ;  import   org . reflections . Reflections ;  import    org . reflections . scanners . TypeAnnotationsScanner ;  import    org . reflections . util . ClasspathHelper ;  import    org . reflections . util . ConfigurationBuilder ;  import     com . citytechinc . cq . classpool . ClassLoaderClassPool ;  import      com . citytechinc . cq . component . annotations . Component ;  import       com . citytechinc . cq . component . annotations . config . Widget ;  import       com . citytechinc . cq . component . annotations . transformer . Transformer ;  import       com . citytechinc . cq . component . content . util . ContentUtil ;  import      com . citytechinc . cq . component . dialog . AbstractWidget ;  import      com . citytechinc . cq . component . dialog . ComponentNameTransformer ;  import       com . citytechinc . cq . component . dialog . exception . InvalidComponentClassException ;  import       com . citytechinc . cq . component . dialog . exception . InvalidComponentFieldException ;  import       com . citytechinc . cq . component . dialog . exception . OutputFailureException ;  import       com . citytechinc . cq . component . dialog . maker . WidgetMaker ;  import       com . citytechinc . cq . component . dialog . util . DialogUtil ;  import       com . citytechinc . cq . component . dialog . widget . WidgetRegistry ;  import       com . citytechinc . cq . component . editconfig . util . EditConfigUtil ;  import      com . citytechinc . cq . component . util . WidgetConfigHolder ;   public class ComponentMojoUtil  {   private static final String  OUTPUT_PATH = "tempComponentConfig" ;   private ComponentMojoUtil  ( )  { } ;   public static final LogSingleton getLog  ( )  {  return  LogSingleton . getInstance  ( ) ; }   public static ClassLoader getClassLoader  (   List  < String > paths ,  ClassLoader mojoClassLoader )  throws MalformedURLException  {   final  List  < URL >  pathURLs =  new  ArrayList  < URL >  ( ) ;  for ( String curPath : paths )  {  URL  newClassPathURL =    new File  ( curPath ) . toURI  ( ) . toURL  ( ) ;    getLog  ( ) . debug  (   "Adding " +  newClassPathURL . toString  ( ) + " to class loader" ) ;   pathURLs . add  ( newClassPathURL ) ; }  return  new URLClassLoader  (  pathURLs . toArray  (  new URL  [ 0 ] ) , mojoClassLoader ) ; }   public static ClassPool getClassPool  (  ClassLoader loader )  {  ClassPool  classPool =  new ClassLoaderClassPool  ( loader ) ;  return classPool ; }   protected static String classNameFromFilePath  (  String filePath ,  String rootPath )  {  String  placeholder = filePath ;  if  (   StringUtils . isNotEmpty  ( rootPath ) &&  placeholder . startsWith  ( rootPath ) )  {   placeholder =  placeholder . replace  ( rootPath , "" ) ; }  if  (   placeholder . charAt  ( 0 ) == '/' )  {   placeholder =  placeholder . substring  ( 1 ) ; }  if  (  placeholder . endsWith  ( ".class" ) )  {   placeholder =  placeholder . substring  ( 0 ,   placeholder . length  ( ) -  ".class" . length  ( ) ) ; }    getLog  ( ) . debug  (  "Class pre replace " + placeholder ) ;  return  placeholder . replace  ( '/' , '.' ) ; }   public static void buildArchiveFileForProjectAndClassList  (   List  < CtClass > classList ,  WidgetRegistry widgetRegistry ,  ClassLoader classLoader ,  ClassPool classPool ,  File buildDirectory ,  String componentPathBase ,  String defaultComponentPathSuffix ,  String defaultComponentGroup ,  File existingArchiveFile ,  File tempArchiveFile ,  ComponentNameTransformer transformer )  throws OutputFailureException , IOException , InvalidComponentClassException , InvalidComponentFieldException , ParserConfigurationException , TransformerException , ClassNotFoundException , CannotCompileException , NotFoundException , SecurityException , NoSuchFieldException , IllegalArgumentException , IllegalAccessException , InvocationTargetException , NoSuchMethodException , InstantiationException  {  if  (  !  existingArchiveFile . exists  ( ) )  {  throw  new OutputFailureException  ( "Archive file does not exist" ) ; }  if  (  tempArchiveFile . exists  ( ) )  {   tempArchiveFile . delete  ( ) ; }   tempArchiveFile . createNewFile  ( ) ;   deleteTemporaryComponentOutputDirectory  ( buildDirectory ) ;  ZipArchiveInputStream  existingInputStream =  new ZipArchiveInputStream  (  new FileInputStream  ( existingArchiveFile ) ) ;  ZipArchiveOutputStream  tempOutputStream =  new ZipArchiveOutputStream  ( tempArchiveFile ) ;  ZipArchiveEntry  curArchiveEntry ;   Set  < String >  existingArchiveEntryNames =  new  HashSet  < String >  ( ) ;  while  (   (  curArchiveEntry =  existingInputStream . getNextZipEntry  ( ) ) != null )  {   existingArchiveEntryNames . add  (   curArchiveEntry . getName  ( ) . toLowerCase  ( ) ) ;    getLog  ( ) . debug  (  "Current File Name: " +  curArchiveEntry . getName  ( ) ) ;   tempOutputStream . putArchiveEntry  ( curArchiveEntry ) ;   IOUtils . copy  ( existingInputStream , tempOutputStream ) ;   tempOutputStream . closeArchiveEntry  ( ) ; }   ContentUtil . buildContentFromClassList  ( classList , tempOutputStream , existingArchiveEntryNames , buildDirectory , componentPathBase , defaultComponentPathSuffix , defaultComponentGroup , transformer ) ;   DialogUtil . buildDialogsFromClassList  ( transformer , classList , tempOutputStream , existingArchiveEntryNames , widgetRegistry , classLoader , classPool , buildDirectory , componentPathBase , defaultComponentPathSuffix ) ;   EditConfigUtil . buildEditConfigFromClassList  ( classList , tempOutputStream , existingArchiveEntryNames , buildDirectory , componentPathBase , defaultComponentPathSuffix , transformer ) ;   tempOutputStream . finish  ( ) ;   existingInputStream . close  ( ) ;   tempOutputStream . close  ( ) ;   existingArchiveFile . delete  ( ) ;   tempArchiveFile . renameTo  ( existingArchiveFile ) ; }   protected static File getArchiveFileForProject  (  MavenProject project )  {  File  buildDirectory =  new File  (   project . getBuild  ( ) . getDirectory  ( ) ) ;  String  zipFileName =     project . getArtifactId  ( ) + "-" +  project . getVersion  ( ) + ".zip" ;    getLog  ( ) . debug  (  "Determined ZIP file name to be " + zipFileName ) ;  return  new File  ( buildDirectory , zipFileName ) ; }   protected static File getTempArchiveFileForProject  (  MavenProject project )  {  File  buildDirectory =  new File  (   project . getBuild  ( ) . getDirectory  ( ) ) ;  String  zipFileName =     project . getArtifactId  ( ) + "-" +  project . getVersion  ( ) + "-temp.zip" ;    getLog  ( ) . debug  (  "Temp archive file name " + zipFileName ) ;  return  new File  ( buildDirectory , zipFileName ) ; }   public static File getOutputDirectoryForComponentClass  (  ComponentNameTransformer transformer ,  CtClass componentClass ,  File buildDirectory ,  String componentPathBase ,  String defaultComponentPathSuffix )  throws OutputFailureException , ClassNotFoundException  {  String  dialogFilePath =       OUTPUT_PATH + "/" +  getComponentBasePathForComponentClass  ( componentClass , componentPathBase ) + "/" +  getComponentPathSuffixForComponentClass  ( componentClass , defaultComponentPathSuffix ) + "/" +  getComponentNameForComponentClass  ( transformer , componentClass ) ;  File  componentOutputDirectory =  new File  ( buildDirectory , dialogFilePath ) ;  if  (  !  componentOutputDirectory . exists  ( ) )  {  if  (  !  componentOutputDirectory . mkdirs  ( ) )  {  throw  new OutputFailureException  ( "Failure creating output directory for Component" ) ; } }  return componentOutputDirectory ; }   protected static void deleteTemporaryComponentOutputDirectory  (  File buildDirectory )  throws IOException  {  File  componentOutputDirectory =  new File  ( buildDirectory , OUTPUT_PATH ) ;  if  (  componentOutputDirectory . exists  ( ) )  {   FileUtils . deleteDirectory  ( componentOutputDirectory ) ; } }   public static String getComponentPathSuffixForComponentClass  (  CtClass componentClass ,  String defaultComponentPathSuffix )  throws ClassNotFoundException  {  Component  componentAnnotation =  ( Component )  componentClass . getAnnotation  (  Component . class ) ;  if  (  componentAnnotation != null )  {  String  path =  componentAnnotation . path  ( ) ;  if  (  StringUtils . isNotEmpty  ( path ) )  {  return path ; } }  return defaultComponentPathSuffix ; }   public static String getComponentNameForComponentClass  (  ComponentNameTransformer transformer ,  CtClass componentClass )  throws ClassNotFoundException  {  Component  componentAnnotation =  ( Component )  componentClass . getAnnotation  (  Component . class ) ;  if  (  componentAnnotation != null )  {  String  name =  componentAnnotation . name  ( ) ;  if  (  StringUtils . isNotEmpty  ( name ) )  {  return name ; } }  return  transformer . transform  (  componentClass . getSimpleName  ( ) ) ; }   public static  List  < WidgetConfigHolder > getAllWidgetAnnotations  (  ClassPool classPool ,  ClassLoader classLoader ,  Reflections reflections )  throws ClassNotFoundException , NotFoundException , MalformedURLException  {   List  < WidgetConfigHolder >  builtInWidgets =  new  ArrayList  < WidgetConfigHolder >  ( ) ;  for (  Class  <  ? > c :  reflections . getTypesAnnotatedWith  (  Widget . class ) )  {  CtClass  clazz =  classPool . getCtClass  (  c . getName  ( ) ) ;  Widget  widgetAnnotation =  ( Widget )  clazz . getAnnotation  (  Widget . class ) ;   Class  <  ? extends Annotation >  annotationClass =  widgetAnnotation . annotationClass  ( ) ;   Class  <  ? extends WidgetMaker >  makerClass =  widgetAnnotation . makerClass  ( ) ;   Class  <  ? extends AbstractWidget >  widgetClass =   classLoader . loadClass  (  clazz . getName  ( ) ) . asSubclass  (  AbstractWidget . class ) ;  WidgetConfigHolder  widgetConfig =  new WidgetConfigHolder  ( annotationClass , widgetClass , makerClass ,  widgetAnnotation . xtype  ( ) ,  widgetAnnotation . ranking  ( ) ) ;   builtInWidgets . add  ( widgetConfig ) ; }  return builtInWidgets ; }   public static  List  < CtClass > getAllComponentAnnotations  (  ClassPool classPool ,  Reflections reflections )  throws ClassNotFoundException , NotFoundException , MalformedURLException  {   List  < CtClass >  classes =  new  ArrayList  < CtClass >  ( ) ;  for (  Class  <  ? > c :  reflections . getTypesAnnotatedWith  (  Component . class ) )  {   classes . add  (  classPool . getCtClass  (  c . getName  ( ) ) ) ; }  return classes ; }   public static  Map  < String , ComponentNameTransformer > getAllTransformers  (  ClassPool classPool ,  Reflections reflections )  throws ClassNotFoundException , NotFoundException , MalformedURLException , InstantiationException , IllegalAccessException  {   Map  < String , ComponentNameTransformer >  transformers =  new  HashMap  < String , ComponentNameTransformer >  ( ) ;  for (  Class  <  ? > c :  reflections . getTypesAnnotatedWith  (  Transformer . class ) )  {  if  (   Arrays . asList  (  c . getInterfaces  ( ) ) . contains  (  ComponentNameTransformer . class ) )  {  CtClass  ctclass =  classPool . getCtClass  (  c . getName  ( ) ) ;  Transformer  transformer =  ( Transformer )  ctclass . getAnnotation  (  Transformer . class ) ;   transformers . put  (  transformer . value  ( ) ,  ( ComponentNameTransformer )  c . newInstance  ( ) ) ; } }  return transformers ; }   public static  List  < CtField > collectFields  (  CtClass ctClass )  throws NotFoundException  {   List  < CtField >  fields =  new  ArrayList  < CtField >  ( ) ;  if  (  ctClass != null )  {   fields . addAll  (  Arrays . asList  (  ctClass . getDeclaredFields  ( ) ) ) ;   fields . addAll  (  collectFields  (  ctClass . getSuperclass  ( ) ) ) ; }  return fields ; }   public static  List  < CtMethod > collectMethods  (  CtClass ctClass )  {   List  < CtMethod >  methods =  new  ArrayList  < CtMethod >  ( ) ;  if  (  ctClass != null )  {   methods . addAll  (  Arrays . asList  (  ctClass . getMethods  ( ) ) ) ; }  return methods ; }   public static Reflections getReflections  (  ClassLoader classLoader )  {  Reflections  reflections =  new Reflections  (     new ConfigurationBuilder  ( ) . addClassLoader  ( classLoader ) . setUrls  (  ClasspathHelper . forClassLoader  (  new ClassLoader  [ ]  { classLoader } ) ) . setScanners  (  new TypeAnnotationsScanner  ( ) ) ) ;  return reflections ; }   public static String getComponentBasePathForComponentClass  (  CtClass componentClass ,  String componentPathBase )  throws ClassNotFoundException  {  Component  componentAnnotation =  ( Component )  componentClass . getAnnotation  (  Component . class ) ;  if  (  componentAnnotation != null )  {  String  basePath =  componentAnnotation . basePath  ( ) ;  if  (  StringUtils . isNotEmpty  ( basePath ) )  {  return basePath ; } }  return componentPathBase ; } }