  package    bibliothek . gui . dock . security ;   import   java . awt . Component ;  import   java . awt . Cursor ;  import   java . awt . Dimension ;  import   java . awt . Point ;  import    java . awt . event . KeyEvent ;  import    java . awt . event . MouseEvent ;  import    java . awt . event . MouseListener ;  import    java . awt . event . MouseMotionListener ;  import    java . awt . event . MouseWheelEvent ;  import    java . awt . event . MouseWheelListener ;  import   javax . swing . JComponent ;  import   javax . swing . JPanel ;  import   javax . swing . JToolTip ;  import   javax . swing . SwingUtilities ;  import   bibliothek . gui . DockController ;  import      bibliothek . gui . dock . control . focus . FocusController ;  import      bibliothek . gui . dock . control . focus . MouseFocusObserver ;  import   bibliothek . util . Todo ;  import    bibliothek . util . Todo . Compatibility ;  import    bibliothek . util . Todo . Priority ;  import    bibliothek . util . Todo . Version ;  import     bibliothek . gui . dock . util . PropertyKey ;  import     bibliothek . gui . dock . util . PropertyValue ;  import      bibliothek . gui . dock . util . property . ConstantPropertyFactory ;  import   bibliothek . util . Workarounds ;  import   java . util . EventListener ;    @ Todo  (  compatibility =  Compatibility . COMPATIBLE ,  priority =  Priority . MAJOR ,  target =  Version . VERSION_1_1_1 ,  description = "In Java 1.7 if a mouse-dragged is followed by a mouse-exit, and the mouse is over another GlassedPane, then this GlassedPane no longer receives events that it received in Java 1.6" ) public class GlassedPane  extends JPanel  {   public static final  PropertyKey  < TooltipStrategy >  TOOLTIP_STRATEGY =  new  PropertyKey  < TooltipStrategy >  ( "tooltip strategy" ,  new  ConstantPropertyFactory  < TooltipStrategy >  (  new DefaultTooltipStrategy  ( ) ) , true ) ;   private JComponent  contentPane =  new JPanel  ( ) ;   private JComponent  glassPane =  new GlassPane  ( ) ;   private DockController  controller ;   private  PropertyValue  < TooltipStrategy >  tooltips =  new  PropertyValue  < TooltipStrategy >  ( TOOLTIP_STRATEGY )  {    @ Override protected void valueChanged  (  TooltipStrategy oldValue ,  TooltipStrategy newValue )  {  if  (  oldValue != null )  {   oldValue . uninstall  (  GlassedPane . this ) ; }  if  (  newValue != null )  {   newValue . install  (  GlassedPane . this ) ; } } } ;   public GlassedPane  ( )  {   setLayout  ( null ) ;   contentPane . setOpaque  ( false ) ;   setOpaque  ( false ) ;   add  ( glassPane ) ;   add  ( contentPane ) ;   setFocusCycleRoot  ( true ) ; }   public void setController  (  DockController controller )  {    this . controller = controller ;   tooltips . setProperties  ( controller ) ; }    @ Override public void doLayout  ( )  {   int  width =  getWidth  ( ) ;   int  height =  getHeight  ( ) ;  if  (  contentPane != null )  {   contentPane . setBounds  ( 0 , 0 , width , height ) ; }   glassPane . setBounds  ( 0 , 0 , width , height ) ; }    @ Override public Dimension getPreferredSize  ( )  {  if  (  contentPane == null )  {  return  super . getPreferredSize  ( ) ; }  return  contentPane . getPreferredSize  ( ) ; }    @ Override public Dimension getMaximumSize  ( )  {  if  (  contentPane == null )  {  return  super . getMaximumSize  ( ) ; }  return  contentPane . getMaximumSize  ( ) ; }    @ Override public Dimension getMinimumSize  ( )  {  if  (  contentPane == null )  {  return  super . getMinimumSize  ( ) ; }  return  contentPane . getMinimumSize  ( ) ; }   public void setContentPane  (  JComponent contentPane )  {    this . contentPane = contentPane ;   removeAll  ( ) ;   add  ( glassPane ) ;  if  (  contentPane != null )  {   add  ( contentPane ) ; } }   public JComponent getContentPane  ( )  {  return contentPane ; }   public JComponent getGlassPane  ( )  {  return glassPane ; }   public class GlassPane  extends JPanel  implements  MouseListener , MouseMotionListener , MouseWheelListener  {   private Component  dragged ;   private Component  over ;   private  int  downCount = 0 ;   private TooltipStrategyCallback  callback =  new TooltipStrategyCallback  ( )  {   public void setToolTipText  (  String text )  {    GlassPane . this . setToolTipText  ( text ) ; }   public String getToolTipText  ( )  {  return   GlassPane . this . getToolTipText  ( ) ; }   public GlassedPane getGlassedPane  ( )  {  return  GlassedPane . this ; }   public JToolTip createToolTip  ( )  {  return  superCreateToolTip  ( ) ; } } ;   public GlassPane  ( )  {   addMouseListener  ( this ) ;   addMouseMotionListener  ( this ) ;   addMouseWheelListener  ( this ) ;   setOpaque  ( false ) ;   setFocusable  ( false ) ;    Workarounds . getDefault  ( ) . markAsGlassPane  ( this ) ; }   public void mouseClicked  (  MouseEvent e )  {  if  (  !  e . isConsumed  ( ) )   send  ( e ) ; }   public void mousePressed  (  MouseEvent e )  {  if  (  !  e . isConsumed  ( ) )   send  ( e ) ; }   public void mouseReleased  (  MouseEvent e )  {  if  (  !  e . isConsumed  ( ) )   send  ( e ) ; }   public void mouseEntered  (  MouseEvent e )  {  if  (  !  e . isConsumed  ( ) )   send  ( e ) ; }   public void mouseExited  (  MouseEvent e )  {  if  (   !  e . isConsumed  ( ) &&  isVisible  ( ) )   send  ( e ) ;  if  (  !  isVisible  ( ) )  {   downCount = 0 ; } }   public void mouseDragged  (  MouseEvent e )  {  if  (  !  e . isConsumed  ( ) )   send  ( e ) ; }   public void mouseMoved  (  MouseEvent e )  {  if  (  !  e . isConsumed  ( ) )   send  ( e ) ; }   public void mouseWheelMoved  (  MouseWheelEvent e )  {  if  (  !  e . isConsumed  ( ) )   send  ( e ) ; }   private void send  (  MouseEvent e )  {   send  ( e ,  e . getID  ( ) ) ; }   private void send  (  MouseEvent e ,   int id )  {  if  (  contentPane == null )  {  return ; }  Point  mouse =  e . getPoint  ( ) ;  Component  component =  SwingUtilities . getDeepestComponentAt  ( contentPane ,  mouse . x ,  mouse . y ) ;  if  (   component != null &&  !  component . isEnabled  ( ) )  {   component = null ; } else  {   component =  fallThrough  ( component , e ) ; }  boolean  drag =  id ==  MouseEvent . MOUSE_DRAGGED ;  boolean  press =  id ==  MouseEvent . MOUSE_PRESSED ;  boolean  release =  id ==  MouseEvent . MOUSE_RELEASED ;  boolean  moved =  id ==  MouseEvent . MOUSE_MOVED ;  boolean  entered =  id ==  MouseEvent . MOUSE_ENTERED ;  boolean  exited =  id ==  MouseEvent . MOUSE_EXITED ;  if  (  drag &&  dragged == null )   dragged = component ; else  if  ( drag )   component = dragged ;  if  ( press )  {   downCount |=  1 <<  e . getButton  ( ) ; }  if  (   downCount > 0 &&  dragged != null )   component = dragged ; else  if  (   downCount > 0 &&  dragged == null )   dragged = component ; else  if  (  downCount == 0 )   dragged = null ;  if  ( release )  {   downCount &=  ~  (  1 <<  e . getButton  ( ) ) ; }  if  (   (   e . getModifiersEx  ( ) &  (    MouseEvent . BUTTON1_DOWN_MASK |  MouseEvent . BUTTON2_DOWN_MASK |  MouseEvent . BUTTON3_DOWN_MASK ) ) == 0 )  {   downCount = 0 ;   dragged = null ; }  boolean  overNewComponent = false ;  if  (   moved || entered || exited )  {  if  (  over != component )  {   overNewComponent = true ;  if  (  over != null )  {   over . dispatchEvent  (  new MouseEvent  ( over ,  MouseEvent . MOUSE_EXITED ,  e . getWhen  ( ) ,  e . getModifiers  ( ) ,  mouse . x ,  mouse . y ,  e . getClickCount  ( ) ,  e . isPopupTrigger  ( ) ,  e . getButton  ( ) ) ) ; }   over = component ;  if  (  over != null )  {   over . dispatchEvent  (  new MouseEvent  ( over ,  MouseEvent . MOUSE_ENTERED ,  e . getWhen  ( ) ,  e . getModifiers  ( ) ,  mouse . x ,  mouse . y ,  e . getClickCount  ( ) ,  e . isPopupTrigger  ( ) ,  e . getButton  ( ) ) ) ; } } }  if  (  component == null )  {   setCursor  ( null ) ;   setToolTipText  ( null ) ; } else  {   mouse =  SwingUtilities . convertPoint  ( this , mouse , component ) ;  MouseEvent  forward =  new MouseEvent  ( component , id ,  e . getWhen  ( ) ,  e . getModifiers  ( ) ,  mouse . x ,  mouse . y ,  e . getClickCount  ( ) ,  e . isPopupTrigger  ( ) ,  e . getButton  ( ) ) ;  if  (  controller != null )  {    controller . getGlobalMouseDispatcher  ( ) . dispatch  ( forward ) ; }   component . dispatchEvent  ( forward ) ;  Cursor  cursor =  component . getCursor  ( ) ;  if  (   getCursor  ( ) != cursor )   setCursor  ( cursor ) ;    tooltips . getValue  ( ) . setTooltipText  ( over , forward , overNewComponent , callback ) ; } }    @ Override public JToolTip createToolTip  ( )  {  return   tooltips . getValue  ( ) . createTooltip  ( over , callback ) ; }   private JToolTip superCreateToolTip  ( )  {  return  super . createToolTip  ( ) ; }   private void send  (  MouseWheelEvent e )  {  if  (  contentPane == null )  {  return ; }  Point  mouse =  e . getPoint  ( ) ;  Component  component =  SwingUtilities . getDeepestComponentAt  ( contentPane ,  mouse . x ,  mouse . y ) ;  if  (  component != null )  {   mouse =  SwingUtilities . convertPoint  ( this , mouse , component ) ;  MouseWheelEvent  forward =  new MouseWheelEvent  ( component ,  e . getID  ( ) ,  e . getWhen  ( ) ,  e . getModifiers  ( ) ,  mouse . x ,  mouse . y ,  e . getClickCount  ( ) ,  e . isPopupTrigger  ( ) ,  e . getScrollType  ( ) ,  e . getScrollAmount  ( ) ,  e . getWheelRotation  ( ) ) ;  if  (  controller != null )  {    controller . getGlobalMouseDispatcher  ( ) . dispatch  ( forward ) ; }   component . dispatchEvent  ( forward ) ; } }   private Component fallThrough  (  Component component ,  MouseEvent event )  {   Class  <  ? extends EventListener >  type = null ;  if  (    event . getID  ( ) ==  MouseEvent . MOUSE_DRAGGED ||   event . getID  ( ) ==  MouseEvent . MOUSE_MOVED )  {   type =  MouseMotionListener . class ; } else  if  (   event . getID  ( ) ==  MouseEvent . MOUSE_WHEEL )  {   type =  MouseWheelListener . class ; } else  {   type =  MouseListener . class ; }  while  (   component != null &&    component . getListeners  ( type ) . length == 0 )  {   component =  component . getParent  ( ) ; }  return component ; } } }