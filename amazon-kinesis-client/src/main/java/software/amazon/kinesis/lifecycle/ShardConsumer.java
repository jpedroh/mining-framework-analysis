  package    software . amazon . kinesis . lifecycle ;   import   java . time . Duration ;  import   java . time . Instant ;  import   java . util . Optional ;  import    java . util . concurrent . CompletableFuture ;  import    java . util . concurrent . ExecutionException ;  import    java . util . concurrent . ExecutorService ;  import    java . util . function . Function ;  import   org . reactivestreams . Subscription ;  import     com . google . common . annotations . VisibleForTesting ;  import  lombok . AccessLevel ;  import  lombok . Getter ;  import  lombok . NonNull ;  import   lombok . experimental . Accessors ;  import    lombok . extern . slf4j . Slf4j ;  import     software . amazon . kinesis . annotations . KinesisClientInternalApi ;  import      software . amazon . kinesis . exceptions . internal . BlockedOnParentShardException ;  import     software . amazon . kinesis . leases . ShardInfo ;  import      software . amazon . kinesis . lifecycle . events . ProcessRecordsInput ;  import      software . amazon . kinesis . lifecycle . events . TaskExecutionListenerInput ;  import     software . amazon . kinesis . metrics . MetricsCollectingTaskDecorator ;  import     software . amazon . kinesis . metrics . MetricsFactory ;  import     software . amazon . kinesis . retrieval . RecordsPublisher ;    @ Getter  (  AccessLevel . PACKAGE )  @ Accessors  (  fluent = true )  @ Slf4j  @ KinesisClientInternalApi public class ShardConsumer  {   public static final  int  MAX_TIME_BETWEEN_REQUEST_RESPONSE = 35000 ;   private final RecordsPublisher  recordsPublisher ;   private final ExecutorService  executorService ;   private final ShardInfo  shardInfo ;   private final ShardConsumerArgument  shardConsumerArgument ;    @ NonNull private final  Optional  < Long >  logWarningForTaskAfterMillis ;   private final  Function  < ConsumerTask , ConsumerTask >  taskMetricsDecorator ;   private final  int  bufferSize ;   private final TaskExecutionListener  taskExecutionListener ;   private ConsumerTask  currentTask ;   private TaskOutcome  taskOutcome ;   private  CompletableFuture  < Boolean >  stateChangeFuture ;   private boolean  needsInitialization = true ;   private volatile Instant  taskDispatchedAt ;   private volatile boolean  taskIsRunning = false ;   private ConsumerState  currentState ;   private final Object  shutdownLock =  new Object  ( ) ;    @ Getter  (  AccessLevel . PUBLIC ) private volatile ShutdownReason  shutdownReason ;   private volatile ShutdownNotification  shutdownNotification ;   private final ShardConsumerSubscriber  subscriber ;   public  @ Deprecated ShardConsumer  (  RecordsPublisher recordsPublisher ,  ExecutorService executorService ,  ShardInfo shardInfo ,   Optional  < Long > logWarningForTaskAfterMillis ,  ShardConsumerArgument shardConsumerArgument ,  TaskExecutionListener taskExecutionListener )  {  this  ( recordsPublisher , executorService , shardInfo , logWarningForTaskAfterMillis , shardConsumerArgument ,  ConsumerStates . INITIAL_STATE ,  ShardConsumer . metricsWrappingFunction  (  shardConsumerArgument . metricsFactory  ( ) ) , 8 , taskExecutionListener ,  LifecycleConfig . DEFAULT_READ_TIMEOUTS_TO_IGNORE ) ; }   public  @ Deprecated ShardConsumer  (  RecordsPublisher recordsPublisher ,  ExecutorService executorService ,  ShardInfo shardInfo ,   Optional  < Long > logWarningForTaskAfterMillis ,  ShardConsumerArgument shardConsumerArgument ,  ConsumerState initialState ,   Function  < ConsumerTask , ConsumerTask > taskMetricsDecorator ,   int bufferSize ,  TaskExecutionListener taskExecutionListener )  {  this  ( recordsPublisher , executorService , shardInfo , logWarningForTaskAfterMillis , shardConsumerArgument , initialState , taskMetricsDecorator , bufferSize , taskExecutionListener ,  LifecycleConfig . DEFAULT_READ_TIMEOUTS_TO_IGNORE ) ; }   synchronized void handleInput  (  ProcessRecordsInput input ,  Subscription subscription )  {  if  (  isShutdownRequested  ( ) )  {   subscription . cancel  ( ) ;  return ; }   processData  ( input ) ;  if  (  taskOutcome ==  TaskOutcome . END_OF_SHARD )  {   markForShutdown  (  ShutdownReason . SHARD_END ) ;   subscription . cancel  ( ) ;  return ; }   subscription . request  ( 1 ) ; }   public void executeLifecycle  ( )  {  if  (  isShutdown  ( ) )  {  return ; }  if  (   stateChangeFuture != null &&  !  stateChangeFuture . isDone  ( ) )  {  return ; }  try  {  if  (  isShutdownRequested  ( ) )  {   stateChangeFuture =  shutdownComplete  ( ) ; } else  if  ( needsInitialization )  {  if  (  stateChangeFuture != null )  {  if  (  stateChangeFuture . get  ( ) )  {   subscribe  ( ) ;   needsInitialization = false ; } }   stateChangeFuture =  initializeComplete  ( ) ; } }  catch (   InterruptedException e )  { }  catch (   ExecutionException e )  {  throw  new RuntimeException  ( e ) ; }  if  (    ConsumerStates . ShardConsumerState . PROCESSING . equals  (  currentState . state  ( ) ) )  {  Throwable  t =  healthCheck  ( ) ;  if  (  t instanceof Error )  {  throw  ( Error ) t ; } } }    @ VisibleForTesting Throwable healthCheck  ( )  {   logNoDataRetrievedAfterTime  ( ) ;   logLongRunningTask  ( ) ;  Throwable  failure =  subscriber . healthCheck  ( MAX_TIME_BETWEEN_REQUEST_RESPONSE ) ;  if  (  failure != null )  {  return failure ; }  Throwable  dispatchFailure =  subscriber . getAndResetDispatchFailure  ( ) ;  if  (  dispatchFailure != null )  {   log . warn  ( "Exception occurred while dispatching incoming data.  The incoming data has been skipped" , dispatchFailure ) ;  return dispatchFailure ; }  return null ; }  Duration taskRunningTime  ( )  {  if  (   taskDispatchedAt != null && taskIsRunning )  {  return  Duration . between  ( taskDispatchedAt ,  Instant . now  ( ) ) ; }  return null ; }  String longRunningTaskMessage  (  Duration taken )  {  if  (  taken != null )  {  return  String . format  ( "Previous %s task still pending for shard %s since %s ago. " ,  currentTask . taskType  ( ) ,  shardInfo . shardId  ( ) , taken ) ; }  return null ; }   private void logNoDataRetrievedAfterTime  ( )  {   logWarningForTaskAfterMillis . ifPresent  (  value ->  {  Instant  lastDataArrival =  subscriber . lastDataArrival  ( ) ;  if  (  lastDataArrival != null )  {  Instant  now =  Instant . now  ( ) ;  Duration  timeSince =  Duration . between  (  subscriber . lastDataArrival  ( ) , now ) ;  if  (   timeSince . toMillis  ( ) > value )  {   log . warn  ( "Last time data arrived: {} ({})" , lastDataArrival , timeSince ) ; } } } ) ; }   private void logLongRunningTask  ( )  {  Duration  taken =  taskRunningTime  ( ) ;  if  (  taken != null )  {  String  message =  longRunningTaskMessage  ( taken ) ;  if  (  log . isDebugEnabled  ( ) )  {   log . debug  ( "{} Not submitting new task." , message ) ; }   logWarningForTaskAfterMillis . ifPresent  (  value ->  {  if  (   taken . toMillis  ( ) > value )  {   log . warn  ( message ) ; } } ) ; } }    @ VisibleForTesting void subscribe  ( )  {   subscriber . startSubscriptions  ( ) ; }    @ VisibleForTesting synchronized  CompletableFuture  < Boolean > initializeComplete  ( )  {  if  (  taskOutcome != null )  {   updateState  ( taskOutcome ) ; }  if  (   currentState . state  ( ) ==   ConsumerStates . ShardConsumerState . PROCESSING )  {  return  CompletableFuture . completedFuture  ( true ) ; }  return  CompletableFuture . supplyAsync  (   ( ) ->  {  if  (  isShutdownRequested  ( ) )  {  throw  new IllegalStateException  ( "Shutdown requested while initializing" ) ; }   executeTask  ( null ) ;  if  (  isShutdownRequested  ( ) )  {  throw  new IllegalStateException  ( "Shutdown requested while initializing" ) ; }  return false ; } , executorService ) ; }    @ VisibleForTesting  CompletableFuture  < Boolean > shutdownComplete  ( )  {  return  CompletableFuture . supplyAsync  (   ( ) ->  {  synchronized  ( this )  {  if  (  taskOutcome != null )  {   updateState  ( taskOutcome ) ; } else  {   updateState  (  TaskOutcome . SUCCESSFUL ) ; }  if  (  isShutdown  ( ) )  {  return true ; }   executeTask  ( null ) ;  return false ; } } , executorService ) ; }   private synchronized void processData  (  ProcessRecordsInput input )  {   executeTask  ( input ) ; }   private synchronized void executeTask  (  ProcessRecordsInput input )  {  TaskExecutionListenerInput  taskExecutionListenerInput =     TaskExecutionListenerInput . builder  ( ) . shardInfo  ( shardInfo ) . taskType  (  currentState . taskType  ( ) ) . build  ( ) ;   taskExecutionListener . beforeTaskExecution  ( taskExecutionListenerInput ) ;  ConsumerTask  task =  currentState . createTask  ( shardConsumerArgument ,  ShardConsumer . this , input ) ;  if  (  task != null )  {   taskDispatchedAt =  Instant . now  ( ) ;   currentTask = task ;   taskIsRunning = true ;  TaskResult  result ;  try  {   result =  task . call  ( ) ; }  finally  {   taskIsRunning = false ; }   taskOutcome =  resultToOutcome  ( result ) ;   taskExecutionListenerInput =    taskExecutionListenerInput . toBuilder  ( ) . taskOutcome  ( taskOutcome ) . build  ( ) ; }   taskExecutionListener . afterTaskExecution  ( taskExecutionListenerInput ) ; }   private TaskOutcome resultToOutcome  (  TaskResult result )  {  if  (   result . getException  ( ) == null )  {  if  (  result . isShardEndReached  ( ) )  {  return  TaskOutcome . END_OF_SHARD ; }  return  TaskOutcome . SUCCESSFUL ; }   logTaskException  ( result ) ;  return  TaskOutcome . FAILURE ; }   private synchronized void updateState  (  TaskOutcome outcome )  {  ConsumerState  nextState = currentState ;  switch  ( outcome )  {   case SUCCESSFUL :   nextState =  currentState . successTransition  ( ) ;  break ;   case END_OF_SHARD :   markForShutdown  (  ShutdownReason . SHARD_END ) ;  break ;   case FAILURE :   nextState =  currentState . failureTransition  ( ) ;  break ;   default :   log . error  ( "No handler for outcome of {}" ,  outcome . name  ( ) ) ;   nextState =  currentState . failureTransition  ( ) ;  break ; }   nextState =  handleShutdownTransition  ( outcome , nextState ) ;   currentState = nextState ; }   private ConsumerState handleShutdownTransition  (  TaskOutcome outcome ,  ConsumerState nextState )  {  synchronized  ( shutdownLock )  {  if  (   isShutdownRequested  ( ) &&  outcome !=  TaskOutcome . FAILURE )  {  return  currentState . shutdownTransition  ( shutdownReason ) ; }  return nextState ; } }   private void logTaskException  (  TaskResult taskResult )  {  if  (  log . isDebugEnabled  ( ) )  {  Exception  taskException =  taskResult . getException  ( ) ;  if  (  taskException instanceof BlockedOnParentShardException )  {   log . debug  ( "Shard {} is blocked on completion of parent shard." ,  shardInfo . shardId  ( ) ) ; } else  {   log . debug  ( "Caught exception running {} task: " ,  currentTask . taskType  ( ) ,  taskResult . getException  ( ) ) ; } } }   public void gracefulShutdown  (  ShutdownNotification shutdownNotification )  {  if  (  subscriber != null )  {   subscriber . cancel  ( ) ; }    this . shutdownNotification = shutdownNotification ;   markForShutdown  (  ShutdownReason . REQUESTED ) ; }   public boolean leaseLost  ( )  {   log . debug  ( "Shutdown({}): Lease lost triggered." ,  shardInfo . shardId  ( ) ) ;  if  (  subscriber != null )  {   subscriber . cancel  ( ) ;   log . debug  ( "Shutdown({}): Subscriber cancelled." ,  shardInfo . shardId  ( ) ) ; }   markForShutdown  (  ShutdownReason . LEASE_LOST ) ;  return  isShutdown  ( ) ; }  void markForShutdown  (  ShutdownReason reason )  {  synchronized  ( shutdownLock )  {  if  (   shutdownReason == null ||  shutdownReason . canTransitionTo  ( reason ) )  {   shutdownReason = reason ; } } }   public boolean isShutdown  ( )  {  return  currentState . isTerminal  ( ) ; }    @ VisibleForTesting public boolean isShutdownRequested  ( )  {  synchronized  ( shutdownLock )  {  return  shutdownReason != null ; } }   private static  Function  < ConsumerTask , ConsumerTask > metricsWrappingFunction  (  MetricsFactory metricsFactory )  {  return   ( task ) ->  {  if  (  task == null )  {  return null ; } else  {  return  new MetricsCollectingTaskDecorator  ( task , metricsFactory ) ; } } ; }   public ShardConsumer  (  RecordsPublisher recordsPublisher ,  ExecutorService executorService ,  ShardInfo shardInfo ,   Optional  < Long > logWarningForTaskAfterMillis ,  ShardConsumerArgument shardConsumerArgument ,  TaskExecutionListener taskExecutionListener ,   int readTimeoutsToIgnoreBeforeWarning )  {  this  ( recordsPublisher , executorService , shardInfo , logWarningForTaskAfterMillis , shardConsumerArgument ,  ConsumerStates . INITIAL_STATE ,  ShardConsumer . metricsWrappingFunction  (  shardConsumerArgument . metricsFactory  ( ) ) , 8 , taskExecutionListener , readTimeoutsToIgnoreBeforeWarning ) ; }   public ShardConsumer  (  RecordsPublisher recordsPublisher ,  ExecutorService executorService ,  ShardInfo shardInfo ,   Optional  < Long > logWarningForTaskAfterMillis ,  ShardConsumerArgument shardConsumerArgument ,  ConsumerState initialState ,   Function  < ConsumerTask , ConsumerTask > taskMetricsDecorator ,   int bufferSize ,  TaskExecutionListener taskExecutionListener ,   int readTimeoutsToIgnoreBeforeWarning )  {    this . recordsPublisher = recordsPublisher ;    this . executorService = executorService ;    this . shardInfo = shardInfo ;    this . shardConsumerArgument = shardConsumerArgument ;    this . logWarningForTaskAfterMillis = logWarningForTaskAfterMillis ;    this . taskExecutionListener = taskExecutionListener ;    this . currentState = initialState ;    this . taskMetricsDecorator = taskMetricsDecorator ;   subscriber =  new ShardConsumerSubscriber  ( recordsPublisher , executorService , bufferSize , this , readTimeoutsToIgnoreBeforeWarning ) ;    this . bufferSize = bufferSize ;  if  (   this . shardInfo . isCompleted  ( ) )  {   markForShutdown  (  ShutdownReason . SHARD_END ) ; } } }