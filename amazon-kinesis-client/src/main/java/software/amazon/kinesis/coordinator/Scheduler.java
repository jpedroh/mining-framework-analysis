  package    software . amazon . kinesis . coordinator ;   import   java . util . Collection ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Set ;  import    java . util . concurrent . Callable ;  import    java . util . concurrent . ConcurrentHashMap ;  import    java . util . concurrent . ConcurrentMap ;  import    java . util . concurrent . CountDownLatch ;  import    java . util . concurrent . ExecutorService ;  import    java . util . concurrent . Future ;  import    java . util . concurrent . TimeUnit ;  import     com . google . common . annotations . VisibleForTesting ;  import  lombok . AccessLevel ;  import  lombok . Getter ;  import  lombok . NoArgsConstructor ;  import  lombok . NonNull ;  import   lombok . experimental . Accessors ;  import    lombok . extern . slf4j . Slf4j ;  import     software . amazon . kinesis . checkpoint . CheckpointConfig ;  import     software . amazon . kinesis . checkpoint . ShardRecordProcessorCheckpointer ;  import     software . amazon . kinesis . common . InitialPositionInStreamExtended ;  import     software . amazon . kinesis . leases . Lease ;  import     software . amazon . kinesis . leases . LeaseCoordinator ;  import     software . amazon . kinesis . leases . LeaseManagementConfig ;  import     software . amazon . kinesis . leases . LeaseRefresher ;  import     software . amazon . kinesis . leases . ShardDetector ;  import     software . amazon . kinesis . leases . ShardInfo ;  import     software . amazon . kinesis . leases . ShardPrioritization ;  import     software . amazon . kinesis . leases . ShardSyncTask ;  import     software . amazon . kinesis . leases . ShardSyncTaskManager ;  import     software . amazon . kinesis . leases . HierarchicalShardSyncer ;  import      software . amazon . kinesis . leases . dynamodb . DynamoDBLeaseCoordinator ;  import      software . amazon . kinesis . leases . exceptions . LeasingException ;  import     software . amazon . kinesis . lifecycle . LifecycleConfig ;  import     software . amazon . kinesis . lifecycle . ShardConsumer ;  import     software . amazon . kinesis . lifecycle . ShardConsumerArgument ;  import     software . amazon . kinesis . lifecycle . ShardConsumerShutdownNotification ;  import     software . amazon . kinesis . lifecycle . ShutdownNotification ;  import     software . amazon . kinesis . lifecycle . ShutdownReason ;  import     software . amazon . kinesis . lifecycle . TaskResult ;  import     software . amazon . kinesis . metrics . CloudWatchMetricsFactory ;  import     software . amazon . kinesis . metrics . MetricsCollectingTaskDecorator ;  import     software . amazon . kinesis . metrics . MetricsConfig ;  import     software . amazon . kinesis . metrics . MetricsFactory ;  import     software . amazon . kinesis . processor . Checkpointer ;  import     software . amazon . kinesis . processor . ProcessorConfig ;  import     software . amazon . kinesis . processor . ShardRecordProcessorFactory ;  import     software . amazon . kinesis . processor . ShutdownNotificationAware ;  import     software . amazon . kinesis . retrieval . AggregatorUtil ;  import     software . amazon . kinesis . retrieval . RecordsPublisher ;  import     software . amazon . kinesis . retrieval . RetrievalConfig ;    @ Getter  @ Accessors  (  fluent = true )  @ Slf4j public class Scheduler  implements  Runnable  {   private SchedulerLog  slog =  new SchedulerLog  ( ) ;   private final CheckpointConfig  checkpointConfig ;   private final CoordinatorConfig  coordinatorConfig ;   private final LeaseManagementConfig  leaseManagementConfig ;   private final LifecycleConfig  lifecycleConfig ;   private final MetricsConfig  metricsConfig ;   private final ProcessorConfig  processorConfig ;   private final RetrievalConfig  retrievalConfig ;   private final String  applicationName ;   private final  int  maxInitializationAttempts ;   private final Checkpointer  checkpoint ;   private final  long  shardConsumerDispatchPollIntervalMillis ;   private final  long  parentShardPollIntervalMillis ;   private final ExecutorService  executorService ;   private final LeaseCoordinator  leaseCoordinator ;   private final ShardSyncTaskManager  shardSyncTaskManager ;   private final ShardPrioritization  shardPrioritization ;   private final boolean  cleanupLeasesUponShardCompletion ;   private final boolean  skipShardSyncAtWorkerInitializationIfLeasesExist ;   private final GracefulShutdownCoordinator  gracefulShutdownCoordinator ;   private final WorkerStateChangeListener  workerStateChangeListener ;   private final InitialPositionInStreamExtended  initialPosition ;   private final MetricsFactory  metricsFactory ;   private final  long  failoverTimeMillis ;   private final  long  taskBackoffTimeMillis ;   private final String  streamName ;   private final  long  listShardsBackoffTimeMillis ;   private final  int  maxListShardsRetryAttempts ;   private final LeaseRefresher  leaseRefresher ;   private final ShardDetector  shardDetector ;   private final boolean  ignoreUnexpetedChildShards ;   private final AggregatorUtil  aggregatorUtil ;   private final HierarchicalShardSyncer  hierarchicalShardSyncer ;   private  ConcurrentMap  < ShardInfo , ShardConsumer >  shardInfoShardConsumerMap =  new  ConcurrentHashMap  < >  ( ) ;   private volatile boolean  shutdown ;   private volatile  long  shutdownStartTimeMillis ;   private volatile boolean  shutdownComplete = false ;   private final Object  lock =  new Object  ( ) ;   private  Future  < Boolean >  gracefulShutdownFuture ;    @ VisibleForTesting protected boolean  gracefuleShutdownStarted = false ;   public Scheduler  (    @ NonNull final CheckpointConfig checkpointConfig ,    @ NonNull final CoordinatorConfig coordinatorConfig ,    @ NonNull final LeaseManagementConfig leaseManagementConfig ,    @ NonNull final LifecycleConfig lifecycleConfig ,    @ NonNull final MetricsConfig metricsConfig ,    @ NonNull final ProcessorConfig processorConfig ,    @ NonNull final RetrievalConfig retrievalConfig )  {    this . checkpointConfig = checkpointConfig ;    this . coordinatorConfig = coordinatorConfig ;    this . leaseManagementConfig = leaseManagementConfig ;    this . lifecycleConfig = lifecycleConfig ;    this . metricsConfig = metricsConfig ;    this . processorConfig = processorConfig ;    this . retrievalConfig = retrievalConfig ;    this . applicationName =   this . coordinatorConfig . applicationName  ( ) ;    this . maxInitializationAttempts =   this . coordinatorConfig . maxInitializationAttempts  ( ) ;    this . metricsFactory =   this . metricsConfig . metricsFactory  ( ) ;    this . leaseCoordinator =    this . leaseManagementConfig . leaseManagementFactory  ( ) . createLeaseCoordinator  (  this . metricsFactory ) ;    this . leaseRefresher =   this . leaseCoordinator . leaseRefresher  ( ) ;    this . checkpoint =    this . checkpointConfig . checkpointFactory  ( ) . createCheckpointer  (  this . leaseCoordinator ,  this . leaseRefresher ) ;    this . shardConsumerDispatchPollIntervalMillis =   this . coordinatorConfig . shardConsumerDispatchPollIntervalMillis  ( ) ;    this . parentShardPollIntervalMillis =   this . coordinatorConfig . parentShardPollIntervalMillis  ( ) ;    this . executorService =    this . coordinatorConfig . coordinatorFactory  ( ) . createExecutorService  ( ) ;    this . shardSyncTaskManager =    this . leaseManagementConfig . leaseManagementFactory  ( ) . createShardSyncTaskManager  (  this . metricsFactory ) ;    this . shardPrioritization =   this . coordinatorConfig . shardPrioritization  ( ) ;    this . cleanupLeasesUponShardCompletion =   this . leaseManagementConfig . cleanupLeasesUponShardCompletion  ( ) ;    this . skipShardSyncAtWorkerInitializationIfLeasesExist =   this . coordinatorConfig . skipShardSyncAtWorkerInitializationIfLeasesExist  ( ) ;  if  (   coordinatorConfig . gracefulShutdownCoordinator  ( ) != null )  {    this . gracefulShutdownCoordinator =  coordinatorConfig . gracefulShutdownCoordinator  ( ) ; } else  {    this . gracefulShutdownCoordinator =    this . coordinatorConfig . coordinatorFactory  ( ) . createGracefulShutdownCoordinator  ( ) ; }  if  (   coordinatorConfig . workerStateChangeListener  ( ) != null )  {    this . workerStateChangeListener =  coordinatorConfig . workerStateChangeListener  ( ) ; } else  {    this . workerStateChangeListener =    this . coordinatorConfig . coordinatorFactory  ( ) . createWorkerStateChangeListener  ( ) ; }    this . initialPosition =  retrievalConfig . initialPositionInStreamExtended  ( ) ;    this . failoverTimeMillis =   this . leaseManagementConfig . failoverTimeMillis  ( ) ;    this . taskBackoffTimeMillis =   this . lifecycleConfig . taskBackoffTimeMillis  ( ) ;    this . streamName =   this . retrievalConfig . streamName  ( ) ;    this . listShardsBackoffTimeMillis =   this . retrievalConfig . listShardsBackoffTimeInMillis  ( ) ;    this . maxListShardsRetryAttempts =   this . retrievalConfig . maxListShardsRetryAttempts  ( ) ;    this . shardDetector =   this . shardSyncTaskManager . shardDetector  ( ) ;    this . ignoreUnexpetedChildShards =   this . leaseManagementConfig . ignoreUnexpectedChildShards  ( ) ;    this . aggregatorUtil =   this . lifecycleConfig . aggregatorUtil  ( ) ;    this . hierarchicalShardSyncer =  leaseManagementConfig . hierarchicalShardSyncer  ( ) ; }    @ Override public void run  ( )  {  if  ( shutdown )  {  return ; }  try  {   initialize  ( ) ;   log . info  ( "Initialization complete. Starting worker loop." ) ; }  catch (   RuntimeException e )  {   log . error  ( "Unable to initialize after {} attempts. Shutting down." , maxInitializationAttempts , e ) ;   workerStateChangeListener . onAllInitializationAttemptsFailed  ( e ) ;   shutdown  ( ) ; }  while  (  !  shouldShutdown  ( ) )  {   runProcessLoop  ( ) ; }   finalShutdown  ( ) ;   log . info  ( "Worker loop is complete. Exiting from worker." ) ; }   private void initialize  ( )  {  synchronized  ( lock )  {   workerStateChangeListener . onWorkerStateChange  (   WorkerStateChangeListener . WorkerState . INITIALIZING ) ;  boolean  isDone = false ;  Exception  lastException = null ;  for (   int  i = 0 ;   (  ! isDone ) &&  (  i < maxInitializationAttempts ) ;  i ++ )  {  try  {   log . info  ( "Initialization attempt {}" ,  (  i + 1 ) ) ;   log . info  ( "Initializing LeaseCoordinator" ) ;   leaseCoordinator . initialize  ( ) ;  TaskResult  result = null ;  if  (   ! skipShardSyncAtWorkerInitializationIfLeasesExist ||  leaseRefresher . isLeaseTableEmpty  ( ) )  {   log . info  ( "Syncing Kinesis shard info" ) ;  ShardSyncTask  shardSyncTask =  new ShardSyncTask  ( shardDetector , leaseRefresher , initialPosition , cleanupLeasesUponShardCompletion , ignoreUnexpetedChildShards , 0L , hierarchicalShardSyncer , metricsFactory ) ;   result =   new MetricsCollectingTaskDecorator  ( shardSyncTask , metricsFactory ) . call  ( ) ; } else  {   log . info  ( "Skipping shard sync per configuration setting (and lease table is not empty)" ) ; }  if  (   result == null ||   result . getException  ( ) == null )  {  if  (  !  leaseCoordinator . isRunning  ( ) )  {   log . info  ( "Starting LeaseCoordinator" ) ;   leaseCoordinator . start  ( ) ; } else  {   log . info  ( "LeaseCoordinator is already running. No need to start it." ) ; }   isDone = true ; } else  {   lastException =  result . getException  ( ) ; } }  catch (   LeasingException e )  {   log . error  ( "Caught exception when initializing LeaseCoordinator" , e ) ;   lastException = e ; }  catch (   Exception e )  {   lastException = e ; }  try  {   Thread . sleep  ( parentShardPollIntervalMillis ) ; }  catch (   InterruptedException e )  {   log . debug  ( "Sleep interrupted while initializing worker." ) ; } }  if  (  ! isDone )  {  throw  new RuntimeException  ( lastException ) ; }   workerStateChangeListener . onWorkerStateChange  (   WorkerStateChangeListener . WorkerState . STARTED ) ; } }    @ VisibleForTesting void runProcessLoop  ( )  {  try  {  boolean  foundCompletedShard = false ;   Set  < ShardInfo >  assignedShards =  new  HashSet  < >  ( ) ;  for ( ShardInfo shardInfo :  getShardInfoForAssignments  ( ) )  {  ShardConsumer  shardConsumer =  createOrGetShardConsumer  ( shardInfo ,  processorConfig . shardRecordProcessorFactory  ( ) ) ;  if  (   shardConsumer . isShutdown  ( ) &&   shardConsumer . shutdownReason  ( ) . equals  (  ShutdownReason . SHARD_END ) )  {   foundCompletedShard = true ; } else  {   shardConsumer . executeLifecycle  ( ) ; }   assignedShards . add  ( shardInfo ) ; }  if  ( foundCompletedShard )  {   shardSyncTaskManager . syncShardAndLeaseInfo  ( ) ; }   cleanupShardConsumers  ( assignedShards ) ;   slog . info  ( "Sleeping ..." ) ;   Thread . sleep  ( shardConsumerDispatchPollIntervalMillis ) ; }  catch (   Exception e )  {   log . error  ( "Worker.run caught exception, sleeping for {} milli seconds!" ,  String . valueOf  ( shardConsumerDispatchPollIntervalMillis ) , e ) ;  try  {   Thread . sleep  ( shardConsumerDispatchPollIntervalMillis ) ; }  catch (   InterruptedException ex )  {   log . info  ( "Worker: sleep interrupted after catching exception " , ex ) ; } }   slog . resetInfoLogging  ( ) ; }    @ VisibleForTesting boolean shouldShutdown  ( )  {  if  (  executorService . isShutdown  ( ) )  {   log . error  ( "Worker executor service has been shutdown, so record processors cannot be shutdown." ) ;  return true ; }  if  ( shutdown )  {  if  (  shardInfoShardConsumerMap . isEmpty  ( ) )  {   log . info  ( "All record processors have been shutdown successfully." ) ;  return true ; }  if  (   (   System . currentTimeMillis  ( ) - shutdownStartTimeMillis ) >= failoverTimeMillis )  {   log . info  ( "Lease failover time is reached, so forcing shutdown." ) ;  return true ; } }  return false ; }   public  Future  < Boolean > startGracefulShutdown  ( )  {  synchronized  ( this )  {  if  (  gracefulShutdownFuture == null )  {   gracefulShutdownFuture =  gracefulShutdownCoordinator . startGracefulShutdown  (  createGracefulShutdownCallable  ( ) ) ; } }  return gracefulShutdownFuture ; }   public  Callable  < Boolean > createGracefulShutdownCallable  ( )  {  if  (  shutdownComplete  ( ) )  {  return   ( ) -> true ; }   Callable  < GracefulShutdownContext >  startShutdown =  createWorkerShutdownCallable  ( ) ;  return  gracefulShutdownCoordinator . createGracefulShutdownCallable  ( startShutdown ) ; }   public boolean hasGracefulShutdownStarted  ( )  {  return gracefuleShutdownStarted ; }    @ VisibleForTesting  Callable  < GracefulShutdownContext > createWorkerShutdownCallable  ( )  {  return   ( ) ->  {  synchronized  ( this )  {  if  (  this . gracefuleShutdownStarted )  {  throw  new IllegalStateException  ( "Requested shutdown has already been started" ) ; }    this . gracefuleShutdownStarted = true ; }   leaseCoordinator . stopLeaseTaker  ( ) ;   Collection  < Lease >  leases =  leaseCoordinator . getAssignments  ( ) ;  if  (   leases == null ||  leases . isEmpty  ( ) )  {   this . shutdown  ( ) ;  return  GracefulShutdownContext . SHUTDOWN_ALREADY_COMPLETED ; }  CountDownLatch  shutdownCompleteLatch =  new CountDownLatch  (  leases . size  ( ) ) ;  CountDownLatch  notificationCompleteLatch =  new CountDownLatch  (  leases . size  ( ) ) ;  for ( Lease lease : leases )  {  ShutdownNotification  shutdownNotification =  new ShardConsumerShutdownNotification  ( leaseCoordinator , lease , notificationCompleteLatch , shutdownCompleteLatch ) ;  ShardInfo  shardInfo =  DynamoDBLeaseCoordinator . convertLeaseToAssignment  ( lease ) ;  ShardConsumer  consumer =  shardInfoShardConsumerMap . get  ( shardInfo ) ;  if  (  consumer != null )  {   consumer . gracefulShutdown  ( shutdownNotification ) ; } else  {   notificationCompleteLatch . countDown  ( ) ;   shutdownCompleteLatch . countDown  ( ) ; } }  return  new GracefulShutdownContext  ( shutdownCompleteLatch , notificationCompleteLatch , this ) ; } ; }   public void shutdown  ( )  {  synchronized  ( lock )  {  if  ( shutdown )  {   log . warn  ( "Shutdown requested a second time." ) ;  return ; }   workerStateChangeListener . onWorkerStateChange  (   WorkerStateChangeListener . WorkerState . SHUT_DOWN_STARTED ) ;   log . info  ( "Worker shutdown requested." ) ;   shutdown = true ;   shutdownStartTimeMillis =  System . currentTimeMillis  ( ) ;   leaseCoordinator . stop  ( ) ;   workerStateChangeListener . onWorkerStateChange  (   WorkerStateChangeListener . WorkerState . SHUT_DOWN ) ; } }   private void finalShutdown  ( )  {   log . info  ( "Starting worker's final shutdown." ) ;  if  (  executorService instanceof  SchedulerCoordinatorFactory . SchedulerThreadPoolExecutor )  {   executorService . shutdownNow  ( ) ; }  if  (  metricsFactory instanceof CloudWatchMetricsFactory )  {    (  ( CloudWatchMetricsFactory ) metricsFactory ) . shutdown  ( ) ; }   shutdownComplete = true ; }   private  List  < ShardInfo > getShardInfoForAssignments  ( )  {   List  < ShardInfo >  assignedStreamShards =  leaseCoordinator . getCurrentAssignments  ( ) ;   List  < ShardInfo >  prioritizedShards =  shardPrioritization . prioritize  ( assignedStreamShards ) ;  if  (   (  prioritizedShards != null ) &&  (  !  prioritizedShards . isEmpty  ( ) ) )  {  if  (  slog . isInfoEnabled  ( ) )  {  StringBuilder  builder =  new StringBuilder  ( ) ;  boolean  firstItem = true ;  for ( ShardInfo shardInfo : prioritizedShards )  {  if  (  ! firstItem )  {   builder . append  ( ", " ) ; }   builder . append  (  shardInfo . shardId  ( ) ) ;   firstItem = false ; }   slog . info  (  "Current stream shard assignments: " +  builder . toString  ( ) ) ; } } else  {   slog . info  ( "No activities assigned" ) ; }  return prioritizedShards ; }  ShardConsumer createOrGetShardConsumer  (    @ NonNull final ShardInfo shardInfo ,    @ NonNull final ShardRecordProcessorFactory shardRecordProcessorFactory )  {  ShardConsumer  consumer =  shardInfoShardConsumerMap . get  ( shardInfo ) ;  if  (   (  consumer == null ) ||  (   consumer . isShutdown  ( ) &&   consumer . shutdownReason  ( ) . equals  (  ShutdownReason . LEASE_LOST ) ) )  {   consumer =  buildConsumer  ( shardInfo , shardRecordProcessorFactory ) ;   shardInfoShardConsumerMap . put  ( shardInfo , consumer ) ;   slog . infoForce  (  "Created new shardConsumer for : " + shardInfo ) ; }  return consumer ; }   protected ShardConsumer buildConsumer  (    @ NonNull final ShardInfo shardInfo ,    @ NonNull final ShardRecordProcessorFactory shardRecordProcessorFactory )  {  RecordsPublisher  cache =   retrievalConfig . retrievalFactory  ( ) . createGetRecordsCache  ( shardInfo , metricsFactory ) ;  ShardRecordProcessorCheckpointer  checkpointer =   coordinatorConfig . coordinatorFactory  ( ) . createRecordProcessorCheckpointer  ( shardInfo , checkpoint ) ;  ShardConsumerArgument  argument =  new ShardConsumerArgument  ( shardInfo , streamName , leaseRefresher , executorService , cache ,  shardRecordProcessorFactory . shardRecordProcessor  ( ) , checkpoint , checkpointer , parentShardPollIntervalMillis , taskBackoffTimeMillis , skipShardSyncAtWorkerInitializationIfLeasesExist , listShardsBackoffTimeMillis , maxListShardsRetryAttempts ,  processorConfig . callProcessRecordsEvenForEmptyRecordList  ( ) , shardConsumerDispatchPollIntervalMillis , initialPosition , cleanupLeasesUponShardCompletion , ignoreUnexpetedChildShards , shardDetector , aggregatorUtil , hierarchicalShardSyncer , metricsFactory ) ;  return  new ShardConsumer  ( cache , executorService , shardInfo ,  lifecycleConfig . logWarningForTaskAfterMillis  ( ) , argument ,  lifecycleConfig . taskExecutionListener  ( ) ,  lifecycleConfig . readTimeoutsToIgnoreBeforeWarning  ( ) ) ; }  void cleanupShardConsumers  (   Set  < ShardInfo > assignedShards )  {  for ( ShardInfo shard :  shardInfoShardConsumerMap . keySet  ( ) )  {  if  (  !  assignedShards . contains  ( shard ) )  {  ShardConsumer  consumer =  shardInfoShardConsumerMap . get  ( shard ) ;  if  (  consumer . leaseLost  ( ) )  {   shardInfoShardConsumerMap . remove  ( shard ) ;   log . debug  ( "Removed consumer for {} as lease has been lost" ,  shard . shardId  ( ) ) ; } else  {   consumer . executeLifecycle  ( ) ; } } } }    @ NoArgsConstructor  (  access =  AccessLevel . PRIVATE ) private static class SchedulerLog  {   private  long  reportIntervalMillis =   TimeUnit . MINUTES . toMillis  ( 1 ) ;   private  long  nextReportTime =   System . currentTimeMillis  ( ) + reportIntervalMillis ;   private boolean  infoReporting ;  void info  (  Object message )  {  if  (  this . isInfoEnabled  ( ) )  {   log . info  ( "{}" , message ) ; } }  void infoForce  (  Object message )  {   log . info  ( "{}" , message ) ; }   private boolean isInfoEnabled  ( )  {  return infoReporting ; }   private void resetInfoLogging  ( )  {  if  ( infoReporting )  {  if  (  log . isInfoEnabled  ( ) )  {   infoReporting = false ;   nextReportTime =   System . currentTimeMillis  ( ) + reportIntervalMillis ; } } else  if  (  nextReportTime <=  System . currentTimeMillis  ( ) )  {   infoReporting = true ; } } }    @ Deprecated public  Future  < Void > requestShutdown  ( )  {  return null ; } }