  package   org . hdiv . filter ;   import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . Enumeration ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . Map ;  import   java . util . Set ;  import   java . util . StringTokenizer ;  import   java . util . Vector ;  import   javax . servlet . AsyncContext ;  import   javax . servlet . ServletRequest ;  import   javax . servlet . ServletResponse ;  import    javax . servlet . http . HttpServletRequest ;  import    javax . servlet . http . HttpServletRequestWrapper ;  import     org . apache . commons . logging . Log ;  import     org . apache . commons . logging . LogFactory ;  import    org . hdiv . util . Constants ;  import    org . hdiv . context . RequestContext ;  import    org . hdiv . session . ISession ;  import    org . springframework . util . Assert ;   public class RequestWrapper  extends HttpServletRequestWrapper  {   private static final Log  log =  LogFactory . getLog  (  RequestWrapper . class ) ;   protected static final String  COOKIE = "cookie" ;   protected  Set  < String >  editableParameters =  new  HashSet  < String >  ( ) ;   protected  Map  < String ,  String  [ ] >  parameters =  new  HashMap  < String ,  String  [ ] >  ( ) ;   protected  Map  < String , Object >  elementsFile =  new  HashMap  < String , Object >  ( ) ;   protected  Map  < String , Object >  elementsText =  new  HashMap  < String , Object >  ( ) ;   protected boolean  isMultipart = false ;   protected boolean  confidentiality = true ;   protected boolean  cookiesConfidentiality ;   protected boolean  isAsyncRequest = false ;   public RequestWrapper  (   final HttpServletRequest servletRequest )  {  super  ( servletRequest ) ;   Assert . notNull  ( servletRequest ) ;  if  (  log . isDebugEnabled  ( ) )  {   log . debug  ( "New RequestWrapper instance." ) ; } }    @ Override public  String  [ ] getParameterValues  (   final String parameter )  {  if  (  !  parameters . containsKey  ( parameter ) )  {  return  super . getParameterValues  ( parameter ) ; }  Object  data =  parameters . get  ( parameter ) ;  if  (   data . getClass  ( ) . isArray  ( ) )  {  return  (  String  [ ] ) data ; } else  {   String  [ ]  array =  parameters . get  ( parameter ) ;  return array ; } }    @ Override public String getParameter  (   final String parameter )  {  if  (  !  parameters . containsKey  ( parameter ) )  {  return  super . getParameter  ( parameter ) ; }  Object  data =  parameters . get  ( parameter ) ;  if  (   data . getClass  ( ) . isArray  ( ) )  {   String  [ ]  array =  (  String  [ ] ) data ;  return  array [ 0 ] ; } else  {   String  [ ]  values =  parameters . get  ( parameter ) ;  return    values . length > 0 ?  values [ 0 ] : null ; } }    @ Override public  Enumeration  < String > getParameterNames  ( )  {   Enumeration  < String >  baseParams =  super . getParameterNames  ( ) ;  if  (  ! isMultipart )  {  return baseParams ; }   Vector  < String >  list =  new  Vector  < String >  ( ) ;  while  (  baseParams . hasMoreElements  ( ) )  {   list . add  (  baseParams . nextElement  ( ) ) ; }   Collection  < String >  multipartParams =  parameters . keySet  ( ) ;   list . addAll  ( multipartParams ) ;  return  Collections . enumeration  ( list ) ; }    @ Override  @ SuppressWarnings  ( "unchecked" ) public String getHeader  (   final String name )  {  String  cookieHeader =  super . getHeader  ( name ) ;  if  (    name . equalsIgnoreCase  ( COOKIE ) && confidentiality && cookiesConfidentiality )  {   Map  < String , SavedCookie >  sessionCookies =  session . getAttribute  ( requestContext ,  Constants . HDIV_COOKIES_KEY ,  Map . class ) ;  if  (  sessionCookies != null )  {  return  replaceCookieString  ( cookieHeader , sessionCookies ) ; } }  return cookieHeader ; }    @ Override  @ SuppressWarnings  ( "unchecked" ) public  Enumeration  < String > getHeaders  (   final String name )  {   Enumeration  < String >  headerValues =  super . getHeaders  ( name ) ;  if  (    name . equalsIgnoreCase  ( COOKIE ) && confidentiality && cookiesConfidentiality )  {   Vector  < String >  values =  new  Vector  < String >  ( ) ;   Map  < String , SavedCookie >  sessionCookies =  session . getAttribute  ( requestContext ,  Constants . HDIV_COOKIES_KEY ,  Map . class ) ;  if  (  sessionCookies != null )  {  while  (  headerValues . hasMoreElements  ( ) )  {  String  element =  headerValues . nextElement  ( ) ;  String  replaced =  replaceCookieString  ( element , sessionCookies ) ;   values . add  ( replaced ) ; } } else  {  return headerValues ; }  return  values . elements  ( ) ; }  return headerValues ; }   protected String replaceCookieString  (   final String cookieHeader ,   final  Map  < String , SavedCookie > sessionCookies )  {  String  header =  cookieHeader . trim  ( ) ;  StringTokenizer  tokens =  new StringTokenizer  ( cookieHeader , ";" ) ;  while  (  tokens . hasMoreTokens  ( ) )  {  StringTokenizer  t =  new StringTokenizer  (  tokens . nextToken  ( ) , "=" ) ;  String  name =   t . nextToken  ( ) . trim  ( ) ;  if  (  name . equals  (  Constants . JSESSIONID ) )  {  continue ; }  if  (  sessionCookies . containsKey  ( name ) )  {  if  (  t . hasMoreTokens  ( ) )  {  String  value =   t . nextToken  ( ) . trim  ( ) ;  SavedCookie  savedCookie =  sessionCookies . get  ( name ) ;   header =  header . replaceFirst  (  "=" + value ,  "=" +  savedCookie . getValue  ( ) ) ; } } }  return header ; }   public void addParameter  (   final String name ,   final  String  [ ] value )  {   parameters . put  ( name , value ) ;  if  ( isMultipart )  {   addTextParameter  ( name , value ) ; } }    @ Override public  Map  < String ,  String  [ ] > getParameterMap  ( )  {   Map  < String ,  String  [ ] >  map =  new  HashMap  < String ,  String  [ ] >  (   super . getRequest  ( ) . getParameterMap  ( ) ) ;   map . putAll  ( parameters ) ;  return map ; }    @ Override public AsyncContext startAsync  ( )  throws IllegalStateException  {   isAsyncRequest = true ;  return  super . startAsync  ( ) ; }    @ Override public AsyncContext startAsync  (   final ServletRequest servletRequest ,   final ServletResponse servletResponse )  throws IllegalStateException  {   isAsyncRequest = true ;  return  super . startAsync  ( servletRequest , servletResponse ) ; }   public  Map  < String , Object > getTextElements  ( )  {  return elementsText ; }   public  Map  < String , Object > getFileElements  ( )  {  return elementsFile ; }   public void addTextParameter  (   final String name ,   final Object value )  {   elementsText . put  ( name , value ) ; }   public void addFileItem  (   final String name ,   final Object values )  {   elementsFile . put  ( name , values ) ; }   public void addEditableParameter  (   final String parameter )  {   editableParameters . add  ( parameter ) ; }   public boolean isEditableParameter  (   final String parameter )  {  return  editableParameters . contains  ( parameter ) ; }   public boolean isAsyncRequest  ( )  {  return isAsyncRequest ; }   public void setMultipart  (   final boolean isMultipart )  {    this . isMultipart = isMultipart ; }   public void setCookiesConfidentiality  (   final boolean cookiesConfidentiality )  {    this . cookiesConfidentiality = cookiesConfidentiality ; }   public void setConfidentiality  (   final boolean confidentiality )  {    this . confidentiality = confidentiality ; }   protected ISession  session ;   protected RequestContext  requestContext =  new RequestContext  ( this ) ;   public void setSession  (   final ISession session )  {    this . session = session ; } }