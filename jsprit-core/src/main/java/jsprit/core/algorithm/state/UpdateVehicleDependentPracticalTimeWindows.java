  package    jsprit . core . algorithm . state ;   import    jsprit . core . problem . Location ;  import     jsprit . core . problem . cost . VehicleRoutingTransportCosts ;  import      jsprit . core . problem . solution . route . VehicleRoute ;  import       jsprit . core . problem . solution . route . activity . TourActivity ;  import     jsprit . core . problem . vehicle . Vehicle ;  import   java . util . Arrays ;  import   java . util . Collection ;  import      jsprit . core . problem . solution . route . RouteVisitor ;  import   java . util . Iterator ;   public class UpdateVehicleDependentPracticalTimeWindows  implements  RouteVisitor , StateUpdater  {   public static interface VehiclesToUpdate  {   public  Collection  < Vehicle > get  (  VehicleRoute route ) ; }   private VehiclesToUpdate  vehiclesToUpdate =  new VehiclesToUpdate  ( )  {    @ Override public  Collection  < Vehicle > get  (  VehicleRoute route )  {  return  Arrays . asList  (  route . getVehicle  ( ) ) ; } } ;   private final StateManager  stateManager ;   private final VehicleRoutingTransportCosts  transportCosts ;   private VehicleRoute  route ;   private   double  [ ]  latest_arrTimes_at_prevAct ;   private  Location  [ ]  location_of_prevAct ;   private  Collection  < Vehicle >  vehicles ;   public UpdateVehicleDependentPracticalTimeWindows  (  StateManager stateManager ,  VehicleRoutingTransportCosts tpCosts )  {  super  ( ) ;    this . stateManager = stateManager ;    this . transportCosts = tpCosts ;   latest_arrTimes_at_prevAct =  new  double  [   stateManager . getMaxIndexOfVehicleTypeIdentifiers  ( ) + 1 ] ;   location_of_prevAct =  new Location  [   stateManager . getMaxIndexOfVehicleTypeIdentifiers  ( ) + 1 ] ; }   public void setVehiclesToUpdate  (  VehiclesToUpdate vehiclesToUpdate )  {    this . vehiclesToUpdate = vehiclesToUpdate ; }   public void begin  (  VehicleRoute route )  {    this . route = route ;   vehicles =  vehiclesToUpdate . get  ( route ) ;  for ( Vehicle vehicle : vehicles )  {    latest_arrTimes_at_prevAct [   vehicle . getVehicleTypeIdentifier  ( ) . getIndex  ( ) ] =  vehicle . getLatestArrival  ( ) ;    location_of_prevAct [   vehicle . getVehicleTypeIdentifier  ( ) . getIndex  ( ) ] =  vehicle . getEndLocation  ( ) ; } }   public void visit  (  TourActivity activity )  {  for ( Vehicle vehicle : vehicles )  {   double  latestArrTimeAtPrevAct =  latest_arrTimes_at_prevAct [   vehicle . getVehicleTypeIdentifier  ( ) . getIndex  ( ) ] ;  Location  prevLocation =  location_of_prevAct [   vehicle . getVehicleTypeIdentifier  ( ) . getIndex  ( ) ] ;   double  potentialLatestArrivalTimeAtCurrAct =   latestArrTimeAtPrevAct -  transportCosts . getBackwardTransportTime  (  activity . getLocation  ( ) , prevLocation , latestArrTimeAtPrevAct ,  route . getDriver  ( ) , vehicle ) -  activity . getOperationTime  ( ) ;   double  latestArrivalTime =  Math . min  (  activity . getTheoreticalLatestOperationStartTime  ( ) , potentialLatestArrivalTimeAtCurrAct ) ;   stateManager . putInternalTypedActivityState  ( activity , vehicle ,  InternalStates . LATEST_OPERATION_START_TIME , latestArrivalTime ) ;    latest_arrTimes_at_prevAct [   vehicle . getVehicleTypeIdentifier  ( ) . getIndex  ( ) ] = latestArrivalTime ;    location_of_prevAct [   vehicle . getVehicleTypeIdentifier  ( ) . getIndex  ( ) ] =  activity . getLocation  ( ) ; } }   public void finish  ( )  { }    @ Override public void visit  (  VehicleRoute route )  {   begin  ( route ) ;   Iterator  < TourActivity >  revIterator =   route . getTourActivities  ( ) . reverseActivityIterator  ( ) ;  while  (  revIterator . hasNext  ( ) )  {   visit  (  revIterator . next  ( ) ) ; }   finish  ( ) ; } }