  package    jsprit . core . algorithm . recreate ;   import      jsprit . core . algorithm . recreate . InsertionData . NoInsertionFound ;  import    jsprit . core . problem . VehicleRoutingProblem ;  import     jsprit . core . problem . driver . Driver ;  import     jsprit . core . problem . job . Job ;  import      jsprit . core . problem . solution . route . VehicleRoute ;  import     jsprit . core . problem . vehicle . Vehicle ;  import     jsprit . core . problem . vehicle . VehicleFleetManager ;  import      jsprit . core . problem . vehicle . VehicleImpl . NoVehicle ;  import     org . apache . logging . log4j . LogManager ;  import     org . apache . logging . log4j . Logger ;  import   java . util . ArrayList ;  import   java . util . Collection ;  import   java . util . HashSet ;  import   java . util . Set ;   final class VehicleTypeDependentJobInsertionCalculator  implements  JobInsertionCostsCalculator  {   private Logger  logger =  LogManager . getLogger  (  VehicleTypeDependentJobInsertionCalculator . class ) ;   private final VehicleFleetManager  fleetManager ;   private final JobInsertionCostsCalculator  insertionCalculator ;   private final VehicleRoutingProblem  vrp ;   private  Set  < String >  initialVehicleIds =  new  HashSet  < String >  ( ) ;   private boolean  vehicleSwitchAllowed = false ;   public VehicleTypeDependentJobInsertionCalculator  (   final VehicleRoutingProblem vrp ,   final VehicleFleetManager fleetManager ,   final JobInsertionCostsCalculator jobInsertionCalc )  {    this . fleetManager = fleetManager ;    this . insertionCalculator = jobInsertionCalc ;    this . vrp = vrp ;   getInitialVehicleIds  ( ) ;   logger . debug  ( "initialise {}" , this ) ; }   private void getInitialVehicleIds  ( )  {   Collection  < VehicleRoute >  initialVehicleRoutes =  vrp . getInitialVehicleRoutes  ( ) ;  for ( VehicleRoute initialRoute : initialVehicleRoutes )  {   initialVehicleIds . add  (   initialRoute . getVehicle  ( ) . getId  ( ) ) ; } }    @ Override public String toString  ( )  {  return "[name=vehicleTypeDependentServiceInsertion]" ; }    @ SuppressWarnings  ( "UnusedDeclaration" ) public boolean isVehicleSwitchAllowed  ( )  {  return vehicleSwitchAllowed ; }   public void setVehicleSwitchAllowed  (  boolean vehicleSwitchAllowed )  {   logger . debug  ( "set vehicleSwitchAllowed to {}" , vehicleSwitchAllowed ) ;    this . vehicleSwitchAllowed = vehicleSwitchAllowed ; }   public InsertionData getInsertionData  (   final VehicleRoute currentRoute ,   final Job jobToInsert ,   final Vehicle vehicle ,   double newVehicleDepartureTime ,   final Driver driver ,   final  double bestKnownCost )  {  Vehicle  selectedVehicle =  currentRoute . getVehicle  ( ) ;  Driver  selectedDriver =  currentRoute . getDriver  ( ) ;  InsertionData  bestIData =  InsertionData . createEmptyInsertionData  ( ) ;   double  bestKnownCost_ = bestKnownCost ;   Collection  < Vehicle >  relevantVehicles =  new  ArrayList  < Vehicle >  ( ) ;  if  (  !  (  selectedVehicle instanceof NoVehicle ) )  {   relevantVehicles . add  ( selectedVehicle ) ;  if  (  vehicleSwitchAllowed &&  !  isVehicleWithInitialRoute  ( selectedVehicle ) )  {   relevantVehicles . addAll  (  fleetManager . getAvailableVehicles  ( selectedVehicle ) ) ; } } else  {   relevantVehicles . addAll  (  fleetManager . getAvailableVehicles  ( ) ) ; }  for ( Vehicle v : relevantVehicles )  {   double  depTime =  v . getEarliestDeparture  ( ) ;  InsertionData  iData =  insertionCalculator . getInsertionData  ( currentRoute , jobToInsert , v , depTime , selectedDriver , bestKnownCost_ ) ;  if  (  iData instanceof NoInsertionFound )  {  continue ; }  if  (   iData . getInsertionCost  ( ) < bestKnownCost_ )  {   bestIData = iData ;   bestKnownCost_ =  iData . getInsertionCost  ( ) ; } }  return bestIData ; }   private boolean isVehicleWithInitialRoute  (  Vehicle selectedVehicle )  {  return  initialVehicleIds . contains  (  selectedVehicle . getId  ( ) ) ; } }