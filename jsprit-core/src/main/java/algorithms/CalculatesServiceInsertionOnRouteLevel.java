  package algorithms ;   import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Comparator ;  import   java . util . HashMap ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . PriorityQueue ;  import    org . apache . log4j . Logger ;  import  util . Neighborhood ;  import   algorithms . RouteStates . ActivityState ;  import  basics . Job ;  import  basics . Service ;  import   basics . costs . VehicleRoutingActivityCosts ;  import   basics . costs . VehicleRoutingTransportCosts ;  import   basics . route . Driver ;  import   basics . route . End ;  import   basics . route . ServiceActivity ;  import   basics . route . Start ;  import   basics . route . TourActivities ;  import   basics . route . TourActivity ;  import   basics . route . Vehicle ;  import   basics . route . VehicleRoute ;  import    basics . route . VehicleImpl . NoVehicle ;   final class CalculatesServiceInsertionOnRouteLevel  implements  JobInsertionCalculator  {   private static final Logger  logger =  Logger . getLogger  (  CalculatesServiceInsertionOnRouteLevel . class ) ;   private final VehicleRoutingTransportCosts  transportCosts ;   private final VehicleRoutingActivityCosts  activityCosts ;   private AuxilliaryCostCalculator  auxilliaryPathCostCalculator ;   private StateManager  states ;   private  int  nuOfActsForwardLooking = 0 ;   private  int  memorySize = 2 ;   private Start  start ;   private End  end ;   private Neighborhood  neighborhood =  new Neighborhood  ( )  {    @ Override public boolean areNeighbors  (  String location1 ,  String location2 )  {  return true ; } } ;   public void setNeighborhood  (  Neighborhood neighborhood )  {    this . neighborhood = neighborhood ;   logger . info  (  "initialise neighborhood " + neighborhood ) ; }   public void setMemorySize  (   int memorySize )  {    this . memorySize = memorySize ;   logger . info  (   "set [solutionMemory=" + memorySize + "]" ) ; }   public CalculatesServiceInsertionOnRouteLevel  (  VehicleRoutingTransportCosts vehicleRoutingCosts ,  VehicleRoutingActivityCosts costFunc )  {  super  ( ) ;    this . transportCosts = vehicleRoutingCosts ;    this . activityCosts = costFunc ;   auxilliaryPathCostCalculator =  new AuxilliaryCostCalculator  ( transportCosts , activityCosts ) ;   logger . info  (  "initialise " + this ) ; }   public void setStates  (  StatesContainer activityStates2 )  {    this . states = activityStates2 ; }  void setNuOfActsForwardLooking  (   int nOfActsForwardLooking )  {    this . nuOfActsForwardLooking = nOfActsForwardLooking ;   logger . info  (   "set [forwardLooking=" + nOfActsForwardLooking + "]" ) ; }    @ Override public String toString  ( )  {  return     "[name=calculatesServiceInsertionOnRouteLevel][solutionMemory=" + memorySize + "][forwardLooking=" + nuOfActsForwardLooking + "]" ; }    @ Override public InsertionData calculate  (   final VehicleRoute currentRoute ,   final Job jobToInsert ,   final Vehicle newVehicle ,   double newVehicleDepartureTime ,   final Driver newDriver ,   final  double best_known_insertion_costs )  {  if  (  jobToInsert == null )  throw  new IllegalStateException  ( "job is null. cannot calculate the insertion of a null-job." ) ;  if  (   newVehicle == null ||  newVehicle instanceof NoVehicle )  throw  new IllegalStateException  ( "no vehicle given. set para vehicle!" ) ;   Map  < TourActivity , Double >  activity2costWithNewVehicle =  new  HashMap  < TourActivity , Double >  ( ) ;   PriorityQueue  < InsertionData >  bestInsertionsQueue =  new  PriorityQueue  < InsertionData >  (  Math . max  ( 2 ,    currentRoute . getTourActivities  ( ) . getActivities  ( ) . size  ( ) ) ,  getComparator  ( ) ) ;  TourActivities  tour =  currentRoute . getTourActivities  ( ) ;   double  best_insertion_costs = best_known_insertion_costs ;  Service  service =  ( Service ) jobToInsert ;  if  (     states . getRouteState  ( currentRoute ,  StateTypes . LOAD ) . toDouble  ( ) +  service . getCapacityDemand  ( ) >  newVehicle . getCapacity  ( ) )  {  return  InsertionData . noInsertionFound  ( ) ; }  TourActivity  serviceAct2Insert =  ServiceActivity . newInstance  ( service ) ;   int  best_insertion_index =  InsertionData . NO_INDEX ;   initialiseStartAndEnd  ( newVehicle , newVehicleDepartureTime ) ;  TourActivity  prevAct = start ;   int  actIndex = 0 ;   double  sumOf_prevCosts_newVehicle = 0.0 ;   double  prevActDepTime_newVehicle =  start . getEndTime  ( ) ;  for ( TourActivity nextAct :  tour . getActivities  ( ) )  {  if  (   neighborhood . areNeighbors  (  serviceAct2Insert . getLocationId  ( ) ,  prevAct . getLocationId  ( ) ) &&  neighborhood . areNeighbors  (  serviceAct2Insert . getLocationId  ( ) ,  nextAct . getLocationId  ( ) ) )  {   List  < TourActivity >  path =  new  ArrayList  < TourActivity >  ( ) ;   path . add  ( prevAct ) ;   path . add  ( serviceAct2Insert ) ;   path . add  ( nextAct ) ;  if  (  nuOfActsForwardLooking > 0 )  {   path . addAll  (  getForwardLookingPath  ( currentRoute , actIndex ) ) ; }   double  forwardPathCost_newVehicle =  auxilliaryPathCostCalculator . costOfPath  ( path , prevActDepTime_newVehicle , newDriver , newVehicle ) ;   double  insertion_cost_approximation =   sumOf_prevCosts_newVehicle + forwardPathCost_newVehicle -  pathCost_oldVehicle  ( currentRoute , path ) ;  if  (  insertion_cost_approximation < best_known_insertion_costs )  {   bestInsertionsQueue . add  (  new InsertionData  ( insertion_cost_approximation ,  InsertionData . NO_INDEX , actIndex , newVehicle , newDriver ) ) ; } }   double  transportCost_prevAct_nextAct_newVehicle =  transportCosts . getTransportCost  (  prevAct . getLocationId  ( ) ,  nextAct . getLocationId  ( ) , prevActDepTime_newVehicle , newDriver , newVehicle ) ;   double  transportTime_prevAct_nextAct_newVehicle =  transportCosts . getTransportTime  (  prevAct . getLocationId  ( ) ,  nextAct . getLocationId  ( ) , prevActDepTime_newVehicle , newDriver , newVehicle ) ;   double  arrTime_nextAct_newVehicle =  prevActDepTime_newVehicle + transportTime_prevAct_nextAct_newVehicle ;   double  activityCost_nextAct =  activityCosts . getActivityCost  ( nextAct , arrTime_nextAct_newVehicle , newDriver , newVehicle ) ;   sumOf_prevCosts_newVehicle +=  transportCost_prevAct_nextAct_newVehicle + activityCost_nextAct ;   activity2costWithNewVehicle . put  ( nextAct , sumOf_prevCosts_newVehicle ) ;   double  depTime_nextAct_newVehicle =   Math . max  ( arrTime_nextAct_newVehicle ,  nextAct . getTheoreticalEarliestOperationStartTime  ( ) ) +  nextAct . getOperationTime  ( ) ;   prevAct = nextAct ;   prevActDepTime_newVehicle = depTime_nextAct_newVehicle ;   actIndex ++ ; }  End  nextAct = end ;  if  (   neighborhood . areNeighbors  (  serviceAct2Insert . getLocationId  ( ) ,  prevAct . getLocationId  ( ) ) &&  neighborhood . areNeighbors  (  serviceAct2Insert . getLocationId  ( ) ,  nextAct . getLocationId  ( ) ) )  {   List  < TourActivity >  path =  Arrays . asList  ( prevAct , serviceAct2Insert , end ) ;   double  forwardPathCost_newVehicle =  auxilliaryPathCostCalculator . costOfPath  ( path , prevActDepTime_newVehicle , newDriver , newVehicle ) ;   double  insertion_cost_approximation =   sumOf_prevCosts_newVehicle + forwardPathCost_newVehicle -  pathCost_oldVehicle  ( currentRoute , path ) ;  if  (  insertion_cost_approximation < best_known_insertion_costs )  {   bestInsertionsQueue . add  (  new InsertionData  ( insertion_cost_approximation ,  InsertionData . NO_INDEX , actIndex , newVehicle , newDriver ) ) ; } }  if  (  memorySize == 0 )  {  InsertionData  insertion =  bestInsertionsQueue . poll  ( ) ;  if  (  insertion != null )  {   best_insertion_index =  insertion . getDeliveryInsertionIndex  ( ) ;   best_insertion_costs =  insertion . getInsertionCost  ( ) ; } }  for (   int  i = 0 ;  i < memorySize ;  i ++ )  {  InsertionData  data =  bestInsertionsQueue . poll  ( ) ;  if  (  data == null )  {  continue ; }   List  < TourActivity >  wholeTour =  new  ArrayList  < TourActivity >  ( ) ;   wholeTour . add  ( start ) ;   wholeTour . addAll  (   currentRoute . getTourActivities  ( ) . getActivities  ( ) ) ;   wholeTour . add  ( end ) ;   wholeTour . add  (   data . getDeliveryInsertionIndex  ( ) + 1 , serviceAct2Insert ) ;   double  insertion_costs =   auxilliaryPathCostCalculator . costOfPath  ( wholeTour ,  start . getEndTime  ( ) , newDriver , newVehicle ) -   states . getRouteState  ( currentRoute ,  StateTypes . COSTS ) . toDouble  ( ) ;  if  (  insertion_costs < best_insertion_costs )  {   best_insertion_index =  data . getDeliveryInsertionIndex  ( ) ;   best_insertion_costs = insertion_costs ; } }  if  (  best_insertion_index ==  InsertionData . NO_INDEX )  return  InsertionData . noInsertionFound  ( ) ;  return  new InsertionData  ( best_insertion_costs ,  InsertionData . NO_INDEX , best_insertion_index , newVehicle , newDriver ) ; }   private void initialiseStartAndEnd  (   final Vehicle newVehicle ,   double newVehicleDepartureTime )  {  if  (  start == null )  {   start =  Start . newInstance  (  newVehicle . getLocationId  ( ) ,  newVehicle . getEarliestDeparture  ( ) ,  newVehicle . getLatestArrival  ( ) ) ;   start . setEndTime  ( newVehicleDepartureTime ) ; } else  {   start . setLocationId  (  newVehicle . getLocationId  ( ) ) ;   start . setTheoreticalEarliestOperationStartTime  (  newVehicle . getEarliestDeparture  ( ) ) ;   start . setTheoreticalLatestOperationStartTime  (  newVehicle . getLatestArrival  ( ) ) ;   start . setEndTime  ( newVehicleDepartureTime ) ; }  if  (  end == null )  {   end =  End . newInstance  (  newVehicle . getLocationId  ( ) , 0.0 ,  newVehicle . getLatestArrival  ( ) ) ; } else  {   end . setLocationId  (  newVehicle . getLocationId  ( ) ) ;   end . setTheoreticalEarliestOperationStartTime  ( newVehicleDepartureTime ) ;   end . setTheoreticalLatestOperationStartTime  (  newVehicle . getLatestArrival  ( ) ) ; } }   private  double pathCost_oldVehicle  (  VehicleRoute vehicleRoute ,   List  < TourActivity > path )  {  TourActivity  act =  path . get  (   path . size  ( ) - 1 ) ;  if  (  act instanceof End )  {  return   states . getRouteState  ( vehicleRoute ,  StateTypes . COSTS ) . toDouble  ( ) ; }  return   states . getActivityState  ( act ,  StateTypes . COSTS ) . toDouble  ( ) ; }   private  List  < TourActivity > getForwardLookingPath  (  VehicleRoute route ,   int actIndex )  {   List  < TourActivity >  forwardLookingPath =  new  ArrayList  < TourActivity >  ( ) ;   int  nuOfActsInPath = 0 ;   int  index =  actIndex + 1 ;  while  (   index <    route . getTourActivities  ( ) . getActivities  ( ) . size  ( ) &&  nuOfActsInPath < nuOfActsForwardLooking )  {   forwardLookingPath . add  (    route . getTourActivities  ( ) . getActivities  ( ) . get  ( index ) ) ;   index ++ ;   nuOfActsInPath ++ ; }  if  (  nuOfActsInPath < nuOfActsForwardLooking )  {   forwardLookingPath . add  (  route . getEnd  ( ) ) ; }  return forwardLookingPath ; }   private  Comparator  < InsertionData > getComparator  ( )  {  return  new  Comparator  < InsertionData >  ( )  {    @ Override public  int compare  (  InsertionData o1 ,  InsertionData o2 )  {  if  (   o1 . getInsertionCost  ( ) <  o2 . getInsertionCost  ( ) )  {  return  - 1 ; } else  {  return 1 ; } } } ; }   public void setActivityStates  (  StateManager activityStates2 )  {    this . states = activityStates2 ; } }