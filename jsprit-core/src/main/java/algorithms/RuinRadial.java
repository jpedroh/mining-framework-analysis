  package algorithms ;   import   java . util . ArrayList ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . Comparator ;  import   java . util . HashMap ;  import   java . util . Iterator ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Random ;  import   java . util . TreeSet ;  import    org . apache . log4j . Logger ;  import  util . RandomNumberGeneration ;  import  util . StopWatch ;  import  basics . Job ;  import  basics . VehicleRoutingProblem ;  import   basics . algo . RuinListener ;  import   basics . algo . RuinListeners ;  import   basics . route . VehicleRoute ;   final class RuinRadial  implements  RuinStrategy  {   static class ReferencedJob  {   private Job  job ;   private  double  distance ;   public ReferencedJob  (  Job job ,   double distance )  {  super  ( ) ;    this . job = job ;    this . distance = distance ; }   public Job getJob  ( )  {  return job ; }   public  double getDistance  ( )  {  return distance ; } }   private Logger  logger =  Logger . getLogger  (  RuinRadial . class ) ;   private VehicleRoutingProblem  vrp ;   private  double  fractionOfAllNodes2beRuined ;   private Random  random =  RandomNumberGeneration . getRandom  ( ) ;   private RuinListeners  ruinListeners ;   public void setRandom  (  Random random )  {    this . random = random ; }   public RuinRadial  (  VehicleRoutingProblem vrp ,   double fraction2beRemoved ,  JobDistance jobDistance )  {  super  ( ) ;    this . vrp = vrp ;    this . fractionOfAllNodes2beRuined = fraction2beRemoved ;   ruinListeners =  new RuinListeners  ( ) ;   int  nJobsToMemorize =  (  int )  Math . ceil  (     vrp . getJobs  ( ) . values  ( ) . size  ( ) * fraction2beRemoved ) ;  JobNeighborhoodsImplWithCapRestriction  jobNeighborhoodsImpl =  new JobNeighborhoodsImplWithCapRestriction  ( vrp , jobDistance , nJobsToMemorize ) ;   jobNeighborhoodsImpl . initialise  ( ) ;   jobNeighborhoods = jobNeighborhoodsImpl ;   logger . info  (  "intialise " + this ) ; } 
<<<<<<<
  private void calculateDistancesFromJob2Job  ( )  {   logger . info  ( "preprocess distances between locations ..." ) ;  StopWatch  stopWatch =  new StopWatch  ( ) ;   stopWatch . start  ( ) ;   int  nuOfDistancesStored = 0 ;  for ( Job i :   vrp . getJobs  ( ) . values  ( ) )  {   TreeSet  < ReferencedJob >  treeSet =  new  TreeSet  < ReferencedJob >  (  new  Comparator  < ReferencedJob >  ( )  {    @ Override public  int compare  (  ReferencedJob o1 ,  ReferencedJob o2 )  {  if  (   o1 . getDistance  ( ) <=  o2 . getDistance  ( ) )  {  return 1 ; } else  {  return  - 1 ; } } } ) ;   distanceNodeTree . put  (  i . getId  ( ) , treeSet ) ;  for ( Job j :   vrp . getJobs  ( ) . values  ( ) )  {   double  distance =  jobDistance . getDistance  ( i , j ) ;  ReferencedJob  refNode =  new ReferencedJob  ( j , distance ) ;   treeSet . add  ( refNode ) ;   nuOfDistancesStored ++ ; } }   stopWatch . stop  ( ) ;   logger . info  (       "preprocessing comp-time: " + stopWatch + "; nuOfDistances stored: " + nuOfDistancesStored + "; estimated memory: " +  (     distanceNodeTree . keySet  ( ) . size  ( ) * 64 +  nuOfDistancesStored * 92 ) + " bytes" ) ; }
=======
>>>>>>>
    @ Override public String toString  ( )  {  return   "[name=radialRuin][fraction=" + fractionOfAllNodes2beRuined + "]" ; }    @ Override public  Collection  < Job > ruin  (   Collection  < VehicleRoute > vehicleRoutes )  {  if  (  vehicleRoutes . isEmpty  ( ) )  {  return  Collections . emptyList  ( ) ; }   int  nOfJobs2BeRemoved =  getNuOfJobs2BeRemoved  ( ) ;  if  (  nOfJobs2BeRemoved == 0 )  {  return  Collections . emptyList  ( ) ; }  Job  randomJob =  pickRandomJob  ( ) ;   Collection  < Job >  unassignedJobs =  ruin  ( vehicleRoutes , randomJob , nOfJobs2BeRemoved ) ;  return unassignedJobs ; }   public  Collection  < Job > ruin  (   Collection  < VehicleRoute > vehicleRoutes ,  Job targetJob ,   int nOfJobs2BeRemoved )  {   ruinListeners . ruinStarts  ( vehicleRoutes ) ;   List  < Job >  unassignedJobs =  new  ArrayList  < Job >  ( ) ;   int  nNeighbors =  nOfJobs2BeRemoved - 1 ;   removeJob  ( targetJob , vehicleRoutes ) ;   unassignedJobs . add  ( targetJob ) ;   Iterator  < Job >  neighborhoodIterator =  jobNeighborhoods . getNearestNeighborsIterator  ( nNeighbors , targetJob ) ;  while  (  neighborhoodIterator . hasNext  ( ) )  {  Job  job =  neighborhoodIterator . next  ( ) ;   removeJob  ( job , vehicleRoutes ) ;   unassignedJobs . add  ( job ) ; }   ruinListeners . ruinEnds  ( vehicleRoutes , unassignedJobs ) ;  return unassignedJobs ; }   private Job pickRandomJob  ( )  {   int  totNuOfJobs =    vrp . getJobs  ( ) . values  ( ) . size  ( ) ;   int  randomIndex =  random . nextInt  ( totNuOfJobs ) ;  Job  job =   new  ArrayList  < Job >  (   vrp . getJobs  ( ) . values  ( ) ) . get  ( randomIndex ) ;  return job ; }   private  int getNuOfJobs2BeRemoved  ( )  {  return  (  int )  Math . ceil  (     vrp . getJobs  ( ) . values  ( ) . size  ( ) * fractionOfAllNodes2beRuined ) ; }    @ Override public void addListener  (  RuinListener ruinListener )  {   ruinListeners . addListener  ( ruinListener ) ; }    @ Override public void removeListener  (  RuinListener ruinListener )  {   ruinListeners . removeListener  ( ruinListener ) ; }    @ Override public  Collection  < RuinListener > getListeners  ( )  {  return  ruinListeners . getListeners  ( ) ; }   static interface JobNeighborhoods  {   public  Iterator  < Job > getNearestNeighborsIterator  (   int nNeighbors ,  Job neighborTo ) ; }   static class NeighborhoodIterator  implements   Iterator  < Job >  {   private static Logger  log =  Logger . getLogger  (  NeighborhoodIterator . class ) ;   private  Iterator  < ReferencedJob >  jobIter ;   private  int  nJobs ;   private  int  jobCount = 0 ;   public NeighborhoodIterator  (   Iterator  < ReferencedJob > jobIter ,   int nJobs )  {  super  ( ) ;    this . jobIter = jobIter ;    this . nJobs = nJobs ; }    @ Override public boolean hasNext  ( )  {  if  (  jobCount < nJobs )  {  boolean  hasNext =  jobIter . hasNext  ( ) ;  if  (  ! hasNext )   log . warn  ( "more jobs are requested then iterator can iterate over. probably the number of neighbors memorized in JobNeighborhoods is too small" ) ;  return hasNext ; }  return false ; }    @ Override public Job next  ( )  {  ReferencedJob  next =  jobIter . next  ( ) ;   jobCount ++ ;  return  next . getJob  ( ) ; }    @ Override public void remove  ( )  {   jobIter . remove  ( ) ; } }   static class JobNeighborhoodsImpl  implements  JobNeighborhoods  {   private static Logger  logger =  Logger . getLogger  (  JobNeighborhoodsImpl . class ) ;   private VehicleRoutingProblem  vrp ;   private  Map  < String ,  TreeSet  < ReferencedJob > >  distanceNodeTree =  new  HashMap  < String ,  TreeSet  < ReferencedJob > >  ( ) ;   private JobDistance  jobDistance ;   public JobNeighborhoodsImpl  (  VehicleRoutingProblem vrp ,  JobDistance jobDistance )  {  super  ( ) ;    this . vrp = vrp ;    this . jobDistance = jobDistance ;   logger . info  (  "intialise " + this ) ; }   public  Iterator  < Job > getNearestNeighborsIterator  (   int nNeighbors ,  Job neighborTo )  {   TreeSet  < ReferencedJob >  tree =  distanceNodeTree . get  (  neighborTo . getId  ( ) ) ;   Iterator  < ReferencedJob >  descendingIterator =  tree . iterator  ( ) ;  return  new NeighborhoodIterator  ( descendingIterator , nNeighbors ) ; }   public void initialise  ( )  {   logger . info  ( "calculates and memorizes distances from EACH job to EACH job --> n^2 calculations" ) ;   calculateDistancesFromJob2Job  ( ) ; }   private void calculateDistancesFromJob2Job  ( )  {   logger . info  ( "preprocess distances between locations ..." ) ;  StopWatch  stopWatch =  new StopWatch  ( ) ;   stopWatch . start  ( ) ;   int  nuOfDistancesStored = 0 ;  for ( Job i :   vrp . getJobs  ( ) . values  ( ) )  {   TreeSet  < ReferencedJob >  treeSet =  new  TreeSet  < ReferencedJob >  (  new  Comparator  < ReferencedJob >  ( )  {    @ Override public  int compare  (  ReferencedJob o1 ,  ReferencedJob o2 )  {  if  (   o1 . getDistance  ( ) <=  o2 . getDistance  ( ) )  {  return  - 1 ; } else  {  return 1 ; } } } ) ;   distanceNodeTree . put  (  i . getId  ( ) , treeSet ) ;  for ( Job j :   vrp . getJobs  ( ) . values  ( ) )  {  if  (  i == j )  continue ;   double  distance =  jobDistance . calculateDistance  ( i , j ) ;  ReferencedJob  refNode =  new ReferencedJob  ( j , distance ) ;   treeSet . add  ( refNode ) ;   nuOfDistancesStored ++ ; } }   stopWatch . stop  ( ) ;   logger . info  (       "preprocessing comp-time: " + stopWatch + "; nuOfDistances stored: " + nuOfDistancesStored + "; estimated memory: " +  (     distanceNodeTree . keySet  ( ) . size  ( ) * 64 +  nuOfDistancesStored * 92 ) + " bytes" ) ; } }   static class JobNeighborhoodsImplWithCapRestriction  implements  JobNeighborhoods  {   private static Logger  logger =  Logger . getLogger  (  JobNeighborhoodsImpl . class ) ;   private VehicleRoutingProblem  vrp ;   private  Map  < String ,  TreeSet  < ReferencedJob > >  distanceNodeTree =  new  HashMap  < String ,  TreeSet  < ReferencedJob > >  ( ) ;   private JobDistance  jobDistance ;   private  int  capacity ;   public JobNeighborhoodsImplWithCapRestriction  (  VehicleRoutingProblem vrp ,  JobDistance jobDistance ,   int capacity )  {  super  ( ) ;    this . vrp = vrp ;    this . jobDistance = jobDistance ;    this . capacity = capacity ;   logger . info  (  "intialise " + this ) ; }   public  Iterator  < Job > getNearestNeighborsIterator  (   int nNeighbors ,  Job neighborTo )  {   TreeSet  < ReferencedJob >  tree =  distanceNodeTree . get  (  neighborTo . getId  ( ) ) ;   Iterator  < ReferencedJob >  descendingIterator =  tree . iterator  ( ) ;  return  new NeighborhoodIterator  ( descendingIterator , nNeighbors ) ; }   public void initialise  ( )  {   logger . info  (     "calculates distances from EACH job to EACH job --> n^2=" +  Math . pow  (    vrp . getJobs  ( ) . values  ( ) . size  ( ) , 2 ) + " calculations, but 'only' " +  (     vrp . getJobs  ( ) . values  ( ) . size  ( ) * capacity ) + " are cached." ) ;   calculateDistancesFromJob2Job  ( ) ; }   private void calculateDistancesFromJob2Job  ( )  {   logger . info  ( "preprocess distances between locations ..." ) ;  StopWatch  stopWatch =  new StopWatch  ( ) ;   stopWatch . start  ( ) ;   int  nuOfDistancesStored = 0 ;  for ( Job i :   vrp . getJobs  ( ) . values  ( ) )  {   TreeSet  < ReferencedJob >  treeSet =  new  TreeSet  < ReferencedJob >  (  new  Comparator  < ReferencedJob >  ( )  {    @ Override public  int compare  (  ReferencedJob o1 ,  ReferencedJob o2 )  {  if  (   o1 . getDistance  ( ) <=  o2 . getDistance  ( ) )  {  return  - 1 ; } else  {  return 1 ; } } } ) ;   distanceNodeTree . put  (  i . getId  ( ) , treeSet ) ;  for ( Job j :   vrp . getJobs  ( ) . values  ( ) )  {  if  (  i == j )  continue ;   double  distance =  jobDistance . calculateDistance  ( i , j ) ;  ReferencedJob  refNode =  new ReferencedJob  ( j , distance ) ;  if  (   treeSet . size  ( ) < capacity )  {   treeSet . add  ( refNode ) ;   nuOfDistancesStored ++ ; } else  {  if  (    treeSet . last  ( ) . getDistance  ( ) > distance )  {   treeSet . pollLast  ( ) ;   treeSet . add  ( refNode ) ; } } }  assert   treeSet . size  ( ) <= capacity : "treeSet.size() is bigger than specified capacity" ; }   stopWatch . stop  ( ) ;   logger . info  (       "preprocessing comp-time: " + stopWatch + "; nuOfDistances stored: " + nuOfDistancesStored + "; estimated memory: " +  (     distanceNodeTree . keySet  ( ) . size  ( ) * 64 +  nuOfDistancesStored * 92 ) + " bytes" ) ; }    @ Override public String toString  ( )  {  return   "[name=neighborhoodWithCapRestriction][capacity=" + capacity + "]" ; } }   private JobNeighborhoods  jobNeighborhoods ;   private void removeJob  (  Job job ,   Collection  < VehicleRoute > vehicleRoutes )  {  boolean  removed = false ;  for ( VehicleRoute route : vehicleRoutes )  {   removed =   route . getTourActivities  ( ) . removeJob  ( job ) ; ;  if  ( removed )  {   ruinListeners . removed  ( job , route ) ;  break ; } } } }