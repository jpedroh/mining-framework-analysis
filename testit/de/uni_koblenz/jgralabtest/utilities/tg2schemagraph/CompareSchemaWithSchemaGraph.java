  package     de . uni_koblenz . jgralabtest . utilities . tg2schemagraph ;   import static    junit . framework . Assert . assertEquals ;  import static    junit . framework . Assert . assertFalse ;  import static    junit . framework . Assert . assertTrue ;  import   java . util . ArrayList ;  import   java . util . Collection ;  import   java . util . HashMap ;  import   java . util . HashSet ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Set ;  import    de . uni_koblenz . jgralab . Edge ;  import    de . uni_koblenz . jgralab . EdgeDirection ;  import    de . uni_koblenz . jgralab . Vertex ;  import     de . uni_koblenz . jgralab . grumlschema . SchemaGraph ;  import      de . uni_koblenz . jgralab . grumlschema . domains . CollectionDomain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . Domain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . EnumDomain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . HasBaseDomain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . HasKeyDomain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . HasRecordDomainComponent ;  import      de . uni_koblenz . jgralab . grumlschema . domains . HasValueDomain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . MapDomain ;  import      de . uni_koblenz . jgralab . grumlschema . domains . RecordDomain ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Annotates ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Attribute ;  import      de . uni_koblenz . jgralab . grumlschema . structure . AttributedElementClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . ComesFrom ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Comment ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Constraint ;  import      de . uni_koblenz . jgralab . grumlschema . structure . ContainsDefaultPackage ;  import      de . uni_koblenz . jgralab . grumlschema . structure . ContainsDomain ;  import      de . uni_koblenz . jgralab . grumlschema . structure . ContainsGraphElementClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . ContainsSubPackage ;  import      de . uni_koblenz . jgralab . grumlschema . structure . DefinesGraphClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . EdgeClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . EndsAt ;  import      de . uni_koblenz . jgralab . grumlschema . structure . GoesTo ;  import      de . uni_koblenz . jgralab . grumlschema . structure . GraphClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . GraphElementClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . HasAttribute ;  import      de . uni_koblenz . jgralab . grumlschema . structure . HasConstraint ;  import      de . uni_koblenz . jgralab . grumlschema . structure . HasDomain ;  import      de . uni_koblenz . jgralab . grumlschema . structure . IncidenceClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . IncidenceDirection ;  import      de . uni_koblenz . jgralab . grumlschema . structure . NamedElement ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Package ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Schema ;  import      de . uni_koblenz . jgralab . grumlschema . structure . SpecializesEdgeClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . SpecializesVertexClass ;  import      de . uni_koblenz . jgralab . grumlschema . structure . Subsets ;  import      de . uni_koblenz . jgralab . grumlschema . structure . VertexClass ;  import      de . uni_koblenz . jgralab . schema . RecordDomain . RecordComponent ;  import      de . uni_koblenz . jgralab . schema . impl . TemporaryEdgeClassImpl ;  import      de . uni_koblenz . jgralab . schema . impl . TemporaryVertexClassImpl ;   public class CompareSchemaWithSchemaGraph  {   private static final EdgeDirection  OUTGOING =  EdgeDirection . OUT ;   private     de . uni_koblenz . jgralab . schema . Schema  schema ;   private String  currentName ;   public CompareSchemaWithSchemaGraph  ( )  { }   final public void compare  (      de . uni_koblenz . jgralab . schema . Schema schema ,  SchemaGraph schemaGraph )  {    this . schema = schema ;   compareAllElements  ( schema ,  schemaGraph . getFirstSchema  ( ) ) ; }   final public void compareAllElements  (      de . uni_koblenz . jgralab . schema . Schema schema ,  Schema gSchema )  {   compareSchema  ( schema , gSchema ) ;   compareGraphClass  ( schema , gSchema ) ;   compareDefaultPackageAndAllSubelements  ( schema , gSchema ) ; }   private void compareSchema  (      de . uni_koblenz . jgralab . schema . Schema schema ,  Schema gSchema )  {   assertFalse  ( "There is no Schema defined!" ,  schema == null ) ;   assertFalse  ( "There is no SchemaGraph defined!" ,  gSchema == null ) ;   assertEquals  ( "Both Schema objects have a different name." ,  schema . getName  ( ) ,  gSchema . get_name  ( ) ) ;   assertEquals  ( "Both Schema objects have a different package prefix." ,  schema . getPackagePrefix  ( ) ,  gSchema . get_packagePrefix  ( ) ) ; }   private void compareGraphClass  (      de . uni_koblenz . jgralab . schema . Schema schema ,  Schema gSchema )  {  GraphClass  gGraphClass =  retrieveAndCheckGraphClass  ( gSchema ) ;      de . uni_koblenz . jgralab . schema . GraphClass  graphClass =  retrieveAndCheckGraphClass  ( schema ) ;   compareAttributedElementClass  ( graphClass , gGraphClass ) ; }   private     de . uni_koblenz . jgralab . schema . GraphClass retrieveAndCheckGraphClass  (      de . uni_koblenz . jgralab . schema . Schema schema )  {      de . uni_koblenz . jgralab . schema . GraphClass  graphClass =  schema . getGraphClass  ( ) ;   assertFalse  ( "There is no GraphClass defined in the Schema" ,  graphClass == null ) ;  return graphClass ; }   private GraphClass retrieveAndCheckGraphClass  (  Schema gSchema )  {  DefinesGraphClass  definesGraphClass =  gSchema . getFirstDefinesGraphClassIncidence  ( OUTGOING ) ;   assertTrue  ( "There is no GraphClass or DefinesGraphClass edge defined." ,  definesGraphClass != null ) ;  Vertex  vertex =  definesGraphClass . getThat  ( ) ;   assertTrue  ( "DefinesGraphClass is not referencing to an instance of GraphClass." ,  vertex instanceof GraphClass ) ;   assertFalse  ( "There is more than one GraphClass defined in the SchemaGraph." ,   definesGraphClass . getNextDefinesGraphClassIncidence  ( OUTGOING ) != null ) ;  GraphClass  gGraphClass =  ( GraphClass ) vertex ;  return gGraphClass ; }   private void compareDefaultPackageAndAllSubelements  (      de . uni_koblenz . jgralab . schema . Schema schema ,  Schema gSchema )  {  Package  gPackage =  retrieveAndCheckDefaultPackage  ( gSchema ) ;      de . uni_koblenz . jgralab . schema . Package  xPackage =  retrieveAndCheckDefaultPackage  ( schema ) ;   comparePackage  ( xPackage , gPackage ) ; }   private     de . uni_koblenz . jgralab . schema . Package retrieveAndCheckDefaultPackage  (      de . uni_koblenz . jgralab . schema . Schema schema )  {      de . uni_koblenz . jgralab . schema . Package  xPackage =  schema . getDefaultPackage  ( ) ;   assertFalse  ( "There is no default Package defined in the Schema." ,  xPackage == null ) ;  return xPackage ; }   private Package retrieveAndCheckDefaultPackage  (  Schema gSchema )  {  Vertex  vertex ;  ContainsDefaultPackage  containsDefaultPackage =  gSchema . getFirstContainsDefaultPackageIncidence  ( OUTGOING ) ;   assertFalse  ( "There is no DefaultPackage defined." ,  containsDefaultPackage == null ) ;   vertex =  containsDefaultPackage . getThat  ( ) ;   assertFalse  ( "There is more than one DefaultPackage defined." ,   containsDefaultPackage . getNextContainsDefaultPackageIncidence  ( OUTGOING ) != null ) ;   assertTrue  ( "ContainsDefaultPackage si not referencing to an instance of Package." ,  vertex instanceof Package ) ;  Package  gPackage =  ( Package ) vertex ;  return gPackage ; }   final private void comparePackage  (      de . uni_koblenz . jgralab . schema . Package xPackage ,  Package gPackage )  {   compareNamedElement  ( xPackage , gPackage ) ;   compareAllDomains  ( xPackage , gPackage ) ;   compareAllGraphElementClasses  ( xPackage , gPackage ) ;   compareAllSubPackages  ( xPackage , gPackage ) ; }   private void compareNamedElement  (      de . uni_koblenz . jgralab . schema . NamedElement element ,  NamedElement gElement )  {   compareQualifiedName  ( element , gElement ) ;   compareComments  ( element , gElement ) ; }   private void compareQualifiedName  (      de . uni_koblenz . jgralab . schema . NamedElement element ,  NamedElement gElement )  {   assertEquals  ( "Both Package objects have a different name." ,  element . getQualifiedName  ( ) ,  gElement . get_qualifiedName  ( ) ) ; }   private void compareComments  (      de . uni_koblenz . jgralab . schema . NamedElement element ,  NamedElement gElement )  {   List  < String >  comments =  element . getComments  ( ) ;   List  < String >  gComments =  retrieveComments  ( gElement ) ;   comments . containsAll  ( gComments ) ;   gComments . containsAll  ( comments ) ; }   private  List  < String > retrieveComments  (  NamedElement gElement )  {   List  < String >  gComments =  new  ArrayList  < String >  ( ) ;  Annotates  annotates =  gElement . getFirstAnnotatesIncidence  ( ) ;  while  (  annotates != null )  {  Comment  comment =  ( Comment )  annotates . getThat  ( ) ;   gComments . add  (  comment . get_text  ( ) ) ;   annotates =  annotates . getNextAnnotatesIncidence  ( ) ; }  return gComments ; }   final private void compareAllDomains  (      de . uni_koblenz . jgralab . schema . Package xPackage ,  Package gPackage )  {  for ( ContainsDomain containsDomain :  gPackage . getContainsDomainIncidences  ( OUTGOING ) )  {  Domain  gDomain =  retrieveDomain  ( containsDomain ) ;  String  simpleName =   schema . getDomain  (  gDomain . get_qualifiedName  ( ) ) . getSimpleName  ( ) ;      de . uni_koblenz . jgralab . schema . Domain  domain =  xPackage . getDomain  ( simpleName ) ;   assertTrue  (   "There is corresponding Domain of name \"" + simpleName + "\" in the Schema." ,  domain != null ) ;   compareDomain  ( domain , gDomain ) ; } }   private Domain retrieveDomain  (  ContainsDomain containsDomain )  {   assertTrue  ( "ContainsDomain is not an instance of type Domain." ,   containsDomain . getOmega  ( ) instanceof Domain ) ;  Domain  gDomain =  containsDomain . getOmega  ( ) ;  return gDomain ; }   final private void compareAllGraphElementClasses  (      de . uni_koblenz . jgralab . schema . Package xPackage ,  Package gPackage )  {   assertEquals  (   "The number of graph element classes in package " + xPackage + " don't match!" ,    xPackage . getVertexClasses  ( ) . size  ( ) +   xPackage . getEdgeClasses  ( ) . size  ( ) ,  gPackage . getDegree  (  ContainsGraphElementClass . class ) ) ; 
<<<<<<<
 for (   Iterator < Entry < String ,      de . uni_koblenz . jgralab . schema . VertexClass >>  it =   vertexClasses . entrySet  ( ) . iterator  ( ) ;  it . hasNext  ( ) ; )  {      de . uni_koblenz . jgralab . schema . VertexClass  vc =   it . next  ( ) . getValue  ( ) ;  if  (  vc . isDefaultGraphElementClass  ( ) )  {   it . remove  ( ) ; } else  if  (  vc instanceof TemporaryVertexClassImpl )  {   it . remove  ( ) ; } }
=======
>>>>>>>
 
<<<<<<<
 for (   Iterator < Entry < String ,      de . uni_koblenz . jgralab . schema . EdgeClass >>  it =   edgeClasses . entrySet  ( ) . iterator  ( ) ;  it . hasNext  ( ) ; )  {      de . uni_koblenz . jgralab . schema . EdgeClass  ec =   it . next  ( ) . getValue  ( ) ;  if  (  ec . isDefaultGraphElementClass  ( ) )  {   it . remove  ( ) ; } else  if  (  ec instanceof TemporaryEdgeClassImpl )  {   it . remove  ( ) ; } }
=======
>>>>>>>
  for ( ContainsGraphElementClass containsGraphElementClass :  gPackage . getContainsGraphElementClassIncidences  ( OUTGOING ) )  {   assertTrue  ( "Omega should be an instance of GraphElementClass." ,   containsGraphElementClass . getOmega  ( ) instanceof GraphElementClass ) ;  Vertex  omega =  containsGraphElementClass . getOmega  ( ) ;  assert  omega != null ;  if  (  omega instanceof VertexClass )  {  VertexClass  gVertexClass =  ( VertexClass ) omega ;  String  simpleName =   schema . getAttributedElementClass  (  gVertexClass . get_qualifiedName  ( ) ) . getSimpleName  ( ) ;   compareVertexClass  (  xPackage . getVertexClass  ( simpleName ) , gVertexClass ) ; } else  if  (  omega instanceof EdgeClass )  {  EdgeClass  gEdgeClass =  ( EdgeClass ) omega ;  String  simpleName =   schema . getAttributedElementClass  (  gEdgeClass . get_qualifiedName  ( ) ) . getSimpleName  ( ) ;   compareEdgeClass  (  xPackage . getEdgeClass  ( simpleName ) , gEdgeClass ) ; } else  {  throw  new RuntimeException  (  "Unexpected type " + omega ) ; } } }   final private void compareAllSubPackages  (      de . uni_koblenz . jgralab . schema . Package xPackage ,  Package gPackage )  {   assertEquals  (   "The number of subpackages in package " + xPackage + " don't match!" ,   xPackage . getSubPackages  ( ) . size  ( ) ,  gPackage . getDegree  (  ContainsSubPackage . class ,  EdgeDirection . OUT ) ) ;  for ( ContainsSubPackage containsSubPackage :  gPackage . getContainsSubPackageIncidences  ( OUTGOING ) )  {   assertTrue  ( "Omega should be an instance of \"Package\"." ,   containsSubPackage . getOmega  ( ) instanceof Package ) ;  Package  gSubPackage =  containsSubPackage . getOmega  ( ) ;      de . uni_koblenz . jgralab . schema . Package  subpackage =  schema . getPackage  (  gSubPackage . get_qualifiedName  ( ) ) ;   assertTrue  ( "There is no corresponding Package in Schema." ,  subpackage != null ) ;   assertTrue  ( "There is no corresponding Package in Schema." ,   xPackage . getSubPackage  (  subpackage . getSimpleName  ( ) ) != null ) ;   comparePackage  ( subpackage , gSubPackage ) ; } }   final private void compareDomain  (      de . uni_koblenz . jgralab . schema . Domain domain ,  Domain gDomain )  {   compareNamedElement  ( domain , gDomain ) ;  if  (   (  domain instanceof     de . uni_koblenz . jgralab . schema . MapDomain ) &&  (  gDomain instanceof MapDomain ) )  {   compareDomain  (  (     de . uni_koblenz . jgralab . schema . MapDomain ) domain ,  ( MapDomain ) gDomain ) ; } else  if  (   (  domain instanceof     de . uni_koblenz . jgralab . schema . RecordDomain ) &&  (  gDomain instanceof RecordDomain ) )  {   compareDomain  (  (     de . uni_koblenz . jgralab . schema . RecordDomain ) domain ,  ( RecordDomain ) gDomain ) ; } else  if  (   (  domain instanceof     de . uni_koblenz . jgralab . schema . CollectionDomain ) &&  (  gDomain instanceof CollectionDomain ) )  {   compareDomain  (  (     de . uni_koblenz . jgralab . schema . CollectionDomain ) domain ,  ( CollectionDomain ) gDomain ) ; } else  if  (   (  domain instanceof     de . uni_koblenz . jgralab . schema . EnumDomain ) &&  (  gDomain instanceof EnumDomain ) )  {   compareDomain  (  (     de . uni_koblenz . jgralab . schema . EnumDomain ) domain ,  ( EnumDomain ) gDomain ) ; } }   final private void compareDomain  (      de . uni_koblenz . jgralab . schema . RecordDomain domain ,  RecordDomain gDomain )  {   Collection  < RecordComponent >  tempComponents =  domain . getComponents  ( ) ;   Map  < String ,     de . uni_koblenz . jgralab . schema . Domain >  components =  new  HashMap  < String ,     de . uni_koblenz . jgralab . schema . Domain >  (  tempComponents . size  ( ) ) ;  for ( RecordComponent component : tempComponents )  {   components . put  (  component . getName  ( ) ,  component . getDomain  ( ) ) ; }  for ( HasRecordDomainComponent hasRecordDomainComponent :  gDomain . getHasRecordDomainComponentIncidences  ( OUTGOING ) )  {   assertTrue  ( "Omega should be an instance of Domain." ,   hasRecordDomainComponent . getOmega  ( ) instanceof Domain ) ;  Domain  domainComponent =  hasRecordDomainComponent . getOmega  ( ) ;      de . uni_koblenz . jgralab . schema . Domain  currentDomain =  components . remove  (  hasRecordDomainComponent . get_name  ( ) ) ;   assertFalse  (   "In the Schema there no Domain called: \"" +  hasRecordDomainComponent . get_name  ( ) + "\"" ,  currentDomain == null ) ;   assertEquals  ( "Both DomainComponents don't have an equal name." ,  currentDomain . getQualifiedName  ( ) ,  domainComponent . get_qualifiedName  ( ) ) ; }   assertTrue  ( "There are more Components in Schema then in SchemaGraph" ,  components . isEmpty  ( ) ) ; }   final private void compareDomain  (      de . uni_koblenz . jgralab . schema . MapDomain domain ,  MapDomain gDomain )  {  HasKeyDomain  hasKeyDomain =  gDomain . getFirstHasKeyDomainIncidence  ( OUTGOING ) ;   assertTrue  ( "There is no key Domain defined." ,  hasKeyDomain != null ) ;  Vertex  vertex =  hasKeyDomain . getThat  ( ) ;   assertTrue  ( "That should be an instance of Domain." ,  vertex instanceof Domain ) ;   assertFalse  ( "There is more than one key Domain." ,   hasKeyDomain . getNextHasKeyDomainIncidence  ( OUTGOING ) != null ) ;  Domain  gKeyDomain =  ( Domain ) vertex ;   assertEquals  ( "Both key Domain objects should have the same QualifiedName." ,   domain . getKeyDomain  ( ) . getQualifiedName  ( ) ,  gKeyDomain . get_qualifiedName  ( ) ) ;  HasValueDomain  hasValueDomain =  gDomain . getFirstHasValueDomainIncidence  ( OUTGOING ) ;   assertTrue  ( "There is no value Domain defined." ,  hasValueDomain != null ) ;   vertex =  hasValueDomain . getThat  ( ) ;   assertTrue  ( "That should be an instance of Domain." ,  vertex instanceof Domain ) ;   assertFalse  ( "There is more than one value Domain." ,   hasValueDomain . getNextHasValueDomainIncidence  ( OUTGOING ) != null ) ;  Domain  gValueDomain =  ( Domain ) vertex ;   assertEquals  ( "Both value Domain objects should have an equal QualifiedName." ,   domain . getValueDomain  ( ) . getQualifiedName  ( ) ,  gValueDomain . get_qualifiedName  ( ) ) ; }   final private void compareDomain  (      de . uni_koblenz . jgralab . schema . CollectionDomain domain ,  CollectionDomain gDomain )  {  HasBaseDomain  hasBaseDomain =  gDomain . getFirstHasBaseDomainIncidence  ( OUTGOING ) ;   assertTrue  ( "There should be a base Domain." ,  hasBaseDomain != null ) ;  Vertex  vertex =  hasBaseDomain . getThat  ( ) ;   assertTrue  ( "That should be an instance of Domain." ,  vertex instanceof Domain ) ;   assertFalse  ( "There is more than one base Domain." ,   hasBaseDomain . getNextHasBaseDomainIncidence  ( OUTGOING ) != null ) ;  Domain  gBaseDomain =  ( Domain ) vertex ;   assertEquals  ( "Both base Domain objects should have an equal QualifiedName." ,   domain . getBaseDomain  ( ) . getQualifiedName  ( ) ,  gBaseDomain . get_qualifiedName  ( ) ) ; }   final private void compareDomain  (      de . uni_koblenz . jgralab . schema . EnumDomain domain ,  EnumDomain gDomain )  {   List  < String >  enumConstants =  domain . getConsts  ( ) ;   List  < String >  gEnumConstants =  gDomain . get_enumConstants  ( ) ;   assertTrue  ( "The size of enum constants are not equal." ,   enumConstants . size  ( ) ==  gEnumConstants . size  ( ) ) ;   assertTrue  ( "Not all Constants are included." ,  gEnumConstants . containsAll  ( enumConstants ) ) ;   assertTrue  ( "Not all Constants are included." ,  enumConstants . containsAll  ( gEnumConstants ) ) ; }   final private void compareAttributedElementClass  (       de . uni_koblenz . jgralab . schema . AttributedElementClass  <  ? ,  ? > element ,  AttributedElementClass gElement )  {   compareNamedElement  ( element , gElement ) ;  if  (  element instanceof     de . uni_koblenz . jgralab . schema . GraphElementClass )  {   compareIsAbstract  (  (      de . uni_koblenz . jgralab . schema . GraphElementClass  <  ? ,  ? > ) element ,  ( GraphElementClass ) gElement ) ; }   compareAttributes  ( element , gElement ) ;   compareConstraints  ( element , gElement ) ; }   private void compareIsAbstract  (       de . uni_koblenz . jgralab . schema . GraphElementClass  <  ? ,  ? > element ,  GraphElementClass gElement )  {   assertEquals  ( "Attribute \"isAbstract\" is different." ,  element . isAbstract  ( ) ,  gElement . is_abstract  ( ) ) ; }   final private void compareVertexClass  (      de . uni_koblenz . jgralab . schema . VertexClass vertexClass ,  VertexClass gVertexClass )  {   compareAttributedElementClass  ( vertexClass , gVertexClass ) ;   Map  < String ,     de . uni_koblenz . jgralab . schema . VertexClass >  superClasses =  getAttributedElementClassMap  (  vertexClass . getDirectSuperClasses  ( ) ) ;  for ( SpecializesVertexClass specializesVertexClass :  gVertexClass . getSpecializesVertexClassIncidences  ( OUTGOING ) )  {  AttributedElementClass  element =  specializesVertexClass . getOmega  ( ) ;   assertEquals  ( "SuperClasses of these AttributeElementClass objects are different." ,   superClasses . remove  (  element . get_qualifiedName  ( ) ) . getQualifiedName  ( ) ,  element . get_qualifiedName  ( ) ) ; }   assertTrue  ( "There are more SuperClasses in the AttibuteElement of the Schema then in the SchemaGraph." ,  superClasses . isEmpty  ( ) ) ; }   final private void compareEdgeClass  (      de . uni_koblenz . jgralab . schema . EdgeClass edgeClass ,  EdgeClass gEdgeClass )  {   compareAttributedElementClass  ( edgeClass , gEdgeClass ) ;   Map  < String ,     de . uni_koblenz . jgralab . schema . EdgeClass >  superClasses =  getAttributedElementClassMap  (  edgeClass . getDirectSuperClasses  ( ) ) ;  for ( SpecializesEdgeClass specializesEdgeClass :  gEdgeClass . getSpecializesEdgeClassIncidences  ( OUTGOING ) )  {  AttributedElementClass  gElement =  specializesEdgeClass . getOmega  ( ) ;      de . uni_koblenz . jgralab . schema . EdgeClass  element =  superClasses . remove  (  gElement . get_qualifiedName  ( ) ) ;   assertEquals  ( "SuperClasses of these AttributeElementClass objects are different." ,  element . getQualifiedName  ( ) ,  gElement . get_qualifiedName  ( ) ) ; }   assertTrue  ( "There are more SuperClasses in the AttibuteElement of the Schema then in the SchemaGraph." ,  superClasses . isEmpty  ( ) ) ;  ComesFrom  comesFrom =  gEdgeClass . getFirstComesFromIncidence  ( ) ;   compareIncidenceClass  (  edgeClass . getFrom  ( ) ,  ( IncidenceClass )  comesFrom . getThat  ( ) ,  IncidenceDirection . OUT ) ;  GoesTo  goesTo =  gEdgeClass . getFirstGoesToIncidence  ( ) ;   compareIncidenceClass  (  edgeClass . getTo  ( ) ,  ( IncidenceClass )  goesTo . getThat  ( ) ,  IncidenceDirection . IN ) ; }   final private void compareIncidenceClass  (      de . uni_koblenz . jgralab . schema . IncidenceClass incidence ,  IncidenceClass gIncidence ,  IncidenceDirection gDirection )  {   currentName = "IncidenceClass" ;   checkExistingsOfSchemaElement  ( incidence ) ;   checkExistingsOfSchemaGraphElement  ( gIncidence ) ;   compareVertexClassesOfIncidenceClasses  ( incidence , gIncidence ) ;   currentName =     incidence . getVertexClass  ( ) . getQualifiedName  ( ) + " -- " +   incidence . getEdgeClass  ( ) . getQualifiedName  ( ) ;   compareAggregationKind  ( incidence , gIncidence ) ;   compareMaxValue  ( incidence , gIncidence ) ;   compareMinValue  ( incidence , gIncidence ) ;   compareRoleNames  ( incidence , gIncidence ) ;   compareDirection  ( incidence , gDirection ) ;   compareSubsettedIncidenceClasses  ( incidence , gIncidence ) ; }   private void compareDirection  (      de . uni_koblenz . jgralab . schema . IncidenceClass incidence ,  IncidenceDirection gDirection )  {   assertEquals  (    "The directions are not equal: " +  incidence . getDirection  ( ) + " != " + gDirection ,   incidence . getDirection  ( ) . toString  ( ) ,  gDirection . toString  ( ) ) ; }   private void checkExistingsOfSchemaElement  (  Object object )  {   assertFalse  (   "There is no \"" + currentName + "\" defined in the schema." ,  object == null ) ; }   private void checkExistingsOfSchemaGraphElement  (  Object incidence )  {   assertFalse  (   "There is no \"" + currentName + "\" defined in the schema." ,  incidence == null ) ; }   private void compareVertexClassesOfIncidenceClasses  (      de . uni_koblenz . jgralab . schema . IncidenceClass incidence ,  IncidenceClass gIncidence )  {  EndsAt  edgeToVertexClass =  gIncidence . getFirstEndsAtIncidence  ( ) ;   assertTrue  ( "That should be an instance of \"VertexClass\"." ,   edgeToVertexClass . getThat  ( ) instanceof VertexClass ) ;  VertexClass  gVertexClass =  ( VertexClass )  edgeToVertexClass . getThat  ( ) ;   assertTrue  (   edgeToVertexClass . getNextEndsAtIncidence  ( OUTGOING ) == null ) ;      de . uni_koblenz . jgralab . schema . VertexClass  vertexClass =  incidence . getVertexClass  ( ) ;   assertFalse  ( "There is no \"VertexClass\" defined in the schema." ,  vertexClass == null ) ;   assertFalse  ( "There is no \"VertexClass\" defined in the schema graph." ,  gVertexClass == null ) ;   assertEquals  (    "The qualifed names of both \"VertexClasses\" do not match: " +  vertexClass . getQualifiedName  ( ) + " != " +  gVertexClass . get_qualifiedName  ( ) ,  vertexClass . getQualifiedName  ( ) ,  gVertexClass . get_qualifiedName  ( ) ) ; }   private void compareRoleNames  (      de . uni_koblenz . jgralab . schema . IncidenceClass incidence ,  IncidenceClass gIncidence )  {   assertEquals  (  currentName + ": Both \"IncidenceClasses\" should have the same Rolename." ,  incidence . getRolename  ( ) ,  gIncidence . get_roleName  ( ) ) ; }   private void compareMaxValue  (      de . uni_koblenz . jgralab . schema . IncidenceClass incidence ,  IncidenceClass gIncidence )  {   assertEquals  (  currentName + ": Both \"IncidenceClasses\" should have the same max value." ,  incidence . getMax  ( ) ,  gIncidence . get_max  ( ) ) ; }   private void compareMinValue  (      de . uni_koblenz . jgralab . schema . IncidenceClass incidence ,  IncidenceClass gIncidence )  {   assertEquals  (  currentName + ": Both \"IncidenceClasses\" should have the same min value." ,  incidence . getMin  ( ) ,  gIncidence . get_min  ( ) ) ; }   private void compareAggregationKind  (      de . uni_koblenz . jgralab . schema . IncidenceClass type ,  IncidenceClass gType )  {   assertEquals  (  currentName + ": These objects should have the same Type." ,   type . getAggregationKind  ( ) . toString  ( ) ,   gType . get_aggregation  ( ) . toString  ( ) ) ; }   final private void compareSubsettedIncidenceClasses  (      de . uni_koblenz . jgralab . schema . IncidenceClass incidence ,  IncidenceClass gIncidence )  {   Set  < String >  subsettedIncidenceClasses =  getherAllSubsettedEdgeClassQualifiedNames  ( incidence ) ;   Set  < String >  gSubsettedIncidenceClasses =  getherAllSubsettedEdgeClassQualifiedNames  ( gIncidence ) ;  String  contents =    subsettedIncidenceClasses + " != " + gSubsettedIncidenceClasses + "." ;   assertTrue  (  "Not all subsets-links are included on the Schema side: " + contents ,  subsettedIncidenceClasses . containsAll  ( gSubsettedIncidenceClasses ) ) ;   assertTrue  (  "Not all subsets-links are included on the Schema graph side: " + contents ,  gSubsettedIncidenceClasses . containsAll  ( subsettedIncidenceClasses ) ) ; }   private  Set  < String > getherAllSubsettedEdgeClassQualifiedNames  (      de . uni_koblenz . jgralab . schema . IncidenceClass incidence )  {   Set  < String >  subsettedIncidenceClasses =  new  HashSet  < String >  (   incidence . getSubsettedIncidenceClasses  ( ) . size  ( ) ) ;  for (     de . uni_koblenz . jgralab . schema . IncidenceClass subsettedIncidenceClass :  incidence . getSubsettedIncidenceClasses  ( ) )  {      de . uni_koblenz . jgralab . schema . EdgeClass  edgeClass =  subsettedIncidenceClass . getEdgeClass  ( ) ;  if  (  edgeClass . isDefaultGraphElementClass  ( ) )  {  continue ; }   subsettedIncidenceClasses . add  (  edgeClass . getQualifiedName  ( ) ) ; }  return subsettedIncidenceClasses ; }   private  Set  < String > getherAllSubsettedEdgeClassQualifiedNames  (  IncidenceClass gIncidence )  {   Set  < String >  gSubsettedIncidenceClasses =  new  HashSet  < String >  ( ) ;  for ( Subsets subsets :  gIncidence . getSubsetsIncidences  ( OUTGOING ) )  {   getherAllSubsettedEdgeClassQaulifiedNames  ( gSubsettedIncidenceClasses , subsets ) ; }  return gSubsettedIncidenceClasses ; }   private void getherAllSubsettedEdgeClassQaulifiedNames  (   Set  < String > gSubsettedIncidenceClasses ,  Subsets subsets )  {  IncidenceClass  subsettedIncidenceClass =  ( IncidenceClass )  subsets . getThat  ( ) ;  Edge  edgeToEdgeClass =  subsettedIncidenceClass . getFirstGoesToIncidence  ( ) ;  if  (  edgeToEdgeClass == null )  {   edgeToEdgeClass =  subsettedIncidenceClass . getFirstComesFromIncidence  ( ) ; }   assertFalse  ( "There is no edge defined to connected this IncidenceClass to its EdgeClass." ,  edgeToEdgeClass == null ) ;  EdgeClass  edgeClass =  ( EdgeClass )  edgeToEdgeClass . getThat  ( ) ;   gSubsettedIncidenceClasses . add  (  edgeClass . get_qualifiedName  ( ) ) ;  for ( Subsets subSubsets :  subsettedIncidenceClass . getSubsetsIncidences  ( OUTGOING ) )  {   getherAllSubsettedEdgeClassQaulifiedNames  ( gSubsettedIncidenceClasses , subSubsets ) ; } }   final private void compareAttributes  (       de . uni_koblenz . jgralab . schema . AttributedElementClass  <  ? ,  ? > element ,  AttributedElementClass gElement )  {   Map  < String ,     de . uni_koblenz . jgralab . schema . Attribute >  attributes =  new  HashMap  < String ,     de . uni_koblenz . jgralab . schema . Attribute >  (  getAttributeMap  (  element . getOwnAttributeList  ( ) ) ) ;  for ( HasAttribute hasAttribute :  gElement . getHasAttributeIncidences  ( OUTGOING ) )  {   assertTrue  ( "Omega should be an instance of Attribute." ,   hasAttribute . getOmega  ( ) instanceof Attribute ) ;  Attribute  gAttribute =  ( Attribute )  hasAttribute . getThat  ( ) ;   assertTrue  ( "Attribute is not include in the AttributeMap." ,  attributes . containsKey  (  gAttribute . get_name  ( ) ) ) ;  HasDomain  hasDomain =  gAttribute . getFirstHasDomainIncidence  ( OUTGOING ) ;   assertTrue  ( "There is no Domain defined." ,  hasDomain != null ) ;  Vertex  vertex =  hasDomain . getThat  ( ) ;   assertTrue  ( "Omega should be an instance of Domain." ,  vertex instanceof Domain ) ;   assertFalse  ( "There is more than one Domain defined." ,   hasDomain . getNextHasDomainIncidence  ( OUTGOING ) != null ) ;   compareDomain  (   attributes . remove  (  gAttribute . get_name  ( ) ) . getDomain  ( ) ,  ( Domain ) vertex ) ; }   assertTrue  ( "There are more Domain objects in Schema then in SchemaGraph." ,  attributes . isEmpty  ( ) ) ; }   final private void compareConstraints  (       de . uni_koblenz . jgralab . schema . AttributedElementClass  <  ? ,  ? > element ,  AttributedElementClass gElement )  {   int  gConstraintCount = 0 ;  for ( HasConstraint hasConstraint :  gElement . getHasConstraintIncidences  ( OUTGOING ) )  {   gConstraintCount ++ ;   assertTrue  ( "Omega should be an instance of \"Constraint\"." ,   hasConstraint . getOmega  ( ) instanceof Constraint ) ;  Constraint  gConstraint =  hasConstraint . getOmega  ( ) ;  boolean  foundMatch = false ;  boolean  equal = false ;  for (     de . uni_koblenz . jgralab . schema . Constraint constraint :  element . getConstraints  ( ) )  {   equal =    constraint . getMessage  ( ) . equals  (  gConstraint . get_message  ( ) ) &&   constraint . getPredicate  ( ) . equals  (  gConstraint . get_predicateQuery  ( ) ) ;   foundMatch |=    equal &&  (   constraint . getOffendingElementsQuery  ( ) != null ) &&  (   gConstraint . get_offendingElementsQuery  ( ) != null ) &&   constraint . getOffendingElementsQuery  ( ) . equals  (  gConstraint . get_offendingElementsQuery  ( ) ) ;   foundMatch |=   equal &&  (   constraint . getOffendingElementsQuery  ( ) == null ) &&  (   gConstraint . get_offendingElementsQuery  ( ) == null ) ; }   assertTrue  ( "No Match have been found for all Constraints." , foundMatch ) ; }   assertTrue  ( "The count of Constraint objects differ." ,  gConstraintCount ==   element . getConstraints  ( ) . size  ( ) ) ; }   final private  Map  < String ,     de . uni_koblenz . jgralab . schema . Attribute > getAttributeMap  (   List  <     de . uni_koblenz . jgralab . schema . Attribute > attributeList )  {   Map  < String ,     de . uni_koblenz . jgralab . schema . Attribute >  attributes =  new  HashMap  < String ,     de . uni_koblenz . jgralab . schema . Attribute >  ( ) ;  for (     de . uni_koblenz . jgralab . schema . Attribute attribute : attributeList )  {   attributes . put  (  attribute . getName  ( ) , attribute ) ; }  return attributes ; }   final private  <  T  extends      de . uni_koblenz . jgralab . schema . GraphElementClass  <  ? ,  ? > >  Map  < String , T > getAttributedElementClassMap  (   Set  < T > elementSet )  {   Map  < String , T >  map =  new  HashMap  < String , T >  ( ) ;  for ( T element : elementSet )  {  if  (  !  element . isDefaultGraphElementClass  ( ) )  {   map . put  (  element . getQualifiedName  ( ) , element ) ; } }  return map ; } }