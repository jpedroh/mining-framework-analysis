  package      com . xxl . job . admin . core . thread ;   import       com . xxl . job . admin . core . conf . XxlJobAdminConfig ;  import       com . xxl . job . admin . core . cron . CronExpression ;  import       com . xxl . job . admin . core . model . XxlJobInfo ;  import       com . xxl . job . admin . core . trigger . TriggerTypeEnum ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     org . springframework . data . domain . PageRequest ;  import     org . springframework . data . domain . Sort ;  import     org . springframework . orm . jpa . JpaTransactionManager ;  import    org . springframework . transaction . TransactionException ;  import    org . springframework . transaction . TransactionStatus ;  import     org . springframework . transaction . support . DefaultTransactionDefinition ;  import   java . text . ParseException ;  import  java . util .  * ;  import    java . util . concurrent . ConcurrentHashMap ;  import    java . util . concurrent . TimeUnit ;   public class JobScheduleHelper  {   private static Logger  logger =  LoggerFactory . getLogger  (  JobScheduleHelper . class ) ;   private static JobScheduleHelper  instance =  new JobScheduleHelper  ( ) ;   public static JobScheduleHelper getInstance  ( )  {  return instance ; }   public static final  long  PRE_READ_MS = 5000 ;   private Thread  scheduleThread ;   private Thread  ringThread ;   private volatile boolean  scheduleThreadToStop = false ;   private volatile boolean  ringThreadToStop = false ;   private volatile static  Map  < Long ,  List  < Long > >  ringData =  new  ConcurrentHashMap  < >  ( ) ;   public void start  ( )  {   scheduleThread =  new Thread  (  new Runnable  ( )  {    @ Override public void run  ( )  {  try  {    TimeUnit . MILLISECONDS . sleep  (  5000 -   System . currentTimeMillis  ( ) % 1000 ) ; }  catch (   InterruptedException e )  {  if  (  ! scheduleThreadToStop )  {   logger . error  (  e . getMessage  ( ) , e ) ; } }   logger . info  ( ">>>>>>>>> init xxl-job admin scheduler success." ) ;   int  preReadCount =   (    XxlJobAdminConfig . getAdminConfig  ( ) . getTriggerPoolFastMax  ( ) +   XxlJobAdminConfig . getAdminConfig  ( ) . getTriggerPoolSlowMax  ( ) ) * 20 ;  while  (  ! scheduleThreadToStop )  {   long  start =  System . currentTimeMillis  ( ) ;  JpaTransactionManager  transactionManager = null ;  TransactionStatus  transactionStatus = null ;  boolean  preReadSuc = true ;  try  {  DefaultTransactionDefinition  transDefinition =  new DefaultTransactionDefinition  ( ) ;   transDefinition . setPropagationBehavior  (  DefaultTransactionDefinition . PROPAGATION_REQUIRES_NEW ) ;   transactionManager =   XxlJobAdminConfig . getAdminConfig  ( ) . getTransactionManager  ( ) ;   transactionStatus =  transactionManager . getTransaction  ( transDefinition ) ;     XxlJobAdminConfig . getAdminConfig  ( ) . getXxlJobLockDao  ( ) . getJobLockForUpdate  ( ) ;   long  nowTime =  System . currentTimeMillis  ( ) ;  Sort  sort =   Sort . by  ( "id" ) . ascending  ( ) ;  PageRequest  pageRequest =  PageRequest . of  ( 0 , preReadCount , sort ) ;   List  < XxlJobInfo >  scheduleList =    XxlJobAdminConfig . getAdminConfig  ( ) . getXxlJobInfoDao  ( ) . scheduleJobQuery  (  nowTime + PRE_READ_MS , pageRequest ) ;  if  (   scheduleList != null &&   scheduleList . size  ( ) > 0 )  {  for ( XxlJobInfo jobInfo : scheduleList )  {  if  (  nowTime >   jobInfo . getTriggerNextTime  ( ) + PRE_READ_MS )  {   logger . warn  (  ">>>>>>>>>>> xxl-job, schedule misfire, jobId = " +  jobInfo . getId  ( ) ) ;   refreshNextValidTime  ( jobInfo ,  new Date  ( ) ) ; } else  if  (  nowTime >  jobInfo . getTriggerNextTime  ( ) )  {   JobTriggerPoolHelper . trigger  (  jobInfo . getId  ( ) ,  TriggerTypeEnum . CRON ,  - 1 , null , null , null ) ;   logger . debug  (  ">>>>>>>>>>> xxl-job, schedule push trigger : jobId = " +  jobInfo . getId  ( ) ) ;   refreshNextValidTime  ( jobInfo ,  new Date  ( ) ) ;  if  (    jobInfo . getTriggerStatus  ( ) == 1 &&   nowTime + PRE_READ_MS >  jobInfo . getTriggerNextTime  ( ) )  {   int  ringSecond =  (  int )  (   (   jobInfo . getTriggerNextTime  ( ) / 1000 ) % 60 ) ;   pushTimeRing  ( ringSecond ,  jobInfo . getId  ( ) ) ;   refreshNextValidTime  ( jobInfo ,  new Date  (  jobInfo . getTriggerNextTime  ( ) ) ) ; } } else  {   int  ringSecond =  (  int )  (   (   jobInfo . getTriggerNextTime  ( ) / 1000 ) % 60 ) ;   pushTimeRing  ( ringSecond ,  jobInfo . getId  ( ) ) ;   refreshNextValidTime  ( jobInfo ,  new Date  (  jobInfo . getTriggerNextTime  ( ) ) ) ; } }  for ( XxlJobInfo jobInfo : scheduleList )  {     XxlJobAdminConfig . getAdminConfig  ( ) . getXxlJobInfoDao  ( ) . scheduleUpdate  ( jobInfo ) ; } } else  {   preReadSuc = false ; } }  catch (   Exception e )  {  if  (  ! scheduleThreadToStop )  {   logger . error  ( ">>>>>>>>>>> xxl-job, JobScheduleHelper#scheduleThread error:{}" , e ) ; } }  finally  {  if  (   transactionManager != null &&  transactionStatus != null )  {  try  {   transactionManager . commit  ( transactionStatus ) ; }  catch (   TransactionException e )  {  if  (  ! scheduleThreadToStop )  {   logger . error  (  e . getMessage  ( ) , e ) ; } } } }   long  cost =   System . currentTimeMillis  ( ) - start ;  if  (  cost < 1000 )  {  try  {    TimeUnit . MILLISECONDS . sleep  (   (  preReadSuc ? 1000 : PRE_READ_MS ) -   System . currentTimeMillis  ( ) % 1000 ) ; }  catch (   InterruptedException e )  {  if  (  ! scheduleThreadToStop )  {   logger . error  (  e . getMessage  ( ) , e ) ; } } } }   logger . info  ( ">>>>>>>>>>> xxl-job, JobScheduleHelper#scheduleThread stop" ) ; } } ) ;   scheduleThread . setDaemon  ( true ) ;   scheduleThread . setName  ( "xxl-job, admin JobScheduleHelper#scheduleThread" ) ;   scheduleThread . start  ( ) ;   ringThread =  new Thread  (  new Runnable  ( )  {    @ Override public void run  ( )  {  try  {    TimeUnit . MILLISECONDS . sleep  (  1000 -   System . currentTimeMillis  ( ) % 1000 ) ; }  catch (   InterruptedException e )  {  if  (  ! ringThreadToStop )  {   logger . error  (  e . getMessage  ( ) , e ) ; } }  while  (  ! ringThreadToStop )  {  try  {   List  < Long >  ringItemData =  new  ArrayList  < >  ( ) ;   int  nowSecond =   Calendar . getInstance  ( ) . get  (  Calendar . SECOND ) ;  for (   int  i = 0 ;  i < 2 ;  i ++ )  {   List  < Long >  tmpData =  ringData . remove  (   (   nowSecond + 60 - i ) % 60 ) ;  if  (  tmpData != null )  {   ringItemData . addAll  ( tmpData ) ; } }   logger . debug  (    ">>>>>>>>>>> xxl-job, time-ring beat : " + nowSecond + " = " +  Arrays . asList  ( ringItemData ) ) ;  if  (   ringItemData . size  ( ) > 0 )  {  for (  long jobId : ringItemData )  {   JobTriggerPoolHelper . trigger  ( jobId ,  TriggerTypeEnum . CRON ,  - 1 , null , null , null ) ; }   ringItemData . clear  ( ) ; } }  catch (   Exception e )  {  if  (  ! ringThreadToStop )  {   logger . error  ( ">>>>>>>>>>> xxl-job, JobScheduleHelper#ringThread error:{}" , e ) ; } }  try  {    TimeUnit . MILLISECONDS . sleep  (  1000 -   System . currentTimeMillis  ( ) % 1000 ) ; }  catch (   InterruptedException e )  {  if  (  ! ringThreadToStop )  {   logger . error  (  e . getMessage  ( ) , e ) ; } } }   logger . info  ( ">>>>>>>>>>> xxl-job, JobScheduleHelper#ringThread stop" ) ; } } ) ;   ringThread . setDaemon  ( true ) ;   ringThread . setName  ( "xxl-job, admin JobScheduleHelper#ringThread" ) ;   ringThread . start  ( ) ; }   private void refreshNextValidTime  (  XxlJobInfo jobInfo ,  Date fromTime )  throws ParseException  {  Date  nextValidTime =   new CronExpression  (  jobInfo . getJobCron  ( ) ) . getNextValidTimeAfter  ( fromTime ) ;  if  (  nextValidTime != null )  {   jobInfo . setTriggerLastTime  (  jobInfo . getTriggerNextTime  ( ) ) ;   jobInfo . setTriggerNextTime  (  nextValidTime . getTime  ( ) ) ; } else  {   jobInfo . setTriggerStatus  ( 0 ) ;   jobInfo . setTriggerLastTime  ( 0 ) ;   jobInfo . setTriggerNextTime  ( 0 ) ; } }   private void pushTimeRing  (   long ringSecond ,   long jobId )  {   List  < Long >  ringItemData =  ringData . get  ( ringSecond ) ;  if  (  ringItemData == null )  {   ringItemData =  new  ArrayList  < Long >  ( ) ;   ringData . put  ( ringSecond , ringItemData ) ; }   ringItemData . add  ( jobId ) ;   logger . debug  (    ">>>>>>>>>>> xxl-job, schedule push time-ring : " + ringSecond + " = " +  Arrays . asList  ( ringItemData ) ) ; }   public void toStop  ( )  {   scheduleThreadToStop = true ;  try  {    TimeUnit . SECONDS . sleep  ( 1 ) ; }  catch (   InterruptedException e )  {   logger . error  (  e . getMessage  ( ) , e ) ; }  if  (   scheduleThread . getState  ( ) !=   Thread . State . TERMINATED )  {   scheduleThread . interrupt  ( ) ;  try  {   scheduleThread . join  ( ) ; }  catch (   InterruptedException e )  {   logger . error  (  e . getMessage  ( ) , e ) ; } }  boolean  hasRingData = false ;  if  (  !  ringData . isEmpty  ( ) )  {  for (  long second :  ringData . keySet  ( ) )  {   List  < Long >  tmpData =  ringData . get  ( second ) ;  if  (   tmpData != null &&   tmpData . size  ( ) > 0 )  {   hasRingData = true ;  break ; } } }  if  ( hasRingData )  {  try  {    TimeUnit . SECONDS . sleep  ( 8 ) ; }  catch (   InterruptedException e )  {   logger . error  (  e . getMessage  ( ) , e ) ; } }   ringThreadToStop = true ;  try  {    TimeUnit . SECONDS . sleep  ( 1 ) ; }  catch (   InterruptedException e )  {   logger . error  (  e . getMessage  ( ) , e ) ; }  if  (   ringThread . getState  ( ) !=   Thread . State . TERMINATED )  {   ringThread . interrupt  ( ) ;  try  {   ringThread . join  ( ) ; }  catch (   InterruptedException e )  {   logger . error  (  e . getMessage  ( ) , e ) ; } }   logger . info  ( ">>>>>>>>>>> xxl-job, JobScheduleHelper stop" ) ; } }