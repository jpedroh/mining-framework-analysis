  package      com . xxl . job . admin . core . thread ;   import       com . xxl . job . admin . core . conf . XxlJobAdminConfig ;  import       com . xxl . job . admin . core . trigger . TriggerTypeEnum ;  import       com . xxl . job . admin . core . trigger . XxlJobTrigger ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import   java . util . concurrent .  * ;  import     java . util . concurrent . atomic . AtomicLong ;   public class JobTriggerPoolHelper  {   private static Logger  logger =  LoggerFactory . getLogger  (  JobTriggerPoolHelper . class ) ;   private ThreadPoolExecutor  fastTriggerPool = null ;   private ThreadPoolExecutor  slowTriggerPool = null ;   public void start  ( )  {   fastTriggerPool =  new ThreadPoolExecutor  ( 10 ,   XxlJobAdminConfig . getAdminConfig  ( ) . getTriggerPoolFastMax  ( ) , 60L ,  TimeUnit . SECONDS ,  new  LinkedBlockingQueue  < Runnable >  ( 1000 ) ,  new ThreadFactory  ( )  {    @ Override public Thread newThread  (  Runnable r )  {  return  new Thread  ( r ,  "xxl-job, admin JobTriggerPoolHelper-fastTriggerPool-" +  r . hashCode  ( ) ) ; } } ) ;   slowTriggerPool =  new ThreadPoolExecutor  ( 10 ,   XxlJobAdminConfig . getAdminConfig  ( ) . getTriggerPoolSlowMax  ( ) , 60L ,  TimeUnit . SECONDS ,  new  LinkedBlockingQueue  < Runnable >  ( 2000 ) ,  new ThreadFactory  ( )  {    @ Override public Thread newThread  (  Runnable r )  {  return  new Thread  ( r ,  "xxl-job, admin JobTriggerPoolHelper-slowTriggerPool-" +  r . hashCode  ( ) ) ; } } ) ; }   public void stop  ( )  {   fastTriggerPool . shutdownNow  ( ) ;   slowTriggerPool . shutdownNow  ( ) ;   logger . info  ( ">>>>>>>>> xxl-job trigger thread pool shutdown success." ) ; }   private volatile  long  minTim =   System . currentTimeMillis  ( ) / 60000 ;   private volatile  ConcurrentMap  < Long , AtomicLong >  jobTimeoutCountMap =  new  ConcurrentHashMap  < >  ( ) ;   public void addTrigger  (   final  long jobId ,   final TriggerTypeEnum triggerType ,   final  int failRetryCount ,   final String executorShardingParam ,   final String executorParam )  {  ThreadPoolExecutor  triggerPool_ = fastTriggerPool ;  AtomicLong  jobTimeoutCount =  jobTimeoutCountMap . get  ( jobId ) ;  if  (   jobTimeoutCount != null &&   jobTimeoutCount . get  ( ) > 10 )  {   triggerPool_ = slowTriggerPool ; }   triggerPool_ . execute  (  new Runnable  ( )  {    @ Override public void run  ( )  {   long  start =  System . currentTimeMillis  ( ) ;  try  {   XxlJobTrigger . trigger  ( jobId , triggerType , failRetryCount , executorShardingParam , executorParam ) ; }  catch (   Exception e )  {   logger . error  (  e . getMessage  ( ) , e ) ; }  finally  {   long  minTim_now =   System . currentTimeMillis  ( ) / 60000 ;  if  (  minTim != minTim_now )  {   minTim = minTim_now ;   jobTimeoutCountMap . clear  ( ) ; }   long  cost =   System . currentTimeMillis  ( ) - start ;  if  (  cost > 500 )  {  AtomicLong  timeoutCount =  jobTimeoutCountMap . putIfAbsent  ( jobId ,  new AtomicLong  ( 1 ) ) ;  if  (  timeoutCount != null )  {   timeoutCount . incrementAndGet  ( ) ; } } } } } ) ; }   private static JobTriggerPoolHelper  helper =  new JobTriggerPoolHelper  ( ) ;   public static void toStart  ( )  {   helper . start  ( ) ; }   public static void toStop  ( )  {   helper . stop  ( ) ; }   public static void trigger  (   long jobId ,  TriggerTypeEnum triggerType ,   int failRetryCount ,  String executorShardingParam ,  String executorParam )  {   helper . addTrigger  ( jobId , triggerType , failRetryCount , executorShardingParam , executorParam ) ; }   public void addTrigger  (   final  int jobId ,   final TriggerTypeEnum triggerType ,   final  int failRetryCount ,   final String executorShardingParam ,   final String executorParam ,   final String addressList )  {  ThreadPoolExecutor  triggerPool_ = fastTriggerPool ;  AtomicInteger  jobTimeoutCount =  jobTimeoutCountMap . get  ( jobId ) ;  if  (   jobTimeoutCount != null &&   jobTimeoutCount . get  ( ) > 10 )  {   triggerPool_ = slowTriggerPool ; }   triggerPool_ . execute  (  new Runnable  ( )  {    @ Override public void run  ( )  {   long  start =  System . currentTimeMillis  ( ) ;  try  {   XxlJobTrigger . trigger  ( jobId , triggerType , failRetryCount , executorShardingParam , executorParam , addressList ) ; }  catch (   Exception e )  {   logger . error  (  e . getMessage  ( ) , e ) ; }  finally  {   long  minTim_now =   System . currentTimeMillis  ( ) / 60000 ;  if  (  minTim != minTim_now )  {   minTim = minTim_now ;   jobTimeoutCountMap . clear  ( ) ; }   long  cost =   System . currentTimeMillis  ( ) - start ;  if  (  cost > 500 )  {  AtomicInteger  timeoutCount =  jobTimeoutCountMap . putIfAbsent  ( jobId ,  new AtomicInteger  ( 1 ) ) ;  if  (  timeoutCount != null )  {   timeoutCount . incrementAndGet  ( ) ; } } } } } ) ; }   public static void trigger  (   int jobId ,  TriggerTypeEnum triggerType ,   int failRetryCount ,  String executorShardingParam ,  String executorParam ,  String addressList )  {   helper . addTrigger  ( jobId , triggerType , failRetryCount , executorShardingParam , executorParam , addressList ) ; } }