  package   org . overture . typechecker ;   import   java . io . PrintWriter ;  import   java . util . HashMap ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Stack ;  import   java . util . Vector ;  import     org . overture . ast . definitions . PDefinition ;  import      org . overture . ast . intf . lex . ILexLocation ;  import      org . overture . ast . intf . lex . ILexNameToken ;  import     org . overture . ast . lex . LexNameSet ;  import     org . overture . ast . lex . LexNameToken ;  import     org . overture . ast . messages . InternalException ;  import     org . overture . parser . messages . VDMError ;  import     org . overture . parser . messages . VDMMessage ;  import     org . overture . parser . messages . VDMWarning ;  import     org . overture . typechecker . assistant . ITypeCheckerAssistantFactory ;  import     org . overture . typechecker . assistant . TypeCheckerAssistantFactory ;  import      org . overture . typechecker . assistant . definition . PDefinitionAssistantTC ;  import     org . overture . typechecker . utilities . FreeVarInfo ;   abstract public class TypeChecker  {   public interface IStatusListener  {  void report  (  VDMError error ) ;  void warning  (  VDMWarning warning ) ; }   private static  List  < VDMError >  errors =  new  Vector  < VDMError >  ( ) ;   private static  List  < VDMWarning >  warnings =  new  Vector  < VDMWarning >  ( ) ;   private static VDMMessage  lastMessage = null ;   private static final  int  MAX = 200 ;   final protected ITypeCheckerAssistantFactory  assistantFactory ;   static  List  < IStatusListener >  listners =  new  Vector  < IStatusListener >  ( ) ;   public TypeChecker  ( )  {   clearErrors  ( ) ;    this . assistantFactory =  new TypeCheckerAssistantFactory  ( ) ; }   public TypeChecker  (  ITypeCheckerAssistantFactory factory )  {   clearErrors  ( ) ;    this . assistantFactory = factory ; }   abstract public void typeCheck  ( ) ;   protected void cyclicDependencyCheck  (   List  < PDefinition > defs )  {  if  (   System . getProperty  ( "skip.cyclic.check" ) != null )  {  return ; }   Map  < ILexNameToken , LexNameSet >  dependencies =  new  HashMap  < ILexNameToken , LexNameSet >  ( ) ;  LexNameSet  skip =  new LexNameSet  ( ) ;  PDefinitionAssistantTC  assistant =  assistantFactory . createPDefinitionAssistant  ( ) ;  for ( PDefinition def : defs )  {  Environment  env =  new FlatEnvironment  ( assistantFactory ,  new  Vector  < PDefinition >  ( ) ) ;  FreeVarInfo  empty =  new FreeVarInfo  ( env , false ) ;  LexNameSet  freevars =  assistant . getFreeVariables  ( def , empty ) ;  if  (  !  freevars . isEmpty  ( ) )  {  for ( ILexNameToken name :  assistant . getVariableNames  ( def ) )  {   dependencies . put  (  nameFix  (  name . getExplicit  ( true ) ) ,  nameFix  ( freevars ) ) ; } }  if  (    assistant . isFunction  ( def ) ||  assistant . isTypeDefinition  ( def ) ||  assistant . isOperation  ( def ) )  {  if  (   def . getName  ( ) != null )  {   skip . add  (  nameFix  (   def . getName  ( ) . getExplicit  ( true ) ) ) ; } } }  for ( ILexNameToken sought :  dependencies . keySet  ( ) )  {  if  (  !  skip . contains  ( sought ) )  {   Stack  < ILexNameToken >  stack =  new  Stack  < ILexNameToken >  ( ) ;   stack . push  ( sought ) ;  if  (  reachable  ( sought ,  dependencies . get  ( sought ) , dependencies , stack ) )  {   report  ( 3355 ,  "Cyclic dependency detected for " + sought ,  sought . getLocation  ( ) ) ;   detail  ( "Cycle" ,  stack . toString  ( ) ) ; }   stack . pop  ( ) ; } } }   private LexNameSet nameFix  (  LexNameSet names )  {  LexNameSet  result =  new LexNameSet  ( ) ;  for ( ILexNameToken name : names )  {   result . add  (  nameFix  ( name ) ) ; }  return result ; }   private ILexNameToken nameFix  (  ILexNameToken name )  {  LexNameToken  rv =  new LexNameToken  (  name . getModule  ( ) ,  name . getName  ( ) ,  name . getLocation  ( ) ,  name . isOld  ( ) ,  name . getExplicit  ( ) )  {   private static final  long  serialVersionUID = 1L ;    @ Override public boolean equals  (  Object other )  {  if  (  super . equals  ( other ) )  {  LexNameToken  lother =  ( LexNameToken ) other ;  if  (   typeQualifier != null &&   lother . typeQualifier != null )  {  TypeComparator  comp =  new TypeComparator  ( assistantFactory ) ;  return  comp . compatible  ( typeQualifier ,  lother . typeQualifier ) ; } else  {  return true ; } } else  {  return false ; } }    @ Override public  int hashCode  ( )  {  return   name . hashCode  ( ) +  module . hashCode  ( ) ; } } ;   rv . setTypeQualifier  (  name . getTypeQualifier  ( ) ) ;  return rv ; }   private boolean reachable  (  ILexNameToken sought ,  LexNameSet nextset ,   Map  < ILexNameToken , LexNameSet > dependencies ,   Stack  < ILexNameToken > stack )  {  if  (  nextset == null )  {  return false ; }  if  (  nextset . contains  ( sought ) )  {   stack . push  ( sought ) ;  return true ; }  for ( ILexNameToken nextname : nextset )  {  if  (  stack . contains  ( nextname ) )  {  return false ; }   stack . push  ( nextname ) ;  if  (  reachable  ( sought ,  dependencies . get  ( nextname ) , dependencies , stack ) )  {  return true ; }   stack . pop  ( ) ; }  return false ; }   public static void report  (   int number ,  String problem ,  ILexLocation location )  {  if  ( suppress )  return ;  VDMError  error =  new VDMError  ( number , problem , location ) ;   errors . add  ( error ) ;   lastMessage = error ;  for ( IStatusListener listner : listners )  {   listner . report  ( error ) ; }  if  (   errors . size  ( ) >=  MAX - 1 )  {   errors . add  (  new VDMError  ( 10 , "Too many type checking errors" , location ) ) ;  throw  new InternalException  ( 10 , "Too many type checking errors" ) ; } }   public static void warning  (   int number ,  String problem ,  ILexLocation location )  {  if  ( suppress )  return ;  VDMWarning  warning =  new VDMWarning  ( number , problem , location ) ;   warnings . add  ( warning ) ;   lastMessage = warning ;  for ( IStatusListener listner : listners )  {   listner . warning  ( warning ) ; } }   public static void detail  (  String tag ,  Object obj )  {  if  (  lastMessage != null )  {   lastMessage . add  (   tag + ": " + obj ) ; } }   public static void detail2  (  String tag1 ,  Object obj1 ,  String tag2 ,  Object obj2 )  {   detail  ( tag1 , obj1 ) ;   detail  ( tag2 , obj2 ) ; }   public static void clearErrors  ( )  {   errors . clear  ( ) ;   warnings . clear  ( ) ; }   public static  int getErrorCount  ( )  {  return  errors . size  ( ) ; }   public static  int getWarningCount  ( )  {  return  warnings . size  ( ) ; }   public static  List  < VDMError > getErrors  ( )  {  return errors ; }   public static  List  < VDMWarning > getWarnings  ( )  {  return warnings ; }   public static void printErrors  (  PrintWriter out )  {  for ( VDMError e : errors )  {   out . println  (  e . toString  ( ) ) ; } }   public static void printWarnings  (  PrintWriter out )  {  for ( VDMWarning w : warnings )  {   out . println  (  w . toString  ( ) ) ; } }   public static void addStatusListner  (  IStatusListener listner )  {   listners . add  ( listner ) ; }   public static void removeStatusListner  (  IStatusListener listner )  {   listners . remove  ( listner ) ; }   private static boolean  suppress = false ;   public static void suppressErrors  (  boolean sup )  {   suppress = sup ; } }