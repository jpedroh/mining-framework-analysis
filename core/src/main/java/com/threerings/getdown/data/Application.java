  package    com . threerings . getdown . data ;   import  java . io .  * ;  import    java . lang . reflect . Method ;  import   java . net . MalformedURLException ;  import   java . net . Proxy ;  import   java . net . URL ;  import   java . net . URLClassLoader ;  import   java . net . URLConnection ;  import   java . net . URLEncoder ;  import    java . nio . channels . FileChannel ;  import    java . nio . channels . FileLock ;  import    java . nio . channels . OverlappingFileLockException ;  import  java . security .  * ;  import    java . security . cert . Certificate ;  import  java . util .  * ;  import   java . util . concurrent .  * ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import    com . threerings . getdown . util .  * ;  import     com . threerings . getdown . util . Base64 ;  import static     com . threerings . getdown . Log . log ;  import static     java . nio . charset . StandardCharsets . UTF_8 ;  import     com . threerings . getdown . net . Connector ;   public class Application  {   public static final String  CONFIG_FILE = "getdown.txt" ;   public static final String  VERSION_FILE = "version.txt" ;   public static final String  PROP_PASSTHROUGH_PREFIX = "app." ;   public static final String  SIGNATURE_SUFFIX = ".sig" ;   public static final String  MANIFEST_CLASS = "manifest" ;   public static final class UpdateInterface  {   public enum Step  {  UPDATE_JAVA  ( 10 ) ,  VERIFY_METADATA  ( 15 , 65 , 95 ) ,  DOWNLOAD  ( 40 ) ,  PATCH  ( 60 ) ,  VERIFY_RESOURCES  ( 70 , 97 ) ,  REDOWNLOAD_RESOURCES  ( 90 ) ,  UNPACK  ( 98 ) ,  LAUNCH  ( 99 )  ;   public final  List  < Integer >  defaultPercents ;  Step  (   int ...  percents )  {    this . defaultPercents =  intsToList  ( percents ) ; } }   public final String  name ;   public final  int  background ;   public final  List  < String >  rotatingBackgrounds ;   public final String  errorBackground ;   public final  List  < String >  iconImages ;   public final String  backgroundImage ;   public final String  progressImage ;   public final Rectangle  progress ;   public final  int  progressText ;   public final  int  progressBar ;   public final Rectangle  status ;   public final  int  statusText ;   public final  int  textShadow ;   public final String  installError ;   public final Rectangle  patchNotes ;   public final String  patchNotesUrl ;   public final boolean  hideDecorations ;   public final boolean  hideProgressText ;   public final  int  minShowSeconds ;   public final  Map  < Step ,  List  < Integer > >  stepPercentages ;    @ Override public String toString  ( )  {  return                                 "[name=" + name + ", bg=" + background + ", bg=" + backgroundImage + ", pi=" + progressImage + ", prect=" + progress + ", pt=" + progressText + ", pb=" + progressBar + ", srect=" + status + ", st=" + statusText + ", shadow=" + textShadow + ", err=" + installError + ", nrect=" + patchNotes + ", notes=" + patchNotesUrl + ", stepPercentages=" + stepPercentages + ", hideProgressText" + hideProgressText + ", minShow=" + minShowSeconds + "]" ; }   public UpdateInterface  (  Config config )  {    this . name =  config . getString  ( "ui.name" ) ;    this . progress =  config . getRect  ( "ui.progress" ,  new Rectangle  ( 5 , 5 , 300 , 15 ) ) ;    this . progressText =  config . getColor  ( "ui.progress_text" ,  Color . BLACK ) ;    this . hideProgressText =  config . getBoolean  ( "ui.hide_progress_text" ) ;    this . minShowSeconds =  config . getInt  ( "ui.min_show_seconds" , 5 ) ;    this . progressBar =  config . getColor  ( "ui.progress_bar" , 0x6699CC ) ;    this . status =  config . getRect  ( "ui.status" ,  new Rectangle  ( 5 , 25 , 500 , 100 ) ) ;    this . statusText =  config . getColor  ( "ui.status_text" ,  Color . BLACK ) ;    this . textShadow =  config . getColor  ( "ui.text_shadow" ,  Color . CLEAR ) ;    this . hideDecorations =  config . getBoolean  ( "ui.hide_decorations" ) ;    this . backgroundImage =  config . getString  ( "ui.background_image" ) ;   int  defaultBackground =   (  0.5f <  Color . brightness  (  this . progressText ) ) ?  Color . BLACK :  Color . WHITE ;    this . background =  config . getColor  ( "ui.background" , defaultBackground ) ;    this . progressImage =  config . getString  ( "ui.progress_image" ) ;    this . rotatingBackgrounds =  stringsToList  (  config . getMultiValue  ( "ui.rotating_background" ) ) ;    this . iconImages =  stringsToList  (  config . getMultiValue  ( "ui.icon" ) ) ;    this . errorBackground =  config . getString  ( "ui.error_background" ) ;  String  installError =  config . getUrl  ( "ui.install_error" , null ) ;    this . installError =   (  installError == null ) ? "m.default_install_error" :  MessageUtil . taint  ( installError ) ;    this . patchNotes =  config . getRect  ( "ui.patch_notes" ,  new Rectangle  ( 5 , 50 , 112 , 26 ) ) ;    this . patchNotesUrl =  config . getUrl  ( "ui.patch_notes_url" , null ) ;   EnumMap  < Step ,  List  < Integer > >  stepPercentages =  new  EnumMap  < >  (  Step . class ) ;  for ( Step step :  Step . values  ( ) )  {   stepPercentages . put  ( step ,  step . defaultPercents ) ; }  for (  UpdateInterface . Step step :   UpdateInterface . Step . values  ( ) )  {  String  spec =  config . getString  (  "ui.percents." +  step . name  ( ) ) ;  if  (  spec != null )  {  try  {   stepPercentages . put  ( step ,  intsToList  (  StringUtil . parseIntArray  ( spec ) ) ) ; }  catch (   Exception e )  {   log . warning  (    "Failed to parse percentages for " + step + ": " + spec ) ; } } }    this . stepPercentages =  Collections . unmodifiableMap  ( stepPercentages ) ; } }   public interface StatusDisplay  {  void updateStatus  (  String message ) ; }   public static class AuxGroup  {   public final String  name ;   public final  List  < Resource >  codes ;   public final  List  < Resource >  rsrcs ;   public AuxGroup  (  String name ,   List  < Resource > codes ,   List  < Resource > rsrcs )  {    this . name = name ;    this . codes =  Collections . unmodifiableList  ( codes ) ;    this . rsrcs =  Collections . unmodifiableList  ( rsrcs ) ; } }   public Application  (  EnvConfig envc )  {   _envc = envc ; }   public File getAppDir  ( )  {  return  _envc . appDir ; }   public boolean useCodeCache  ( )  {  return _useCodeCache ; }   public  int getCodeCacheRetentionDays  ( )  {  return _codeCacheRetentionDays ; }   public  int maxConcurrentDownloads  ( )  {  return _maxConcDownloads ; }   public Resource getConfigResource  ( )  {  try  {  return  createResource  ( CONFIG_FILE ,  Resource . NORMAL ) ; }  catch (   Exception e )  {  throw  new RuntimeException  (   "Invalid appbase '" + _vappbase + "'." , e ) ; } }   public  List  < Resource > getCodeResources  ( )  {  return _codes ; }   public  List  < Resource > getResources  ( )  {  return _resources ; }   public String getDigest  (  Resource resource )  {  return  _digest . getDigest  ( resource ) ; }   public  List  < Resource > getAllActiveResources  ( )  {   List  < Resource >  allResources =  new  ArrayList  < >  ( ) ;   allResources . addAll  (  getActiveCodeResources  ( ) ) ;   allResources . addAll  (  getActiveResources  ( ) ) ;  return allResources ; }   public AuxGroup getAuxGroup  (  String name )  {  return  _auxgroups . get  ( name ) ; }   public  Iterable  < AuxGroup > getAuxGroups  ( )  {  return  _auxgroups . values  ( ) ; }   public boolean isAuxGroupActive  (  String auxgroup )  {  Boolean  active =  _auxactive . get  ( auxgroup ) ;  if  (  active == null )  {   active =   getLocalPath  (  auxgroup + ".dat" ) . exists  ( ) ;   _auxactive . put  ( auxgroup , active ) ; }  return active ; }   public  List  < Resource > getActiveCodeResources  ( )  {   List  < Resource >  codes =  new  ArrayList  < >  (  getCodeResources  ( ) ) ;  for ( AuxGroup aux :  getAuxGroups  ( ) )  {  if  (  isAuxGroupActive  (  aux . name ) )  {   codes . addAll  (  aux . codes ) ; } }  return codes ; }   public  List  < Resource > getNativeResources  ( )  {   List  < Resource >  natives =  new  ArrayList  < >  ( ) ;  for ( Resource resource : _resources )  {  if  (  resource . isNative  ( ) )  {   natives . add  ( resource ) ; } }  return natives ; }   public  List  < Resource > getActiveResources  ( )  {   List  < Resource >  rsrcs =  new  ArrayList  < >  (  getResources  ( ) ) ;  for ( AuxGroup aux :  getAuxGroups  ( ) )  {  if  (  isAuxGroupActive  (  aux . name ) )  {   rsrcs . addAll  (  aux . rsrcs ) ; } }  return rsrcs ; }   public Resource getPatchResource  (  String auxgroup )  {  if  (  _targetVersion <= _version )  {   log . warning  ( "Requested patch resource for up-to-date or non-versioned application" , "cvers" , _version , "tvers" , _targetVersion ) ;  return null ; }  String  infix =   (  auxgroup == null ) ? "" :  (  "-" + auxgroup ) ;  String  pfile =    "patch" + infix + _version + ".dat" ;  try  {  URL  remote =  new URL  (  createVAppBase  ( _targetVersion ) ,  encodePath  ( pfile ) ) ;  return  new Resource  ( pfile , remote ,  getLocalPath  ( pfile ) ,  Resource . NORMAL ) ; }  catch (   Exception e )  {   log . warning  ( "Failed to create patch resource path" , "pfile" , pfile , "appbase" , _appbase , "tvers" , _targetVersion , "error" , e ) ;  return null ; } }   public File getJavaLocalDir  ( )  {  return _javaLocalDir ; }   public Resource getJavaVMResource  ( )  {  if  (  StringUtil . isBlank  ( _javaLocation ) )  {  return null ; }  String  vmfileExt =  _javaLocation . substring  (  _javaLocation . lastIndexOf  ( '.' ) ) ;  String  vmfile =   _javaLocalDir . getName  ( ) + vmfileExt ;  try  {  URL  remote =  new URL  (  createVAppBase  ( _targetVersion ) ,  encodePath  ( _javaLocation ) ) ;  return  new Resource  ( vmfile , remote ,  getLocalPath  ( vmfile ) ,  EnumSet . of  (   Resource . Attr . UNPACK ,   Resource . Attr . CLEAN ) ) ; }  catch (   Exception e )  {   log . warning  ( "Failed to create VM resource" , "vmfile" , vmfile , "appbase" , _appbase , "tvers" , _targetVersion , "javaloc" , _javaLocation , "error" , e ) ;  return null ; } }   public Resource getFullResource  ( )  {  String  file = "full" ;  try  {  URL  remote =  new URL  (  createVAppBase  ( _targetVersion ) ,  encodePath  ( file ) ) ;  return  new Resource  ( file , remote ,  getLocalPath  ( file ) ,  Resource . NORMAL ) ; }  catch (   Exception e )  {   log . warning  ( "Failed to create full resource path" , "file" , file , "appbase" , _appbase , "tvers" , _targetVersion , "error" , e ) ;  return null ; } }   public URL getTrackingURL  (  String event )  {  try  {  String  suffix =   _trackingURLSuffix == null ? "" : _trackingURLSuffix ;  String  ga =  getGATrackingCode  ( ) ;  return   _trackingURL == null ? null :  HostWhitelist . verify  (  new URL  (  _trackingURL +  encodePath  (   event + suffix + ga ) ) ) ; }  catch (   MalformedURLException mue )  {   log . warning  ( "Invalid tracking URL" , "path" , _trackingURL , "event" , event , "error" , mue ) ;  return null ; } }   public URL getTrackingProgressURL  (   int percent )  {  if  (   _trackingPcts == null ||  !  _trackingPcts . contains  ( percent ) )  {  return null ; }  return  getTrackingURL  (  "pct" + percent ) ; }   public String getTrackingCookieName  ( )  {  return _trackingCookieName ; }   public String getTrackingCookieProperty  ( )  {  return _trackingCookieProperty ; }   public Config init  (  boolean checkPlatform )  throws IOException  {  Config  config =  readConfig  ( _envc , checkPlatform ) ;   _version =  config . getLong  ( "version" ,  - 1L ) ;   initBase  ( config ) ;   initJava  ( config ) ;   initTracking  ( config ) ;   initResources  ( config ) ;   initArgs  ( config ) ;  return config ; }   protected void fillAssignmentListFromPairs  (  String pairLocation ,   List  < String > collector )  {  File  pairFile =  getLocalPath  ( pairLocation ) ;  if  (  pairFile . exists  ( ) )  {  try  {   List  <  String  [ ] >  args =  Config . parsePairs  ( pairFile ,  Config . createOpts  ( false ) ) ;  for (  String  [ ] pair : args )  {  if  (    pair [ 1 ] . length  ( ) == 0 )  {   collector . add  (  pair [ 0 ] ) ; } else  {   collector . add  (    pair [ 0 ] + "=" +  pair [ 1 ] ) ; } } }  catch (   Throwable t )  {   log . warning  (    "Failed to parse '" + pairFile + "': " + t ) ; } } }   public URL getRemoteURL  (  String path )  throws MalformedURLException  {  return  new URL  ( _vappbase ,  encodePath  ( path ) ) ; }   public File getLocalPath  (  String path )  {  return  new File  (  getAppDir  ( ) , path ) ; }   public boolean haveValidJavaVersion  ( )  {  if  (   _javaMinVersion == 0 &&  _javaMaxVersion == 0 )  return true ;  try  {   long  version =  SysProps . parseJavaVersion  ( _javaVersionProp , _javaVersionRegex ) ;   log . info  ( "Checking Java version" , "current" , version , "wantMin" , _javaMinVersion , "wantMax" , _javaMaxVersion ) ;  Resource  vmjar =  getJavaVMResource  ( ) ;  if  (   vmjar != null &&  vmjar . isMarkedValid  ( ) )  {  File  relfile =  new File  ( _javaLocalDir , "release" ) ;  if  (  !  relfile . exists  ( ) )  {   log . warning  ( "Unpacked JVM missing 'release' file. Assuming valid version." ) ;  return true ; }   long  vmvers =  VersionUtil . readReleaseVersion  ( relfile , _javaVersionRegex ) ;  if  (  vmvers == 0L )  {   log . warning  ( "Unable to read version from 'release' file. Assuming valid." ) ;  return true ; }   version = vmvers ;   log . info  (   "Checking version of unpacked JVM [vers=" + version + "]." ) ; }  if  ( _javaExactVersionRequired )  {  if  (  version == _javaMinVersion )  return true ; else  {   log . warning  ( "An exact Java VM version is required." , "current" , version , "required" , _javaMinVersion ) ;  return false ; } }  boolean  minVersionOK =   (  _javaMinVersion == 0 ) ||  (  version >= _javaMinVersion ) ;  boolean  maxVersionOK =   (  _javaMaxVersion == 0 ) ||  (  version <= _javaMaxVersion ) ;  return  minVersionOK && maxVersionOK ; }  catch (   RuntimeException re )  {   log . warning  ( "Unable to parse VM version, hoping for the best" , "error" , re , "needed" , _javaMinVersion ) ;  return true ; } }   public boolean hasOptimumJvmArgs  ( )  {  return  _optimumJvmArgs != null ; }   public boolean allowOffline  ( )  {  return _allowOffline ; }   public void attemptRecovery  (  StatusDisplay status )  throws IOException  {   status . updateStatus  ( "m.updating_metadata" ) ;   downloadConfigFile  ( ) ; }   public void updateMetadata  ( )  throws IOException  {  try  {   _vappbase =  createVAppBase  ( _targetVersion ) ; }  catch (   MalformedURLException mue )  {  String  err =  MessageUtil . tcompose  ( "m.invalid_appbase" , _appbase ) ;  throw  new IOException  ( err , mue ) ; }  try  {   downloadDigestFiles  ( ) ;   downloadConfigFile  ( ) ; }  catch (   IOException ex )  {  if  ( _allowOffline )  {   log . warning  ( "Failed to update digest files.  Attempting offline operaton." , ex ) ;  if  (  !  FileUtil . deleteHarder  (  getLocalPath  ( VERSION_FILE ) ) )  {   log . warning  ( "Deleting version.txt failed.  This probably isn't going to work." ) ; } } else  {  throw ex ; } } }   public Process createProcess  (  boolean optimum )  throws IOException  {   ArrayList  < String >  args =  new  ArrayList  < >  ( ) ;   args . add  (  LaunchUtil . getJVMBinaryPath  ( _javaLocalDir ,  _windebug || optimum ) ) ;  boolean  dashJarMode =  MANIFEST_CLASS . equals  ( _class ) ;  ClassPath  classPath =  PathBuilder . buildClassPath  ( this ) ;  if  (  ! dashJarMode )  {   args . add  ( "-classpath" ) ;   args . add  (  classPath . asArgumentString  ( ) ) ; }  if  (  LaunchUtil . isMacOS  ( ) )  {   args . add  (  "-Xdock:icon=" +   getLocalPath  ( _dockIconPath ) . getAbsolutePath  ( ) ) ;   args . add  (  "-Xdock:name=" + _dockName ) ; }   conn . addProxyArgs  ( args ) ;   args . add  (   "-D" +  Properties . GETDOWN + "=true" ) ;  ClassPath  javaLibPath =  PathBuilder . buildLibsPath  ( this , true ) ;  if  (  javaLibPath != null )  {   args . add  (  "-Djava.library.path=" +  javaLibPath . asArgumentString  ( ) ) ; }  for (   Map . Entry  < Object , Object > entry :   System . getProperties  ( ) . entrySet  ( ) )  {  String  key =  ( String )  entry . getKey  ( ) ;  if  (  key . startsWith  ( PROP_PASSTHROUGH_PREFIX ) )  {   key =  key . substring  (  PROP_PASSTHROUGH_PREFIX . length  ( ) ) ;   args . add  (    "-D" + key + "=" +  entry . getValue  ( ) ) ; } }  for ( String string : _jvmargs )  {   args . add  (  processArg  ( string ) ) ; }  if  (  optimum &&  _optimumJvmArgs != null )  {  for ( String string : _optimumJvmArgs )  {   args . add  (  processArg  ( string ) ) ; } }  for ( String string : _txtJvmArgs )  {   args . add  (  processArg  ( string ) ) ; }  if  ( dashJarMode )  {   args . add  ( "-jar" ) ;   args . add  (  classPath . asArgumentString  ( ) ) ; } else  {   args . add  ( _class ) ; }  for ( String string : _appargs )  {   args . add  (  processArg  ( string ) ) ; }   String  [ ]  envp =  createEnvironment  ( ) ;   String  [ ]  sargs =  args . toArray  (  new String  [  args . size  ( ) ] ) ;   log . info  (  "Running " +  StringUtil . join  ( sargs , "\n  " ) ) ;  return   Runtime . getRuntime  ( ) . exec  ( sargs , envp ,  getAppDir  ( ) ) ; }   protected  String  [ ] createEnvironment  ( )  {   List  < String >  envvar =  new  ArrayList  < >  ( ) ;   fillAssignmentListFromPairs  ( "env.txt" , envvar ) ;  if  (  envvar . isEmpty  ( ) )  {   log . info  ( "Didn't find any custom environment variables, not setting any." ) ;  return null ; }   List  < String >  envAssignments =  new  ArrayList  < >  ( ) ;  for ( String assignment : envvar )  {   envAssignments . add  (  processArg  ( assignment ) ) ; }  for (   Map . Entry  < String , String > environmentEntry :   System . getenv  ( ) . entrySet  ( ) )  {   envAssignments . add  (    environmentEntry . getKey  ( ) + "=" +  environmentEntry . getValue  ( ) ) ; }   String  [ ]  envp =  envAssignments . toArray  (  new String  [  envAssignments . size  ( ) ] ) ;   log . info  (  "Environment " +  StringUtil . join  ( envp , "\n " ) ) ;  return envp ; }   public void invokeDirect  ( )  throws IOException  {  ClassPath  classPath =  PathBuilder . buildClassPath  ( this ) ;   URL  [ ]  jarUrls =  classPath . asUrls  ( ) ;  URLClassLoader  loader =  new URLClassLoader  ( jarUrls ,  ClassLoader . getSystemClassLoader  ( ) )  {    @ Override protected PermissionCollection getPermissions  (  CodeSource code )  {  Permissions  perms =  new Permissions  ( ) ;   perms . add  (  new AllPermission  ( ) ) ;  return perms ; } } ;    Thread . currentThread  ( ) . setContextClassLoader  ( loader ) ;   log . info  ( "Configured URL class loader:" ) ;  for ( URL url : jarUrls )   log . info  (  "  " + url ) ;  for ( String jvmarg : _jvmargs )  {  if  (  jvmarg . startsWith  ( "-D" ) )  {   jvmarg =  processArg  (  jvmarg . substring  ( 2 ) ) ;   int  eqidx =  jvmarg . indexOf  ( '=' ) ;  if  (  eqidx ==  - 1 )  {   log . warning  (   "Bogus system property: '" + jvmarg + "'?" ) ; } else  {   System . setProperty  (  jvmarg . substring  ( 0 , eqidx ) ,  jvmarg . substring  (  eqidx + 1 ) ) ; } } }   Map  < String , String >  passProps =  new  HashMap  < >  ( ) ;  for (   Map . Entry  < Object , Object > entry :   System . getProperties  ( ) . entrySet  ( ) )  {  String  key =  ( String )  entry . getKey  ( ) ;  if  (  key . startsWith  ( PROP_PASSTHROUGH_PREFIX ) )  {   key =  key . substring  (  PROP_PASSTHROUGH_PREFIX . length  ( ) ) ;   passProps . put  ( key ,  ( String )  entry . getValue  ( ) ) ; } }  for (   Map . Entry  < String , String > entry :  passProps . entrySet  ( ) )  {   System . setProperty  (  entry . getKey  ( ) ,  entry . getValue  ( ) ) ; }   String  [ ]  args =  new String  [  _appargs . size  ( ) ] ;  for (   int  ii = 0 ;  ii <  args . length ;  ii ++ )    args [ ii ] =  processArg  (  _appargs . get  ( ii ) ) ;  try  {   log . info  (  "Loading " + _class ) ;   Class  <  ? >  appclass =  loader . loadClass  ( _class ) ;  Method  main =  appclass . getMethod  ( "main" ,  EMPTY_STRING_ARRAY . getClass  ( ) ) ;   log . info  (   "Invoking main({" +  StringUtil . join  ( args , ", " ) + "})" ) ;   main . invoke  ( null ,  new Object  [ ]  { args } ) ; }  catch (   Exception e )  {   log . warning  ( "Failure invoking app main" , e ) ; } }   protected String processArg  (  String arg )  {   arg =  arg . replace  ( "%APPDIR%" ,   getAppDir  ( ) . getAbsolutePath  ( ) ) ;   arg =  arg . replace  ( "%VERSION%" ,  String . valueOf  ( _version ) ) ;  if  (  arg . contains  ( ENV_VAR_PREFIX ) )  {  StringBuffer  sb =  new StringBuffer  ( ) ;  Matcher  matcher =  ENV_VAR_PATTERN . matcher  ( arg ) ;  while  (  matcher . find  ( ) )  {  String  varName =  matcher . group  ( 1 ) ,  varValue =  System . getenv  ( varName ) ;  String  repValue =   varValue == null ?  "MISSING:" + varName : varValue ;   matcher . appendReplacement  ( sb ,  Matcher . quoteReplacement  ( repValue ) ) ; }   matcher . appendTail  ( sb ) ;   arg =  sb . toString  ( ) ; }  return arg ; }   public boolean verifyMetadata  (  StatusDisplay status )  throws IOException  {   log . info  (  "Verifying application: " + _vappbase ) ;   log . info  (  "Version: " + _version ) ;   log . info  (  "Class: " + _class ) ;  try  {   _digest =  new Digest  (  getAppDir  ( ) , _strictComments ) ; }  catch (   IOException ioe )  {   log . info  (   "Failed to load digest: " +  ioe . getMessage  ( ) + ". Attempting recovery..." ) ; }  if  (  _version ==  - 1 )  {  String  olddig =   (  _digest == null ) ? "" :  _digest . getMetaDigest  ( ) ;  try  {   status . updateStatus  ( "m.checking" ) ;   downloadDigestFiles  ( ) ;   _digest =  new Digest  (  getAppDir  ( ) , _strictComments ) ;  if  (  !  olddig . equals  (  _digest . getMetaDigest  ( ) ) )  {   log . info  ( "Unversioned digest changed. Revalidating..." ) ;   status . updateStatus  ( "m.validating" ) ;   clearValidationMarkers  ( ) ; } }  catch (   IOException ioe )  {   log . warning  (   "Failed to refresh non-versioned digest: " +  ioe . getMessage  ( ) + ". Proceeding..." ) ; } }  if  (  _digest == null )  {   status . updateStatus  ( "m.updating_metadata" ) ;   downloadDigestFiles  ( ) ;   _digest =  new Digest  (  getAppDir  ( ) , _strictComments ) ; }  Resource  crsrc =  getConfigResource  ( ) ;  if  (  !  _digest . validateResource  ( crsrc , null ) )  {   status . updateStatus  ( "m.updating_metadata" ) ;   downloadConfigFile  ( ) ;   downloadDigestFiles  ( ) ;   _digest =  new Digest  (  getAppDir  ( ) , _strictComments ) ;   clearValidationMarkers  ( ) ;  if  (  _digest . validateResource  ( crsrc , null ) )  {   init  ( true ) ; } else  {   log . warning  (   CONFIG_FILE + " failed to validate even after redownloading. " + "Blindly forging onward." ) ; } }   _targetVersion = _version ;  if  (  _version !=  - 1 )  {  File  vfile =  getLocalPath  ( VERSION_FILE ) ;   long  fileVersion =  VersionUtil . readVersion  ( vfile ) ;  if  (  fileVersion !=  - 1 )  {   _targetVersion = fileVersion ; }  if  (  _latest != null )  {  try  {   List  <  String  [ ] >  vdata =  Config . parsePairs  (  new StringReader  (  conn . fetch  ( _latest ) ) ,  Config . createOpts  ( false ) ) ;  for (  String  [ ] pair : vdata )  {  if  (  "version" . equals  (  pair [ 0 ] ) )  {   _targetVersion =  Math . max  (  Long . parseLong  (  pair [ 1 ] ) , _targetVersion ) ;  if  (   fileVersion !=  - 1 &&  _targetVersion > fileVersion )  {  try  (  FileOutputStream fos =  new FileOutputStream  ( vfile ) ;  PrintStream out =  new PrintStream  ( fos ) )  {   out . println  ( _targetVersion ) ; } }  break ; } } }  catch (   Exception e )  {   log . warning  ( "Unable to retrieve version from latest config file." , e ) ; } } }  return  _version != _targetVersion ; }   public void verifyResources  (  ProgressObserver obs ,    int  [ ] alreadyValid ,   Set  < Resource > unpacked ,   Set  < Resource > toInstall ,   Set  < Resource > toDownload )  throws InterruptedException  {  ExecutorService  exec =  Executors . newFixedThreadPool  (  SysProps . threadPoolSize  ( ) ) ;   final  BlockingQueue  < Runnable >  actions =  new  LinkedBlockingQueue  < Runnable >  ( ) ;   final   int  [ ]  completed =  new  int  [ 1 ] ;   long  start =  System . currentTimeMillis  ( ) ;   List  < Resource >  rsrcs =  getAllActiveResources  ( ) ;    long  [ ]  sizes =  new  long  [  rsrcs . size  ( ) ] ;   long  totalSize = 0 ;  for (   int  ii = 0 ;  ii <  sizes . length ;  ii ++ )  {   totalSize +=   sizes [ ii ] =    rsrcs . get  ( ii ) . getLocal  ( ) . length  ( ) ; }   final ProgressObserver  fobs = obs ;   final ProgressAggregator  pagg =  new ProgressAggregator  (  new ProgressObserver  ( )  {   public void progress  (   final  int percent )  {   actions . add  (  new Runnable  ( )  {   public void run  ( )  {   fobs . progress  ( percent ) ; } } ) ; } } , sizes ) ;   final   int  [ ]  fAlreadyValid = alreadyValid ;   final  Set  < Resource >  toInstallAsync =  new  ConcurrentSkipListSet  < >  ( toInstall ) ;   final  Set  < Resource >  toDownloadAsync =  new  ConcurrentSkipListSet  < >  ( ) ;   final  Set  < Resource >  unpackedAsync =  new  ConcurrentSkipListSet  < >  ( ) ;  for (   int  ii = 0 ;  ii <  sizes . length ;  ii ++ )  {   final Resource  rsrc =  rsrcs . get  ( ii ) ;   final  int  index = ii ;   exec . execute  (  new Runnable  ( )  {   public void run  ( )  {   verifyResource  ( rsrc ,  pagg . startElement  ( index ) , fAlreadyValid , unpackedAsync , toInstallAsync , toDownloadAsync ) ;   actions . add  (  new Runnable  ( )  {   public void run  ( )  {    completed [ 0 ] += 1 ; } } ) ; } } ) ; }  while  (   completed [ 0 ] <  rsrcs . size  ( ) )  {  Runnable  action =  actions . poll  ( _verifyTimeout ,  TimeUnit . SECONDS ) ;  if  (  action == null )  {  throw  new IllegalStateException  ( "m.verify_timeout" ) ; }   action . run  ( ) ; }   exec . shutdown  ( ) ;   toInstall . addAll  ( toInstallAsync ) ;   toDownload . addAll  ( toDownloadAsync ) ;   unpacked . addAll  ( unpackedAsync ) ;   long  complete =  System . currentTimeMillis  ( ) ;   log . info  ( "Verified resources" , "count" ,  rsrcs . size  ( ) , "size" ,   (  totalSize / 1024 ) + "k" , "duration" ,   (  complete - start ) + "ms" ) ; }   private void verifyResource  (  Resource rsrc ,  ProgressObserver obs ,    int  [ ] alreadyValid ,   Set  < Resource > unpacked ,   Set  < Resource > toInstall ,   Set  < Resource > toDownload )  {  if  (  rsrc . isMarkedValid  ( ) )  {  if  (  alreadyValid != null )  {    alreadyValid [ 0 ] ++ ; }   obs . progress  ( 100 ) ;  return ; }  try  {  if  (  _digest . validateResource  ( rsrc , obs ) )  {  if  (   rsrc . getLocalNew  ( ) . exists  ( ) )  {   toInstall . add  ( rsrc ) ;  return ; }   rsrc . applyAttrs  ( ) ;   unpacked . add  ( rsrc ) ;   rsrc . markAsValid  ( ) ;  return ; } }  catch (   Exception e )  {   log . info  ( "Failure verifying resource. Requesting redownload..." , "rsrc" , rsrc , "error" , e ) ; }  finally  {   obs . progress  ( 100 ) ; }   toDownload . add  ( rsrc ) ; }   public void unpackResources  (  ProgressObserver obs ,   Set  < Resource > unpacked )  throws InterruptedException  {   List  < Resource >  rsrcs =  getActiveResources  ( ) ;  for (   Iterator  < Resource >  it =  rsrcs . iterator  ( ) ;  it . hasNext  ( ) ; )  {  Resource  rsrc =  it . next  ( ) ;  if  (   !  rsrc . shouldUnpack  ( ) ||  unpacked . contains  ( rsrc ) )  {   it . remove  ( ) ; } }    long  [ ]  sizes =  new  long  [  rsrcs . size  ( ) ] ;  for (   int  ii = 0 ;  ii <  sizes . length ;  ii ++ )  {    sizes [ ii ] =    rsrcs . get  ( ii ) . getLocal  ( ) . length  ( ) ; }  ProgressAggregator  pagg =  new ProgressAggregator  ( obs , sizes ) ;  for (   int  ii = 0 ;  ii <  sizes . length ;  ii ++ )  {  Resource  rsrc =  rsrcs . get  ( ii ) ;  ProgressObserver  pobs =  pagg . startElement  ( ii ) ;  try  {   rsrc . unpack  ( ) ; }  catch (   IOException ioe )  {   log . warning  ( "Failure unpacking resource" , "rsrc" , rsrc , ioe ) ; }   pobs . progress  ( 100 ) ; } }   public void clearValidationMarkers  ( )  {   clearValidationMarkers  (   getAllActiveResources  ( ) . iterator  ( ) ) ; }   public  long getVersion  ( )  {  return _version ; }   protected URL createVAppBase  (   long version )  throws MalformedURLException  {  String  url =   version < 0 ? _appbase :  _appbase . replace  ( "%VERSION%" ,  String . valueOf  ( version ) ) ;  return  HostWhitelist . verify  (  new URL  ( url ) ) ; }   protected void clearValidationMarkers  (   Iterator  < Resource > iter )  {  while  (  iter . hasNext  ( ) )  {    iter . next  ( ) . clearMarker  ( ) ; } }   protected void downloadConfigFile  ( )  throws IOException  {   downloadControlFile  ( CONFIG_FILE , 0 ) ; }   public synchronized boolean lockForUpdates  ( )  {  if  (   _lock != null &&  _lock . isValid  ( ) )  {  return true ; }  try  {   _lockChannel =   new RandomAccessFile  (  getLocalPath  ( "gettingdown.lock" ) , "rw" ) . getChannel  ( ) ; }  catch (   FileNotFoundException e )  {   log . warning  ( "Unable to create lock file" , "message" ,  e . getMessage  ( ) , e ) ;  return false ; }  try  {   _lock =  _lockChannel . tryLock  ( ) ; }  catch (   IOException e )  {   log . warning  ( "Unable to create lock" , "message" ,  e . getMessage  ( ) , e ) ;  return false ; }  catch (   OverlappingFileLockException e )  {   log . warning  ( "The lock is held elsewhere in this JVM" , e ) ;  return false ; }   log . info  (  "Able to lock for updates: " +  (  _lock != null ) ) ;  return  _lock != null ; }   public synchronized void releaseLock  ( )  {  if  (  _lock != null )  {   log . info  ( "Releasing lock" ) ;  try  {   _lock . release  ( ) ; }  catch (   IOException e )  {   log . warning  ( "Unable to release lock" , "message" ,  e . getMessage  ( ) , e ) ; }  try  {   _lockChannel . close  ( ) ; }  catch (   IOException e )  {   log . warning  ( "Unable to close lock channel" , "message" ,  e . getMessage  ( ) , e ) ; }   _lockChannel = null ;   _lock = null ; } }   protected void downloadDigestFiles  ( )  throws IOException  {  for (   int  version = 1 ;  version <=  Digest . VERSION ;  version ++ )  {   downloadControlFile  (  Digest . digestFile  ( version ) , version ) ; } }   protected void downloadControlFile  (  String path ,   int sigVersion )  throws IOException  {  File  target =  downloadFile  ( path ) ;  if  (  sigVersion > 0 )  {  if  (   _envc . certs . isEmpty  ( ) )  {   log . info  ( "No signing certs, not verifying digest.txt" , "path" , path ) ; } else  {  File  signatureFile =  downloadFile  (  path + SIGNATURE_SUFFIX ) ;    byte  [ ]  signature = null ;  try  (  FileInputStream signatureStream =  new FileInputStream  ( signatureFile ) )  {   signature =  StreamUtil . toByteArray  ( signatureStream ) ; }  finally  {   FileUtil . deleteHarder  ( signatureFile ) ; }    byte  [ ]  buffer =  new  byte  [ 8192 ] ;   int  length ,  validated = 0 ;  for ( Certificate cert :  _envc . certs )  {  try  (  FileInputStream dataInput =  new FileInputStream  ( target ) )  {  Signature  sig =  Signature . getInstance  (  Digest . sigAlgorithm  ( sigVersion ) ) ;   sig . initVerify  ( cert ) ;  while  (   (  length =  dataInput . read  ( buffer ) ) !=  - 1 )  {   sig . update  ( buffer , 0 , length ) ; }  if  (  !  sig . verify  (  Base64 . decode  ( signature ,  Base64 . DEFAULT ) ) )  {   log . info  ( "Signature does not match" , "cert" ,  cert . getPublicKey  ( ) ) ;  continue ; } else  {   log . info  ( "Signature matches" , "cert" ,  cert . getPublicKey  ( ) ) ;   validated ++ ; } }  catch (   IOException ioe )  {   log . warning  (    "Failure validating signature of " + target + ": " + ioe ) ; }  catch (   GeneralSecurityException gse )  { } }  if  (  validated == 0 )  {   FileUtil . deleteHarder  ( target ) ;  throw  new IOException  ( "m.corrupt_digest_signature_error" ) ; } } }  File  original =  getLocalPath  ( path ) ;  if  (  !  FileUtil . renameTo  ( target , original ) )  {  throw  new IOException  (     "Failed to rename(" + target + ", " + original + ")" ) ; } }   protected File downloadFile  (  String path )  throws IOException  {  File  target =  getLocalPath  (  path + "_new" ) ;  URL  targetURL = null ;  try  {   targetURL =  getRemoteURL  ( path ) ; }  catch (   Exception e )  {   log . warning  ( "Requested to download invalid control file" , "appbase" , _vappbase , "path" , path , "error" , e ) ;  throw  new IOException  (   "Invalid path '" + path + "'." , e ) ; }   log . info  (     "Attempting to refetch '" + path + "' from '" + targetURL + "'." ) ;   conn . download  ( targetURL , target ) ;  return target ; }   protected Resource createResource  (  String path ,   EnumSet  <  Resource . Attr > attrs )  throws MalformedURLException  {  return  new Resource  ( path ,  getRemoteURL  ( path ) ,  getLocalPath  ( path ) , attrs ) ; }   protected static void addAll  (   String  [ ] values ,   List  < String > target )  {  if  (  values != null )  {   Collections . addAll  ( target , values ) ; } }   public static  List  < Integer > intsToList  (    int  [ ] values )  {   List  < Integer >  list =  new  ArrayList  < >  (  values . length ) ;  for (  int val : values )  {   list . add  ( val ) ; }  return  Collections . unmodifiableList  ( list ) ; }   public static  List  < String > stringsToList  (   String  [ ] values )  {  return   values == null ? null :  Collections . unmodifiableList  (  Arrays . asList  ( values ) ) ; }   protected void parseResources  (  Config config ,  String name ,   EnumSet  <  Resource . Attr > attrs ,   List  < Resource > list )  {   String  [ ]  rsrcs =  config . getMultiValue  ( name ) ;  if  (  rsrcs == null )  {  return ; }  for ( String rsrc : rsrcs )  {  try  {   list . add  (  createResource  ( rsrc , attrs ) ) ; }  catch (   Exception e )  {   log . warning  (    "Invalid resource '" + rsrc + "'. " + e ) ; } } }   protected String getGATrackingCode  ( )  {  if  (  _trackingGAHash == null )  {  return "" ; }   long  time =   System . currentTimeMillis  ( ) / 1000 ;  if  (  _trackingStart == 0 )  {   _trackingStart = time ; }  if  (  _trackingId == 0 )  {   int  low = 100000000 ,  high = 1000000000 ;   _trackingId =  low +  _rando . nextInt  (  high - low ) ; }  StringBuilder  cookie =   new StringBuilder  ( "&utmcc=__utma%3D" ) . append  ( _trackingGAHash ) ;    cookie . append  ( "." ) . append  ( _trackingId ) ;      cookie . append  ( "." ) . append  ( _trackingStart ) . append  ( "." ) . append  ( _trackingStart ) ;     cookie . append  ( "." ) . append  ( time ) . append  ( ".1%3B%2B" ) ;     cookie . append  ( "__utmz%3D" ) . append  ( _trackingGAHash ) . append  ( "." ) ;    cookie . append  ( _trackingStart ) . append  ( ".1.1." ) ;   cookie . append  ( "utmcsr%3D(direct)%7Cutmccn%3D(direct)%7Cutmcmd%3D(none)%3B" ) ;   int  low = 1000000000 ,  high = 2000000000 ;    cookie . append  ( "&utmn=" ) . append  (  _rando . nextInt  (  high - low ) ) ;  return  cookie . toString  ( ) ; }   protected static String encodePath  (  String path )  {  try  {  return    URLEncoder . encode  ( path , "UTF-8" ) . replace  ( "%2F" , "/" ) . replace  ( "+" , "%20" ) ; }  catch (   UnsupportedEncodingException ue )  {   log . warning  (    "Failed to URL encode " + path + ": " + ue ) ;  return path ; } }   protected final EnvConfig  _envc ;   protected Digest  _digest ;   protected  long  _version =  - 1 ;   protected  long  _targetVersion =  - 1 ;   protected String  _appbase ;   protected URL  _vappbase ;   protected URL  _latest ;   protected String  _class ;   protected String  _dockName ;   protected String  _dockIconPath ;   protected boolean  _strictComments ;   protected boolean  _windebug ;   protected boolean  _allowOffline ;   protected  int  _maxConcDownloads ;   protected String  _trackingURL ;   protected  Set  < Integer >  _trackingPcts ;   protected String  _trackingCookieName ;   protected String  _trackingCookieProperty ;   protected String  _trackingURLSuffix ;   protected String  _trackingGAHash ;   protected  long  _trackingStart ;   protected  int  _trackingId ;   protected String  _javaVersionProp = "java.version" ;   protected String  _javaVersionRegex = "(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(_\\d+)?)?)?" ;   protected  long  _javaMinVersion ,  _javaMaxVersion ;   protected boolean  _javaExactVersionRequired ;   protected String  _javaLocation ;   protected File  _javaLocalDir ;   protected  List  < Resource >  _codes =  new  ArrayList  < >  ( ) ;   protected  List  < Resource >  _resources =  new  ArrayList  < >  ( ) ;   protected  int  _verifyTimeout = 60 ;   protected boolean  _useCodeCache ;   protected  int  _codeCacheRetentionDays ;   protected  Map  < String , AuxGroup >  _auxgroups =  new  HashMap  < >  ( ) ;   protected  Map  < String , Boolean >  _auxactive =  new  HashMap  < >  ( ) ;   protected  List  < String >  _jvmargs =  new  ArrayList  < >  ( ) ;   protected  List  < String >  _appargs =  new  ArrayList  < >  ( ) ;   protected  String  [ ]  _optimumJvmArgs ;   protected  List  < String >  _txtJvmArgs =  new  ArrayList  < >  ( ) ;   protected FileLock  _lock ;   protected FileChannel  _lockChannel ;   protected Random  _rando =  new Random  ( ) ;   protected static final  String  [ ]  EMPTY_STRING_ARRAY =  new String  [ 0 ] ;   protected static final String  ENV_VAR_PREFIX = "%ENV." ;   protected static final Pattern  ENV_VAR_PATTERN =  Pattern . compile  ( "%ENV\\.(.*?)%" ) ;   public static Config readConfig  (  EnvConfig envc ,  boolean checkPlatform )  throws IOException  {  Config  config = null ;  File  cfgfile =  new File  (  envc . appDir , CONFIG_FILE ) ;   Config . ParseOpts  opts =  Config . createOpts  ( checkPlatform ) ;  try  {  if  (  cfgfile . exists  ( ) )  {   config =  Config . parseConfig  ( cfgfile , opts ) ; } else  if  (   (  cfgfile =  new File  (  envc . appDir ,   Application . CONFIG_FILE + "_old" ) ) . exists  ( ) )  {   config =  Config . parseConfig  ( cfgfile , opts ) ; } else  {   log . info  ( "Found no getdown.txt file" , "appdir" ,  envc . appDir ) ; } }  catch (   Exception e )  {   log . warning  ( "Failure reading config file" , "file" , config , e ) ; }  if  (  config == null )  {   log . info  ( "Using 'appbase' from bootstrap config" , "appbase" ,  envc . appBase ) ;   Map  < String , Object >  cdata =  new  HashMap  < >  ( ) ;   cdata . put  ( "appbase" ,  envc . appBase ) ;   config =  new Config  ( cdata ) ; }  return config ; }   public Connector  conn =  Connector . DEFAULT ;   public void initBase  (  Config config )  throws IOException  {   _appbase =  config . getString  ( "appbase" ) ;  if  (  _appbase == null )  {  throw  new RuntimeException  ( "m.missing_appbase" ) ; }   _appbase =  processArg  (  SysProps . overrideAppbase  ( _appbase ) ) ;  if  (  !  _appbase . endsWith  ( "/" ) )  {   _appbase += "/" ; }   _version =  config . getLong  ( "version" ,  - 1L ) ;  try  {   _vappbase =  createVAppBase  ( _version ) ; }  catch (   MalformedURLException mue )  {  String  err =  MessageUtil . tcompose  ( "m.invalid_appbase" , _appbase ) ;  throw  new IOException  ( err , mue ) ; }  String  latest =  config . getString  ( "latest" ) ;  if  (  latest != null )  {   latest =  processArg  ( latest ) ;  if  (  latest . startsWith  ( _appbase ) )  {   latest =  _appbase +  latest . substring  (  _appbase . length  ( ) ) ; } else  {   latest =  SysProps . replaceDomain  ( latest ) ; }  try  {   _latest =  HostWhitelist . verify  (  new URL  ( latest ) ) ; }  catch (   MalformedURLException mue )  {   log . warning  ( "Invalid URL for latest attribute." , mue ) ; } }   _strictComments =  config . getBoolean  ( "strict_comments" ) ;   _allowOffline =  config . getBoolean  ( "allow_offline" ) ;   _useCodeCache =  config . getBoolean  ( "use_code_cache" ) ;   _codeCacheRetentionDays =  config . getInt  ( "code_cache_retention_days" , 7 ) ;   _maxConcDownloads =  Math . max  ( 1 ,  config . getInt  ( "max_concurrent_downloads" ,  SysProps . threadPoolSize  ( ) ) ) ;   _verifyTimeout =  config . getInt  ( "verify_timeout" , 60 ) ; }   public void initJava  (  Config config )  {   _javaVersionProp =  config . getString  ( "java_version_prop" , _javaVersionProp ) ;   _javaVersionRegex =  config . getString  ( "java_version_regex" , _javaVersionRegex ) ;   _javaMinVersion =  config . getLong  ( "java_version" , _javaMinVersion ) ;   _javaMinVersion =  config . getLong  ( "java_min_version" , _javaMinVersion ) ;   _javaMaxVersion =  config . getLong  ( "java_max_version" , _javaMaxVersion ) ;   _javaExactVersionRequired =  config . getBoolean  ( "java_exact_version_required" ) ;   _javaLocation =  config . getString  ( "java_location" ) ;   _javaLocalDir =  getLocalPath  (  config . getString  ( "java_local_dir" ,  LaunchUtil . LOCAL_JAVA_DIR ) ) ; }   public void initTracking  (  Config config )  {   _trackingURL =  config . getString  ( "tracking_url" ) ;  String  trackPcts =  config . getString  ( "tracking_percents" ) ;  if  (  !  StringUtil . isBlank  ( trackPcts ) )  {   _trackingPcts =  new  HashSet  < >  ( ) ;  for (  int pct :  StringUtil . parseIntArray  ( trackPcts ) )  {   _trackingPcts . add  ( pct ) ; } } else  if  (  !  StringUtil . isBlank  ( _trackingURL ) )  {   _trackingPcts =  new  HashSet  < >  ( ) ;   _trackingPcts . add  ( 50 ) ; }   _trackingCookieName =  config . getString  ( "tracking_cookie_name" ) ;   _trackingCookieProperty =  config . getString  ( "tracking_cookie_property" ) ;   _trackingURLSuffix =  config . getString  ( "tracking_url_suffix" ) ;   _trackingGAHash =  config . getString  ( "tracking_ga_hash" ) ; }   public void initResources  (  Config config )  throws IOException  {   _codes . clear  ( ) ;   _resources . clear  ( ) ;   _auxgroups . clear  ( ) ;  if  (    config . getMultiValue  ( "code" ) == null &&   config . getMultiValue  ( "ucode" ) == null )  {  throw  new IOException  ( "m.missing_code" ) ; }   parseResources  ( config , "code" ,  Resource . NORMAL , _codes ) ;   parseResources  ( config , "ucode" ,  Resource . UNPACK , _codes ) ;   parseResources  ( config , "resource" ,  Resource . NORMAL , _resources ) ;   parseResources  ( config , "uresource" ,  Resource . UNPACK , _resources ) ;   parseResources  ( config , "xresource" ,  Resource . EXEC , _resources ) ;   parseResources  ( config , "presource" ,  Resource . PRELOAD , _resources ) ;   parseResources  ( config , "nresource" ,  Resource . NATIVE , _resources ) ;  for ( String auxgroup :  config . getList  ( "auxgroups" ) )  {   List  < Resource >  codes =  new  ArrayList  < >  ( ) ;   parseResources  ( config ,  auxgroup + ".code" ,  Resource . NORMAL , codes ) ;   parseResources  ( config ,  auxgroup + ".ucode" ,  Resource . UNPACK , codes ) ;   List  < Resource >  rsrcs =  new  ArrayList  < >  ( ) ;   parseResources  ( config ,  auxgroup + ".resource" ,  Resource . NORMAL , rsrcs ) ;   parseResources  ( config ,  auxgroup + ".xresource" ,  Resource . EXEC , rsrcs ) ;   parseResources  ( config ,  auxgroup + ".uresource" ,  Resource . UNPACK , rsrcs ) ;   parseResources  ( config ,  auxgroup + ".presource" ,  Resource . PRELOAD , rsrcs ) ;   parseResources  ( config ,  auxgroup + ".nresource" ,  Resource . NATIVE , rsrcs ) ;   _auxgroups . put  ( auxgroup ,  new AuxGroup  ( auxgroup , codes , rsrcs ) ) ; } }   public void initArgs  (  Config config )  throws IOException  {   _jvmargs . clear  ( ) ;   _appargs . clear  ( ) ;   _txtJvmArgs . clear  ( ) ;  String  appPrefix =    _envc . appId == null ? "" :  (   _envc . appId + "." ) ;   _class =  config . getString  ( "class" ) ;  if  (   appPrefix . length  ( ) > 0 )  {   _class =  config . getString  (  appPrefix + "class" , _class ) ; }  if  (  _class == null )  {  throw  new IOException  ( "m.missing_class" ) ; }   addAll  (  config . getMultiValue  ( "jvmarg" ) , _jvmargs ) ;  if  (   appPrefix . length  ( ) > 0 )  {   addAll  (  config . getMultiValue  (  appPrefix + "jvmarg" ) , _jvmargs ) ; }   _optimumJvmArgs =  config . getMultiValue  ( "optimum_jvmarg" ) ;   addAll  (  config . getMultiValue  (  appPrefix + "apparg" ) , _appargs ) ;   _appargs . addAll  (  _envc . appArgs ) ;   fillAssignmentListFromPairs  ( "extra.txt" , _txtJvmArgs ) ;   _dockName =  config . getString  ( "ui.name" ) ;   _dockIconPath =  config . getString  ( "ui.mac_dock_icon" , "../desktop.icns" ) ;   _windebug =   getLocalPath  ( "debug.txt" ) . exists  ( ) ; } }