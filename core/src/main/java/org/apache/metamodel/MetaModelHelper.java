  package   org . apache . metamodel ;   import    java . util . Map . Entry ;  import    java . util . stream . Collectors ;  import    java . util . stream . Stream ;  import     org . apache . metamodel . data . CachingDataSetHeader ;  import     org . apache . metamodel . data . DataSet ;  import     org . apache . metamodel . data . DataSetHeader ;  import     org . apache . metamodel . data . DefaultRow ;  import     org . apache . metamodel . data . EmptyDataSet ;  import     org . apache . metamodel . data . FilteredDataSet ;  import     org . apache . metamodel . data . FirstRowDataSet ;  import     org . apache . metamodel . data . IRowFilter ;  import     org . apache . metamodel . data . InMemoryDataSet ;  import     org . apache . metamodel . data . MaxRowsDataSet ;  import     org . apache . metamodel . data . Row ;  import     org . apache . metamodel . data . ScalarFunctionDataSet ;  import     org . apache . metamodel . data . SimpleDataSetHeader ;  import     org . apache . metamodel . data . SubSelectionDataSet ;  import     org . apache . metamodel . query . FilterItem ;  import     org . apache . metamodel . query . FromItem ;  import     org . apache . metamodel . query . GroupByItem ;  import     org . apache . metamodel . query . OrderByItem ;  import     org . apache . metamodel . query . Query ;  import     org . apache . metamodel . query . ScalarFunction ;  import     org . apache . metamodel . query . SelectItem ;  import      org . apache . metamodel . query . parser . QueryParser ;  import     org . apache . metamodel . schema . Column ;  import     org . apache . metamodel . schema . ColumnType ;  import     org . apache . metamodel . schema . Schema ;  import     org . apache . metamodel . schema . SuperColumnType ;  import     org . apache . metamodel . schema . Table ;  import     org . apache . metamodel . util . AggregateBuilder ;  import     org . apache . metamodel . util . CollectionUtils ;  import     org . apache . metamodel . util . ObjectComparator ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import  java . util .  * ;   public final class MetaModelHelper  {   private final static Logger  logger =  LoggerFactory . getLogger  (  MetaModelHelper . class ) ;   private MetaModelHelper  ( )  { }   public static  Table  [ ] getTables  (   Collection  < Table > tableList ,   Iterable  < Column > columnList )  {   HashSet  < Table >  set =  new  HashSet  < Table >  ( ) ;   set . addAll  ( tableList ) ;  for ( Column column : columnList )  {   set . add  (  column . getTable  ( ) ) ; }  return  set . toArray  (  new Table  [  set . size  ( ) ] ) ; }   public static boolean isInformationSchema  (  Schema schema )  {  String  name =  schema . getName  ( ) ;  return  isInformationSchema  ( name ) ; }   public static boolean isInformationSchema  (  String name )  {  if  (  name == null )  {  return false ; }  return   QueryPostprocessDataContext . INFORMATION_SCHEMA_NAME . equals  (  name . toLowerCase  ( ) ) ; }   public static  Table  [ ] getTables  (   Iterable  < Column > columns )  {   ArrayList  < Table >  result =  new  ArrayList  < Table >  ( ) ;  for ( Column column : columns )  {  Table  table =  column . getTable  ( ) ;  if  (  !  result . contains  ( table ) )  {   result . add  ( table ) ; } }  return  result . toArray  (  new Table  [  result . size  ( ) ] ) ; }   public static  Column  [ ] getTableColumns  (  Table table ,   Iterable  < Column > columns )  {  if  (  table == null )  {  return  new Column  [ 0 ] ; }   final  List  < Column >  result =  new  ArrayList  < Column >  ( ) ;  for ( Column column : columns )  {   final boolean  sameTable =  table . equals  (  column . getTable  ( ) ) ;  if  ( sameTable )  {   result . add  ( column ) ; } }  return  result . toArray  (  new Column  [  result . size  ( ) ] ) ; }   public static  Column  [ ] getTableColumns  (  Table table ,   Column  [ ] columns )  {  return  getTableColumns  ( table ,  Arrays . asList  ( columns ) ) ; }   public static DataSet getCarthesianProduct  (  DataSet ...  fromDataSets )  {  return  getCarthesianProduct  ( fromDataSets ,  new FilterItem  [ 0 ] ) ; }   public static DataSet getCarthesianProduct  (   DataSet  [ ] fromDataSets ,   Iterable  < FilterItem > whereItems )  {  assert  (   fromDataSets . length > 0 ) ;  if  (   fromDataSets . length == 1 )  {  return  getFiltered  (  fromDataSets [ 0 ] , whereItems ) ; } 
<<<<<<<
 for ( DataSet dataSet : fromDataSets )  {  for (   int  i = 0 ;  i <   dataSet . getSelectItems  ( ) . size  ( ) ;  i ++ )  {  SelectItem  item =   dataSet . getSelectItems  ( ) . get  ( i ) ;   selectItems . add  ( item ) ; } }
=======
>>>>>>>
 
<<<<<<<
 for (   int  fromDataSetIndex = 0 ;  fromDataSetIndex <  fromDataSets . length ;  fromDataSetIndex ++ )  {  DataSet  fromDataSet =  fromDataSets [ fromDataSetIndex ] ;   List  < SelectItem >  fromSelectItems =  fromDataSet . getSelectItems  ( ) ;  if  (  fromDataSetIndex == 0 )  {  while  (  fromDataSet . next  ( ) )  {   Object  [ ]  values =   fromDataSet . getRow  ( ) . getValues  ( ) ;   Object  [ ]  row =  new Object  [  selectItems . size  ( ) ] ;   System . arraycopy  ( values , 0 , row , selectItemOffset ,  values . length ) ;   data . add  ( row ) ; }   fromDataSet . close  ( ) ; } else  {   List  <  Object  [ ] >  fromDataRows =  new  ArrayList  <  Object  [ ] >  ( ) ;  while  (  fromDataSet . next  ( ) )  {   fromDataRows . add  (   fromDataSet . getRow  ( ) . getValues  ( ) ) ; }   fromDataSet . close  ( ) ;  for (   int  i = 0 ;  i <  data . size  ( ) ;  i =  i +  fromDataRows . size  ( ) )  {   Object  [ ]  originalRow =  data . get  ( i ) ;   data . remove  ( i ) ;  for (   int  j = 0 ;  j <  fromDataRows . size  ( ) ;  j ++ )  {   Object  [ ]  newRow =  fromDataRows . get  ( j ) ;   System . arraycopy  ( newRow , 0 , originalRow , selectItemOffset ,  newRow . length ) ;   data . add  (  i + j ,  originalRow . clone  ( ) ) ; } } }   selectItemOffset +=  fromSelectItems . size  ( ) ; }
=======
>>>>>>>
   Iterator  < DataSet >  dsIter =   Arrays . asList  ( fromDataSets ) . iterator  ( ) ;  DataSet  joined =  dsIter . next  ( ) ;  while  (  dsIter . hasNext  ( ) )  {   joined =  nestedLoopJoin  (  dsIter . next  ( ) , joined ,  ( whereItems ) ) ; }  return joined ; }   public static DataSet getCarthesianProduct  (   DataSet  [ ] fromDataSets ,  FilterItem ...  filterItems )  {  return  getCarthesianProduct  ( fromDataSets ,  Arrays . asList  ( filterItems ) ) ; }   public static DataSet getFiltered  (  DataSet dataSet ,   Iterable  < FilterItem > filterItems )  {   List  < IRowFilter >  filters =  CollectionUtils . map  ( filterItems ,  filterItem ->  {  return filterItem ; } ) ;  if  (  filters . isEmpty  ( ) )  {  return dataSet ; }  return  new FilteredDataSet  ( dataSet ,  filters . toArray  (  new IRowFilter  [  filters . size  ( ) ] ) ) ; }   public static DataSet getFiltered  (  DataSet dataSet ,  FilterItem ...  filterItems )  {  return  getFiltered  ( dataSet ,  Arrays . asList  ( filterItems ) ) ; }   public static DataSet getSelection  (   final  List  < SelectItem > selectItems ,   final DataSet dataSet )  {   final  List  < SelectItem >  dataSetSelectItems =  dataSet . getSelectItems  ( ) ;  if  (  selectItems . equals  ( dataSetSelectItems ) )  {  return dataSet ; }   final  List  < SelectItem >  scalarFunctionSelectItemsToEvaluate =  new  ArrayList  < >  ( ) ;  for ( SelectItem selectItem : selectItems )  {  if  (   selectItem . getScalarFunction  ( ) != null )  {  if  (   !  dataSetSelectItems . contains  ( selectItem ) &&  dataSetSelectItems . contains  (  selectItem . replaceFunction  ( null ) ) )  {   scalarFunctionSelectItemsToEvaluate . add  ( selectItem ) ; } } }  if  (  scalarFunctionSelectItemsToEvaluate . isEmpty  ( ) )  {  return  new SubSelectionDataSet  ( selectItems , dataSet ) ; }   final ScalarFunctionDataSet  scalaFunctionDataSet =  new ScalarFunctionDataSet  ( scalarFunctionSelectItemsToEvaluate , dataSet ) ;  return  new SubSelectionDataSet  ( selectItems , scalaFunctionDataSet ) ; }   public static DataSet getSelection  (   SelectItem  [ ] selectItems ,  DataSet dataSet )  {  return  getSelection  (  Arrays . asList  ( selectItems ) , dataSet ) ; }   public static DataSet getGrouped  (   List  < SelectItem > selectItems ,  DataSet dataSet ,   Collection  < GroupByItem > groupByItems )  {  return  getGrouped  ( selectItems , dataSet , groupByItems ) ; }   public static DataSet getGrouped  (   List  < SelectItem > selectItems ,  DataSet dataSet ,   List  < GroupByItem > groupByItems )  {  DataSet  result = dataSet ;  if  (   groupByItems != null &&   groupByItems . size  ( ) > 0 )  {   Map  < Row ,  Map  < SelectItem ,  List  < Object > > >  uniqueRows =  new  HashMap  < Row ,  Map  < SelectItem ,  List  < Object > > >  ( ) ;   final  List  < SelectItem >  groupBySelects =    groupByItems . stream  ( ) . map  (  gbi ->  gbi . getSelectItem  ( ) ) . collect  (  Collectors . toList  ( ) ) ;   final DataSetHeader  groupByHeader =  new CachingDataSetHeader  ( groupBySelects ) ;   List  < SelectItem >  functionItems =  getAggregateFunctionSelectItems  ( selectItems ) ;  while  (  dataSet . next  ( ) )  {  Row  row =  dataSet . getRow  ( ) ;  Row  uniqueRow =  row . getSubSelection  ( groupByHeader ) ;   Map  < SelectItem ,  List  < Object > >  functionInput ;  if  (  !  uniqueRows . containsKey  ( uniqueRow ) )  {   functionInput =  new  HashMap  < SelectItem ,  List  < Object > >  ( ) ;  for ( SelectItem item : functionItems )  {   functionInput . put  ( item ,  new  ArrayList  < Object >  ( ) ) ; }   uniqueRows . put  ( uniqueRow , functionInput ) ; } else  {   functionInput =  uniqueRows . get  ( uniqueRow ) ; }  for ( SelectItem item : functionItems )  {   List  < Object >  objects =  functionInput . get  ( item ) ;  Column  column =  item . getColumn  ( ) ;  if  (  column != null )  {  Object  value =  row . getValue  (  new SelectItem  ( column ) ) ;   objects . add  ( value ) ; } else  if  (  SelectItem . isCountAllItem  ( item ) )  {   objects . add  ( "" ) ; } else  {  throw  new IllegalArgumentException  (  "Expression function not supported: " + item ) ; } } }   dataSet . close  ( ) ;   final  List  < Row >  resultData =  new  ArrayList  < Row >  ( ) ;   final DataSetHeader  resultHeader =  new CachingDataSetHeader  ( selectItems ) ;  for (  Entry  < Row ,  Map  < SelectItem ,  List  < Object > > > entry :  uniqueRows . entrySet  ( ) )  {  Row  row =  entry . getKey  ( ) ;   Map  < SelectItem ,  List  < Object > >  functionInput =  entry . getValue  ( ) ;   Object  [ ]  resultRow =  new Object  [  selectItems . size  ( ) ] ;   int  i = 0 ;  for ( SelectItem item : selectItems )  {   int  uniqueRowIndex =  row . indexOf  ( item ) ;  if  (  uniqueRowIndex !=  - 1 )  {    resultRow [ i ] =  row . getValue  ( uniqueRowIndex ) ; } else  {   List  < Object >  objects =  functionInput . get  ( item ) ;  if  (  objects != null )  {  Object  functionResult =   item . getAggregateFunction  ( ) . evaluate  (  objects . toArray  ( ) ) ;    resultRow [ i ] = functionResult ; } else  {  if  (   item . getAggregateFunction  ( ) != null )  {   logger . error  ( "No function input found for SelectItem: {}" , item ) ; } } }   i ++ ; }   resultData . add  (  new DefaultRow  ( resultHeader , resultRow , null ) ) ; }  if  (  resultData . isEmpty  ( ) )  {   result =  new EmptyDataSet  ( selectItems ) ; } else  {   result =  new InMemoryDataSet  ( resultHeader , resultData ) ; } }   result =  getSelection  ( selectItems , result ) ;  return result ; }   public static DataSet getAggregated  (   List  < SelectItem > workSelectItems ,  DataSet dataSet )  {   final  List  < SelectItem >  functionItems =  getAggregateFunctionSelectItems  ( workSelectItems ) ;  if  (  functionItems . isEmpty  ( ) )  {  return dataSet ; }   final  Map  < SelectItem ,  AggregateBuilder  <  ? > >  aggregateBuilders =  new  HashMap  < SelectItem ,  AggregateBuilder  <  ? > >  ( ) ;  for ( SelectItem item : functionItems )  {   aggregateBuilders . put  ( item ,   item . getAggregateFunction  ( ) . createAggregateBuilder  ( ) ) ; }   final DataSetHeader  header ;   final boolean  onlyAggregates ;  if  (   functionItems . size  ( ) !=  workSelectItems . size  ( ) )  {   onlyAggregates = false ;   header =  new CachingDataSetHeader  ( workSelectItems ) ; } else  {   onlyAggregates = true ;   header =  new SimpleDataSetHeader  ( workSelectItems ) ; }   final  List  < Row >  resultRows =  new  ArrayList  < Row >  ( ) ;  while  (  dataSet . next  ( ) )  {   final Row  inputRow =  dataSet . getRow  ( ) ;  for ( SelectItem item : functionItems )  {   final  AggregateBuilder  <  ? >  aggregateBuilder =  aggregateBuilders . get  ( item ) ;   final Column  column =  item . getColumn  ( ) ;  if  (  column != null )  {  Object  value =  inputRow . getValue  (  new SelectItem  ( column ) ) ;   aggregateBuilder . add  ( value ) ; } else  if  (  SelectItem . isCountAllItem  ( item ) )  {   aggregateBuilder . add  ( "" ) ; } else  {  throw  new IllegalArgumentException  (  "Expression function not supported: " + item ) ; } }  if  (  ! onlyAggregates )  {   final  Object  [ ]  values =  new Object  [  header . size  ( ) ] ;  for (   int  i = 0 ;  i <  header . size  ( ) ;  i ++ )  {   final Object  value =  inputRow . getValue  (  header . getSelectItem  ( i ) ) ;  if  (  value != null )  {    values [ i ] = value ; } }   resultRows . add  (  new DefaultRow  ( header , values ) ) ; } }   dataSet . close  ( ) ;   Map  < SelectItem , Object >  functionResult =  new  HashMap  < SelectItem , Object >  ( ) ;  for ( SelectItem item : functionItems )  {   AggregateBuilder  <  ? >  aggregateBuilder =  aggregateBuilders . get  ( item ) ;  Object  result =  aggregateBuilder . getAggregate  ( ) ;   functionResult . put  ( item , result ) ; }   final boolean  noResultRows =  resultRows . isEmpty  ( ) ;  if  (  onlyAggregates || noResultRows )  {   Object  [ ]  values =  new Object  [  header . size  ( ) ] ;  for (   int  i = 0 ;  i <  header . size  ( ) ;  i ++ )  {    values [ i ] =  functionResult . get  (  header . getSelectItem  ( i ) ) ; }  Row  row =  new DefaultRow  ( header , values ) ;   resultRows . add  ( row ) ; } else  {  for (   int  i = 0 ;  i <  resultRows . size  ( ) ;  i ++ )  {  Row  row =  resultRows . get  ( i ) ;   Object  [ ]  values =  row . getValues  ( ) ;  for (  Entry  < SelectItem , Object > entry :  functionResult . entrySet  ( ) )  {  SelectItem  item =  entry . getKey  ( ) ;   int  itemIndex =  row . indexOf  ( item ) ;  if  (  itemIndex !=  - 1 )  {  Object  value =  entry . getValue  ( ) ;    values [ itemIndex ] = value ; } }   resultRows . set  ( i ,  new DefaultRow  ( header , values ) ) ; } }  return  new InMemoryDataSet  ( header , resultRows ) ; }   public static  List  < SelectItem > getAggregateFunctionSelectItems  (   Iterable  < SelectItem > selectItems )  {  return  CollectionUtils . filter  ( selectItems ,  arg ->  {  return   arg . getAggregateFunction  ( ) != null ; } ) ; }   public static  List  < SelectItem > getScalarFunctionSelectItems  (   Iterable  < SelectItem > selectItems )  {  return  CollectionUtils . filter  ( selectItems ,  arg ->  {  return   arg . getScalarFunction  ( ) != null ; } ) ; }   public static DataSet getOrdered  (  DataSet dataSet ,   List  < OrderByItem > orderByItems )  {  return  getOrdered  ( dataSet ,  orderByItems . toArray  (  new OrderByItem  [  orderByItems . size  ( ) ] ) ) ; }   public static DataSet getOrdered  (  DataSet dataSet ,   final OrderByItem ...  orderByItems )  {  if  (   orderByItems != null &&   orderByItems . length != 0 )  {   final   int  [ ]  sortIndexes =  new  int  [  orderByItems . length ] ;  for (   int  i = 0 ;  i <  orderByItems . length ;  i ++ )  {  OrderByItem  item =  orderByItems [ i ] ;   int  indexOf =  dataSet . indexOf  (  item . getSelectItem  ( ) ) ;    sortIndexes [ i ] = indexOf ; }   final  List  < Row >  data =  readDataSetFull  ( dataSet ) ;  if  (  data . isEmpty  ( ) )  {  return  new EmptyDataSet  (  dataSet . getSelectItems  ( ) ) ; }   final  Comparator  < Object >  valueComparator =  ObjectComparator . getComparator  ( ) ;   final  Comparator  < Row >  comparator =  new  Comparator  < Row >  ( )  {   public  int compare  (  Row o1 ,  Row o2 )  {  for (   int  i = 0 ;  i <  sortIndexes . length ;  i ++ )  {   int  sortIndex =  sortIndexes [ i ] ;  Object  sortObj1 =  o1 . getValue  ( sortIndex ) ;  Object  sortObj2 =  o2 . getValue  ( sortIndex ) ;   int  compare =  valueComparator . compare  ( sortObj1 , sortObj2 ) ;  if  (  compare != 0 )  {  OrderByItem  orderByItem =  orderByItems [ i ] ;  boolean  ascending =  orderByItem . isAscending  ( ) ;  if  ( ascending )  {  return compare ; } else  {  return  compare *  - 1 ; } } }  return 0 ; } } ;   Collections . sort  ( data , comparator ) ;   dataSet =  new InMemoryDataSet  ( data ) ; }  return dataSet ; }   public static  List  < Row > readDataSetFull  (  DataSet dataSet )  {   final  List  < Row >  result ;  if  (  dataSet instanceof InMemoryDataSet )  {   result =   (  ( InMemoryDataSet ) dataSet ) . getRows  ( ) ; } else  {   result =  new  ArrayList  < Row >  ( ) ;  while  (  dataSet . next  ( ) )  {   result . add  (  dataSet . getRow  ( ) ) ; } }   dataSet . close  ( ) ;  return result ; }   public static  FromItem  [ ] getTableFromItems  (  Query q )  {   List  < FromItem >  result =  new  ArrayList  < FromItem >  ( ) ;   List  < FromItem >  items =   q . getFromClause  ( ) . getItems  ( ) ;  for ( FromItem item : items )  {   result . addAll  (  getTableFromItems  ( item ) ) ; }  return  result . toArray  (  new FromItem  [  result . size  ( ) ] ) ; }   public static  List  < FromItem > getTableFromItems  (  FromItem item )  {   List  < FromItem >  result =  new  ArrayList  < FromItem >  ( ) ;  if  (   item . getTable  ( ) != null )  {   result . add  ( item ) ; } else  if  (   item . getSubQuery  ( ) != null )  {   FromItem  [ ]  sqItems =  getTableFromItems  (  item . getSubQuery  ( ) ) ;  for (   int  i = 0 ;  i <  sqItems . length ;  i ++ )  {   result . add  (  sqItems [ i ] ) ; } } else  if  (   item . getJoin  ( ) != null )  {  FromItem  leftSide =  item . getLeftSide  ( ) ;   result . addAll  (  getTableFromItems  ( leftSide ) ) ;  FromItem  rightSide =  item . getRightSide  ( ) ;   result . addAll  (  getTableFromItems  ( rightSide ) ) ; } else  {  throw  new IllegalStateException  (  "FromItem was neither of Table type, SubQuery type or Join type: " + item ) ; }  return result ; }   public static Row executeSingleRowQuery  (  DataContext dataContext ,  Query query )  throws MetaModelException  {  DataSet  dataSet =  dataContext . executeQuery  ( query ) ;  boolean  next =  dataSet . next  ( ) ;  if  (  ! next )  {  throw  new MetaModelException  (  "No rows returned from query: " + query ) ; }  Row  row =  dataSet . getRow  ( ) ;   next =  dataSet . next  ( ) ;  if  ( next )  {  throw  new MetaModelException  (  "More than one row returned from query: " + query ) ; }   dataSet . close  ( ) ;  return row ; }   public static DataSet getLeftJoin  (  DataSet ds1 ,  DataSet ds2 ,   FilterItem  [ ] onConditions )  {  if  (  ds1 == null )  {  throw  new IllegalArgumentException  ( "Left DataSet cannot be null" ) ; }  if  (  ds2 == null )  {  throw  new IllegalArgumentException  ( "Right DataSet cannot be null" ) ; }   List  < SelectItem >  si1 =  ds1 . getSelectItems  ( ) ;   List  < SelectItem >  si2 =  ds2 . getSelectItems  ( ) ;   List  < SelectItem >  selectItems =   Stream . concat  (  si1 . stream  ( ) ,  si2 . stream  ( ) ) . collect  (  Collectors . toList  ( ) ) ;   List  < Row >  resultRows =  new  ArrayList  < Row >  ( ) ;   List  < Row >  ds2data =  readDataSetFull  ( ds2 ) ;  if  (  ds2data . isEmpty  ( ) )  {  return  getSelection  ( selectItems , ds1 ) ; }   final DataSetHeader  header =  new CachingDataSetHeader  ( selectItems ) ;  while  (  ds1 . next  ( ) )  {  Row  ds1row =  ds1 . getRow  ( ) ;   List  < Row >  ds1rows =  new  ArrayList  < Row >  ( ) ;   ds1rows . add  ( ds1row ) ;  DataSet  carthesianProduct =  getCarthesianProduct  (  new DataSet  [ ]  {  new InMemoryDataSet  (  new CachingDataSetHeader  ( si1 ) , ds1rows ) ,  new InMemoryDataSet  (  new CachingDataSetHeader  ( si2 ) , ds2data ) } , onConditions ) ;   List  < Row >  carthesianRows =  readDataSetFull  ( carthesianProduct ) ;  if  (   carthesianRows . size  ( ) > 0 )  {   resultRows . addAll  ( carthesianRows ) ; } else  {   Object  [ ]  values =  ds1row . getValues  ( ) ;   Object  [ ]  row =  new Object  [  selectItems . size  ( ) ] ;   System . arraycopy  ( values , 0 , row , 0 ,  values . length ) ;   resultRows . add  (  new DefaultRow  ( header , row ) ) ; } }   ds1 . close  ( ) ;  if  (  resultRows . isEmpty  ( ) )  {  return  new EmptyDataSet  ( selectItems ) ; }  return  new InMemoryDataSet  ( header , resultRows ) ; }   public static DataSet getRightJoin  (  DataSet ds1 ,  DataSet ds2 ,   FilterItem  [ ] onConditions )  {   List  < SelectItem >  ds1selects =  ds1 . getSelectItems  ( ) ;   List  < SelectItem >  ds2selects =  ds2 . getSelectItems  ( ) ;   List  < SelectItem >  leftOrderedSelects =  new  ArrayList  < >  ( ) ;   leftOrderedSelects . addAll  ( ds1selects ) ;   leftOrderedSelects . addAll  ( ds2selects ) ;  DataSet  dataSet =  getLeftJoin  ( ds2 , ds1 , onConditions ) ;   dataSet =  getSelection  ( leftOrderedSelects , dataSet ) ;  return dataSet ; }   public static  SelectItem  [ ] createSelectItems  (  Column ...  columns )  {   SelectItem  [ ]  items =  new SelectItem  [  columns . length ] ;  for (   int  i = 0 ;  i <  items . length ;  i ++ )  {    items [ i ] =  new SelectItem  (  columns [ i ] ) ; }  return items ; }   public static DataSet getDistinct  (  DataSet dataSet )  {   List  < SelectItem >  selectItems =  dataSet . getSelectItems  ( ) ;   List  < GroupByItem >  groupByItems =    selectItems . stream  ( ) . map  (  GroupByItem :: new ) . collect  (  Collectors . toList  ( ) ) ;  return  getGrouped  ( selectItems , dataSet , groupByItems ) ; }   public static  Table  [ ] getTables  (   Column  [ ] columns )  {  return  getTables  (  Arrays . asList  ( columns ) ) ; }   public static  Column  [ ] getColumnsByType  (   Column  [ ] columns ,   final ColumnType columnType )  {  return   CollectionUtils . filter  ( columns ,  column ->  {  return   column . getType  ( ) == columnType ; } ) . toArray  (  new Column  [ 0 ] ) ; }   public static  Column  [ ] getColumnsBySuperType  (   Column  [ ] columns ,   final SuperColumnType superColumnType )  {  return   CollectionUtils . filter  ( columns ,  column ->  {  return    column . getType  ( ) . getSuperType  ( ) == superColumnType ; } ) . toArray  (  new Column  [ 0 ] ) ; }   public static Query parseQuery  (  DataContext dc ,  String queryString )  {   final QueryParser  parser =  new QueryParser  ( dc , queryString ) ;  return  parser . parse  ( ) ; }   public static DataSet getPaged  (  DataSet dataSet ,   int firstRow ,   int maxRows )  {  if  (  firstRow > 1 )  {   dataSet =  new FirstRowDataSet  ( dataSet , firstRow ) ; }  if  (  maxRows !=  - 1 )  {   dataSet =  new MaxRowsDataSet  ( dataSet , maxRows ) ; }  return dataSet ; }   public static  List  < SelectItem > getEvaluatedSelectItems  (   final  List  < FilterItem > items )  {   final  List  < SelectItem >  result =  new  ArrayList  < SelectItem >  ( ) ;  for ( FilterItem item : items )  {   addEvaluatedSelectItems  ( result , item ) ; }  return result ; }   private static void addEvaluatedSelectItems  (   List  < SelectItem > result ,  FilterItem item )  {   final  FilterItem  [ ]  orItems =  item . getChildItems  ( ) ;  if  (  orItems != null )  {  for ( FilterItem filterItem : orItems )  {   addEvaluatedSelectItems  ( result , filterItem ) ; } }   final SelectItem  selectItem =  item . getSelectItem  ( ) ;  if  (   selectItem != null &&  !  result . contains  ( selectItem ) )  {   result . add  ( selectItem ) ; }   final Object  operand =  item . getOperand  ( ) ;  if  (    operand != null &&  operand instanceof SelectItem &&  !  result . contains  ( operand ) )  {   result . add  (  ( SelectItem ) operand ) ; } }   public static SelectItem getSelectItemByAlias  (  Query query ,  String alias )  {   List  < SelectItem >  selectItems =   query . getSelectClause  ( ) . getItems  ( ) ;  for ( SelectItem selectItem : selectItems )  {  if  (    selectItem . getAlias  ( ) != null &&   selectItem . getAlias  ( ) . equals  ( alias ) )  {  return selectItem ; } }  return null ; }   public static boolean containsNonSelectScalaFunctions  (  Query query )  {   final  List  < FromItem >  fromItems =   query . getFromClause  ( ) . getItems  ( ) ;  for ( FromItem fromItem : fromItems )  {   final Query  subQuery =  fromItem . getSubQuery  ( ) ;  if  (  subQuery != null )  {  if  (  containsNonSelectScalaFunctions  ( subQuery ) )  {  return true ; }  if  (  !   getScalarFunctionSelectItems  (   subQuery . getSelectClause  ( ) . getItems  ( ) ) . isEmpty  ( ) )  {  return true ; } } }  if  (  !   getScalarFunctionSelectItems  (   query . getWhereClause  ( ) . getEvaluatedSelectItems  ( ) ) . isEmpty  ( ) )  {  return true ; }  if  (  !   getScalarFunctionSelectItems  (   query . getGroupByClause  ( ) . getEvaluatedSelectItems  ( ) ) . isEmpty  ( ) )  {  return true ; }  if  (  !   getScalarFunctionSelectItems  (   query . getHavingClause  ( ) . getEvaluatedSelectItems  ( ) ) . isEmpty  ( ) )  {  return true ; }  if  (  !   getScalarFunctionSelectItems  (   query . getOrderByClause  ( ) . getEvaluatedSelectItems  ( ) ) . isEmpty  ( ) )  {  return true ; }  return false ; }   public static InMemoryDataSet nestedLoopJoin  (  DataSet innerLoopDs ,  DataSet outerLoopDs ,   Iterable  < FilterItem > filtersIterable )  {   List  < FilterItem >  filters =  new  ArrayList  < >  ( ) ;  for ( FilterItem fi : filtersIterable )  {   filters . add  ( fi ) ; }   List  < Row >  innerRows =  innerLoopDs . toRows  ( ) ;   List  < SelectItem >  allItems =  new  ArrayList  < >  (  Arrays . asList  (  outerLoopDs . getSelectItems  ( ) ) ) ;   allItems . addAll  (  Arrays . asList  (  innerLoopDs . getSelectItems  ( ) ) ) ;   Set  < FilterItem >  applicableFilters =  applicableFilters  ( filters , allItems ) ;  DataSetHeader  jointHeader =  new CachingDataSetHeader  ( allItems ) ;   List  < Row >  resultRows =  new  ArrayList  < >  ( ) ;  for ( Row outerRow : outerLoopDs )  {  for ( Row innerRow : innerRows )  {   Object  [ ]  joinedRowObjects =  new Object  [    outerRow . getValues  ( ) . length +   innerRow . getValues  ( ) . length ] ;   System . arraycopy  (  outerRow . getValues  ( ) , 0 , joinedRowObjects , 0 ,   outerRow . getValues  ( ) . length ) ;   System . arraycopy  (  innerRow . getValues  ( ) , 0 , joinedRowObjects ,   outerRow . getValues  ( ) . length ,   innerRow . getValues  ( ) . length ) ;  Row  joinedRow =  new DefaultRow  ( jointHeader , joinedRowObjects ) ;  if  (   applicableFilters . isEmpty  ( ) ||   applicableFilters . stream  ( ) . allMatch  (  fi ->  fi . accept  ( joinedRow ) ) )  {   resultRows . add  ( joinedRow ) ; } } }  return  new InMemoryDataSet  ( jointHeader , resultRows ) ; }   private static  Set  < FilterItem > applicableFilters  (   Collection  < FilterItem > filters ,   Collection  < SelectItem > selectItemList )  {   Set  < SelectItem >  items =  new  HashSet  < SelectItem >  ( selectItemList ) ;  return    filters . stream  ( ) . filter  (  fi ->  {   Collection  < SelectItem >  fiSelectItems =  new  ArrayList  < >  ( ) ;   fiSelectItems . add  (  fi . getSelectItem  ( ) ) ;  Object  operand =  fi . getOperand  ( ) ;  if  (  operand instanceof SelectItem )  {   fiSelectItems . add  (  ( SelectItem ) operand ) ; }  return  items . containsAll  ( fiSelectItems ) ; } ) . collect  (  Collectors . toSet  ( ) ) ; } }