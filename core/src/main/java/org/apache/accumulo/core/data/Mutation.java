  package     org . apache . accumulo . core . data ;   import static     java . nio . charset . StandardCharsets . UTF_8 ;  import   java . io . DataInput ;  import   java . io . DataOutput ;  import   java . io . IOException ;  import   java . nio . ByteBuffer ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Collections ;  import   java . util . List ;  import       org . apache . accumulo . core . dataImpl . thrift . TMutation ;  import      org . apache . accumulo . core . security . ColumnVisibility ;  import      org . apache . accumulo . core . util . ByteBufferUtil ;  import      org . apache . accumulo . core . util . UnsynchronizedBuffer ;  import     org . apache . hadoop . io . Text ;  import     org . apache . hadoop . io . Writable ;  import     org . apache . hadoop . io . WritableUtils ;  import     com . google . common . annotations . VisibleForTesting ;  import     com . google . common . base . Preconditions ;   public class Mutation  implements  Writable  {   static final  int  VALUE_SIZE_COPY_CUTOFF =  1 << 15 ;   static final  long  MAX_MUTATION_SIZE =  (  1L << 31 ) ;   static final  long  SERIALIZATION_OVERHEAD = 5 ;   public enum SERIALIZED_FORMAT  {  VERSION1 ,  VERSION2 }   private boolean  useOldDeserialize = false ;   private   byte  [ ]  row ;   private   byte  [ ]  data ;   private  int  entries ;   private  List  <   byte  [ ] >  values ;    @ VisibleForTesting  long  estRowAndLargeValSize = 0 ;   private  UnsynchronizedBuffer . Writer  buffer ;   private  List  < ColumnUpdate >  updates ;   private static final   byte  [ ]  EMPTY_BYTES =  new  byte  [ 0 ] ;   private void serialize  ( )  {  if  (  buffer != null )  {   data =  buffer . toArray  ( ) ;   buffer = null ; } }   private ByteBuffer serializedSnapshot  ( )  {  if  (  buffer != null )  {  return   this . buffer . toByteBuffer  ( ) ; } else  {  return  ByteBuffer . wrap  (  this . data ) ; } }   public Mutation  (    byte  [ ] row )  {  this  ( row , 0 ,  row . length ) ; }   public Mutation  (    byte  [ ] row ,   int initialBufferSize )  {  this  ( row , 0 ,  row . length , initialBufferSize ) ; }   public Mutation  (    byte  [ ] row ,   int start ,   int length )  {  this  ( row , start , length , 64 ) ; }   public Mutation  (    byte  [ ] row ,   int start ,   int length ,   int initialBufferSize )  {    this . row =  new  byte  [ length ] ;   System . arraycopy  ( row , start ,  this . row , 0 , length ) ;   buffer =  new  UnsynchronizedBuffer . Writer  ( initialBufferSize ) ;   estRowAndLargeValSize =  length + SERIALIZATION_OVERHEAD ; }   public Mutation  (  Text row )  {  this  (  row . getBytes  ( ) , 0 ,  row . getLength  ( ) ) ; }   public Mutation  (  Text row ,   int initialBufferSize )  {  this  (  row . getBytes  ( ) , 0 ,  row . getLength  ( ) , initialBufferSize ) ; }   public Mutation  (  CharSequence row )  {  this  (  new Text  (  row . toString  ( ) ) ) ; }   public Mutation  (  CharSequence row ,   int initialBufferSize )  {  this  (  new Text  (  row . toString  ( ) ) , initialBufferSize ) ; }   public Mutation  ( )  { }   public Mutation  (  TMutation tmutation )  {    this . row =  ByteBufferUtil . toBytes  (  tmutation . row ) ;    this . data =  ByteBufferUtil . toBytes  (  tmutation . data ) ;    this . entries =  tmutation . entries ;    this . values =  ByteBufferUtil . toBytesList  (  tmutation . values ) ;  if  (   this . row == null )  {  throw  new IllegalArgumentException  ( "null row" ) ; }  if  (   this . data == null )  {  throw  new IllegalArgumentException  ( "null serialized data" ) ; } }   public Mutation  (  Mutation m )  {   m . serialize  ( ) ;    this . row =  m . row ;    this . data =  m . data ;    this . entries =  m . entries ;    this . values =  m . values ; }   public   byte  [ ] getRow  ( )  {  return row ; }   private void fill  (    byte  [ ] b )  {   fill  ( b ,  b . length ) ; }   private void fill  (    byte  [ ] b ,   int length )  {   buffer . writeVLong  ( length ) ;   buffer . add  ( b , 0 , length ) ; }   private void fill  (  boolean b )  {   buffer . add  ( b ) ; }   private void fill  (   int i )  {   buffer . writeVLong  ( i ) ; }   private void fill  (   long l )  {   buffer . writeVLong  ( l ) ; }   private void put  (    byte  [ ] cf ,    byte  [ ] cq ,    byte  [ ] cv ,  boolean hasts ,   long ts ,  boolean deleted ,    byte  [ ] val )  {   put  ( cf ,  cf . length , cq ,  cq . length , cv , hasts , ts , deleted , val ,  val . length ) ; }   private void put  (  Text cf ,  Text cq ,    byte  [ ] cv ,  boolean hasts ,   long ts ,  boolean deleted ,    byte  [ ] val )  {   put  (  cf . getBytes  ( ) ,  cf . getLength  ( ) ,  cq . getBytes  ( ) ,  cq . getLength  ( ) , cv , hasts , ts , deleted , val ,  val . length ) ; }   private void put  (    byte  [ ] cf ,   int cfLength ,    byte  [ ] cq ,   int cqLength ,    byte  [ ] cv ,  boolean hasts ,   long ts ,  boolean deleted ,    byte  [ ] val ,   int valLength )  {  if  (  buffer == null )  {  throw  new IllegalStateException  ( "Can not add to mutation after serializing it" ) ; }   long  estimatedSizeAfterPut =         estRowAndLargeValSize +  buffer . size  ( ) + cfLength + cqLength +  cv . length +  (  hasts ? 8 : 0 ) + valLength + 2 +  4 * SERIALIZATION_OVERHEAD ;   Preconditions . checkArgument  (   estimatedSizeAfterPut < MAX_MUTATION_SIZE &&  estimatedSizeAfterPut >= 0 , "Maximum mutation size must be less than 2GB " ) ;   fill  ( cf , cfLength ) ;   fill  ( cq , cqLength ) ;   fill  ( cv ) ;   fill  ( hasts ) ;  if  ( hasts )  {   fill  ( ts ) ; }   fill  ( deleted ) ;  if  (  valLength < VALUE_SIZE_COPY_CUTOFF )  {   fill  ( val , valLength ) ; } else  {  if  (  values == null )  {   values =  new  ArrayList  < >  ( ) ; }    byte  [ ]  copy =  new  byte  [ valLength ] ;   System . arraycopy  ( val , 0 , copy , 0 , valLength ) ;   values . add  ( copy ) ;   fill  (   - 1 *  values . size  ( ) ) ;   estRowAndLargeValSize +=  valLength + SERIALIZATION_OVERHEAD ; }   entries ++ ; }   private void put  (  CharSequence cf ,  CharSequence cq ,    byte  [ ] cv ,  boolean hasts ,   long ts ,  boolean deleted ,    byte  [ ] val )  {   put  (  new Text  (  cf . toString  ( ) ) ,  new Text  (  cq . toString  ( ) ) , cv , hasts , ts , deleted , val ) ; }   private void put  (  Text cf ,  Text cq ,    byte  [ ] cv ,  boolean hasts ,   long ts ,  boolean deleted ,  Text val )  {   put  (  cf . getBytes  ( ) ,  cf . getLength  ( ) ,  cq . getBytes  ( ) ,  cq . getLength  ( ) , cv , hasts , ts , deleted ,  val . getBytes  ( ) ,  val . getLength  ( ) ) ; }   private void put  (  CharSequence cf ,  CharSequence cq ,    byte  [ ] cv ,  boolean hasts ,   long ts ,  boolean deleted ,  CharSequence val )  {   put  (  new Text  (  cf . toString  ( ) ) ,  new Text  (  cq . toString  ( ) ) , cv , hasts , ts , deleted ,  new Text  (  val . toString  ( ) ) ) ; }   public void put  (  Text columnFamily ,  Text columnQualifier ,  Value value )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , false , 0L , false ,  value . get  ( ) ) ; }   public void put  (  Text columnFamily ,  Text columnQualifier ,  ColumnVisibility columnVisibility ,  Value value )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , false , 0L , false ,  value . get  ( ) ) ; }   public void put  (  Text columnFamily ,  Text columnQualifier ,   long timestamp ,  Value value )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , true , timestamp , false ,  value . get  ( ) ) ; }   public void put  (  Text columnFamily ,  Text columnQualifier ,  ColumnVisibility columnVisibility ,   long timestamp ,  Value value )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , true , timestamp , false ,  value . get  ( ) ) ; }   public void putDelete  (  Text columnFamily ,  Text columnQualifier )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , false , 0L , true , EMPTY_BYTES ) ; }   public void putDelete  (  Text columnFamily ,  Text columnQualifier ,  ColumnVisibility columnVisibility )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , false , 0L , true , EMPTY_BYTES ) ; }   public void putDelete  (  Text columnFamily ,  Text columnQualifier ,   long timestamp )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , true , timestamp , true , EMPTY_BYTES ) ; }   public void putDelete  (  Text columnFamily ,  Text columnQualifier ,  ColumnVisibility columnVisibility ,   long timestamp )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , true , timestamp , true , EMPTY_BYTES ) ; }   public void put  (  CharSequence columnFamily ,  CharSequence columnQualifier ,  Value value )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , false , 0L , false ,  value . get  ( ) ) ; }   public void put  (  CharSequence columnFamily ,  CharSequence columnQualifier ,  ColumnVisibility columnVisibility ,  Value value )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , false , 0L , false ,  value . get  ( ) ) ; }   public void put  (  CharSequence columnFamily ,  CharSequence columnQualifier ,   long timestamp ,  Value value )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , true , timestamp , false ,  value . get  ( ) ) ; }   public void put  (  CharSequence columnFamily ,  CharSequence columnQualifier ,  ColumnVisibility columnVisibility ,   long timestamp ,  Value value )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , true , timestamp , false ,  value . get  ( ) ) ; }   public void putDelete  (  CharSequence columnFamily ,  CharSequence columnQualifier )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , false , 0L , true , EMPTY_BYTES ) ; }   public void putDelete  (  CharSequence columnFamily ,  CharSequence columnQualifier ,  ColumnVisibility columnVisibility )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , false , 0L , true , EMPTY_BYTES ) ; }   public void putDelete  (  CharSequence columnFamily ,  CharSequence columnQualifier ,   long timestamp )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , true , timestamp , true , EMPTY_BYTES ) ; }   public void putDelete  (  CharSequence columnFamily ,  CharSequence columnQualifier ,  ColumnVisibility columnVisibility ,   long timestamp )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , true , timestamp , true , EMPTY_BYTES ) ; }   public void put  (  CharSequence columnFamily ,  CharSequence columnQualifier ,  CharSequence value )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , false , 0L , false , value ) ; }   public void put  (  CharSequence columnFamily ,  CharSequence columnQualifier ,  ColumnVisibility columnVisibility ,  CharSequence value )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , false , 0L , false , value ) ; }   public void put  (  CharSequence columnFamily ,  CharSequence columnQualifier ,   long timestamp ,  CharSequence value )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , true , timestamp , false , value ) ; }   public void put  (  CharSequence columnFamily ,  CharSequence columnQualifier ,  ColumnVisibility columnVisibility ,   long timestamp ,  CharSequence value )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , true , timestamp , false , value ) ; }   public void put  (    byte  [ ] columnFamily ,    byte  [ ] columnQualifier ,    byte  [ ] value )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , false , 0L , false , value ) ; }   public void put  (    byte  [ ] columnFamily ,    byte  [ ] columnQualifier ,  ColumnVisibility columnVisibility ,    byte  [ ] value )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , false , 0L , false , value ) ; }   public void put  (    byte  [ ] columnFamily ,    byte  [ ] columnQualifier ,   long timestamp ,    byte  [ ] value )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , true , timestamp , false , value ) ; }   public void put  (    byte  [ ] columnFamily ,    byte  [ ] columnQualifier ,  ColumnVisibility columnVisibility ,   long timestamp ,    byte  [ ] value )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , true , timestamp , false , value ) ; }   public void putDelete  (    byte  [ ] columnFamily ,    byte  [ ] columnQualifier )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , false , 0L , true , EMPTY_BYTES ) ; }   public void putDelete  (    byte  [ ] columnFamily ,    byte  [ ] columnQualifier ,  ColumnVisibility columnVisibility )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , false , 0L , true , EMPTY_BYTES ) ; }   public void putDelete  (    byte  [ ] columnFamily ,    byte  [ ] columnQualifier ,   long timestamp )  {   put  ( columnFamily , columnQualifier , EMPTY_BYTES , true , timestamp , true , EMPTY_BYTES ) ; }   public void putDelete  (    byte  [ ] columnFamily ,    byte  [ ] columnQualifier ,  ColumnVisibility columnVisibility ,   long timestamp )  {   put  ( columnFamily , columnQualifier ,  columnVisibility . getExpression  ( ) , true , timestamp , true , EMPTY_BYTES ) ; }   public interface FamilyOptions  extends  QualifierOptions  {  QualifierOptions family  (    byte  [ ] colFam ) ;  QualifierOptions family  (  ByteBuffer colFam ) ;  QualifierOptions family  (  CharSequence colFam ) ;  QualifierOptions family  (  Text colFam ) ; }   public interface QualifierOptions  extends  VisibilityOptions  {  VisibilityOptions qualifier  (    byte  [ ] colQual ) ;  VisibilityOptions qualifier  (  ByteBuffer colQual ) ;  VisibilityOptions qualifier  (  CharSequence colQual ) ;  VisibilityOptions qualifier  (  Text colQual ) ; }   public interface VisibilityOptions  extends  TimestampOptions  {  TimestampOptions visibility  (    byte  [ ] colVis ) ;  TimestampOptions visibility  (  ByteBuffer colVis ) ;  TimestampOptions visibility  (  CharSequence colVis ) ;  TimestampOptions visibility  (  ColumnVisibility colVis ) ;  TimestampOptions visibility  (  Text colVis ) ; }   public interface TimestampOptions  extends  MutationOptions  {  MutationOptions timestamp  (   long ts ) ; }   public interface MutationOptions  {  Mutation put  (    byte  [ ] val ) ;  Mutation put  (  ByteBuffer val ) ;  Mutation put  (  CharSequence val ) ;  Mutation put  (  Text val ) ;  Mutation put  (  Value val ) ;  Mutation delete  ( ) ; }   public FamilyOptions at  ( )  {  return  new Options  ( ) ; }   private class Options  implements  FamilyOptions  {    byte  [ ]  columnFamily ;   int  columnFamilyLength ;    byte  [ ]  columnQualifier ;   int  columnQualifierLength ;    byte  [ ]  columnVisibility = null ;   int  columnVisibilityLength ;  boolean  hasTs = false ;   long  timestamp ;   private Options  ( )  { }   private QualifierOptions family  (    byte  [ ] colFam ,   int colFamLength )  {   columnFamily = colFam ;   columnFamilyLength = colFamLength ;  return this ; }    @ Override public QualifierOptions family  (    byte  [ ] colFam )  {  return  family  ( colFam ,  colFam . length ) ; }    @ Override public QualifierOptions family  (  ByteBuffer colFam )  {  return  family  (  ByteBufferUtil . toBytes  ( colFam ) ) ; }    @ Override public QualifierOptions family  (  CharSequence colFam )  {  return  family  (  new Text  (  colFam . toString  ( ) ) ) ; }    @ Override public QualifierOptions family  (  Text colFam )  {  return  family  (  colFam . getBytes  ( ) ,  colFam . getLength  ( ) ) ; }   private VisibilityOptions qualifier  (    byte  [ ] colQual ,   int colQualLength )  {   columnQualifier = colQual ;   columnQualifierLength = colQualLength ;  return this ; }    @ Override public VisibilityOptions qualifier  (    byte  [ ] colQual )  {  return  qualifier  ( colQual ,  colQual . length ) ; }    @ Override public VisibilityOptions qualifier  (  ByteBuffer colQual )  {  return  qualifier  (  ByteBufferUtil . toBytes  ( colQual ) ) ; }    @ Override public VisibilityOptions qualifier  (  CharSequence colQual )  {  return  qualifier  (  new Text  (  colQual . toString  ( ) ) ) ; }    @ Override public VisibilityOptions qualifier  (  Text colQual )  {  return  qualifier  (  colQual . getBytes  ( ) ,  colQual . getLength  ( ) ) ; }   private TimestampOptions visibility  (    byte  [ ] colVis ,   int colVisLen )  {   columnVisibility = colVis ;   columnVisibilityLength = colVisLen ;  return this ; }    @ Override public TimestampOptions visibility  (    byte  [ ] colVis )  {  return  visibility  ( colVis ,  colVis . length ) ; }    @ Override public TimestampOptions visibility  (  ByteBuffer colVis )  {  return  visibility  (  ByteBufferUtil . toBytes  ( colVis ) ) ; }    @ Override public TimestampOptions visibility  (  CharSequence colVis )  {  return  visibility  (  new Text  (  colVis . toString  ( ) ) ) ; }    @ Override public TimestampOptions visibility  (  ColumnVisibility colVis )  {  return  visibility  (  colVis . getExpression  ( ) ) ; }    @ Override public TimestampOptions visibility  (  Text colVis )  {  return  visibility  (  colVis . copyBytes  ( ) ) ; }    @ Override public MutationOptions timestamp  (   long ts )  {   hasTs = true ;   timestamp = ts ;  return this ; }   private Mutation put  (    byte  [ ] val ,  boolean delete )  {  if  (  buffer == null )  {  throw  new IllegalStateException  ( "Can not add to mutation after serializing it" ) ; }   fill  ( columnFamily , columnFamilyLength ) ;   fill  ( columnQualifier , columnQualifierLength ) ;  if  (  columnVisibility == null )  {   fill  ( EMPTY_BYTES ,  EMPTY_BYTES . length ) ; } else  {   fill  ( columnVisibility , columnVisibilityLength ) ; }   fill  ( hasTs ) ;  if  ( hasTs )  {   fill  ( timestamp ) ; }   fill  ( delete ) ;  if  (   val . length < VALUE_SIZE_COPY_CUTOFF )  {   fill  ( val ,  val . length ) ; } else  {  if  (  values == null )  {   values =  new  ArrayList  < >  ( ) ; }    byte  [ ]  copy =  new  byte  [  val . length ] ;   System . arraycopy  ( val , 0 , copy , 0 ,  val . length ) ;   values . add  ( copy ) ;   fill  (   - 1 *  values . size  ( ) ) ; }   entries ++ ;  return  Mutation . this ; }    @ Override public Mutation put  (    byte  [ ] val )  {  return  put  ( val , false ) ; }    @ Override public Mutation put  (  ByteBuffer val )  {  return  put  (  ByteBufferUtil . toBytes  ( val ) , false ) ; }    @ Override public Mutation put  (  CharSequence val )  {  return  put  (  new Text  (  val . toString  ( ) ) ) ; }    @ Override public Mutation put  (  Text val )  {  return  put  (  val . copyBytes  ( ) , false ) ; }    @ Override public Mutation put  (  Value val )  {  return  put  (  val . get  ( ) , false ) ; }    @ Override public Mutation delete  ( )  {  return  put  ( EMPTY_BYTES , true ) ; } }   private   byte  [ ] oldReadBytes  (   UnsynchronizedBuffer . Reader in )  {   int  len =  in . readInt  ( ) ;  if  (  len == 0 )  {  return EMPTY_BYTES ; }    byte  [ ]  bytes =  new  byte  [ len ] ;   in . readBytes  ( bytes ) ;  return bytes ; }   private   byte  [ ] readBytes  (   UnsynchronizedBuffer . Reader in )  {   int  len =  (  int )  in . readVLong  ( ) ;  if  (  len == 0 )  {  return EMPTY_BYTES ; }    byte  [ ]  bytes =  new  byte  [ len ] ;   in . readBytes  ( bytes ) ;  return bytes ; }   public  List  < ColumnUpdate > getUpdates  ( )  {   serialize  ( ) ;   UnsynchronizedBuffer . Reader  in =  new  UnsynchronizedBuffer . Reader  ( data ) ;  if  (  updates == null )  {  if  (  entries == 1 )  {   updates =  Collections . singletonList  (  deserializeColumnUpdate  ( in ) ) ; } else  {   ColumnUpdate  [ ]  tmpUpdates =  new ColumnUpdate  [ entries ] ;  for (   int  i = 0 ;  i < entries ;  i ++ )  {    tmpUpdates [ i ] =  deserializeColumnUpdate  ( in ) ; }   updates =  Arrays . asList  ( tmpUpdates ) ; } }  return updates ; }   protected ColumnUpdate newColumnUpdate  (    byte  [ ] cf ,    byte  [ ] cq ,    byte  [ ] cv ,  boolean hasts ,   long ts ,  boolean deleted ,    byte  [ ] val )  {  return  new ColumnUpdate  ( cf , cq , cv , hasts , ts , deleted , val ) ; }   private ColumnUpdate deserializeColumnUpdate  (   UnsynchronizedBuffer . Reader in )  {    byte  [ ]  cf =  readBytes  ( in ) ;    byte  [ ]  cq =  readBytes  ( in ) ;    byte  [ ]  cv =  readBytes  ( in ) ;  boolean  hasts =  in . readBoolean  ( ) ;   long  ts = 0 ;  if  ( hasts )  {   ts =  in . readVLong  ( ) ; }  boolean  deleted =  in . readBoolean  ( ) ;    byte  [ ]  val ;   int  valLen =  (  int )  in . readVLong  ( ) ;  if  (  valLen < 0 )  {   val =  values . get  (   (   - 1 * valLen ) - 1 ) ; } else  if  (  valLen == 0 )  {   val = EMPTY_BYTES ; } else  {   val =  new  byte  [ valLen ] ;   in . readBytes  ( val ) ; }  return  newColumnUpdate  ( cf , cq , cv , hasts , ts , deleted , val ) ; }   private  int  cachedValLens =  - 1 ;   long getValueLengths  ( )  {  if  (  values == null )  {  return 0 ; }  if  (  cachedValLens ==  - 1 )  {   int  tmpCVL = 0 ;  for (   byte  [ ] val : values )  {   tmpCVL +=  val . length ; }   cachedValLens = tmpCVL ; }  return cachedValLens ; }   public  long numBytes  ( )  {   serialize  ( ) ;  return    row . length +  data . length +  getValueLengths  ( ) ; }   public  long estimatedMemoryUsed  ( )  {  return   numBytes  ( ) + 238 ; }   public  int size  ( )  {  return entries ; }    @ Override public void readFields  (  DataInput in )  throws IOException  {   updates = null ;   cachedValLens =  - 1 ;   buffer = null ;   useOldDeserialize = false ;   byte  first =  in . readByte  ( ) ;  if  (   (  first & 0x80 ) != 0x80 )  {   oldReadFields  ( first , in ) ;   useOldDeserialize = true ;  return ; }   int  len =  WritableUtils . readVInt  ( in ) ;   row =  new  byte  [ len ] ;   in . readFully  ( row ) ;   len =  WritableUtils . readVInt  ( in ) ;   data =  new  byte  [ len ] ;   in . readFully  ( data ) ;   entries =  WritableUtils . readVInt  ( in ) ;  boolean  valuesPresent =   (  first & 0x01 ) == 0x01 ;  if  ( valuesPresent )  {   values =  new  ArrayList  < >  ( ) ;   int  numValues =  WritableUtils . readVInt  ( in ) ;  for (   int  i = 0 ;  i < numValues ;  i ++ )  {   len =  WritableUtils . readVInt  ( in ) ;    byte  [ ]  val =  new  byte  [ len ] ;   in . readFully  ( val ) ;   values . add  ( val ) ; } } else  {   values = null ; }  if  (   (  first & 0x02 ) == 0x02 )  {   int  numMutations =  WritableUtils . readVInt  ( in ) ;  for (   int  i = 0 ;  i < numMutations ;  i ++ )  {   WritableUtils . readString  ( in ) ; } } }   protected void droppingOldTimestamp  (   long ts )  { }   private void oldReadFields  (   byte first ,  DataInput in )  throws IOException  {   byte  b =  in . readByte  ( ) ;   byte  c =  in . readByte  ( ) ;   byte  d =  in . readByte  ( ) ;   int  len =  (     (   (  first & 0xff ) << 24 ) |  (   (  b & 0xff ) << 16 ) |  (   (  c & 0xff ) << 8 ) |  (  d & 0xff ) ) ;   row =  new  byte  [ len ] ;   in . readFully  ( row ) ;   len =  in . readInt  ( ) ;    byte  [ ]  localData =  new  byte  [ len ] ;   in . readFully  ( localData ) ;   int  localEntries =  in . readInt  ( ) ;   List  <   byte  [ ] >  localValues ;  boolean  valuesPresent =  in . readBoolean  ( ) ;  if  ( valuesPresent )  {   localValues =  new  ArrayList  < >  ( ) ;   int  numValues =  in . readInt  ( ) ;  for (   int  i = 0 ;  i < numValues ;  i ++ )  {   len =  in . readInt  ( ) ;    byte  [ ]  val =  new  byte  [ len ] ;   in . readFully  ( val ) ;   localValues . add  ( val ) ; } } else  {   localValues = null ; }   UnsynchronizedBuffer . Reader  din =  new  UnsynchronizedBuffer . Reader  ( localData ) ;   buffer =  new  UnsynchronizedBuffer . Writer  ( ) ;  for (   int  i = 0 ;  i < localEntries ;  i ++ )  {    byte  [ ]  cf =  oldReadBytes  ( din ) ;    byte  [ ]  cq =  oldReadBytes  ( din ) ;    byte  [ ]  cv =  oldReadBytes  ( din ) ;  boolean  hasts =  din . readBoolean  ( ) ;   long  ts =  din . readLong  ( ) ;  boolean  deleted =  din . readBoolean  ( ) ;    byte  [ ]  val ;   int  valLen =  din . readInt  ( ) ;  if  (  valLen < 0 )  {   val =  localValues . get  (   (   - 1 * valLen ) - 1 ) ; } else  if  (  valLen == 0 )  {   val = EMPTY_BYTES ; } else  {   val =  new  byte  [ valLen ] ;   din . readBytes  ( val ) ; }   put  ( cf , cq , cv , hasts , ts , deleted , val ) ;  if  (  ! hasts )  {   droppingOldTimestamp  ( ts ) ; } }   serialize  ( ) ; }    @ Override public void write  (  DataOutput out )  throws IOException  {   final   byte  [ ]  integerBuffer =  new  byte  [ 5 ] ;   serialize  ( ) ;   byte  hasValues =   (  values == null ) ? 0 :  (  byte ) 1 ;   out . write  (  (  byte )  (  0x80 | hasValues ) ) ;   UnsynchronizedBuffer . writeVInt  ( out , integerBuffer ,  row . length ) ;   out . write  ( row ) ;   UnsynchronizedBuffer . writeVInt  ( out , integerBuffer ,  data . length ) ;   out . write  ( data ) ;   UnsynchronizedBuffer . writeVInt  ( out , integerBuffer , entries ) ;  if  (   (  0x01 & hasValues ) == 0x01 )  {   UnsynchronizedBuffer . writeVInt  ( out , integerBuffer ,  values . size  ( ) ) ;  for (   byte  [ ] val : values )  {   UnsynchronizedBuffer . writeVInt  ( out , integerBuffer ,  val . length ) ;   out . write  ( val ) ; } } }    @ Override public boolean equals  (  Object o )  {  if  (  o == this )  {  return true ; }  if  (   o != null &&   o . getClass  ( ) . equals  (  this . getClass  ( ) ) )  {  return  equalMutation  (  ( Mutation ) o ) ; }  return false ; }    @ Override public  int hashCode  ( )  {  return   serializedSnapshot  ( ) . hashCode  ( ) ; }   public boolean equals  (  Mutation m )  {  return  this . equals  (  ( Object ) m ) ; }   private boolean equalMutation  (  Mutation m )  {  ByteBuffer  myData =  serializedSnapshot  ( ) ;  ByteBuffer  otherData =  m . serializedSnapshot  ( ) ;  if  (    Arrays . equals  ( row ,  m . row ) &&  entries ==  m . entries &&  myData . equals  ( otherData ) )  {  if  (   values == null &&   m . values == null )  {  return true ; }  if  (    values != null &&   m . values != null &&   values . size  ( ) ==   m . values . size  ( ) )  {  for (   int  i = 0 ;  i <  values . size  ( ) ;  i ++ )  {  if  (  !  Arrays . equals  (  values . get  ( i ) ,   m . values . get  ( i ) ) )  {  return false ; } }  return true ; } }  return false ; }   public TMutation toThrift  ( )  {  return  toThrift  ( true ) ; }   private TMutation toThrift  (  boolean serialize )  {  if  ( serialize )  {   this . serialize  ( ) ; }  ByteBuffer  data =  serializedSnapshot  ( ) ;  return  new TMutation  (  ByteBuffer . wrap  ( row ) , data ,  ByteBufferUtil . toByteBuffers  ( values ) , entries ) ; }   protected SERIALIZED_FORMAT getSerializedFormat  ( )  {  return   this . useOldDeserialize ?  SERIALIZED_FORMAT . VERSION1 :  SERIALIZED_FORMAT . VERSION2 ; }   public String prettyPrint  ( )  {  StringBuilder  sb =  new StringBuilder  ( ) ;     sb . append  ( "mutation: " ) . append  (  new String  ( row , UTF_8 ) ) . append  ( '\n' ) ;  for ( ColumnUpdate update :  getUpdates  ( ) )  {   sb . append  ( " update: " ) ;   sb . append  (  new String  (  update . getColumnFamily  ( ) , UTF_8 ) ) ;   sb . append  ( ':' ) ;   sb . append  (  new String  (  update . getColumnQualifier  ( ) , UTF_8 ) ) ;   sb . append  ( " value " ) ;  if  (  update . isDeleted  ( ) )  {   sb . append  ( "[delete]" ) ; } else  {   sb . append  (  new String  (  update . getValue  ( ) , UTF_8 ) ) ; }   sb . append  ( '\n' ) ; }  return  sb . toString  ( ) ; } }