  package   org . jooq . tools ;   import static     java . time . temporal . ChronoField . INSTANT_SECONDS ;  import static     java . time . temporal . ChronoField . MILLI_OF_DAY ;  import static     java . time . temporal . ChronoField . MILLI_OF_SECOND ;  import static     org . jooq . types . Unsigned . ubyte ;  import static     org . jooq . types . Unsigned . uint ;  import static     org . jooq . types . Unsigned . ulong ;  import static     org . jooq . types . Unsigned . ushort ;  import   java . io . File ;  import    java . lang . reflect . Array ;  import   java . math . BigDecimal ;  import   java . math . BigInteger ;  import   java . net . URI ;  import   java . net . URISyntaxException ;  import   java . net . URL ;  import   java . nio . ByteBuffer ;  import   java . sql . Date ;  import   java . sql . Time ;  import   java . sql . Timestamp ;  import   java . time . Instant ;  import   java . time . LocalDate ;  import   java . time . LocalDateTime ;  import   java . time . LocalTime ;  import   java . time . OffsetDateTime ;  import   java . time . OffsetTime ;  import    java . time . format . DateTimeParseException ;  import    java . time . temporal . Temporal ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Calendar ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . HashSet ;  import   java . util . LinkedHashSet ;  import   java . util . List ;  import   java . util . Optional ;  import   java . util . Set ;  import   java . util . UUID ;  import    java . util . regex . Pattern ;  import   org . jooq . Converter ;  import   org . jooq . EnumType ;  import   org . jooq . Field ;  import   org . jooq . Record ;  import   org . jooq . SQLDialect ;  import    org . jooq . exception . DataTypeException ;  import     org . jooq . tools . jdbc . MockArray ;  import    org . jooq . types . UByte ;  import    org . jooq . types . UInteger ;  import    org . jooq . types . ULong ;  import    org . jooq . types . UShort ;   public final class Convert  {   public static final  Set  < String >  TRUE_VALUES ;   public static final  Set  < String >  FALSE_VALUES ;   private static final Pattern  UUID_PATTERN =  Pattern . compile  ( "(\\p{XDigit}{8})-?(\\p{XDigit}{4})-?(\\p{XDigit}{4})-?(\\p{XDigit}{4})-?(\\p{XDigit}{12})" ) ;  static  {   Set  < String >  trueValues =  new  HashSet  < String >  ( ) ;   Set  < String >  falseValues =  new  HashSet  < String >  ( ) ;   trueValues . add  ( "1" ) ;   trueValues . add  ( "1.0" ) ;   trueValues . add  ( "y" ) ;   trueValues . add  ( "Y" ) ;   trueValues . add  ( "yes" ) ;   trueValues . add  ( "YES" ) ;   trueValues . add  ( "true" ) ;   trueValues . add  ( "TRUE" ) ;   trueValues . add  ( "t" ) ;   trueValues . add  ( "T" ) ;   trueValues . add  ( "on" ) ;   trueValues . add  ( "ON" ) ;   trueValues . add  ( "enabled" ) ;   trueValues . add  ( "ENABLED" ) ;   falseValues . add  ( "0" ) ;   falseValues . add  ( "0.0" ) ;   falseValues . add  ( "n" ) ;   falseValues . add  ( "N" ) ;   falseValues . add  ( "no" ) ;   falseValues . add  ( "NO" ) ;   falseValues . add  ( "false" ) ;   falseValues . add  ( "FALSE" ) ;   falseValues . add  ( "f" ) ;   falseValues . add  ( "F" ) ;   falseValues . add  ( "off" ) ;   falseValues . add  ( "OFF" ) ;   falseValues . add  ( "disabled" ) ;   falseValues . add  ( "DISABLED" ) ;   TRUE_VALUES =  Collections . unmodifiableSet  ( trueValues ) ;   FALSE_VALUES =  Collections . unmodifiableSet  ( falseValues ) ; }   public static final  Object  [ ] convert  (   Object  [ ] values ,    Field  <  ? >  [ ] fields )  {  if  (  values != null )  {   Object  [ ]  result =  new Object  [  values . length ] ;  for (   int  i = 0 ;  i <  values . length ;  i ++ )  {  if  (   values [ i ] instanceof  Field  <  ? > )  {    result [ i ] =  values [ i ] ; } else  {    result [ i ] =  convert  (  values [ i ] ,   fields [ i ] . getType  ( ) ) ; } }  return result ; } else  {  return null ; } }   public static final  Object  [ ] convert  (   Object  [ ] values ,    Class  <  ? >  [ ] types )  {  if  (  values != null )  {   Object  [ ]  result =  new Object  [  values . length ] ;  for (   int  i = 0 ;  i <  values . length ;  i ++ )  {  if  (   values [ i ] instanceof  Field  <  ? > )  {    result [ i ] =  values [ i ] ; } else  {    result [ i ] =  convert  (  values [ i ] ,  types [ i ] ) ; } }  return result ; } else  {  return null ; } }    @ SuppressWarnings  ( "unchecked" ) public static final  <  U >  U  [ ] convertArray  (   Object  [ ] from ,   Converter  <  ? ,  ? extends U > converter )  throws DataTypeException  {  if  (  from == null )  {  return null ; } else  {   Object  [ ]  arrayOfT =  convertArray  ( from ,  converter . fromType  ( ) ) ;   Object  [ ]  arrayOfU =  (  Object  [ ] )  Array . newInstance  (  converter . toType  ( ) ,  from . length ) ;  for (   int  i = 0 ;  i <  arrayOfT . length ;  i ++ )  {    arrayOfU [ i ] =  convert  (  arrayOfT [ i ] , converter ) ; }  return  (  U  [ ] ) arrayOfU ; } }    @ SuppressWarnings  ( "unchecked" ) public static final  Object  [ ] convertArray  (   Object  [ ] from ,   Class  <  ? > toClass )  throws DataTypeException  {  if  (  from == null )  {  return null ; } else  if  (  !  toClass . isArray  ( ) )  {  return  convertArray  ( from ,   Array . newInstance  ( toClass , 0 ) . getClass  ( ) ) ; } else  if  (  toClass ==  from . getClass  ( ) )  {  return from ; } else  {   final  Class  <  ? >  toComponentType =  toClass . getComponentType  ( ) ;  if  (   from . length == 0 )  {  return  Arrays . copyOf  ( from ,  from . length ,  (  Class  <  ? extends  Object  [ ] > ) toClass ) ; } else  if  (    from [ 0 ] != null &&    from [ 0 ] . getClass  ( ) == toComponentType )  {  return  Arrays . copyOf  ( from ,  from . length ,  (  Class  <  ? extends  Object  [ ] > ) toClass ) ; } else  {   final  Object  [ ]  result =  (  Object  [ ] )  Array . newInstance  ( toComponentType ,  from . length ) ;  for (   int  i = 0 ;  i <  from . length ;  i ++ )  {    result [ i ] =  convert  (  from [ i ] , toComponentType ) ; }  return result ; } } }   public static final  <  U > U convert  (  Object from ,   Converter  <  ? ,  ? extends U > converter )  throws DataTypeException  {  return  convert0  ( from , converter ) ; }   private static final  <  T ,  U > U convert0  (  Object from ,   Converter  < T ,  ? extends U > converter )  throws DataTypeException  {   ConvertAll  < T >  all =  new  ConvertAll  < T >  (  converter . fromType  ( ) ) ;  return  converter . from  (  all . from  ( from ) ) ; }   public static final  <  T > T convert  (  Object from ,   Class  <  ? extends T > toClass )  throws DataTypeException  {  return  convert  ( from ,  new  ConvertAll  < T >  ( toClass ) ) ; }   public static final  <  T >  List  < T > convert  (   Collection  <  ? > collection ,   Class  <  ? extends T > type )  throws DataTypeException  {  return  convert  ( collection ,  new  ConvertAll  < T >  ( type ) ) ; }   public static final  <  U >  List  < U > convert  (   Collection  <  ? > collection ,   Converter  <  ? ,  ? extends U > converter )  throws DataTypeException  {  return  convert0  ( collection , converter ) ; }   private static final  <  T ,  U >  List  < U > convert0  (   Collection  <  ? > collection ,   Converter  < T ,  ? extends U > converter )  throws DataTypeException  {   ConvertAll  < T >  all =  new  ConvertAll  < T >  (  converter . fromType  ( ) ) ;   List  < U >  result =  new  ArrayList  < U >  (  collection . size  ( ) ) ;  for ( Object o : collection )  {   result . add  (  convert  (  all . from  ( o ) , converter ) ) ; }  return result ; }   private Convert  ( )  { }   private static class ConvertAll  <  U >  implements   Converter  < Object , U >  {   private static final  long  serialVersionUID = 2508560107067092501L ;   private final  Class  <  ? extends U >  toClass ;  ConvertAll  (   Class  <  ? extends U > toClass )  {    this . toClass = toClass ; }    @ SuppressWarnings  (  { "unchecked" , "rawtypes" } )  @ Override public U from  (  Object from )  {  if  (  from == null )  {  if  (  toClass . isPrimitive  ( ) )  {  if  (  toClass ==   char . class )  {  return  ( U )  Character . valueOf  (  (  char ) 0 ) ; } else  {  return  convert  ( 0 , toClass ) ; } } else  if  (  toClass ==  Optional . class )  {  return  ( U )  Optional . empty  ( ) ; } else  {  return null ; } } else  {   final  Class  <  ? >  fromClass =  from . getClass  ( ) ;  if  (  toClass == fromClass )  {  return  ( U ) from ; } else  if  (  toClass . isAssignableFrom  ( fromClass ) )  {  return  ( U ) from ; } else  if  (  fromClass ==    byte  [ ] . class )  {  if  (  toClass ==  UUID . class )  {  ByteBuffer  b =  ByteBuffer . wrap  (  (   byte  [ ] ) from ) ;   long  mostSigBits =  b . getLong  ( ) ;   long  leastSigBits =  b . getLong  ( ) ;  return  ( U )  new UUID  ( mostSigBits , leastSigBits ) ; } else  {  return  convert  (  new String  (  (   byte  [ ] ) from ) , toClass ) ; } } else  if  (  fromClass . isArray  ( ) )  {   Object  [ ]  fromArray =  (  Object  [ ] ) from ;  if  (    Collection . class . isAssignableFrom  ( toClass ) &&  toClass . isAssignableFrom  (  ArrayList . class ) )  {  return  ( U )  new ArrayList  (  Arrays . asList  ( fromArray ) ) ; } else  if  (    Collection . class . isAssignableFrom  ( toClass ) &&  toClass . isAssignableFrom  (  LinkedHashSet . class ) )  {  return  ( U )  new LinkedHashSet  (  Arrays . asList  ( fromArray ) ) ; }  if  (  toClass ==    java . sql . Array . class )  {  return  ( U )  new MockArray  ( null , fromArray , fromClass ) ; } else  {  return  ( U )  convertArray  ( fromArray , toClass ) ; } } else  if  (   toClass . isArray  ( ) &&   Collection . class . isAssignableFrom  ( fromClass ) )  {  Collection  f =  ( Collection ) from ;  Class  componentType =  toClass . getComponentType  ( ) ;   Object  [ ]  dest =  (  Object  [ ] )  Array . newInstance  ( componentType ,  f . size  ( ) ) ;   Object  [ ]  list =    f . stream  ( ) . map  (  e ->  {  if  (  !  componentType . isAssignableFrom  (  e . getClass  ( ) ) )  return  convert  ( e , componentType ) ;  return e ; } ) . toArray  ( ) ;   System . arraycopy  ( list , 0 , dest , 0 ,  dest . length ) ;  return  ( U ) dest ; } else  if  (  toClass ==  Optional . class )  {  return  ( U )  Optional . of  ( from ) ; } else  if  (  toClass ==  
<<<<<<<
  byte  [ ]
=======
String
>>>>>>>
 . class )  {  if  (  from instanceof 
<<<<<<<
UUID
=======
EnumType
>>>>>>>
 )  {  ByteBuffer  b =  ByteBuffer . wrap  (  new  byte  [ 16 ] ) ;   b . putLong  (   (  ( UUID ) from ) . getMostSignificantBits  ( ) ) ;   b . putLong  (   (  ( UUID ) from ) . getLeastSignificantBits  ( ) ) ;  return  ( U )  b . array  ( ) ; } else  {  return  ( U )  
<<<<<<<
 from . toString  ( )
=======
 (  ( EnumType ) from )
>>>>>>>
 . 
<<<<<<<
getBytes
=======
getLiteral
>>>>>>>
  ( ) ; }  return  ( U )  from . toString  ( ) ; } else  if  (   toClass ==  Byte . class ||  toClass ==   byte . class )  {  if  (   Number . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  Byte . valueOf  (   (  ( Number ) from ) . byteValue  ( ) ) ; }  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  Byte . valueOf  (  (  byte ) 1 ) :  Byte . valueOf  (  (  byte ) 0 ) ) ; }  try  {  return  ( U )  Byte . valueOf  (   new BigDecimal  (   from . toString  ( ) . trim  ( ) ) . byteValue  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (   toClass ==  Short . class ||  toClass ==   short . class )  {  if  (   Number . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  Short . valueOf  (   (  ( Number ) from ) . shortValue  ( ) ) ; }  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  Short . valueOf  (  (  short ) 1 ) :  Short . valueOf  (  (  short ) 0 ) ) ; }  try  {  return  ( U )  Short . valueOf  (   new BigDecimal  (   from . toString  ( ) . trim  ( ) ) . shortValue  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (   toClass ==  Integer . class ||  toClass ==   int . class )  {  if  (   Number . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  Integer . valueOf  (   (  ( Number ) from ) . intValue  ( ) ) ; }  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  Integer . valueOf  ( 1 ) :  Integer . valueOf  ( 0 ) ) ; }  try  {  return  ( U )  Integer . valueOf  (   new BigDecimal  (   from . toString  ( ) . trim  ( ) ) . intValue  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (   toClass ==  Long . class ||  toClass ==   long . class )  {  if  (   Number . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  Long . valueOf  (   (  ( Number ) from ) . longValue  ( ) ) ; }  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  Long . valueOf  ( 1L ) :  Long . valueOf  ( 0L ) ) ; }  if  (     java . util . Date . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  Long . valueOf  (   (  (   java . util . Date ) from ) . getTime  ( ) ) ; }  if  (   Temporal . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  Long . valueOf  (  millis  (  ( Temporal ) from ) ) ; }  try  {  return  ( U )  Long . valueOf  (   new BigDecimal  (   from . toString  ( ) . trim  ( ) ) . longValue  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (  toClass ==  UByte . class )  {  try  {  if  (   Number . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  ubyte  (   (  ( Number ) from ) . shortValue  ( ) ) ; }  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  ubyte  ( 1 ) :  ubyte  ( 0 ) ) ; }  return  ( U )  ubyte  (   new BigDecimal  (   from . toString  ( ) . trim  ( ) ) . shortValue  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (  toClass ==  UShort . class )  {  try  {  if  (   Number . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  ushort  (   (  ( Number ) from ) . intValue  ( ) ) ; }  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  ushort  ( 1 ) :  ushort  ( 0 ) ) ; }  return  ( U )  ushort  (   new BigDecimal  (   from . toString  ( ) . trim  ( ) ) . intValue  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (  toClass ==  UInteger . class )  {  try  {  if  (   Number . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  uint  (   (  ( Number ) from ) . longValue  ( ) ) ; }  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  uint  ( 1 ) :  uint  ( 0 ) ) ; }  return  ( U )  uint  (   new BigDecimal  (   from . toString  ( ) . trim  ( ) ) . longValue  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (  toClass ==  ULong . class )  {  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  ulong  ( 1 ) :  ulong  ( 0 ) ) ; }  if  (     java . util . Date . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  ulong  (   (  (   java . util . Date ) from ) . getTime  ( ) ) ; }  if  (   Temporal . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  ulong  (  millis  (  ( Temporal ) from ) ) ; }  try  {  return  ( U )  ulong  (    new BigDecimal  (   from . toString  ( ) . trim  ( ) ) . toBigInteger  ( ) . toString  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (   toClass ==  Float . class ||  toClass ==   float . class )  {  if  (   Number . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  Float . valueOf  (   (  ( Number ) from ) . floatValue  ( ) ) ; }  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  Float . valueOf  ( 1.0f ) :  Float . valueOf  ( 0.0f ) ) ; }  try  {  return  ( U )  Float . valueOf  (   from . toString  ( ) . trim  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (   toClass ==  Double . class ||  toClass ==   double . class )  {  if  (   Number . class . isAssignableFrom  ( fromClass ) )  {  return  ( U )  Double . valueOf  (   (  ( Number ) from ) . doubleValue  ( ) ) ; }  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  Double . valueOf  ( 1.0 ) :  Double . valueOf  ( 0.0 ) ) ; }  try  {  return  ( U )  Double . valueOf  (   from . toString  ( ) . trim  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (  toClass ==  BigDecimal . class )  {  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  BigDecimal . ONE :  BigDecimal . ZERO ) ; }  try  {  return  ( U )  new BigDecimal  (   from . toString  ( ) . trim  ( ) ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (  toClass ==  BigInteger . class )  {  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  BigInteger . ONE :  BigInteger . ZERO ) ; }  try  {  return  ( U )   new BigDecimal  (   from . toString  ( ) . trim  ( ) ) . toBigInteger  ( ) ; }  catch (   NumberFormatException e )  {  return null ; } } else  if  (   toClass ==  Boolean . class ||  toClass ==  boolean . class )  {  String  s =    from . toString  ( ) . toLowerCase  ( ) . trim  ( ) ;  if  (  TRUE_VALUES . contains  ( s ) )  {  return  ( U )  Boolean . TRUE ; } else  if  (  FALSE_VALUES . contains  ( s ) )  {  return  ( U )  Boolean . FALSE ; } else  {  return  ( U )  (   toClass ==  Boolean . class ? null : false ) ; } } else  if  (   toClass ==  Character . class ||  toClass ==   char . class )  {  if  (   fromClass ==  Boolean . class ||  fromClass ==  boolean . class )  {  return  ( U )  (   (  ( Boolean ) from ) ?  Character . valueOf  ( '1' ) :  Character . valueOf  ( '0' ) ) ; }  if  (    from . toString  ( ) . length  ( ) < 1 )  {  return null ; }  return  ( U )  Character . valueOf  (   from . toString  ( ) . charAt  ( 0 ) ) ; } else  if  (   (  fromClass ==  String . class ) &&  toClass ==  URI . class )  {  try  {  return  ( U )  new URI  (  from . toString  ( ) ) ; }  catch (   URISyntaxException e )  {  return null ; } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==  URL . class )  {  try  {  return  ( U )   new URI  (  from . toString  ( ) ) . toURL  ( ) ; }  catch (   Exception e )  {  return null ; } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==  File . class )  {  try  {  return  ( U )  new File  (  from . toString  ( ) ) ; }  catch (   Exception e )  {  return null ; } } else  if  (     java . util . Date . class . isAssignableFrom  ( fromClass ) )  {  return  toDate  (   (  (   java . util . Date ) from ) . getTime  ( ) , toClass ) ; } else  if  (   Temporal . class . isAssignableFrom  ( fromClass ) )  {  return  toDate  (  convert  ( from ,  Long . class ) , toClass ) ; } else  if  (   (   fromClass ==  Long . class ||  fromClass ==   long . class ) &&     java . util . Date . class . isAssignableFrom  ( toClass ) )  {  return  toDate  (  ( Long ) from , toClass ) ; } else  if  (   (   fromClass ==  Long . class ||  fromClass ==   long . class ) &&   Temporal . class . isAssignableFrom  ( toClass ) )  {  return  toDate  (  ( Long ) from , toClass ) ; } else  if  (   (  fromClass ==  String . class ) &&  toClass ==    java . sql . Date . class )  {  try  {  return  ( U )    java . sql . Date . valueOf  (  ( String ) from ) ; }  catch (   IllegalArgumentException e )  {  return null ; } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==    java . sql . Time . class )  {  try  {  return  ( U )    java . sql . Time . valueOf  (  ( String ) from ) ; }  catch (   IllegalArgumentException e )  {  return null ; } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==    java . sql . Timestamp . class )  {  try  {  return  ( U )    java . sql . Timestamp . valueOf  (  ( String ) from ) ; }  catch (   IllegalArgumentException e )  {  return null ; } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==  LocalDate . class )  {  try  {  return  ( U )     java . sql . Date . valueOf  (  ( String ) from ) . toLocalDate  ( ) ; }  catch (   IllegalArgumentException e1 )  {  try  {  return  ( U )  LocalDate . parse  (  ( String ) from ) ; }  catch (   DateTimeParseException e2 )  {  return null ; } } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==  LocalTime . class )  {  try  {  return  ( U )     java . sql . Time . valueOf  (  ( String ) from ) . toLocalTime  ( ) ; }  catch (   IllegalArgumentException e1 )  {  try  {  return  ( U )  LocalTime . parse  (  ( String ) from ) ; }  catch (   DateTimeParseException e2 )  {  return null ; } } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==  OffsetTime . class )  {  try  {  return  ( U )      java . sql . Time . valueOf  (  ( String ) from ) . toLocalTime  ( ) . atOffset  (   OffsetTime . now  ( ) . getOffset  ( ) ) ; }  catch (   IllegalArgumentException e1 )  {  try  {  return  ( U )  OffsetTime . parse  (  ( String ) from ) ; }  catch (   DateTimeParseException e2 )  {  return null ; } } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==  LocalDateTime . class )  {  try  {  return  ( U )     java . sql . Timestamp . valueOf  (  ( String ) from ) . toLocalDateTime  ( ) ; }  catch (   IllegalArgumentException e1 )  {  try  {  return  ( U )  LocalDateTime . parse  (  ( String ) from ) ; }  catch (   DateTimeParseException e2 )  {  return null ; } } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==  OffsetDateTime . class )  {  try  {  return  ( U )      java . sql . Timestamp . valueOf  (  ( String ) from ) . toLocalDateTime  ( ) . atOffset  (   OffsetDateTime . now  ( ) . getOffset  ( ) ) ; }  catch (   IllegalArgumentException e1 )  {  try  {  return  ( U )  OffsetDateTime . parse  (  ( String ) from ) ; }  catch (   DateTimeParseException e2 )  {  return null ; } } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==  Instant . class )  {  try  {  return  ( U )       java . sql . Timestamp . valueOf  (  ( String ) from ) . toLocalDateTime  ( ) . atOffset  (   OffsetDateTime . now  ( ) . getOffset  ( ) ) . toInstant  ( ) ; }  catch (   IllegalArgumentException e1 )  {  try  {  return  ( U )  Instant . parse  (  ( String ) from ) ; }  catch (   DateTimeParseException e2 )  {  return null ; } } } else  if  (   (  fromClass ==  String . class ) &&     java . lang . Enum . class . isAssignableFrom  ( toClass ) )  {  try  {  return  ( U )    java . lang . Enum . valueOf  (  ( Class ) toClass ,  ( String ) from ) ; }  catch (   IllegalArgumentException e )  {  return null ; } } else  if  (   (  fromClass ==  String . class ) &&  toClass ==  UUID . class )  {  try  {  return  ( U )  parseUUID  (  ( String ) from ) ; }  catch (   IllegalArgumentException e )  {  return null ; } } else  if  (   Record . class . isAssignableFrom  ( fromClass ) )  {  Record  record =  ( Record ) from ;  return  record . into  ( toClass ) ; } }  throw  fail  ( from , toClass ) ; }    @ Override public Object to  (  U to )  {  return to ; }    @ Override public  Class  < Object > fromType  ( )  {  return  Object . class ; }    @ SuppressWarnings  ( "unchecked" )  @ Override public  Class  < U > toType  ( )  {  return  (  Class  < U > ) toClass ; }    @ SuppressWarnings  ( "unchecked" ) private static  <  X > X toDate  (   long time ,   Class  < X > toClass )  {  if  (  toClass ==  Date . class )  {  return  ( X )  new Date  ( time ) ; } else  if  (  toClass ==  Time . class )  {  return  ( X )  new Time  ( time ) ; } else  if  (  toClass ==  Timestamp . class )  {  return  ( X )  new Timestamp  ( time ) ; } else  if  (  toClass ==    java . util . Date . class )  {  return  ( X )  new   java . util . Date  ( time ) ; } else  if  (  toClass ==  Calendar . class )  {  Calendar  calendar =  Calendar . getInstance  ( ) ;   calendar . setTimeInMillis  ( time ) ;  return  ( X ) calendar ; } else  if  (  toClass ==  LocalDate . class )  {  return  ( X )   new Date  ( time ) . toLocalDate  ( ) ; } else  if  (  toClass ==  LocalTime . class )  {  return  ( X )   new Time  ( time ) . toLocalTime  ( ) ; } else  if  (  toClass ==  OffsetTime . class )  {  return  ( X )    new Time  ( time ) . toLocalTime  ( ) . atOffset  (   OffsetTime . now  ( ) . getOffset  ( ) ) ; } else  if  (  toClass ==  LocalDateTime . class )  {  return  ( X )   new Timestamp  ( time ) . toLocalDateTime  ( ) ; } else  if  (  toClass ==  OffsetDateTime . class )  {  return  ( X )    new Timestamp  ( time ) . toLocalDateTime  ( ) . atOffset  (   OffsetDateTime . now  ( ) . getOffset  ( ) ) ; } else  if  (  toClass ==  Instant . class )  {  return  ( X )  Instant . ofEpochMilli  ( time ) ; }  throw  fail  ( time , toClass ) ; }   private static final  long millis  (  Temporal temporal )  {  if  (  temporal instanceof LocalDate )  {  return   Date . valueOf  (  ( LocalDate ) temporal ) . getTime  ( ) ; } else  if  (  temporal instanceof LocalTime )  {  return   Time . valueOf  (  ( LocalTime ) temporal ) . getTime  ( ) ; } else  if  (  temporal instanceof LocalDateTime )  {  return   Timestamp . valueOf  (  ( LocalDateTime ) temporal ) . getTime  ( ) ; } else  if  (  temporal . isSupported  ( INSTANT_SECONDS ) )  {  return   1000 *  temporal . getLong  ( INSTANT_SECONDS ) +  temporal . getLong  ( MILLI_OF_SECOND ) ; } else  if  (  temporal . isSupported  ( MILLI_OF_DAY ) )  {  return  temporal . getLong  ( MILLI_OF_DAY ) ; }  throw  fail  ( temporal ,  Long . class ) ; }   private static final UUID parseUUID  (  String string )  {  if  (  string == null )  {  return null ; } else  if  (  string . contains  ( "-" ) )  {  return  UUID . fromString  ( string ) ; } else  {  return  UUID . fromString  (   UUID_PATTERN . matcher  ( string ) . replaceAll  ( "$1-$2-$3-$4-$5" ) ) ; } }   private static DataTypeException fail  (  Object from ,   Class  <  ? > toClass )  {  return  new DataTypeException  (      "Cannot convert from " + from + " (" +  from . getClass  ( ) + ") to " + toClass ) ; } }   public static final  <  U >  U  [ ] convertCollection  (  Collection from ,   Class  <  ? extends  U  [ ] > to )  {  return   new  ConvertAll  <  U  [ ] >  ( to ) . from  ( from ) ; } }