  package   io . jsonwebtoken . lang ;   import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Collection ;  import   java . util . Enumeration ;  import   java . util . Iterator ;  import   java . util . LinkedHashSet ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Properties ;  import   java . util . Set ;    @ SuppressWarnings  (  { "unused" , "rawtypes" } ) public final class Collections  {   private Collections  ( )  { }   public static  <  T >  List  < T > emptyList  ( )  {  return    java . util . Collections . emptyList  ( ) ; }    @ SuppressWarnings  ( "unused" ) public static  <  T >  Set  < T > emptySet  ( )  {  return    java . util . Collections . emptySet  ( ) ; }    @ SuppressWarnings  ( "unused" ) public static  <  K ,  V >  Map  < K , V > emptyMap  ( )  {  return    java . util . Collections . emptyMap  ( ) ; }    @ SafeVarargs public static  <  T >  List  < T > of  (  T ...  elements )  {  if  (   elements == null ||   elements . length == 0 )  {  return    java . util . Collections . emptyList  ( ) ; }  return    java . util . Collections . unmodifiableList  (  Arrays . asList  ( elements ) ) ; }    @ SafeVarargs public static  <  T >  Set  < T > setOf  (  T ...  elements )  {  if  (   elements == null ||   elements . length == 0 )  {  return    java . util . Collections . emptySet  ( ) ; }   Set  < T >  set =  new  LinkedHashSet  < >  (  Arrays . asList  ( elements ) ) ;  return  immutable  ( set ) ; }   public static  <  K ,  V >  Map  < K , V > immutable  (   Map  < K , V > m )  {  return   m != null ?    java . util . Collections . unmodifiableMap  ( m ) : null ; }   public static  <  T >  Set  < T > immutable  (   Set  < T > set )  {  return   set != null ?    java . util . Collections . unmodifiableSet  ( set ) : null ; }   public static  <  T >  List  < T > immutable  (   List  < T > list )  {  return   list != null ?    java . util . Collections . unmodifiableList  ( list ) : null ; }    @ SuppressWarnings  ( "unchecked" ) public static  <  T ,  C  extends  Collection  < T > > C immutable  (  C c )  {  if  (  c == null )  {  return null ; } else  if  (  c instanceof Set )  {  return  ( C )    java . util . Collections . unmodifiableSet  (  (  Set  < T > ) c ) ; } else  if  (  c instanceof List )  {  return  ( C )    java . util . Collections . unmodifiableList  (  (  List  < T > ) c ) ; } else  {  return  ( C )    java . util . Collections . unmodifiableCollection  ( c ) ; } }   public static boolean isEmpty  (   Collection  <  ? > collection )  {  return   size  ( collection ) == 0 ; }   public static  int size  (   Collection  <  ? > collection )  {  return   collection == null ? 0 :  collection . size  ( ) ; }   public static  int size  (   Map  <  ? ,  ? > map )  {  return   map == null ? 0 :  map . size  ( ) ; }   public static boolean isEmpty  (   Map  <  ? ,  ? > map )  {  return   size  ( map ) == 0 ; }   public static List arrayToList  (  Object source )  {  return  Arrays . asList  (  Objects . toObjectArray  ( source ) ) ; }    @ SafeVarargs public static  <  T >  Set  < T > concat  (   Set  < T > c ,  T ...  elements )  {   int  size =  Math . max  ( 1 ,   Collections . size  ( c ) +     io . jsonwebtoken . lang . Arrays . length  ( elements ) ) ;   Set  < T >  set =  new  LinkedHashSet  < >  ( size ) ;   set . addAll  ( c ) ;     java . util . Collections . addAll  ( set , elements ) ;  return  immutable  ( set ) ; }    @ SuppressWarnings  ( "unchecked" ) public static void mergeArrayIntoCollection  (  Object array ,  Collection collection )  {  if  (  collection == null )  {  throw  new IllegalArgumentException  ( "Collection must not be null" ) ; }   Object  [ ]  arr =  Objects . toObjectArray  ( array ) ;     java . util . Collections . addAll  ( collection , arr ) ; }    @ SuppressWarnings  ( "unchecked" ) public static void mergePropertiesIntoMap  (  Properties props ,  Map map )  {  if  (  map == null )  {  throw  new IllegalArgumentException  ( "Map must not be null" ) ; }  if  (  props != null )  {  for (  Enumeration  en =  props . propertyNames  ( ) ;  en . hasMoreElements  ( ) ; )  {  String  key =  ( String )  en . nextElement  ( ) ;  Object  value =  props . getProperty  ( key ) ;  if  (  value == null )  {   value =  props . get  ( key ) ; }   map . put  ( key , value ) ; } } }   public static boolean contains  (  Iterator iterator ,  Object element )  {  if  (  iterator != null )  {  while  (  iterator . hasNext  ( ) )  {  Object  candidate =  iterator . next  ( ) ;  if  (  Objects . nullSafeEquals  ( candidate , element ) )  {  return true ; } } }  return false ; }   public static boolean contains  (  Enumeration enumeration ,  Object element )  {  if  (  enumeration != null )  {  while  (  enumeration . hasMoreElements  ( ) )  {  Object  candidate =  enumeration . nextElement  ( ) ;  if  (  Objects . nullSafeEquals  ( candidate , element ) )  {  return true ; } } }  return false ; }   public static boolean containsInstance  (  Collection collection ,  Object element )  {  if  (  collection != null )  {  for ( Object candidate : collection )  {  if  (  candidate == element )  {  return true ; } } }  return false ; }   public static boolean containsAny  (  Collection source ,  Collection candidates )  {  if  (   isEmpty  ( source ) ||  isEmpty  ( candidates ) )  {  return false ; }  for ( Object candidate : candidates )  {  if  (  source . contains  ( candidate ) )  {  return true ; } }  return false ; }   public static Object findFirstMatch  (  Collection source ,  Collection candidates )  {  if  (   isEmpty  ( source ) ||  isEmpty  ( candidates ) )  {  return null ; }  for ( Object candidate : candidates )  {  if  (  source . contains  ( candidate ) )  {  return candidate ; } }  return null ; }    @ SuppressWarnings  ( "unchecked" ) public static  <  T > T findValueOfType  (   Collection  <  ? > collection ,   Class  < T > type )  {  if  (  isEmpty  ( collection ) )  {  return null ; }  T  value = null ;  for ( Object element : collection )  {  if  (   type == null ||  type . isInstance  ( element ) )  {  if  (  value != null )  {  return null ; }   value =  ( T ) element ; } }  return value ; }   public static Object findValueOfType  (   Collection  <  ? > collection ,    Class  <  ? >  [ ] types )  {  if  (   isEmpty  ( collection ) ||  Objects . isEmpty  ( types ) )  {  return null ; }  for (  Class  <  ? > type : types )  {  Object  value =  findValueOfType  ( collection , type ) ;  if  (  value != null )  {  return value ; } }  return null ; }   public static boolean hasUniqueObject  (  Collection collection )  {  if  (  isEmpty  ( collection ) )  {  return false ; }  boolean  hasCandidate = false ;  Object  candidate = null ;  for ( Object elem : collection )  {  if  (  ! hasCandidate )  {   hasCandidate = true ;   candidate = elem ; } else  if  (  candidate != elem )  {  return false ; } }  return true ; }   public static  Class  <  ? > findCommonElementType  (  Collection collection )  {  if  (  isEmpty  ( collection ) )  {  return null ; }   Class  <  ? >  candidate = null ;  for ( Object val : collection )  {  if  (  val != null )  {  if  (  candidate == null )  {   candidate =  val . getClass  ( ) ; } else  if  (  candidate !=  val . getClass  ( ) )  {  return null ; } } }  return candidate ; }   public static  <  A ,  E  extends A >  A  [ ] toArray  (   Enumeration  < E > enumeration ,   A  [ ] array )  {   ArrayList  < A >  elements =  new  ArrayList  < >  ( ) ;  while  (  enumeration . hasMoreElements  ( ) )  {   elements . add  (  enumeration . nextElement  ( ) ) ; }  return  elements . toArray  ( array ) ; }   public static  <  E >  Iterator  < E > toIterator  (   Enumeration  < E > enumeration )  {  return  new  EnumerationIterator  < >  ( enumeration ) ; }   private static class EnumerationIterator  <  E >  implements   Iterator  < E >  {   private final  Enumeration  < E >  enumeration ;   public EnumerationIterator  (   Enumeration  < E > enumeration )  {    this . enumeration = enumeration ; }   public boolean hasNext  ( )  {  return   this . enumeration . hasMoreElements  ( ) ; }   public E next  ( )  {  return   this . enumeration . nextElement  ( ) ; }   public void remove  ( )  throws UnsupportedOperationException  {  throw  new UnsupportedOperationException  ( "Not supported" ) ; } } }