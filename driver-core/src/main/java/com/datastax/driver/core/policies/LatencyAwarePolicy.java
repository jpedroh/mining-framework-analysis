  package     com . datastax . driver . core . policies ;   import  java . util .  * ;  import   java . util . concurrent .  * ;  import     java . util . concurrent . atomic . AtomicReference ;  import     com . google . common . collect . AbstractIterator ;  import     com . google . common . collect . ImmutableMap ;  import      com . google . common . util . concurrent . ThreadFactoryBuilder ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import    com . datastax . driver . core .  * ;   public class LatencyAwarePolicy  implements  LoadBalancingPolicy  {   private static final Logger  logger =  LoggerFactory . getLogger  (  LatencyAwarePolicy . class ) ;   private final LoadBalancingPolicy  childPolicy ;   private final Tracker  latencyTracker ;   private final ScheduledExecutorService  updaterService =  Executors . newSingleThreadScheduledExecutor  (  threadFactory  ( "LatencyAwarePolicy updater" ) ) ;   private final  double  exclusionThreshold ;   private final  long  scale ;   private final  long  retryPeriod ;   private final  long  minMeasure ;   private LatencyAwarePolicy  (  LoadBalancingPolicy childPolicy ,   double exclusionThreshold ,   long scale ,   long retryPeriod ,   long updateRate ,   int minMeasure )  {    this . childPolicy = childPolicy ;    this . retryPeriod = retryPeriod ;    this . scale = scale ;    this . latencyTracker =  new Tracker  ( ) ;    this . exclusionThreshold = exclusionThreshold ;    this . minMeasure = minMeasure ;   updaterService . scheduleAtFixedRate  (  new Updater  ( ) , updateRate , updateRate ,  TimeUnit . NANOSECONDS ) ; }   public static Builder builder  (  LoadBalancingPolicy childPolicy )  {  return  new Builder  ( childPolicy ) ; }   private class Updater  implements  Runnable  {   private  Set  < Host >  excludedAtLastTick =  Collections .  < Host > emptySet  ( ) ;    @ Override public void run  ( )  {  try  {   logger . trace  ( "Updating LatencyAwarePolicy minimum" ) ;   latencyTracker . updateMin  ( ) ;  if  (  logger . isDebugEnabled  ( ) )  {   Set  < Host >  excludedThisTick =  new  HashSet  < Host >  ( ) ;   double  currentMin =  latencyTracker . getMinAverage  ( ) ;  for (   Map . Entry  < Host ,  Snapshot . Stats > entry :    getScoresSnapshot  ( ) . getAllStats  ( ) . entrySet  ( ) )  {  Host  host =  entry . getKey  ( ) ;   Snapshot . Stats  stats =  entry . getValue  ( ) ;  if  (   stats . getMeasurementsCount  ( ) < minMeasure )  continue ;  if  (   stats . lastUpdatedSince  ( ) > retryPeriod )  {  if  (  excludedAtLastTick . contains  ( host ) )   logger . debug  (  String . format  ( "Previously avoided host %s has not be queried since %.3fms: will be reconsidered." , host ,  inMS  (  stats . lastUpdatedSince  ( ) ) ) ) ;  continue ; }  if  (   stats . getLatencyScore  ( ) >  (  (  long )  (  exclusionThreshold * currentMin ) ) )  {   excludedThisTick . add  ( host ) ;  if  (  !  excludedAtLastTick . contains  ( host ) )   logger . debug  (  String . format  ( "Host %s has an average latency score of %.3fms, more than %f times more than the minimum %.3fms: will be avoided temporarily." , host ,  inMS  (  stats . getLatencyScore  ( ) ) , exclusionThreshold ,  inMS  ( currentMin ) ) ) ;  continue ; }  if  (  excludedAtLastTick . contains  ( host ) )  {   logger . debug  ( "Previously avoided host {} average latency has come back within accepted bounds: will be reconsidered." , host ) ; } }   excludedAtLastTick = excludedThisTick ; } }  catch (   RuntimeException e )  {   logger . error  ( "Error while updating LatencyAwarePolicy minimum" , e ) ; } } }   private static  double inMS  (   long nanos )  {  return   (  (  double ) nanos ) /  (  1000 * 1000 ) ; }   private static  double inMS  (   double nanos )  {  return  nanos /  (  1000 * 1000 ) ; }   private static ThreadFactory threadFactory  (  String nameFormat )  {  return    new ThreadFactoryBuilder  ( ) . setNameFormat  ( nameFormat ) . build  ( ) ; }    @ Override public void init  (  Cluster cluster ,   Collection  < Host > hosts )  {   childPolicy . init  ( cluster , hosts ) ;   cluster . register  ( latencyTracker ) ; }    @ Override public HostDistance distance  (  Host host )  {  return  childPolicy . distance  ( host ) ; }    @ Override public  Iterator  < Host > newQueryPlan  (  String loggedKeyspace ,  Statement statement )  {   final  Iterator  < Host >  childIter =  childPolicy . newQueryPlan  ( loggedKeyspace , statement ) ;  return  new  AbstractIterator  < Host >  ( )  {   private  Queue  < Host >  skipped ;    @ Override protected Host computeNext  ( )  {   long  min =  latencyTracker . getMinAverage  ( ) ;   long  now =  System . nanoTime  ( ) ;  while  (  childIter . hasNext  ( ) )  {  Host  host =  childIter . next  ( ) ;  TimestampedAverage  latency =  latencyTracker . latencyOf  ( host ) ;  if  (     min < 0 ||  latency == null ||   latency . nbMeasure < minMeasure ||   (  now -  latency . timestamp ) > retryPeriod )  return host ;  if  (   latency . average <=  (  (  long )  (  exclusionThreshold *  (  double ) min ) ) )  return host ;  if  (  skipped == null )   skipped =  new  ArrayDeque  < Host >  ( ) ;   skipped . offer  ( host ) ; }  if  (   skipped != null &&  !  skipped . isEmpty  ( ) )  return  skipped . poll  ( ) ;  return  endOfData  ( ) ; } ; } ; }   public Snapshot getScoresSnapshot  ( )  {   Map  < Host , TimestampedAverage >  currentLatencies =  latencyTracker . currentLatencies  ( ) ;    ImmutableMap . Builder  < Host ,  Snapshot . Stats >  builder =  ImmutableMap . builder  ( ) ;   long  now =  System . nanoTime  ( ) ;  for (   Map . Entry  < Host , TimestampedAverage > entry :  currentLatencies . entrySet  ( ) )  {  Host  host =  entry . getKey  ( ) ;  TimestampedAverage  latency =  entry . getValue  ( ) ;   Snapshot . Stats  stats =  new  Snapshot . Stats  (  now -  latency . timestamp ,  latency . average ,  latency . nbMeasure ) ;   builder . put  ( host , stats ) ; }  return  new Snapshot  (  builder . build  ( ) ) ; }    @ Override public void onUp  (  Host host )  {   childPolicy . onUp  ( host ) ; }    @ Override public void onDown  (  Host host )  {   childPolicy . onDown  ( host ) ;   latencyTracker . resetHost  ( host ) ; }    @ Override public void onAdd  (  Host host )  {   childPolicy . onAdd  ( host ) ; }    @ Override public void onRemove  (  Host host )  {   childPolicy . onRemove  ( host ) ;   latencyTracker . resetHost  ( host ) ; }   public static class Snapshot  {   private final  Map  < Host , Stats >  stats ;   private Snapshot  (   Map  < Host , Stats > stats )  {    this . stats = stats ; }   public  Map  < Host , Stats > getAllStats  ( )  {  return stats ; }   public Stats getStats  (  Host host )  {  return  stats . get  ( host ) ; }   public static class Stats  {   private final  long  lastUpdatedSince ;   private final  long  average ;   private final  long  nbMeasurements ;   private Stats  (   long lastUpdatedSince ,   long average ,   long nbMeasurements )  {    this . lastUpdatedSince = lastUpdatedSince ;    this . average = average ;    this . nbMeasurements = nbMeasurements ; }   public  long lastUpdatedSince  ( )  {  return lastUpdatedSince ; }   public  long getLatencyScore  ( )  {  return average ; }   public  long getMeasurementsCount  ( )  {  return nbMeasurements ; } } }   private class Tracker  implements  LatencyTracker  {   private final  ConcurrentMap  < Host , HostLatencyTracker >  latencies =  new  ConcurrentHashMap  < Host , HostLatencyTracker >  ( ) ;   private volatile  long  cachedMin =  - 1L ;   public void update  (  Host host ,   long newLatencyNanos )  {  HostLatencyTracker  hostTracker =  latencies . get  ( host ) ;  if  (  hostTracker == null )  {   hostTracker =  new HostLatencyTracker  ( scale ,   (  30L * minMeasure ) / 100L ) ;  HostLatencyTracker  old =  latencies . putIfAbsent  ( host , hostTracker ) ;  if  (  old != null )   hostTracker = old ; }   hostTracker . add  ( newLatencyNanos ) ; }   public void updateMin  ( )  {   long  newMin =  Long . MAX_VALUE ;   long  now =  System . nanoTime  ( ) ;  for ( HostLatencyTracker tracker :  latencies . values  ( ) )  {  TimestampedAverage  latency =  tracker . getCurrentAverage  ( ) ;  if  (     latency != null &&   latency . average >= 0 &&   latency . nbMeasure >= minMeasure &&   (  now -  latency . timestamp ) <= retryPeriod )   newMin =  Math . min  ( newMin ,  latency . average ) ; }  if  (  newMin !=  Long . MAX_VALUE )   cachedMin = newMin ; }   public  long getMinAverage  ( )  {  return cachedMin ; }   public TimestampedAverage latencyOf  (  Host host )  {  HostLatencyTracker  tracker =  latencies . get  ( host ) ;  return   tracker == null ? null :  tracker . getCurrentAverage  ( ) ; }   public  Map  < Host , TimestampedAverage > currentLatencies  ( )  {   Map  < Host , TimestampedAverage >  map =  new  HashMap  < Host , TimestampedAverage >  (  latencies . size  ( ) ) ;  for (   Map . Entry  < Host , HostLatencyTracker > entry :  latencies . entrySet  ( ) )   map . put  (  entry . getKey  ( ) ,   entry . getValue  ( ) . getCurrentAverage  ( ) ) ;  return map ; }   public void resetHost  (  Host host )  {   latencies . remove  ( host ) ; } }   private static class TimestampedAverage  {   private final  long  timestamp ;   private final  long  average ;   private final  long  nbMeasure ;  TimestampedAverage  (   long timestamp ,   long average ,   long nbMeasure )  {    this . timestamp = timestamp ;    this . average = average ;    this . nbMeasure = nbMeasure ; } }   private static class HostLatencyTracker  {   private final  long  thresholdToAccount ;   private final  double  scale ;   private final  AtomicReference  < TimestampedAverage >  current =  new  AtomicReference  < TimestampedAverage >  ( ) ;  HostLatencyTracker  (   long scale ,   long thresholdToAccount )  {    this . scale =  (  double ) scale ;    this . thresholdToAccount = thresholdToAccount ; }   public void add  (   long newLatencyNanos )  {  TimestampedAverage  previous ,  next ;  do  {   previous =  current . get  ( ) ;   next =  computeNextAverage  ( previous , newLatencyNanos ) ; } while  (   next != null &&  !  current . compareAndSet  ( previous , next ) ) ; }   private TimestampedAverage computeNextAverage  (  TimestampedAverage previous ,   long newLatencyNanos )  {   long  currentTimestamp =  System . nanoTime  ( ) ;   long  nbMeasure =   previous == null ? 1 :   previous . nbMeasure + 1 ;  if  (  nbMeasure < thresholdToAccount )  return  new TimestampedAverage  ( currentTimestamp ,  - 1L , nbMeasure ) ;  if  (   previous == null ||   previous . average < 0 )  return  new TimestampedAverage  ( currentTimestamp , newLatencyNanos , nbMeasure ) ;   long  delay =  currentTimestamp -  previous . timestamp ;  if  (  delay <= 0 )  return null ;   double  scaledDelay =   (  (  double ) delay ) / scale ;   double  prevWeight =   Math . log  (  scaledDelay + 1 ) / scaledDelay ;   long  newAverage =  (  long )  (    (  1.0 - prevWeight ) * newLatencyNanos +  prevWeight *  previous . average ) ;  return  new TimestampedAverage  ( currentTimestamp , newAverage , nbMeasure ) ; }   public TimestampedAverage getCurrentAverage  ( )  {  return  current . get  ( ) ; } }   public static class Builder  {   private static final  double  DEFAULT_EXCLUSION_THRESHOLD = 2.0 ;   private static final  long  DEFAULT_SCALE =   TimeUnit . MILLISECONDS . toNanos  ( 100 ) ;   private static final  long  DEFAULT_RETRY_PERIOD =   TimeUnit . SECONDS . toNanos  ( 10 ) ;   private static final  long  DEFAULT_UPDATE_RATE =   TimeUnit . MILLISECONDS . toNanos  ( 100 ) ;   private static final  int  DEFAULT_MIN_MEASURE = 50 ;   private final LoadBalancingPolicy  childPolicy ;   private  double  exclusionThreshold = DEFAULT_EXCLUSION_THRESHOLD ;   private  long  scale = DEFAULT_SCALE ;   private  long  retryPeriod = DEFAULT_RETRY_PERIOD ;   private  long  updateRate = DEFAULT_UPDATE_RATE ;   private  int  minMeasure = DEFAULT_MIN_MEASURE ;   public Builder  (  LoadBalancingPolicy childPolicy )  {    this . childPolicy = childPolicy ; }   public Builder withExclusionThreshold  (   double exclusionThreshold )  {  if  (  exclusionThreshold < 1d )  throw  new IllegalArgumentException  ( "Invalid exclusion threshold, must be greater than 1." ) ;    this . exclusionThreshold = exclusionThreshold ;  return this ; }   public Builder withScale  (   long scale ,  TimeUnit unit )  {  if  (  scale <= 0 )  throw  new IllegalArgumentException  ( "Invalid scale, must be strictly positive" ) ;  return this ; }   public Builder withRetryPeriod  (   long retryPeriod ,  TimeUnit unit )  {  if  (  retryPeriod < 0 )  throw  new IllegalArgumentException  ( "Invalid retry period, must be positive" ) ;    this . retryPeriod =  unit . toNanos  ( retryPeriod ) ;  return this ; }   public Builder withUpdateRate  (   long updateRate ,  TimeUnit unit )  {  if  (  updateRate <= 0 )  throw  new IllegalArgumentException  ( "Invalid update rate value, must be strictly positive" ) ;    this . updateRate =  unit . toNanos  ( updateRate ) ;  return this ; }   public Builder withMininumMeasurements  (   int minMeasure )  {  if  (  minMeasure < 0 )  throw  new IllegalArgumentException  ( "Invalid minimum measurements value, must be positive" ) ;    this . minMeasure = minMeasure ;  return this ; }   public LatencyAwarePolicy build  ( )  {  return  new LatencyAwarePolicy  ( childPolicy , exclusionThreshold , scale , retryPeriod , updateRate , minMeasure ) ; } } }