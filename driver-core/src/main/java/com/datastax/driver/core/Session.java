  package    com . datastax . driver . core ;   import   java . net . InetAddress ;  import   java . nio . ByteBuffer ;  import  java . util .  * ;  import   java . util . concurrent .  * ;  import     java . util . concurrent . atomic . AtomicBoolean ;  import      com . google . common . util . concurrent . Futures ;  import      com . google . common . util . concurrent . ListenableFuture ;  import      com . google . common . util . concurrent . ListeningExecutorService ;  import      com . google . common . util . concurrent . MoreExecutors ;  import      com . google . common . util . concurrent . Uninterruptibles ;  import     com . datastax . driver . core . exceptions .  * ;  import     com . datastax . driver . core . policies .  * ;  import     com . datastax . cassandra . transport . Message ;  import     com . datastax . cassandra . transport . messages .  * ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;   public class Session  {   private static final Logger  logger =  LoggerFactory . getLogger  (  Session . class ) ;   final Manager  manager ;  Session  (  Cluster cluster ,   Collection  < Host > hosts )  {    this . manager =  new Manager  ( cluster , hosts ) ; }   public ResultSet execute  (  String query )  {  return  execute  (  new SimpleStatement  ( query ) ) ; }   public ResultSet execute  (  Query query )  {  return   executeAsync  ( query ) . getUninterruptibly  ( ) ; }   public ResultSetFuture executeAsync  (  String query )  {  return  executeAsync  (  new SimpleStatement  ( query ) ) ; }   public ResultSetFuture executeAsync  (  Query query )  {  if  (  query instanceof Statement )  {  return  manager . executeQuery  (  new QueryMessage  (   (  ( Statement ) query ) . getQueryString  ( ) ,  ConsistencyLevel . toCassandraCL  (  query . getConsistencyLevel  ( ) ) ) , query ) ; } else  {  assert  query instanceof BoundStatement : query ;  BoundStatement  bs =  ( BoundStatement ) query ;  return  manager . executeQuery  (  new ExecuteMessage  (   bs . statement . id ,  Arrays . asList  (  bs . values ) ,  ConsistencyLevel . toCassandraCL  (  query . getConsistencyLevel  ( ) ) ) , query ) ; } }   public PreparedStatement prepare  (  String query )  {   Connection . Future  future =  new  Connection . Future  (  new PrepareMessage  ( query ) ) ;   manager . execute  ( future ,  Query . DEFAULT ) ;  return  toPreparedStatement  ( query , future ) ; }   public PreparedStatement prepare  (  Statement statement )  {  PreparedStatement  prepared =  prepare  (  statement . getQueryString  ( ) ) ;  ByteBuffer  routingKey =  statement . getRoutingKey  ( ) ;  if  (  routingKey != null )   prepared . setRoutingKey  ( routingKey ) ;   prepared . setConsistencyLevel  (  statement . getConsistencyLevel  ( ) ) ;  if  (  statement . isTracing  ( ) )   prepared . enableTracing  ( ) ;   prepared . setRetryPolicy  (  statement . getRetryPolicy  ( ) ) ;  return prepared ; }   public void shutdown  ( )  {   shutdown  (  Long . MAX_VALUE ,  TimeUnit . MILLISECONDS ) ; }   public boolean shutdown  (   long timeout ,  TimeUnit unit )  {  try  {  return  manager . shutdown  ( timeout , unit ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ;  return false ; } }   public Cluster getCluster  ( )  {  return  manager . cluster ; }   private PreparedStatement toPreparedStatement  (  String query ,   Connection . Future future )  {  try  {   Message . Response  response =  Uninterruptibles . getUninterruptibly  ( future ) ;  switch  (  response . type )  {   case RESULT :  ResultMessage  rm =  ( ResultMessage ) response ;  switch  (  rm . kind )  {   case PREPARED :   ResultMessage . Prepared  pmsg =  (  ResultMessage . Prepared ) rm ;  PreparedStatement  stmt =  PreparedStatement . fromMessage  ( pmsg ,   manager . cluster . getMetadata  ( ) , query ,   manager . poolsState . keyspace ) ;  try  {     manager . cluster . manager . prepare  (  pmsg . statementId , stmt ,  future . getAddress  ( ) ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  return stmt ;   default :  throw  new DriverInternalError  (  String . format  ( "%s response received when prepared statement was expected" ,  rm . kind ) ) ; }   case ERROR :   ResultSetFuture . extractCause  (  ResultSetFuture . convertException  (   (  ( ErrorMessage ) response ) . error ) ) ;  break ;   default :  throw  new DriverInternalError  (  String . format  ( "%s response received when prepared statement was expected" ,  response . type ) ) ; }  throw  new AssertionError  ( ) ; }  catch (   ExecutionException e )  {   ResultSetFuture . extractCauseFromExecutionException  ( e ) ;  throw  new AssertionError  ( ) ; } }   static class Manager  {   final Cluster  cluster ;   final  ConcurrentMap  < Host , HostConnectionPool >  pools ;   final  HostConnectionPool . PoolState  poolsState ;   final AtomicBoolean  isShutdown =  new AtomicBoolean  ( false ) ;   public Manager  (  Cluster cluster ,   Collection  < Host > hosts )  {    this . cluster = cluster ;    this . pools =  new  ConcurrentHashMap  < Host , HostConnectionPool >  (  hosts . size  ( ) ) ;    this . poolsState =  new  HostConnectionPool . PoolState  ( ) ;  for ( Host host : hosts )  {  try  {    addOrRenewPool  ( host , false ) . get  ( ) ; }  catch (   ExecutionException e )  {  throw  new DriverInternalError  ( e ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; } } }   public  Connection . Factory connectionFactory  ( )  {  return   cluster . manager . connectionFactory ; }   public Configuration configuration  ( )  {  return   cluster . manager . configuration ; }  LoadBalancingPolicy loadBalancingPolicy  ( )  {  return   cluster . manager . loadBalancingPolicy  ( ) ; }  ReconnectionPolicy reconnectionPolicy  ( )  {  return   cluster . manager . reconnectionPolicy  ( ) ; }   public ListeningExecutorService executor  ( )  {  return   cluster . manager . executor ; }   private boolean shutdown  (   long timeout ,  TimeUnit unit )  throws InterruptedException  {  if  (  !  isShutdown . compareAndSet  ( false , true ) )  return true ;   long  start =  System . nanoTime  ( ) ;  boolean  success = true ;  for ( HostConnectionPool pool :  pools . values  ( ) )   success &=  pool . shutdown  (  timeout -  Cluster . timeSince  ( start , unit ) , unit ) ;  return success ; }   ListenableFuture  <  ? > removePool  (  Host host )  {   final HostConnectionPool  pool =  pools . remove  ( host ) ;  if  (  pool == null )  return  Futures . immediateFuture  ( null ) ;  return   executor  ( ) . submit  (  new Runnable  ( )  {   public void run  ( )  {   pool . shutdown  ( ) ; } } ) ; }  void updateCreatedPools  ( )  {  for ( Host h :   cluster . getMetadata  ( ) . allHosts  ( ) )  {  HostDistance  dist =   loadBalancingPolicy  ( ) . distance  ( h ) ;  HostConnectionPool  pool =  pools . get  ( h ) ;  if  (  pool == null )  {  if  (   dist !=  HostDistance . IGNORED &&  h . isUp  ( ) )   addOrRenewPool  ( h , false ) ; } else  if  (  dist !=  pool . hostDistance )  {  if  (  dist ==  HostDistance . IGNORED )  {   removePool  ( h ) ; } else  {    pool . hostDistance = dist ; } } } }   public void onDown  (  Host host )  {    removePool  ( host ) . addListener  (  new Runnable  ( )  {   public void run  ( )  {   updateCreatedPools  ( ) ; } } ,  MoreExecutors . sameThreadExecutor  ( ) ) ; }   public void onRemove  (  Host host )  {   onDown  ( host ) ; }   public void setKeyspace  (  String keyspace )  {   long  timeout =    configuration  ( ) . getSocketOptions  ( ) . getConnectTimeoutMillis  ( ) ;  try  {   Future  <  ? >  future =  executeQuery  (  new QueryMessage  (  "use " + keyspace ,  ConsistencyLevel . DEFAULT_CASSANDRA_CL ) ,  Query . DEFAULT ) ;   Uninterruptibles . getUninterruptibly  ( future , timeout ,  TimeUnit . MILLISECONDS ) ; }  catch (   TimeoutException e )  {  throw  new DriverInternalError  (  String . format  ( "No responses after %d milliseconds while setting current keyspace. This should not happen, unless you have setup a very low connection timeout." , timeout ) ) ; }  catch (   ExecutionException e )  {   ResultSetFuture . extractCauseFromExecutionException  ( e ) ; } }   public void execute  (   RequestHandler . Callback callback ,  Query query )  {    new RequestHandler  ( this , callback , query ) . sendRequest  ( ) ; }   public void prepare  (  String query ,  InetAddress toExclude )  throws InterruptedException  {  for (   Map . Entry  < Host , HostConnectionPool > entry :  pools . entrySet  ( ) )  {  if  (    entry . getKey  ( ) . getAddress  ( ) . equals  ( toExclude ) )  continue ;  Connection  c = null ;  try  {   c =   entry . getValue  ( ) . borrowConnection  ( 200 ,  TimeUnit . MILLISECONDS ) ;    c . write  (  new PrepareMessage  ( query ) ) . get  ( ) ; }  catch (   ConnectionException e )  { }  catch (   BusyConnectionException e )  { }  catch (   TimeoutException e )  { }  catch (   ExecutionException e )  {   logger . error  (  String . format  ( "Unexpected error while preparing query (%s) on %s" , query ,  entry . getKey  ( ) ) , e ) ; }  finally  {  if  (  c != null )    entry . getValue  ( ) . returnConnection  ( c ) ; } } }   public ResultSetFuture executeQuery  (   Message . Request msg ,  Query query )  {  if  (  query . isTracing  ( ) )   msg . setTracingRequested  ( ) ;  ResultSetFuture  future =  new ResultSetFuture  ( this , msg ) ;   execute  (  future . callback , query ) ;  return future ; }   ListenableFuture  < Boolean > addOrRenewPool  (   final Host host ,   final boolean isHostAddition )  {   final HostDistance  distance =    cluster . manager . loadBalancingPolicy  ( ) . distance  ( host ) ;  if  (  distance ==  HostDistance . IGNORED )  return  Futures . immediateFuture  ( true ) ;  return   executor  ( ) . submit  (  new  Callable  < Boolean >  ( )  {   public Boolean call  ( )  {   logger . debug  ( "Adding {} to list of queried hosts" , host ) ;  try  {  HostConnectionPool  previous =  pools . put  ( host ,  new HostConnectionPool  ( host , distance ,   Session . Manager . this ) ) ;  if  (  previous != null )   previous . shutdown  ( ) ;  return true ; }  catch (   AuthenticationException e )  {   logger . error  ( "Error creating pool to {} ({})" , host ,  e . getMessage  ( ) ) ;    cluster . manager . signalConnectionFailure  ( host ,  new ConnectionException  (  e . getHost  ( ) ,  e . getMessage  ( ) ) , isHostAddition ) ;  return false ; }  catch (   ConnectionException e )  {   logger . debug  ( "Error creating pool to {} ({})" , host ,  e . getMessage  ( ) ) ;    cluster . manager . signalConnectionFailure  ( host , e , isHostAddition ) ;  return false ; } } } ) ; } } }