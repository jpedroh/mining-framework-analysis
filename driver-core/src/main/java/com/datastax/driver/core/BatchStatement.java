  package    com . datastax . driver . core ;   import   java . nio . ByteBuffer ;  import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Collection ;  import   java . util . Collections ;  import   java . util . List ;  import     com . google . common . collect . ImmutableList ;  import      com . datastax . driver . core . exceptions . UnsupportedFeatureException ;   public class BatchStatement  extends Statement  {   public enum Type  {  LOGGED ,  UNLOGGED ,  COUNTER } ;   final Type  batchType ;   private final  List  < Statement >  statements =  new  ArrayList  < Statement >  ( ) ;   public BatchStatement  ( )  {  this  (  Type . LOGGED ) ; }   public BatchStatement  (  Type batchType )  {    this . batchType = batchType ; }  IdAndValues getIdAndValues  (  ProtocolVersion protocolVersion )  {  IdAndValues  idAndVals =  new IdAndValues  (  statements . size  ( ) ) ;  for ( Statement statement : statements )  {  if  (  statement instanceof RegularStatement )  {  RegularStatement  st =  ( RegularStatement ) statement ;   ByteBuffer  [ ]  vals =  st . getValues  ( protocolVersion ) ;    idAndVals . ids . add  (  st . getQueryString  ( ) ) ;    idAndVals . values . add  (   vals == null ?  Collections .  < ByteBuffer > emptyList  ( ) :  Arrays . asList  ( vals ) ) ; } else  {  assert  statement instanceof BoundStatement ;  BoundStatement  st =  ( BoundStatement ) statement ;    idAndVals . ids . add  (    st . statement . getPreparedId  ( ) . id ) ;    idAndVals . values . add  (  Arrays . asList  (   st . wrapper . values ) ) ; } }  return idAndVals ; }   public BatchStatement add  (  Statement statement )  {  if  (  statement instanceof BatchStatement )  {  for ( Statement subStatements :   (  ( BatchStatement ) statement ) . statements )  {   add  ( subStatements ) ; } } else  {  if  (   statements . size  ( ) >= 0xFFFF )  throw  new IllegalStateException  (   "Batch statement cannot contain more than " + 0xFFFF + " statements." ) ;   statements . add  ( statement ) ; }  return this ; }   public BatchStatement addAll  (   Iterable  <  ? extends Statement > statements )  {  for ( Statement statement : statements )   add  ( statement ) ;  return this ; }   public  Collection  < Statement > getStatements  ( )  {  return  ImmutableList . copyOf  ( statements ) ; }   public BatchStatement clear  ( )  {   statements . clear  ( ) ;  return this ; }   public  int size  ( )  {  return  statements . size  ( ) ; }    @ Override public BatchStatement setSerialConsistencyLevel  (  ConsistencyLevel serialConsistency )  {  return  ( BatchStatement )  super . setSerialConsistencyLevel  ( serialConsistency ) ; }    @ Override public ByteBuffer getRoutingKey  ( )  {  for ( Statement statement : statements )  {  ByteBuffer  rk =  statement . getRoutingKey  ( ) ;  if  (  rk != null )  return rk ; }  return null ; }    @ Override public String getKeyspace  ( )  {  for ( Statement statement : statements )  {  String  keyspace =  statement . getKeyspace  ( ) ;  if  (  keyspace != null )  return keyspace ; }  return null ; }  void ensureAllSet  ( )  {  for ( Statement statement : statements )  if  (  statement instanceof BoundStatement )    (  ( BoundStatement ) statement ) . ensureAllSet  ( ) ; }   static class IdAndValues  {   public final  List  < Object >  ids ;   public final  List  <  List  < ByteBuffer > >  values ;  IdAndValues  (   int nbstatements )  {   ids =  new  ArrayList  < Object >  ( nbstatements ) ;   values =  new  ArrayList  <  List  < ByteBuffer > >  ( nbstatements ) ; } } }