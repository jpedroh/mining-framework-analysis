  package     com . datastax . driver . core . policies ;   import  java . util .  * ;  import     java . util . concurrent . atomic . AtomicInteger ;  import    java . util . concurrent . ConcurrentHashMap ;  import    java . util . concurrent . ConcurrentMap ;  import    java . util . concurrent . CopyOnWriteArrayList ;  import     com . google . common . collect . AbstractIterator ;  import     com . datastax . driver . core . Cluster ;  import     com . datastax . driver . core . Host ;  import     com . datastax . driver . core . HostDistance ;  import     com . datastax . driver . core . Query ;   public class DCAwareRoundRobinPolicy  implements  LoadBalancingPolicy  {   private final  ConcurrentMap  < String ,  CopyOnWriteArrayList  < Host > >  perDcLiveHosts =  new  ConcurrentHashMap  < String ,  CopyOnWriteArrayList  < Host > >  ( ) ;   private final AtomicInteger  index =  new AtomicInteger  ( ) ;   private final String  localDc ;   private final  int  usedHostsPerRemoteDc ;   public DCAwareRoundRobinPolicy  (  String localDc )  {  this  ( localDc , 0 ) ; }   public DCAwareRoundRobinPolicy  (  String localDc ,   int usedHostsPerRemoteDc )  {    this . localDc = localDc ;    this . usedHostsPerRemoteDc = usedHostsPerRemoteDc ; }    @ Override public void init  (  Cluster cluster ,   Collection  < Host > hosts )  {    this . index . set  (   new Random  ( ) . nextInt  (  Math . max  (  hosts . size  ( ) , 1 ) ) ) ;  for ( Host host : hosts )  {  String  dc =  dc  ( host ) ;   CopyOnWriteArrayList  < Host >  prev =  perDcLiveHosts . get  ( dc ) ;  if  (  prev == null )   perDcLiveHosts . put  ( dc ,  new  CopyOnWriteArrayList  < Host >  (  Collections . singletonList  ( host ) ) ) ; else   prev . addIfAbsent  ( host ) ; } }   private String dc  (  Host host )  {  String  dc =  host . getDatacenter  ( ) ;  return   dc == null ? localDc : dc ; }    @ SuppressWarnings  ( "unchecked" ) private static  CopyOnWriteArrayList  < Host > cloneList  (   CopyOnWriteArrayList  < Host > list )  {  return  (  CopyOnWriteArrayList  < Host > )  list . clone  ( ) ; }    @ Override public HostDistance distance  (  Host host )  {  String  dc =  dc  ( host ) ;  if  (  dc . equals  ( localDc ) )  return  HostDistance . LOCAL ;   CopyOnWriteArrayList  < Host >  dcHosts =  perDcLiveHosts . get  ( dc ) ;  if  (   dcHosts == null ||  usedHostsPerRemoteDc == 0 )  return  HostDistance . IGNORED ;   dcHosts =  cloneList  ( dcHosts ) ;  return    dcHosts . subList  ( 0 ,  Math . min  (  dcHosts . size  ( ) , usedHostsPerRemoteDc ) ) . contains  ( host ) ?  HostDistance . REMOTE :  HostDistance . IGNORED ; }    @ Override public  Iterator  < Host > newQueryPlan  (  String loggedKeyspace ,  Statement statement )  {   CopyOnWriteArrayList  < Host >  localLiveHosts =  perDcLiveHosts . get  ( localDc ) ;   final  List  < Host >  hosts =   localLiveHosts == null ?  Collections .  < Host > emptyList  ( ) :  cloneList  ( localLiveHosts ) ;   final  int  startIdx =  index . getAndIncrement  ( ) ;  return  new  AbstractIterator  < Host >  ( )  {   private  int  idx = startIdx ;   private  int  remainingLocal =  hosts . size  ( ) ;   private  Iterator  < String >  remoteDcs ;   private  List  < Host >  currentDcHosts ;   private  int  currentDcRemaining ;    @ Override protected Host computeNext  ( )  {  if  (  remainingLocal > 0 )  {   remainingLocal -- ;   int  c =   idx ++ %  hosts . size  ( ) ;  if  (  c < 0 )   c +=  hosts . size  ( ) ;  return  hosts . get  ( c ) ; }  if  (   currentDcHosts != null &&  currentDcRemaining > 0 )  {   currentDcRemaining -- ;   int  c =   idx ++ %  currentDcHosts . size  ( ) ;  if  (  c < 0 )   c +=  currentDcHosts . size  ( ) ;  return  currentDcHosts . get  ( c ) ; }  if  (  remoteDcs == null )  {   Set  < String >  copy =  new  HashSet  < String >  (  perDcLiveHosts . keySet  ( ) ) ;   copy . remove  ( localDc ) ;   remoteDcs =  copy . iterator  ( ) ; }  if  (  !  remoteDcs . hasNext  ( ) )  return  endOfData  ( ) ;  String  nextRemoteDc =  remoteDcs . next  ( ) ;   CopyOnWriteArrayList  < Host >  nextDcHosts =  perDcLiveHosts . get  ( nextRemoteDc ) ;  if  (  nextDcHosts != null )  {   List  < Host >  dcHosts =  cloneList  ( nextDcHosts ) ;   currentDcHosts =  dcHosts . subList  ( 0 ,  Math . min  (  dcHosts . size  ( ) , usedHostsPerRemoteDc ) ) ;   currentDcRemaining =  currentDcHosts . size  ( ) ; }  return  computeNext  ( ) ; } } ; }    @ Override public void onUp  (  Host host )  {  String  dc =  dc  ( host ) ;   CopyOnWriteArrayList  < Host >  dcHosts =  perDcLiveHosts . get  ( dc ) ;  if  (  dcHosts == null )  {   CopyOnWriteArrayList  < Host >  newMap =  new  CopyOnWriteArrayList  < Host >  (  Collections . singletonList  ( host ) ) ;   dcHosts =  perDcLiveHosts . putIfAbsent  ( dc , newMap ) ;  if  (  dcHosts == null )  return ; }   dcHosts . addIfAbsent  ( host ) ; }    @ Override public void onDown  (  Host host )  {   CopyOnWriteArrayList  < Host >  dcHosts =  perDcLiveHosts . get  (  dc  ( host ) ) ;  if  (  dcHosts != null )   dcHosts . remove  ( host ) ; }    @ Override public void onAdd  (  Host host )  {   onUp  ( host ) ; }    @ Override public void onRemove  (  Host host )  {   onDown  ( host ) ; } }