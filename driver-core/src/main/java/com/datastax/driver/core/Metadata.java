  package    com . datastax . driver . core ;   import   java . net . InetSocketAddress ;  import   java . nio . ByteBuffer ;  import  java . util .  * ;  import    java . util . concurrent . ConcurrentHashMap ;  import    java . util . concurrent . ConcurrentMap ;  import    java . util . regex . Pattern ;  import     com . google . common . collect . ImmutableSet ;  import     com . google . common . collect . Maps ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;   public class Metadata  {   private static final Logger  logger =  LoggerFactory . getLogger  (  Metadata . class ) ;   private final  Cluster . Manager  cluster ;   volatile String  clusterName ;   volatile String  partitioner ;   private final  ConcurrentMap  < InetSocketAddress , Host >  hosts =  new  ConcurrentHashMap  < InetSocketAddress , Host >  ( ) ;   private final  ConcurrentMap  < String , KeyspaceMetadata >  keyspaces =  new  ConcurrentHashMap  < String , KeyspaceMetadata >  ( ) ;   volatile TokenMap  tokenMap ;   private static final Pattern  cqlId =  Pattern . compile  ( "\\w+" ) ;   private static final Pattern  lowercaseId =  Pattern . compile  ( "[a-z][a-z0-9_]*" ) ;  Metadata  (   Cluster . Manager cluster )  {    this . cluster = cluster ; }   synchronized void rebuildSchema  (  String keyspaceName ,  String tableName ,  String udtName ,  ResultSet ks ,  ResultSet udts ,  ResultSet cfs ,  ResultSet cols ,  VersionNumber cassandraVersion )  {   Map  < String ,  List  < Row > >  cfDefs =  new  HashMap  < String ,  List  < Row > >  ( ) ;   Map  < String ,  List  < Row > >  udtDefs =  new  HashMap  < String ,  List  < Row > >  ( ) ;   Map  < String ,  Map  < String ,  Map  < String ,  ColumnMetadata . Raw > > >  colsDefs =  new  HashMap  < String ,  Map  < String ,  Map  < String ,  ColumnMetadata . Raw > > >  ( ) ;  if  (  cfs != null )  {  for ( Row row : cfs )  {  String  ksName =  row . getString  (  KeyspaceMetadata . KS_NAME ) ;   List  < Row >  l =  cfDefs . get  ( ksName ) ;  if  (  l == null )  {   l =  new  ArrayList  < Row >  ( ) ;   cfDefs . put  ( ksName , l ) ; }   l . add  ( row ) ; } }  if  (  udts != null )  {  for ( Row row : udts )  {  String  ksName =  row . getString  (  KeyspaceMetadata . KS_NAME ) ;   List  < Row >  l =  udtDefs . get  ( ksName ) ;  if  (  l == null )  {   l =  new  ArrayList  < Row >  ( ) ;   udtDefs . put  ( ksName , l ) ; }   l . add  ( row ) ; } }  if  (  cols != null )  {  for ( Row row : cols )  {  String  ksName =  row . getString  (  KeyspaceMetadata . KS_NAME ) ;  String  cfName =  row . getString  (  TableMetadata . CF_NAME ) ;   Map  < String ,  Map  < String ,  ColumnMetadata . Raw > >  colsByCf =  colsDefs . get  ( ksName ) ;  if  (  colsByCf == null )  {   colsByCf =  new  HashMap  < String ,  Map  < String ,  ColumnMetadata . Raw > >  ( ) ;   colsDefs . put  ( ksName , colsByCf ) ; }   Map  < String ,  ColumnMetadata . Raw >  l =  colsByCf . get  ( cfName ) ;  if  (  l == null )  {   l =  new  HashMap  < String ,  ColumnMetadata . Raw >  ( ) ;   colsByCf . put  ( cfName , l ) ; }   ColumnMetadata . Raw  c =   ColumnMetadata . Raw . fromRow  ( row , cassandraVersion ) ;   l . put  (  c . name , c ) ; } }  if  (   tableName == null &&  udtName == null )  {  assert  ks != null ;   Set  < String >  addedKs =  new  HashSet  < String >  ( ) ;  for ( Row ksRow : ks )  {  String  ksName =  ksRow . getString  (  KeyspaceMetadata . KS_NAME ) ;  KeyspaceMetadata  ksm =  KeyspaceMetadata . build  ( ksRow ,  udtDefs . get  ( ksName ) ) ;  if  (  cfDefs . containsKey  ( ksName ) )  {   buildTableMetadata  ( ksm ,  cfDefs . get  ( ksName ) ,  colsDefs . get  ( ksName ) , cassandraVersion ) ; }   addedKs . add  ( ksName ) ;   keyspaces . put  ( ksName , ksm ) ; }  if  (  keyspaceName == null )  {   Iterator  < String >  iter =   keyspaces . keySet  ( ) . iterator  ( ) ;  while  (  iter . hasNext  ( ) )  {  if  (  !  addedKs . contains  (  iter . next  ( ) ) )   iter . remove  ( ) ; } } } else  if  (  tableName != null )  {  assert  keyspaceName != null ;  KeyspaceMetadata  ksm =  keyspaces . get  ( keyspaceName ) ;  if  (  ksm == null )  {   logger . error  (  String . format  ( "Asked to rebuild table %s.%s but I don't know keyspace %s" , keyspaceName , tableName , keyspaceName ) ) ;   cluster . submitSchemaRefresh  ( null , null , null ) ;  return ; }  if  (  cfDefs . containsKey  ( keyspaceName ) )   buildTableMetadata  ( ksm ,  cfDefs . get  ( keyspaceName ) ,  colsDefs . get  ( keyspaceName ) , cassandraVersion ) ; } else  {  assert  keyspaceName != null ;  KeyspaceMetadata  ksm =  keyspaces . get  ( keyspaceName ) ;  if  (  ksm == null )  {   logger . error  (  String . format  ( "Asked to rebuild type %s.%s but I don't know keyspace %s" , keyspaceName , udtName , keyspaceName ) ) ;   cluster . submitSchemaRefresh  ( null , null , null ) ;  return ; }  if  (  udtDefs . containsKey  ( keyspaceName ) )   ksm . addUserTypes  (  udtDefs . get  ( keyspaceName ) ) ; } }   private void buildTableMetadata  (  KeyspaceMetadata ksm ,   List  < Row > cfRows ,   Map  < String ,  Map  < String ,  ColumnMetadata . Raw > > colsDefs ,  VersionNumber cassandraVersion )  {  for ( Row cfRow : cfRows )  {  String  cfName =  cfRow . getString  (  TableMetadata . CF_NAME ) ;  try  {   Map  < String ,  ColumnMetadata . Raw >  cols =   colsDefs == null ? null :  colsDefs . get  ( cfName ) ;  if  (   cols == null ||  cols . isEmpty  ( ) )  {  if  (   cassandraVersion . getMajor  ( ) >= 2 )  {  continue ; } else  {   cols =  Collections .  < String ,  ColumnMetadata . Raw > emptyMap  ( ) ; } }   TableMetadata . build  ( ksm , cfRow , cols , cassandraVersion ) ; }  catch (   RuntimeException e )  {   logger . error  (  String . format  (  "Error parsing schema for table %s.%s: " + "Cluster.getMetadata().getKeyspace(\"%s\").getTable(\"%s\") will be missing or incomplete" ,  ksm . getName  ( ) , cfName ,  ksm . getName  ( ) , cfName ) , e ) ; } } }   synchronized void rebuildTokenMap  (  String partitioner ,   Map  < Host ,  Collection  < String > > allTokens )  {  if  (  allTokens . isEmpty  ( ) )  return ;   Token . Factory  factory =   partitioner == null ?  (   tokenMap == null ? null :  tokenMap . factory ) :  Token . getFactory  ( partitioner ) ;  if  (  factory == null )  return ;    this . tokenMap =  TokenMap . build  ( factory , allTokens ,  keyspaces . values  ( ) ) ; }  Host add  (  InetSocketAddress address )  {  Host  newHost =  new Host  ( address ,  cluster . convictionPolicyFactory , cluster ) ;  Host  previous =  hosts . putIfAbsent  ( address , newHost ) ;  return   previous == null ? newHost : null ; }  boolean remove  (  Host host )  {  return   hosts . remove  (  host . getSocketAddress  ( ) ) != null ; }  Host getHost  (  InetSocketAddress address )  {  return  hosts . get  ( address ) ; }   Collection  < Host > allHosts  ( )  {  return  hosts . values  ( ) ; }   static String handleId  (  String id )  {  if  (  id == null )  return null ;  if  (   cqlId . matcher  ( id ) . matches  ( ) )  return  id . toLowerCase  ( ) ;  if  (    id . charAt  ( 0 ) == '"' &&   id . charAt  (   id . length  ( ) - 1 ) == '"' )  return  id . substring  ( 1 ,   id . length  ( ) - 1 ) ;  return id ; }   static String escapeId  (  String ident )  {  return    lowercaseId . matcher  ( ident ) . matches  ( ) ? ident :  quote  ( ident ) ; }   public static String quote  (  String id )  {  return   '"' + id + '"' ; }   public  Set  < TokenRange > getTokenRanges  ( )  {  TokenMap  current = tokenMap ;  return   (  current == null ) ?  Collections .  < TokenRange > emptySet  ( ) :  current . tokenRanges ; }   public  Set  < TokenRange > getTokenRanges  (  String keyspace ,  Host host )  {   keyspace =  handleId  ( keyspace ) ;  TokenMap  current = tokenMap ;  if  (  current == null )  {  return  Collections . emptySet  ( ) ; } else  {   Map  < Host ,  Set  < TokenRange > >  dcRanges =   current . hostsToRanges . get  ( keyspace ) ;  if  (  dcRanges == null )  {  return  Collections . emptySet  ( ) ; } else  {   Set  < TokenRange >  ranges =  dcRanges . get  ( host ) ;  return   (  ranges == null ) ?  Collections .  < TokenRange > emptySet  ( ) : ranges ; } } }   public  Set  < Host > getReplicas  (  String keyspace ,  ByteBuffer partitionKey )  {   keyspace =  handleId  ( keyspace ) ;  TokenMap  current = tokenMap ;  if  (  current == null )  {  return  Collections . emptySet  ( ) ; } else  {   Set  < Host >  hosts =  current . getReplicas  ( keyspace ,   current . factory . hash  ( partitionKey ) ) ;  return   hosts == null ?  Collections .  < Host > emptySet  ( ) : hosts ; } }   public  Set  < Host > getReplicas  (  String keyspace ,  TokenRange range )  {   keyspace =  handleId  ( keyspace ) ;  TokenMap  current = tokenMap ;  if  (  current == null )  {  return  Collections . emptySet  ( ) ; } else  {   Set  < Host >  hosts =  current . getReplicas  ( keyspace ,  range . getEnd  ( ) ) ;  return   hosts == null ?  Collections .  < Host > emptySet  ( ) : hosts ; } }   public String getClusterName  ( )  {  return clusterName ; }   public String getPartitioner  ( )  {  return partitioner ; }   public  Set  < Host > getAllHosts  ( )  {  return  new  HashSet  < Host >  (  allHosts  ( ) ) ; }   public KeyspaceMetadata getKeyspace  (  String keyspace )  {  return  keyspaces . get  (  handleId  ( keyspace ) ) ; }  void removeKeyspace  (  String keyspace )  {   keyspaces . remove  ( keyspace ) ;  if  (  tokenMap != null )    tokenMap . tokenToHosts . remove  ( keyspace ) ; }   public  List  < KeyspaceMetadata > getKeyspaces  ( )  {  return  new  ArrayList  < KeyspaceMetadata >  (  keyspaces . values  ( ) ) ; }   public String exportSchemaAsString  ( )  {  StringBuilder  sb =  new StringBuilder  ( ) ;  for ( KeyspaceMetadata ksm :  keyspaces . values  ( ) )    sb . append  (  ksm . exportAsString  ( ) ) . append  ( '\n' ) ;  return  sb . toString  ( ) ; }   Token . Factory tokenFactory  ( )  {  TokenMap  current = tokenMap ;  return   (  current == null ) ? null :  current . factory ; }   static class TokenMap  {   private final  Token . Factory  factory ;   private final  Map  < String ,  Map  < Token ,  Set  < Host > > >  tokenToHosts ;   private final  Map  < String ,  Map  < Host ,  Set  < TokenRange > > >  hostsToRanges ;   private final  List  < Token >  ring ;   private final  Set  < TokenRange >  tokenRanges ;   final  Set  < Host >  hosts ;   private TokenMap  (   Token . Factory factory ,   Map  < Host ,  Set  < Token > > primaryToTokens ,   Map  < String ,  Map  < Token ,  Set  < Host > > > tokenToHosts ,   Map  < String ,  Map  < Host ,  Set  < TokenRange > > > hostsToRanges ,   List  < Token > ring ,   Set  < TokenRange > tokenRanges ,   Set  < Host > hosts )  {    this . factory = factory ;    this . tokenToHosts = tokenToHosts ;    this . hostsToRanges = hostsToRanges ;    this . ring = ring ;    this . tokenRanges = tokenRanges ;    this . hosts = hosts ;  for (   Map . Entry  < Host ,  Set  < Token > > entry :  primaryToTokens . entrySet  ( ) )  {  Host  host =  entry . getKey  ( ) ;   host . setTokens  (  ImmutableSet . copyOf  (  entry . getValue  ( ) ) ) ; } }   public static TokenMap build  (   Token . Factory factory ,   Map  < Host ,  Collection  < String > > allTokens ,   Collection  < KeyspaceMetadata > keyspaces )  {   Set  < Host >  hosts =  allTokens . keySet  ( ) ;   Map  < Token , Host >  tokenToPrimary =  new  HashMap  < Token , Host >  ( ) ;   Map  < Host ,  Set  < Token > >  primaryToTokens =  new  HashMap  < Host ,  Set  < Token > >  ( ) ;   Set  < Token >  allSorted =  new  TreeSet  < Token >  ( ) ;  for (   Map . Entry  < Host ,  Collection  < String > > entry :  allTokens . entrySet  ( ) )  {  Host  host =  entry . getKey  ( ) ;  for ( String tokenStr :  entry . getValue  ( ) )  {  try  {  Token  t =  factory . fromString  ( tokenStr ) ;   allSorted . add  ( t ) ;   tokenToPrimary . put  ( t , host ) ;   Set  < Token >  hostTokens =  primaryToTokens . get  ( host ) ;  if  (  hostTokens == null )  {   hostTokens =  new  HashSet  < Token >  ( ) ;   primaryToTokens . put  ( host , hostTokens ) ; }   hostTokens . add  ( t ) ; }  catch (   IllegalArgumentException e )  { } } }   List  < Token >  ring =  new  ArrayList  < Token >  ( allSorted ) ;   Set  < TokenRange >  tokenRanges =  makeTokenRanges  ( ring , factory ) ;   Map  < String ,  Map  < Token ,  Set  < Host > > >  tokenToHosts =  new  HashMap  < String ,  Map  < Token ,  Set  < Host > > >  ( ) ;   Map  < String ,  Map  < Host ,  Set  < TokenRange > > >  hostsToRanges =  new  HashMap  < String ,  Map  < Host ,  Set  < TokenRange > > >  ( ) ;  for ( KeyspaceMetadata keyspace : keyspaces )  {  ReplicationStrategy  strategy =  keyspace . replicationStrategy  ( ) ;   Map  < Token ,  Set  < Host > >  ksTokens =   (  strategy == null ) ?  makeNonReplicatedMap  ( tokenToPrimary ) :  strategy . computeTokenToReplicaMap  ( tokenToPrimary , ring ) ;   tokenToHosts . put  (  keyspace . getName  ( ) , ksTokens ) ;   Map  < Host ,  Set  < TokenRange > >  ksRanges =  computeHostsToRangesMap  ( tokenRanges , ksTokens ,  hosts . size  ( ) ) ;   hostsToRanges . put  (  keyspace . getName  ( ) , ksRanges ) ; }  return  new TokenMap  ( factory , primaryToTokens , tokenToHosts , hostsToRanges , ring , tokenRanges , hosts ) ; }   private  Set  < Host > getReplicas  (  String keyspace ,  Token token )  {   Map  < Token ,  Set  < Host > >  keyspaceHosts =  tokenToHosts . get  ( keyspace ) ;  if  (  keyspaceHosts == null )  return  Collections . emptySet  ( ) ;   Set  < Host >  hosts =  keyspaceHosts . get  ( token ) ;  if  (  hosts != null )  return hosts ;   int  i =  Collections . binarySearch  ( ring , token ) ;  if  (  i < 0 )  {   i =   - i - 1 ;  if  (  i >=  ring . size  ( ) )   i = 0 ; }  return  keyspaceHosts . get  (  ring . get  ( i ) ) ; }   private static  Map  < Token ,  Set  < Host > > makeNonReplicatedMap  (   Map  < Token , Host > input )  {   Map  < Token ,  Set  < Host > >  output =  new  HashMap  < Token ,  Set  < Host > >  (  input . size  ( ) ) ;  for (   Map . Entry  < Token , Host > entry :  input . entrySet  ( ) )   output . put  (  entry . getKey  ( ) ,  ImmutableSet . of  (  entry . getValue  ( ) ) ) ;  return output ; }   private static  Set  < TokenRange > makeTokenRanges  (   List  < Token > ring ,   Token . Factory factory )  {     ImmutableSet . Builder < TokenRange >  builder =  ImmutableSet . builder  ( ) ;  for (   int  i = 0 ;  i <  ring . size  ( ) ;  i ++ )  {  Token  start =  ring . get  ( i ) ;  Token  end =  ring . get  (   (  i + 1 ) %  ring . size  ( ) ) ;   builder . add  (  new TokenRange  ( start , end , factory ) ) ; }  return  builder . build  ( ) ; }   private static  Map  < Host ,  Set  < TokenRange > > computeHostsToRangesMap  (   Set  < TokenRange > tokenRanges ,   Map  < Token ,  Set  < Host > > ksTokens ,   int hostCount )  {   Map  < Host ,   ImmutableSet . Builder  < TokenRange > >  builders =  Maps . newHashMapWithExpectedSize  ( hostCount ) ;  for ( TokenRange range : tokenRanges )  {   Set  < Host >  replicas =  ksTokens . get  (  range . getEnd  ( ) ) ;  for ( Host host : replicas )  {     ImmutableSet . Builder < TokenRange >  hostRanges =  builders . get  ( host ) ;  if  (  hostRanges == null )  {   hostRanges =  ImmutableSet . builder  ( ) ;   builders . put  ( host , hostRanges ) ; }   hostRanges . add  ( range ) ; } }   Map  < Host ,  Set  < TokenRange > >  ksRanges =  Maps . newHashMapWithExpectedSize  ( hostCount ) ;  for (   Map . Entry  < Host ,   ImmutableSet . Builder  < TokenRange > > entry :  builders . entrySet  ( ) )  {   ksRanges . put  (  entry . getKey  ( ) ,   entry . getValue  ( ) . build  ( ) ) ; }  return ksRanges ; } }  KeyspaceMetadata getKeyspaceInternal  (  String keyspace )  {  return  keyspaces . get  ( keyspace ) ; } }