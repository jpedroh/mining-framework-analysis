  package    com . datastax . driver . core ;   import   java . net . InetAddress ;  import   java . nio . ByteBuffer ;  import  java . util .  * ;  import    java . util . concurrent . ConcurrentHashMap ;  import    java . util . concurrent . ConcurrentMap ;  import    java . util . regex . Pattern ;  import     com . google . common . collect . ImmutableSet ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;   public class Metadata  {   private static final Logger  logger =  LoggerFactory . getLogger  (  Metadata . class ) ;   private final  Cluster . Manager  cluster ;   volatile String  clusterName ;   private final  ConcurrentMap  < InetAddress , Host >  hosts =  new  ConcurrentHashMap  < InetAddress , Host >  ( ) ;   private final  ConcurrentMap  < String , KeyspaceMetadata >  keyspaces =  new  ConcurrentHashMap  < String , KeyspaceMetadata >  ( ) ;   private volatile TokenMap  tokenMap ;   private static final Pattern  cqlId =  Pattern . compile  ( "\\w+" ) ;   private static final Pattern  lowercaseId =  Pattern . compile  ( "[a-z][a-z0-9_]*" ) ;  Metadata  (   Cluster . Manager cluster )  {    this . cluster = cluster ; }   synchronized void rebuildSchema  (  String keyspace ,  String table ,  ResultSet ks ,  ResultSet cfs ,  ResultSet cols ,  VersionNumber cassandraVersion )  {   Map  < String ,  List  < Row > >  cfDefs =  new  HashMap  < String ,  List  < Row > >  ( ) ;   Map  < String ,  Map  < String ,  Map  < String ,  ColumnMetadata . Raw > > >  colsDefs =  new  HashMap  < String ,  Map  < String ,  Map  < String ,  ColumnMetadata . Raw > > >  ( ) ;  for ( Row row : cfs )  {  String  ksName =  row . getString  (  KeyspaceMetadata . KS_NAME ) ;   List  < Row >  l =  cfDefs . get  ( ksName ) ;  if  (  l == null )  {   l =  new  ArrayList  < Row >  ( ) ;   cfDefs . put  ( ksName , l ) ; }   l . add  ( row ) ; }  for ( Row row : cols )  {  String  ksName =  row . getString  (  KeyspaceMetadata . KS_NAME ) ;  String  cfName =  row . getString  (  TableMetadata . CF_NAME ) ;   Map  < String ,  Map  < String ,  ColumnMetadata . Raw > >  colsByCf =  colsDefs . get  ( ksName ) ;  if  (  colsByCf == null )  {   colsByCf =  new  HashMap  < String ,  Map  < String ,  ColumnMetadata . Raw > >  ( ) ;   colsDefs . put  ( ksName , colsByCf ) ; }   Map  < String ,  ColumnMetadata . Raw >  l =  colsByCf . get  ( cfName ) ;  if  (  l == null )  {   l =  new  HashMap  < String ,  ColumnMetadata . Raw >  ( ) ;   colsByCf . put  ( cfName , l ) ; }   ColumnMetadata . Raw  c =   ColumnMetadata . Raw . fromRow  ( row , cassandraVersion ) ;   l . put  (  c . name , c ) ; }  if  (  table == null )  {  assert  ks != null ;   Set  < String >  addedKs =  new  HashSet  < String >  ( ) ;  for ( Row ksRow : ks )  {  String  ksName =  ksRow . getString  (  KeyspaceMetadata . KS_NAME ) ;  KeyspaceMetadata  ksm =  KeyspaceMetadata . build  ( ksRow ) ;  if  (  cfDefs . containsKey  ( ksName ) )  {   buildTableMetadata  ( ksm ,  cfDefs . get  ( ksName ) ,  colsDefs . get  ( ksName ) , cassandraVersion ) ; }   addedKs . add  ( ksName ) ;   keyspaces . put  ( ksName , ksm ) ; }  if  (  keyspace == null )  {   Iterator  < String >  iter =   keyspaces . keySet  ( ) . iterator  ( ) ;  while  (  iter . hasNext  ( ) )  {  if  (  !  addedKs . contains  (  iter . next  ( ) ) )   iter . remove  ( ) ; } } } else  {  assert  keyspace != null ;  KeyspaceMetadata  ksm =  keyspaces . get  ( keyspace ) ;  if  (  ksm == null )  {   logger . error  (  String . format  ( "Asked to rebuild table %s.%s but I don't know keyspace %s" , keyspace , table , keyspace ) ) ;   cluster . submitSchemaRefresh  ( null , null ) ;  return ; }  if  (  cfDefs . containsKey  ( keyspace ) )   buildTableMetadata  ( ksm ,  cfDefs . get  ( keyspace ) ,  colsDefs . get  ( keyspace ) , cassandraVersion ) ; } }   private void buildTableMetadata  (  KeyspaceMetadata ksm ,   List  < Row > cfRows ,   Map  < String ,  Map  < String ,  ColumnMetadata . Raw > > colsDefs ,  VersionNumber cassandraVersion )  {  for ( Row cfRow : cfRows )  {  String  cfName =  cfRow . getString  (  TableMetadata . CF_NAME ) ;  try  {   Map  < String ,  ColumnMetadata . Raw >  cols =   colsDefs == null ? null :  colsDefs . get  ( cfName ) ;  if  (  cols == null )   cols =  Collections .  < String ,  ColumnMetadata . Raw > emptyMap  ( ) ;   TableMetadata . build  ( ksm , cfRow , cols , cassandraVersion ) ; }  catch (   RuntimeException e )  {   logger . error  (  String . format  (  "Error parsing schema for table %s.%s: " + "Cluster.getMetadata().getKeyspace(\"%s\").getTable(\"%s\") will be missing or incomplete" ,  ksm . getName  ( ) , cfName ,  ksm . getName  ( ) , cfName ) , e ) ; } } }   synchronized void rebuildTokenMap  (  String partitioner ,   Map  < Host ,  Collection  < String > > allTokens )  {  if  (  allTokens . isEmpty  ( ) )  return ;   Token . Factory  factory =   partitioner == null ?  (   tokenMap == null ? null :  tokenMap . factory ) :  Token . getFactory  ( partitioner ) ;  if  (  factory == null )  return ;    this . tokenMap =  TokenMap . build  ( factory , allTokens ,  keyspaces . values  ( ) ) ; }  Host add  (  InetAddress address )  {  Host  newHost =  new Host  ( address ,  cluster . convictionPolicyFactory ) ;  Host  previous =  hosts . putIfAbsent  ( address , newHost ) ;  return   previous == null ? newHost : null ; }  boolean remove  (  Host host )  {  return   hosts . remove  (  host . getAddress  ( ) ) != null ; }  Host getHost  (  InetAddress address )  {  return  hosts . get  ( address ) ; }   Collection  < Host > allHosts  ( )  {  return  hosts . values  ( ) ; }   static String handleId  (  String id )  {  if  (  id == null )  return null ;  if  (   cqlId . matcher  ( id ) . matches  ( ) )  return  id . toLowerCase  ( ) ;  if  (    id . charAt  ( 0 ) == '"' &&   id . charAt  (   id . length  ( ) - 1 ) == '"' )  return  id . substring  ( 1 ,   id . length  ( ) - 1 ) ;  return id ; }   static String escapeId  (  String ident )  {  return    lowercaseId . matcher  ( ident ) . matches  ( ) ? ident :  quote  ( ident ) ; }   public static String quote  (  String id )  {  return   '"' + id + '"' ; }   public  Set  < Host > getReplicas  (  String keyspace ,  ByteBuffer partitionKey )  {   keyspace =  handleId  ( keyspace ) ;  TokenMap  current = tokenMap ;  if  (  current == null )  {  return  Collections . emptySet  ( ) ; } else  {   Set  < Host >  hosts =  current . getReplicas  ( keyspace ,   current . factory . hash  ( partitionKey ) ) ;  return   hosts == null ?  Collections .  < Host > emptySet  ( ) : hosts ; } }   public String getClusterName  ( )  {  return clusterName ; }   public  Set  < Host > getAllHosts  ( )  {  return  new  HashSet  < Host >  (  allHosts  ( ) ) ; }   public KeyspaceMetadata getKeyspace  (  String keyspace )  {  return  keyspaces . get  (  handleId  ( keyspace ) ) ; }   public  List  < KeyspaceMetadata > getKeyspaces  ( )  {  return  new  ArrayList  < KeyspaceMetadata >  (  keyspaces . values  ( ) ) ; }   public String exportSchemaAsString  ( )  {  StringBuilder  sb =  new StringBuilder  ( ) ;  for ( KeyspaceMetadata ksm :  keyspaces . values  ( ) )    sb . append  (  ksm . exportAsString  ( ) ) . append  ( '\n' ) ;  return  sb . toString  ( ) ; }   static class TokenMap  {   private final  Token . Factory  factory ;   private final  Map  < String ,  Map  < Token ,  Set  < Host > > >  tokenToHosts ;   private final  List  < Token >  ring ;   private TokenMap  (   Token . Factory factory ,   Map  < String ,  Map  < Token ,  Set  < Host > > > tokenToHosts ,   List  < Token > ring )  {    this . factory = factory ;    this . tokenToHosts = tokenToHosts ;    this . ring = ring ; }   public static TokenMap build  (   Token . Factory factory ,   Map  < Host ,  Collection  < String > > allTokens ,   Collection  < KeyspaceMetadata > keyspaces )  {   Map  < Token , Host >  tokenToPrimary =  new  HashMap  < Token , Host >  ( ) ;   Set  < Token >  allSorted =  new  TreeSet  < Token >  ( ) ;  for (   Map . Entry  < Host ,  Collection  < String > > entry :  allTokens . entrySet  ( ) )  {  Host  host =  entry . getKey  ( ) ;  for ( String tokenStr :  entry . getValue  ( ) )  {  try  {  Token  t =  factory . fromString  ( tokenStr ) ;   allSorted . add  ( t ) ;   tokenToPrimary . put  ( t , host ) ; }  catch (   IllegalArgumentException e )  { } } }   List  < Token >  ring =  new  ArrayList  < Token >  ( allSorted ) ;   Map  < String ,  Map  < Token ,  Set  < Host > > >  tokenToHosts =  new  HashMap  < String ,  Map  < Token ,  Set  < Host > > >  ( ) ;  for ( KeyspaceMetadata keyspace : keyspaces )  {  ReplicationStrategy  strategy =  keyspace . replicationStrategy  ( ) ;  if  (  strategy == null )  {   tokenToHosts . put  (  keyspace . getName  ( ) ,  makeNonReplicatedMap  ( tokenToPrimary ) ) ; } else  {   tokenToHosts . put  (  keyspace . getName  ( ) ,  strategy . computeTokenToReplicaMap  ( tokenToPrimary , ring ) ) ; } }  return  new TokenMap  ( factory , tokenToHosts , ring ) ; }   private  Set  < Host > getReplicas  (  String keyspace ,  Token token )  {   Map  < Token ,  Set  < Host > >  keyspaceHosts =  tokenToHosts . get  ( keyspace ) ;  if  (  keyspaceHosts == null )  return  Collections . emptySet  ( ) ;   int  i =  Collections . binarySearch  ( ring , token ) ;  if  (  i < 0 )  {   i =   - i - 1 ;  if  (  i >=  ring . size  ( ) )   i = 0 ; }  return  keyspaceHosts . get  (  ring . get  ( i ) ) ; }   private static  Map  < Token ,  Set  < Host > > makeNonReplicatedMap  (   Map  < Token , Host > input )  {   Map  < Token ,  Set  < Host > >  output =  new  HashMap  < Token ,  Set  < Host > >  (  input . size  ( ) ) ;  for (   Map . Entry  < Token , Host > entry :  input . entrySet  ( ) )   output . put  (  entry . getKey  ( ) ,  ImmutableSet . of  (  entry . getValue  ( ) ) ) ;  return output ; } }   volatile String  partitioner ;   public String getPartitioner  ( )  {  return partitioner ; } }