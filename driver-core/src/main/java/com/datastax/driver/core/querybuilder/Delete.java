  package     com . datastax . driver . core . querybuilder ;   import   java . nio . ByteBuffer ;  import   java . util . ArrayList ;  import   java . util . List ;  import     com . datastax . driver . core . TableMetadata ;   public class Delete  extends BuiltStatement  {   private final String  table ;   private final  List  <  ? >  columnNames ;   private final Where  where ;   private final Options  usings ;   private final Conditions  conditions ;   private boolean  ifExists ;  Delete  (  TableMetadata table ,   List  < Object > columnNames )  {  super  ( table ) ;    this . table =  escapeId  (  table . getName  ( ) ) ;    this . columnNames = columnNames ;    this . where =  new Where  ( this ) ;    this . usings =  new Options  ( this ) ;    this . conditions =  new Conditions  ( this ) ; }    @ Override StringBuilder buildQueryString  (   List  < Object > variables )  {  StringBuilder  builder =  new StringBuilder  ( ) ;   builder . append  ( "DELETE" ) ;  if  (  columnNames != null )   Utils . joinAndAppendNames  (  builder . append  ( " " ) , "," , columnNames ) ;   builder . append  ( " FROM " ) ;  if  (  keyspace != null )    Utils . appendName  ( keyspace , builder ) . append  ( '.' ) ;   Utils . appendName  ( table , builder ) ;  if  (  !   usings . usings . isEmpty  ( ) )  {   builder . append  ( " USING " ) ;   Utils . joinAndAppend  ( builder , " AND " ,  usings . usings , variables ) ; }  if  (  !   where . clauses . isEmpty  ( ) )  {   builder . append  ( " WHERE " ) ;   Utils . joinAndAppend  ( builder , " AND " ,  where . clauses , variables ) ; }  if  ( ifExists )  {   builder . append  ( " IF EXISTS " ) ; }  if  (  !   conditions . conditions . isEmpty  ( ) )  {   builder . append  ( " IF " ) ;   Utils . joinAndAppend  ( builder , " AND " ,  conditions . conditions , variables ) ; }  return builder ; }   public Where where  (  Clause clause )  {  return  where . and  ( clause ) ; }   public Where where  ( )  {  return where ; }   public Conditions onlyIf  (  Clause condition )  {  return  conditions . and  ( condition ) ; }   public Conditions onlyIf  ( )  {  return conditions ; }   public Options using  (  Using using )  {  return  usings . and  ( using ) ; }   public Delete ifExists  ( )  {    this . ifExists = true ;  return this ; }   public static class Where  extends   BuiltStatement . ForwardingStatement  < Delete >  {   private final  List  < Clause >  clauses =  new  ArrayList  < Clause >  ( ) ;  Where  (  Delete statement )  {  super  ( statement ) ; }   public Where and  (  Clause clause )  {   clauses . add  ( clause ) ;   statement . maybeAddRoutingKey  (  clause . name  ( ) ,  clause . firstValue  ( ) ) ;   checkForBindMarkers  ( clause ) ;  return this ; }   public Options using  (  Using using )  {  return  statement . using  ( using ) ; }   public Delete ifExists  ( )  {  return  statement . ifExists  ( ) ; }   public Conditions onlyIf  (  Clause condition )  {  return  statement . onlyIf  ( condition ) ; } }   public static class Options  extends   BuiltStatement . ForwardingStatement  < Delete >  {   private final  List  < Using >  usings =  new  ArrayList  < Using >  ( ) ;  Options  (  Delete statement )  {  super  ( statement ) ; }   public Options and  (  Using using )  {   usings . add  ( using ) ;   checkForBindMarkers  ( using ) ;  return this ; }   public Where where  (  Clause clause )  {  return  statement . where  ( clause ) ; } }   public static class Builder  {   List  < Object >  columnNames ;  Builder  ( )  { }  Builder  (   List  < Object > columnNames )  {    this . columnNames = columnNames ; }   public Delete from  (  String table )  {  return  from  ( null , table ) ; }   public Delete from  (  String keyspace ,  String table )  {  return  new Delete  ( keyspace , table , columnNames ) ; }   public Delete from  (  TableMetadata table )  {  return  new Delete  ( table , columnNames ) ; } }   public static class Selection  extends Builder  {   public Builder all  ( )  {  if  (  columnNames != null )  throw  new IllegalStateException  (  String . format  ( "Some columns (%s) have already been selected." , columnNames ) ) ;  return  ( Builder ) this ; }   public Selection column  (  String name )  {  if  (  columnNames == null )   columnNames =  new  ArrayList  < Object >  ( ) ;   columnNames . add  ( name ) ;  return this ; }   public Selection listElt  (  String columnName ,   int idx )  {  StringBuilder  sb =  new StringBuilder  ( ) ;   Utils . appendName  ( columnName , sb ) ;  return  column  (     sb . append  ( '[' ) . append  ( idx ) . append  ( ']' ) . toString  ( ) ) ; }   public Selection mapElt  (  String columnName ,  Object key )  {  StringBuilder  sb =  new StringBuilder  ( ) ;   Utils . appendName  ( columnName , sb ) ;   sb . append  ( '[' ) ;   Utils . appendFlatValue  ( key , sb ) ;  return  column  (   sb . append  ( ']' ) . toString  ( ) ) ; } }   public static class Conditions  extends   BuiltStatement . ForwardingStatement  < Delete >  {   private final  List  < Clause >  conditions =  new  ArrayList  < Clause >  ( ) ;  Conditions  (  Delete statement )  {  super  ( statement ) ; }   public Conditions and  (  Clause condition )  {   conditions . add  ( condition ) ;   checkForBindMarkers  ( condition ) ;  return this ; }   public Where where  (  Clause clause )  {  return  statement . where  ( clause ) ; }   public Options using  (  Using using )  {  return  statement . using  ( using ) ; } }  Delete  (  String keyspace ,  String table ,   List  <  ? > columnNames )  {  super  ( keyspace ) ;    this . table = table ;    this . columnNames = columnNames ;    this . where =  new Where  ( this ) ;    this . usings =  new Options  ( this ) ;    this . conditions =  new Conditions  ( this ) ; } }