  package    com . datastax . driver . core ;   import   java . io . Closeable ;  import   java . net . InetAddress ;  import   java . net . InetSocketAddress ;  import   java . net . UnknownHostException ;  import  java . util .  * ;  import   java . util . concurrent .  * ;  import     java . util . concurrent . atomic . AtomicInteger ;  import     java . util . concurrent . atomic . AtomicReference ;  import     com . google . common . base . Predicates ;  import     com . google . common . collect . HashMultimap ;  import     com . google . common . collect . Iterables ;  import     com . google . common . collect . MapMaker ;  import     com . google . common . collect . SetMultimap ;  import     com . google . common . util . concurrent .  * ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import      com . datastax . driver . core . exceptions . AuthenticationException ;  import      com . datastax . driver . core . exceptions . DriverInternalError ;  import      com . datastax . driver . core . exceptions . NoHostAvailableException ;  import     com . datastax . driver . core . policies .  * ;   public class Cluster  implements  Closeable  {   private static final Logger  logger =  LoggerFactory . getLogger  (  Cluster . class ) ;   private static final AtomicInteger  CLUSTER_ID =  new AtomicInteger  ( 0 ) ;   private static final  int  DEFAULT_THREAD_KEEP_ALIVE = 30 ;   final Manager  manager ;   protected Cluster  (  String name ,   List  < InetSocketAddress > contactPoints ,  Configuration configuration )  {  this  ( name , contactPoints , configuration ,  Collections .  <  Host . StateListener > emptySet  ( ) ) ; }   protected Cluster  (  Initializer initializer )  {  this  (  initializer . getClusterName  ( ) ,  checkNotEmpty  (  initializer . getContactPoints  ( ) ) ,  initializer . getConfiguration  ( ) ,  initializer . getInitialListeners  ( ) ) ; }   private static  List  < InetSocketAddress > checkNotEmpty  (   List  < InetSocketAddress > contactPoints )  {  if  (  contactPoints . isEmpty  ( ) )  throw  new IllegalArgumentException  ( "Cannot build a cluster without contact points" ) ;  return contactPoints ; }   private Cluster  (  String name ,   List  < InetSocketAddress > contactPoints ,  Configuration configuration ,   Collection  <  Host . StateListener > listeners )  {    this . manager =  new Manager  ( name , contactPoints , configuration , listeners ) ; }   public Cluster init  ( )  {    this . manager . init  ( ) ;  return this ; }   public static Cluster buildFrom  (  Initializer initializer )  {  return  new Cluster  ( initializer ) ; }   public static  Cluster . Builder builder  ( )  {  return  new  Cluster . Builder  ( ) ; }   public Session newSession  ( )  {  return  manager . newSession  ( ) ; }   public Session connect  ( )  {   init  ( ) ;  Session  session =  manager . newSession  ( ) ;   session . init  ( ) ;  return session ; }   public Session connect  (  String keyspace )  {   long  timeout =    getConfiguration  ( ) . getSocketOptions  ( ) . getConnectTimeoutMillis  ( ) ;  Session  session =  connect  ( ) ;  try  {  ResultSetFuture  future =  session . executeAsync  (  "USE " + keyspace ) ;   Uninterruptibles . getUninterruptibly  ( future , timeout ,  TimeUnit . MILLISECONDS ) ;  return session ; }  catch (   TimeoutException e )  {  throw  new DriverInternalError  (  String . format  ( "No responses after %d milliseconds while setting current keyspace. This should not happen, unless you have setup a very low connection timeout." , timeout ) ) ; }  catch (   ExecutionException e )  {  throw  DefaultResultSetFuture . extractCauseFromExecutionException  ( e ) ; }  catch (   RuntimeException e )  {   session . close  ( ) ;  throw e ; } }   public String getClusterName  ( )  {  return  manager . clusterName ; }   public Metadata getMetadata  ( )  {   manager . init  ( ) ;  return  manager . metadata ; }   public Configuration getConfiguration  ( )  {  return  manager . configuration ; }   public Metrics getMetrics  ( )  {  return  manager . metrics ; }   public Cluster register  (   Host . StateListener listener )  {    manager . listeners . add  ( listener ) ;  return this ; }   public Cluster unregister  (   Host . StateListener listener )  {    manager . listeners . remove  ( listener ) ;  return this ; }   public Cluster register  (  LatencyTracker tracker )  {    manager . trackers . add  ( tracker ) ;  return this ; }   public Cluster unregister  (  LatencyTracker tracker )  {    manager . trackers . remove  ( tracker ) ;  return this ; }   public CloseFuture closeAsync  ( )  {  return  manager . close  ( ) ; }   public void close  ( )  {  try  {    closeAsync  ( ) . get  ( ) ; }  catch (   ExecutionException e )  {  throw  DefaultResultSetFuture . extractCauseFromExecutionException  ( e ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; } }   public boolean isClosed  ( )  {  return    manager . closeFuture . get  ( ) != null ; }   public interface Initializer  {   public String getClusterName  ( ) ;   public  List  < InetSocketAddress > getContactPoints  ( ) ;   public Configuration getConfiguration  ( ) ;   public  Collection  <  Host . StateListener > getInitialListeners  ( ) ; }   public static class Builder  implements  Initializer  {   private String  clusterName ;   private final  List  < InetSocketAddress >  addresses =  new  ArrayList  < InetSocketAddress >  ( ) ;   private final  List  < InetAddress >  rawAddresses =  new  ArrayList  < InetAddress >  ( ) ;   private  int  port =  ProtocolOptions . DEFAULT_PORT ;   private  int  protocolVersion =  - 1 ;   private AuthProvider  authProvider =  AuthProvider . NONE ;   private LoadBalancingPolicy  loadBalancingPolicy ;   private ReconnectionPolicy  reconnectionPolicy ;   private RetryPolicy  retryPolicy ;   private AddressTranslater  addressTranslater ;   private  ProtocolOptions . Compression  compression =   ProtocolOptions . Compression . NONE ;   private SSLOptions  sslOptions = null ;   private boolean  metricsEnabled = true ;   private boolean  jmxEnabled = true ;   private PoolingOptions  poolingOptions ;   private SocketOptions  socketOptions ;   private QueryOptions  queryOptions ;   private  Collection  <  Host . StateListener >  listeners ;    @ Override public String getClusterName  ( )  {  return clusterName ; }    @ Override public  List  < InetSocketAddress > getContactPoints  ( )  {  if  (  rawAddresses . isEmpty  ( ) )  return addresses ;   List  < InetSocketAddress >  allAddresses =  new  ArrayList  < InetSocketAddress >  ( addresses ) ;  for ( InetAddress address : rawAddresses )   allAddresses . add  (  new InetSocketAddress  ( address , port ) ) ;  return allAddresses ; }   public Builder withClusterName  (  String name )  {    this . clusterName = name ;  return this ; }   public Builder withPort  (   int port )  {    this . port = port ;  return this ; }   public Builder withProtocolVersion  (   int version )  {  if  (   protocolVersion == 0 ||  protocolVersion >  ProtocolOptions . NEWEST_SUPPORTED_PROTOCOL_VERSION )  throw  new IllegalArgumentException  (  String . format  ( "Unsupported protocol version %d; valid values must be between 1 and %d or negative (for auto-detect)." , protocolVersion ,  ProtocolOptions . NEWEST_SUPPORTED_PROTOCOL_VERSION ) ) ;    this . protocolVersion = version ;  return this ; }   public Builder addContactPoint  (  String address )  {  if  (  address == null )  throw  new NullPointerException  ( ) ;  try  {    this . rawAddresses . add  (  InetAddress . getByName  ( address ) ) ;  return this ; }  catch (   UnknownHostException e )  {  throw  new IllegalArgumentException  (  e . getMessage  ( ) ) ; } }   public Builder addContactPoints  (  String ...  addresses )  {  for ( String address : addresses )   addContactPoint  ( address ) ;  return this ; }   public Builder addContactPoints  (  InetAddress ...  addresses )  {   Collections . addAll  (  this . rawAddresses , addresses ) ;  return this ; }   public Builder addContactPoints  (   Collection  < InetAddress > addresses )  {    this . rawAddresses . addAll  ( addresses ) ;  return this ; }   public Builder addContactPointsWithPorts  (   Collection  < InetSocketAddress > addresses )  {    this . addresses . addAll  ( addresses ) ;  return this ; }   public Builder withLoadBalancingPolicy  (  LoadBalancingPolicy policy )  {    this . loadBalancingPolicy = policy ;  return this ; }   public Builder withReconnectionPolicy  (  ReconnectionPolicy policy )  {    this . reconnectionPolicy = policy ;  return this ; }   public Builder withRetryPolicy  (  RetryPolicy policy )  {    this . retryPolicy = policy ;  return this ; }   public Builder withAddressTranslater  (  AddressTranslater translater )  {    this . addressTranslater = translater ;  return this ; }   public Builder withCredentials  (  String username ,  String password )  {    this . authProvider =  new PlainTextAuthProvider  ( username , password ) ;  return this ; }   public Builder withAuthProvider  (  AuthProvider authProvider )  {    this . authProvider = authProvider ;  return this ; }   public Builder withCompression  (   ProtocolOptions . Compression compression )  {    this . compression = compression ;  return this ; }   public Builder withoutMetrics  ( )  {    this . metricsEnabled = false ;  return this ; }   public Builder withSSL  ( )  {    this . sslOptions =  new SSLOptions  ( ) ;  return this ; }   public Builder withSSL  (  SSLOptions sslOptions )  {    this . sslOptions = sslOptions ;  return this ; }   public Builder withInitialListeners  (   Collection  <  Host . StateListener > listeners )  {    this . listeners = listeners ;  return this ; }   public Builder withoutJMXReporting  ( )  {    this . jmxEnabled = false ;  return this ; }   public Builder withPoolingOptions  (  PoolingOptions options )  {    this . poolingOptions = options ;  return this ; }   public Builder withSocketOptions  (  SocketOptions options )  {    this . socketOptions = options ;  return this ; }   public Builder withQueryOptions  (  QueryOptions options )  {    this . queryOptions = options ;  return this ; }    @ Override public Configuration getConfiguration  ( )  {  Policies  policies =  new Policies  (   loadBalancingPolicy == null ?  Policies . defaultLoadBalancingPolicy  ( ) : loadBalancingPolicy ,   reconnectionPolicy == null ?  Policies . defaultReconnectionPolicy  ( ) : reconnectionPolicy ,   retryPolicy == null ?  Policies . defaultRetryPolicy  ( ) : retryPolicy ,   addressTranslater == null ?  Policies . defaultAddressTranslater  ( ) : addressTranslater ) ;  return  new Configuration  ( policies ,   new ProtocolOptions  ( port , protocolVersion , sslOptions , authProvider ) . setCompression  ( compression ) ,   poolingOptions == null ?  new PoolingOptions  ( ) : poolingOptions ,   socketOptions == null ?  new SocketOptions  ( ) : socketOptions ,  metricsEnabled ?  new MetricsOptions  ( jmxEnabled ) : null ,   queryOptions == null ?  new QueryOptions  ( ) : queryOptions ) ; }    @ Override public  Collection  <  Host . StateListener > getInitialListeners  ( )  {  return   listeners == null ?  Collections .  <  Host . StateListener > emptySet  ( ) : listeners ; }   public Cluster build  ( )  {  return  Cluster . buildFrom  ( this ) ; } }   private static ThreadFactory threadFactory  (  String nameFormat )  {  return    new ThreadFactoryBuilder  ( ) . setNameFormat  ( nameFormat ) . build  ( ) ; }   static  long timeSince  (   long startNanos ,  TimeUnit destUnit )  {  return  destUnit . convert  (   System . nanoTime  ( ) - startNanos ,  TimeUnit . NANOSECONDS ) ; }   private static String generateClusterName  ( )  {  return  "cluster" +  CLUSTER_ID . incrementAndGet  ( ) ; }   private static ListeningExecutorService makeExecutor  (   int threads ,  String name )  {  ThreadPoolExecutor  executor =  new ThreadPoolExecutor  ( threads , threads , DEFAULT_THREAD_KEEP_ALIVE ,  TimeUnit . SECONDS ,  new  LinkedBlockingQueue  < Runnable >  ( ) ,  threadFactory  ( name ) ) ;   executor . allowCoreThreadTimeOut  ( true ) ;  return  MoreExecutors . listeningDecorator  ( executor ) ; }  class Manager  implements   Connection . DefaultResponseHandler  {   final String  clusterName ;   private boolean  isInit ;   private volatile boolean  isFullyInit ;   final  List  < InetSocketAddress >  contactPoints ;   final  Set  < SessionManager >  sessions =  new  CopyOnWriteArraySet  < SessionManager >  ( ) ;   final Metadata  metadata ;   final Configuration  configuration ;   final Metrics  metrics ;   final  Connection . Factory  connectionFactory ;   final ControlConnection  controlConnection ;   final  ConvictionPolicy . Factory  convictionPolicyFactory =  new   ConvictionPolicy . Simple . Factory  ( ) ;   final ScheduledExecutorService  reconnectionExecutor =  Executors . newScheduledThreadPool  ( 2 ,  threadFactory  ( "Reconnection-%d" ) ) ;   final ScheduledExecutorService  scheduledTasksExecutor =  Executors . newScheduledThreadPool  ( 1 ,  threadFactory  ( "Scheduled Tasks-%d" ) ) ;   final ListeningExecutorService  executor ;   final ListeningExecutorService  blockingExecutor ;   final  AtomicReference  < CloseFuture >  closeFuture =  new  AtomicReference  < CloseFuture >  ( ) ;   final  ConcurrentMap  < MD5Digest , PreparedStatement >  preparedQueries =    new MapMaker  ( ) . weakValues  ( ) . makeMap  ( ) ;   final  Set  <  Host . StateListener >  listeners ;   final  Set  < LatencyTracker >  trackers =  new  CopyOnWriteArraySet  < LatencyTracker >  ( ) ;   private Manager  (  String clusterName ,   List  < InetSocketAddress > contactPoints ,  Configuration configuration ,   Collection  <  Host . StateListener > listeners )  {   logger . debug  (  "Starting new cluster with contact points " + contactPoints ) ;    this . clusterName =   clusterName == null ?  generateClusterName  ( ) : clusterName ;    this . configuration = configuration ;    this . configuration . register  ( this ) ;    this . executor =  makeExecutor  (   Runtime . getRuntime  ( ) . availableProcessors  ( ) , "Cassandra Java Driver worker-%d" ) ;    this . blockingExecutor =  makeExecutor  ( 2 , "Cassandra Java Driver blocking tasks worker-%d" ) ;    this . metadata =  new Metadata  ( this ) ;    this . contactPoints = contactPoints ;    this . connectionFactory =  new  Connection . Factory  ( this , configuration ) ;    this . controlConnection =  new ControlConnection  ( this ) ;    this . metrics =    configuration . getMetricsOptions  ( ) == null ? null :  new Metrics  ( this ) ;    this . listeners =  new  CopyOnWriteArraySet  <  Host . StateListener >  ( listeners ) ; }   synchronized void init  ( )  {  if  (  isClosed  ( ) )  throw  new IllegalStateException  ( "Can't use this Cluster instance because it was previously closed" ) ;  if  ( isInit )  return ;   isInit = true ;  for ( InetSocketAddress address : contactPoints )  {  Host  host =  metadata . add  ( address ) ; }  try  {  while  ( true )  {  try  {   controlConnection . connect  ( ) ;  if  (   connectionFactory . protocolVersion < 0 )    connectionFactory . protocolVersion =  ProtocolOptions . NEWEST_SUPPORTED_PROTOCOL_VERSION ;   Collection  < Host >  hosts =  metadata . allHosts  ( ) ;    loadBalancingPolicy  ( ) . init  (  Cluster . this , hosts ) ;   isFullyInit = true ;  for ( Host host : hosts )   triggerOnAdd  ( host ) ;  return ; }  catch (   UnsupportedProtocolVersionException e )  {  assert   connectionFactory . protocolVersion < 1 ;  if  (   e . versionUnsupported <= 1 )  throw  new DriverInternalError  ( "Got a node that don't even support the protocol version 1, this makes no sense" , e ) ;   logger . debug  ( "{}: retrying with version {}" ,  e . getMessage  ( ) ,   e . versionUnsupported - 1 ) ;    connectionFactory . protocolVersion =   e . versionUnsupported - 1 ; } } }  catch (   NoHostAvailableException e )  {   close  ( ) ;  throw e ; } }   int protocolVersion  ( )  {  return  connectionFactory . protocolVersion ; }  Cluster getCluster  ( )  {  return  Cluster . this ; }  LoadBalancingPolicy loadBalancingPolicy  ( )  {  return   configuration . getPolicies  ( ) . getLoadBalancingPolicy  ( ) ; }  ReconnectionPolicy reconnectionPolicy  ( )  {  return   configuration . getPolicies  ( ) . getReconnectionPolicy  ( ) ; }  InetSocketAddress translateAddress  (  InetAddress address )  {  InetSocketAddress  sa =  new InetSocketAddress  ( address ,  connectionFactory . getPort  ( ) ) ;  return    configuration . getPolicies  ( ) . getAddressTranslater  ( ) . translate  ( sa ) ; }   private Session newSession  ( )  {  SessionManager  session =  new SessionManager  (  Cluster . this ) ;   sessions . add  ( session ) ;  return session ; }  boolean removeSession  (  Session session )  {  return  sessions . remove  ( session ) ; }  void reportLatency  (  Host host ,   long latencyNanos )  {  for ( LatencyTracker tracker : trackers )  {   tracker . update  ( host , latencyNanos ) ; } }  boolean isClosed  ( )  {  return   closeFuture . get  ( ) != null ; }   private CloseFuture close  ( )  {  CloseFuture  future =  closeFuture . get  ( ) ;  if  (  future != null )  return future ;   logger . debug  ( "Shutting down" ) ;   reconnectionExecutor . shutdownNow  ( ) ;   scheduledTasksExecutor . shutdownNow  ( ) ;   executor . shutdown  ( ) ;  if  (  metrics != null )   metrics . shutdown  ( ) ;   List  < CloseFuture >  futures =  new  ArrayList  < CloseFuture >  (   sessions . size  ( ) + 1 ) ;   futures . add  (  controlConnection . closeAsync  ( ) ) ;  for ( Session session : sessions )   futures . add  (  session . closeAsync  ( ) ) ;   future =  new ClusterCloseFuture  ( futures ) ;  return   closeFuture . compareAndSet  ( null , future ) ? future :  closeFuture . get  ( ) ; }  void logUnsupportedVersionProtocol  (  Host host )  {   logger . warn  (   "Detected added or restarted Cassandra host {} but ignoring it since it does not support the version 2 of the native " + "protocol which is currently in use. If you want to force the use of the version 1 of the native protocol, use " + "Cluster.Builder#usingProtocolVersion() when creating the Cluster instance." , host ) ; }   public  ListenableFuture  <  ? > triggerOnUp  (   final Host host )  {  return  executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   onUp  ( host ) ; } } ) ; }   private void onUp  (   final Host host )  throws InterruptedException , ExecutionException  {   onUp  ( host , blockingExecutor ) ; }   private void onUp  (   final Host host ,  ListeningExecutorService poolCreationExecutor )  throws InterruptedException , ExecutionException  {   logger . debug  ( "Host {} is UP" , host ) ;  if  (  isClosed  ( ) )  return ;  if  (   host . state ==   Host . State . UP )  return ;  if  (    connectionFactory . protocolVersion == 2 &&  !  supportsProtocolV2  ( host ) )  {   logUnsupportedVersionProtocol  ( host ) ;  return ; }   ScheduledFuture  <  ? >  scheduledAttempt =   host . reconnectionAttempt . getAndSet  ( null ) ;  if  (  scheduledAttempt != null )  {   logger . debug  ( "Cancelling reconnection attempt since node is UP" ) ;   scheduledAttempt . cancel  ( false ) ; }  try  {   prepareAllQueries  ( host ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   UnsupportedProtocolVersionException e )  {   logUnsupportedVersionProtocol  ( host ) ;  return ; }  for ( SessionManager s : sessions )   s . removePool  ( host ) ;    loadBalancingPolicy  ( ) . onUp  ( host ) ;   controlConnection . onUp  ( host ) ;   logger . trace  ( "Adding/renewing host pools for newly UP host {}" , host ) ;   List  <  ListenableFuture  < Boolean > >  futures =  new  ArrayList  <  ListenableFuture  < Boolean > >  (  sessions . size  ( ) ) ;  for ( SessionManager s : sessions )   futures . add  (  s . forceRenewPool  ( host , poolCreationExecutor ) ) ;   ListenableFuture  <  List  < Boolean > >  f =  Futures . allAsList  ( futures ) ;   Futures . addCallback  ( f ,  new  FutureCallback  <  List  < Boolean > >  ( )  {   public void onSuccess  (   List  < Boolean > poolCreationResults )  {  if  (  Iterables . any  ( poolCreationResults ,  Predicates . equalTo  ( false ) ) )  {   logger . debug  ( "Connection pool cannot be created, not marking {} UP" , host ) ;  return ; }   host . setUp  ( ) ;  for (  Host . StateListener listener : listeners )   listener . onUp  ( host ) ; }   public void onFailure  (  Throwable t )  {  if  (  !  (  t instanceof InterruptedException ) )   logger . error  ( "Unexpected error while marking node UP: while this shouldn't happen, this shouldn't be critical" , t ) ; } } ) ;   f . get  ( ) ;  for ( SessionManager s : sessions )   s . updateCreatedPools  ( blockingExecutor ) ; }   public  ListenableFuture  <  ? > triggerOnDown  (   final Host host )  {  return  triggerOnDown  ( host , false ) ; }   public  ListenableFuture  <  ? > triggerOnDown  (   final Host host ,   final boolean isHostAddition )  {  return  executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   onDown  ( host , isHostAddition , false ) ; } } ) ; }   public void onSuspected  (   final Host host )  {   logger . debug  ( "Host {} is Suspected" , host ) ;  if  (  isClosed  ( ) )  return ;  if  (    loadBalancingPolicy  ( ) . distance  ( host ) ==  HostDistance . IGNORED )  {   triggerOnDown  ( host ) ;  return ; }  synchronized  ( host )  {  if  (   !  host . setSuspected  ( ) ||    host . reconnectionAttempt . get  ( ) != null )  return ;    host . initialReconnectionAttempt . set  (  executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {  try  {    connectionFactory . open  ( host ) . closeAsync  ( ) ;   onUp  ( host ,  MoreExecutors . sameThreadExecutor  ( ) ) ; }  catch (   Exception e )  {   onDown  ( host , false , true ) ; } } } ) ) ;    loadBalancingPolicy  ( ) . onSuspected  ( host ) ; }   controlConnection . onSuspected  ( host ) ;  for ( SessionManager s : sessions )   s . onSuspected  ( host ) ;  for (  Host . StateListener listener : listeners )   listener . onSuspected  ( host ) ; }   private void onDown  (   final Host host ,   final boolean isHostAddition ,   final boolean isSuspectedVerification )  throws InterruptedException , ExecutionException  {   logger . debug  ( "Host {} is DOWN" , host ) ;  if  (  isClosed  ( ) )  return ;  if  (   ! isSuspectedVerification &&   host . state ==   Host . State . SUSPECT )  return ;  if  (    host . reconnectionAttempt . get  ( ) != null )  return ;  HostDistance  distance =   loadBalancingPolicy  ( ) . distance  ( host ) ;  boolean  wasUp =  host . isUp  ( ) ;   host . setDown  ( ) ;    loadBalancingPolicy  ( ) . onDown  ( host ) ;   controlConnection . onDown  ( host ) ;  for ( SessionManager s : sessions )   s . onDown  ( host ) ;  if  ( wasUp )  {  for (  Host . StateListener listener : listeners )   listener . onDown  ( host ) ; }  if  (  distance ==  HostDistance . IGNORED )  return ;   logger . debug  ( "{} is down, scheduling connection retries" , host ) ;    new AbstractReconnectionHandler  ( reconnectionExecutor ,   reconnectionPolicy  ( ) . newSchedule  ( ) ,  host . reconnectionAttempt )  {   protected Connection tryReconnect  ( )  throws ConnectionException , InterruptedException , UnsupportedProtocolVersionException  {  return  connectionFactory . open  ( host ) ; }   protected void onReconnection  (  Connection connection )  {   connection . closeAsync  ( ) ;   logger . debug  ( "Successful reconnection to {}, setting host UP" , host ) ;   controlConnection . refreshNodeInfo  ( host ) ;  try  {  if  ( isHostAddition )   onAdd  ( host ) ; else   onUp  ( host ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   Exception e )  {   logger . error  ( "Unexpected error while setting node up" , e ) ; } }   protected boolean onConnectionException  (  ConnectionException e ,   long nextDelayMs )  {  if  (  logger . isDebugEnabled  ( ) )   logger . debug  ( "Failed reconnection to {} ({}), scheduling retry in {} milliseconds" , host ,  e . getMessage  ( ) , nextDelayMs ) ;  return true ; }   protected boolean onUnknownException  (  Exception e ,   long nextDelayMs )  {   logger . error  (  String . format  ( "Unknown error during control connection reconnection, scheduling retry in %d milliseconds" , nextDelayMs ) , e ) ;  return true ; } } . start  ( ) ; }   public  ListenableFuture  <  ? > triggerOnAdd  (   final Host host )  {  return  executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   onAdd  ( host ) ; } } ) ; }   private void onAdd  (   final Host host )  throws InterruptedException , ExecutionException  {  if  (  isClosed  ( ) )  return ;   logger . info  ( "New Cassandra host {} added" , host ) ;  if  (    connectionFactory . protocolVersion == 2 &&  !  supportsProtocolV2  ( host ) )  {   logUnsupportedVersionProtocol  ( host ) ;  return ; }    loadBalancingPolicy  ( ) . onAdd  ( host ) ;  if  (    loadBalancingPolicy  ( ) . distance  ( host ) ==  HostDistance . IGNORED )  {   host . setUp  ( ) ;  for (  Host . StateListener listener : listeners )   listener . onAdd  ( host ) ;  return ; }  try  {   prepareAllQueries  ( host ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   UnsupportedProtocolVersionException e )  {   logUnsupportedVersionProtocol  ( host ) ;  return ; }   controlConnection . onAdd  ( host ) ;   List  <  ListenableFuture  < Boolean > >  futures =  new  ArrayList  <  ListenableFuture  < Boolean > >  (  sessions . size  ( ) ) ;  for ( SessionManager s : sessions )   futures . add  (  s . maybeAddPool  ( host , blockingExecutor ) ) ;   ListenableFuture  <  List  < Boolean > >  f =  Futures . allAsList  ( futures ) ;   Futures . addCallback  ( f ,  new  FutureCallback  <  List  < Boolean > >  ( )  {   public void onSuccess  (   List  < Boolean > poolCreationResults )  {  if  (  Iterables . any  ( poolCreationResults ,  Predicates . equalTo  ( false ) ) )  {   logger . debug  ( "Connection pool cannot be created, not marking {} UP" , host ) ;  return ; }   host . setUp  ( ) ;  for (  Host . StateListener listener : listeners )   listener . onAdd  ( host ) ; }   public void onFailure  (  Throwable t )  {  if  (  !  (  t instanceof InterruptedException ) )   logger . error  ( "Unexpected error while adding node: while this shouldn't happen, this shouldn't be critical" , t ) ; } } ) ;   f . get  ( ) ;  for ( SessionManager s : sessions )   s . updateCreatedPools  ( blockingExecutor ) ; }   public  ListenableFuture  <  ? > triggerOnRemove  (   final Host host )  {  return  executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   onRemove  ( host ) ; } } ) ; }   private void onRemove  (  Host host )  throws InterruptedException , ExecutionException  {  if  (  isClosed  ( ) )  return ;   host . setDown  ( ) ;   logger . debug  ( "Removing host {}" , host ) ;    loadBalancingPolicy  ( ) . onRemove  ( host ) ;   controlConnection . onRemove  ( host ) ;  for ( SessionManager s : sessions )   s . onRemove  ( host ) ;  for (  Host . StateListener listener : listeners )   listener . onRemove  ( host ) ; }   public boolean signalConnectionFailure  (  Host host ,  ConnectionException exception ,  boolean isHostAddition ,  boolean markSuspected )  {  if  (   ! isFullyInit ||  isClosed  ( ) )  return true ;  boolean  isDown =  host . signalConnectionFailure  ( exception ) ;  if  ( isDown )  {  if  (  isHostAddition ||  ! markSuspected )  {   triggerOnDown  ( host , isHostAddition ) ; } else  {   onSuspected  ( host ) ; } }  return isDown ; }   private boolean supportsProtocolV2  (  Host newHost )  {  return    newHost . getCassandraVersion  ( ) == null ||    newHost . getCassandraVersion  ( ) . getMajor  ( ) >= 2 ; }   public void removeHost  (  Host host ,  boolean isInitialConnection )  {  if  (  host == null )  return ;  if  (  metadata . remove  ( host ) )  {  if  ( isInitialConnection )  {   logger . warn  ( "You listed {} in your contact points, but it could not be reached at startup" , host ) ; } else  {   logger . info  ( "Cassandra host {} removed" , host ) ;   triggerOnRemove  ( host ) ; } } }   public void ensurePoolsSizing  ( )  {  for ( SessionManager session : sessions )  {  for ( HostConnectionPool pool :   session . pools . values  ( ) )   pool . ensureCoreConnections  ( ) ; } }   public PreparedStatement addPrepared  (  PreparedStatement stmt )  {  PreparedStatement  previous =  preparedQueries . putIfAbsent  (   stmt . getPreparedId  ( ) . id , stmt ) ;  if  (  previous != null )  {   logger . warn  (  "Re-preparing already prepared query {}. Please note that preparing the same query more than once is " + "generally an anti-pattern and will likely affect performance. Consider preparing the statement only once." ,  stmt . getQueryString  ( ) ) ;  return previous ; }  return stmt ; }   private void prepareAllQueries  (  Host host )  throws InterruptedException , UnsupportedProtocolVersionException  {  if  (  preparedQueries . isEmpty  ( ) )  return ;   logger . debug  ( "Preparing {} prepared queries on newly up node {}" ,  preparedQueries . size  ( ) , host ) ;  try  {  Connection  connection =  connectionFactory . open  ( host ) ;  try  {  try  {   ControlConnection . waitForSchemaAgreement  ( connection , this ) ; }  catch (   ExecutionException e )  { }   SetMultimap  < String , String >  perKeyspace =  HashMultimap . create  ( ) ;  for ( PreparedStatement ps :  preparedQueries . values  ( ) )  {  String  keyspace =    ps . getQueryKeyspace  ( ) == null ? "" :  ps . getQueryKeyspace  ( ) ;   perKeyspace . put  ( keyspace ,  ps . getQueryString  ( ) ) ; }  for ( String keyspace :  perKeyspace . keySet  ( ) )  {  if  (  !  keyspace . isEmpty  ( ) )   connection . setKeyspace  ( keyspace ) ;    List <  Connection . Future >  futures =  new  ArrayList  <  Connection . Future >  (  preparedQueries . size  ( ) ) ;  for ( String query :  perKeyspace . get  ( keyspace ) )  {   futures . add  (  connection . write  (  new  Requests . Prepare  ( query ) ) ) ; }  for (  Connection . Future future : futures )  {  try  {   future . get  ( ) ; }  catch (   ExecutionException e )  {   logger . debug  ( "Unexpected error while preparing queries on new/newly up host" , e ) ; } } } }  finally  {   connection . closeAsync  ( ) ; } }  catch (   ConnectionException e )  { }  catch (   AuthenticationException e )  { }  catch (   BusyConnectionException e )  { } }   public void submitSchemaRefresh  (   final String keyspace ,   final String table )  {   logger . trace  ( "Submitting schema refresh" ) ;   executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   controlConnection . refreshSchema  ( keyspace , table ) ; } } ) ; }   public void refreshSchemaAndSignal  (   final Connection connection ,   final DefaultResultSetFuture future ,   final ResultSet rs ,   final String keyspace ,   final String table )  {  if  (  logger . isDebugEnabled  ( ) )   logger . debug  ( "Refreshing schema for {}{}" ,   keyspace == null ? "" : keyspace ,   table == null ? "" :  '.' + table ) ;   executor . submit  (  new Runnable  ( )  {    @ Override public void run  ( )  {  try  {  if  (  !  ControlConnection . waitForSchemaAgreement  ( connection ,   Cluster . Manager . this ) )   logger . warn  ( "No schema agreement from live replicas after {} ms. The schema may not be up to date on some nodes." ,  ControlConnection . MAX_SCHEMA_AGREEMENT_WAIT_MS ) ;   ControlConnection . refreshSchema  ( connection , keyspace , table ,   Cluster . Manager . this , false ) ; }  catch (   Exception e )  {   logger . error  ( "Error during schema refresh ({}). The schema from Cluster.getMetadata() might appear stale. Asynchronously submitting job to fix." ,  e . getMessage  ( ) ) ;   submitSchemaRefresh  ( keyspace , table ) ; }  finally  {   future . setResult  ( rs ) ; } } } ) ; }    @ Override public void handle  (   Message . Response response )  {  if  (  !  (  response instanceof  Responses . Event ) )  {   logger . error  ( "Received an unexpected message from the server: {}" , response ) ;  return ; }   final ProtocolEvent  event =   (  (  Responses . Event ) response ) . event ;   logger . debug  ( "Received event {}, scheduling delivery" , response ) ;  switch  (  event . type )  {   case TOPOLOGY_CHANGE :   ProtocolEvent . TopologyChange  tpc =  (  ProtocolEvent . TopologyChange ) event ;  InetSocketAddress  tpAddr =  translateAddress  (   tpc . node . getAddress  ( ) ) ;  switch  (  tpc . change )  {   case NEW_NODE :   final Host  newHost =  metadata . add  ( tpAddr ) ;  if  (  newHost != null )  {   scheduledTasksExecutor . schedule  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   controlConnection . refreshNodeInfo  ( newHost ) ;   onAdd  ( newHost ) ; } } , 1 ,  TimeUnit . SECONDS ) ; }  break ;   case REMOVED_NODE :   removeHost  (  metadata . getHost  ( tpAddr ) , false ) ;  break ;   case MOVED_NODE :   executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  {   controlConnection . refreshNodeListAndTokenMap  ( ) ; } } ) ;  break ; }  break ;   case STATUS_CHANGE :   ProtocolEvent . StatusChange  stc =  (  ProtocolEvent . StatusChange ) event ;  InetSocketAddress  stAddr =  translateAddress  (   stc . node . getAddress  ( ) ) ;  switch  (  stc . status )  {   case UP :   final Host  hostUp =  metadata . getHost  ( stAddr ) ;  if  (  hostUp == null )  {   final Host  h =  metadata . add  ( stAddr ) ;  if  (  h == null )  return ;   scheduledTasksExecutor . schedule  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   controlConnection . refreshNodeInfo  ( h ) ;   onAdd  ( h ) ; } } , 1 ,  TimeUnit . SECONDS ) ; } else  {   executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   controlConnection . refreshNodeInfo  ( hostUp ) ;   onUp  ( hostUp ) ; } } ) ; }  break ;   case DOWN :  Host  hostDown =  metadata . getHost  ( stAddr ) ;  if  (  hostDown != null )   triggerOnDown  ( hostDown ) ;  break ; }  break ;   case SCHEMA_CHANGE :   ProtocolEvent . SchemaChange  scc =  (  ProtocolEvent . SchemaChange ) event ;  switch  (  scc . change )  {   case CREATED :  if  (   scc . table . isEmpty  ( ) )   submitSchemaRefresh  ( null , null ) ; else   submitSchemaRefresh  (  scc . keyspace , null ) ;  break ;   case DROPPED :  if  (   scc . table . isEmpty  ( ) )   submitSchemaRefresh  ( null , null ) ; else   submitSchemaRefresh  (  scc . keyspace , null ) ;  break ;   case UPDATED :  if  (   scc . table . isEmpty  ( ) )   submitSchemaRefresh  (  scc . keyspace , null ) ; else   submitSchemaRefresh  (  scc . keyspace ,  scc . table ) ;  break ; }  break ; } }  void refreshConnectedHosts  ( )  {  Host  ccHost =  controlConnection . connectedHost  ( ) ;  if  (   ccHost == null ||    loadBalancingPolicy  ( ) . distance  ( ccHost ) !=  HostDistance . LOCAL )   controlConnection . reconnect  ( ) ;  for ( SessionManager s : sessions )   s . updateCreatedPools  ( executor ) ; }   private class ClusterCloseFuture  extends  CloseFuture . Forwarding  {  ClusterCloseFuture  (   List  < CloseFuture > futures )  {  super  ( futures ) ; }    @ Override public CloseFuture force  ( )  {   executor . shutdownNow  ( ) ;  return  super . force  ( ) ; }    @ Override protected void onFuturesDone  ( )  {    (  new Thread  ( "Shutdown-checker" )  {   public void run  ( )  {  try  {   reconnectionExecutor . awaitTermination  (  Long . MAX_VALUE ,  TimeUnit . SECONDS ) ;   scheduledTasksExecutor . awaitTermination  (  Long . MAX_VALUE ,  TimeUnit . SECONDS ) ;   executor . awaitTermination  (  Long . MAX_VALUE ,  TimeUnit . SECONDS ) ;   connectionFactory . shutdown  ( ) ;   set  ( null ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ;   setException  ( e ) ; } } } ) . start  ( ) ; } } } }