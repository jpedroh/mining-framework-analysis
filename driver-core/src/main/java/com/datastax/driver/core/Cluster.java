  package    com . datastax . driver . core ;   import   java . io . Closeable ;  import   java . net . InetAddress ;  import   java . net . InetSocketAddress ;  import   java . net . UnknownHostException ;  import  java . util .  * ;  import    java . util . Map . Entry ;  import   java . util . concurrent .  * ;  import     java . util . concurrent . atomic . AtomicInteger ;  import     java . util . concurrent . atomic . AtomicReference ;  import     com . google . common . annotations . VisibleForTesting ;  import     com . google . common . base . Predicates ;  import    com . google . common . collect .  * ;  import     com . google . common . util . concurrent .  * ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import      com . datastax . driver . core . exceptions . AuthenticationException ;  import      com . datastax . driver . core . exceptions . DriverInternalError ;  import      com . datastax . driver . core . exceptions . NoHostAvailableException ;  import     com . datastax . driver . core . policies .  * ;   public class Cluster  implements  Closeable  {   private static final Logger  logger =  LoggerFactory . getLogger  (  Cluster . class ) ;    @ VisibleForTesting static final  int  NEW_NODE_DELAY_SECONDS =  SystemProperties . getInt  ( "com.datastax.driver.NEW_NODE_DELAY_SECONDS" , 1 ) ;   private static final  int  NON_BLOCKING_EXECUTOR_SIZE =  SystemProperties . getInt  ( "com.datastax.driver.NON_BLOCKING_EXECUTOR_SIZE" ,   Runtime . getRuntime  ( ) . availableProcessors  ( ) ) ;   private static final ResourceBundle  driverProperties =  ResourceBundle . getBundle  ( "com.datastax.driver.core.Driver" ) ;   private static final AtomicInteger  CLUSTER_ID =  new AtomicInteger  ( 0 ) ;   private static final  int  DEFAULT_THREAD_KEEP_ALIVE = 30 ;   private static final  int  NOTIF_LOCK_TIMEOUT_SECONDS =  SystemProperties . getInt  ( "com.datastax.driver.NOTIF_LOCK_TIMEOUT_SECONDS" , 60 ) ;   final Manager  manager ;   protected Cluster  (  String name ,   List  < InetSocketAddress > contactPoints ,  Configuration configuration )  {  this  ( name , contactPoints , configuration ,  Collections .  <  Host . StateListener > emptySet  ( ) ) ; }   protected Cluster  (  Initializer initializer )  {  this  (  initializer . getClusterName  ( ) ,  checkNotEmpty  (  initializer . getContactPoints  ( ) ) ,  initializer . getConfiguration  ( ) ,  initializer . getInitialListeners  ( ) ) ; }   private static  List  < InetSocketAddress > checkNotEmpty  (   List  < InetSocketAddress > contactPoints )  {  if  (  contactPoints . isEmpty  ( ) )  throw  new IllegalArgumentException  ( "Cannot build a cluster without contact points" ) ;  return contactPoints ; }   private Cluster  (  String name ,   List  < InetSocketAddress > contactPoints ,  Configuration configuration ,   Collection  <  Host . StateListener > listeners )  {    this . manager =  new Manager  ( name , contactPoints , configuration , listeners ) ; }   public Cluster init  ( )  {    this . manager . init  ( ) ;  return this ; }   public static Cluster buildFrom  (  Initializer initializer )  {  return  new Cluster  ( initializer ) ; }   public static  Cluster . Builder builder  ( )  {  return  new  Cluster . Builder  ( ) ; }   public static String getDriverVersion  ( )  {  return  driverProperties . getString  ( "driver.version" ) ; }   public Session newSession  ( )  {  return  manager . newSession  ( ) ; }   public Session connect  ( )  {   init  ( ) ;  Session  session =  manager . newSession  ( ) ;   session . init  ( ) ;  return session ; }   public Session connect  (  String keyspace )  {   long  timeout =    getConfiguration  ( ) . getSocketOptions  ( ) . getConnectTimeoutMillis  ( ) ;  Session  session =  connect  ( ) ;  try  {  ResultSetFuture  future =  session . executeAsync  (  "USE " + keyspace ) ;   Uninterruptibles . getUninterruptibly  ( future , timeout ,  TimeUnit . MILLISECONDS ) ;  return session ; }  catch (   TimeoutException e )  {  throw  new DriverInternalError  (  String . format  ( "No responses after %d milliseconds while setting current keyspace. This should not happen, unless you have setup a very low connection timeout." , timeout ) ) ; }  catch (   ExecutionException e )  {  throw  DefaultResultSetFuture . extractCauseFromExecutionException  ( e ) ; }  catch (   RuntimeException e )  {   session . close  ( ) ;  throw e ; } }   public String getClusterName  ( )  {  return  manager . clusterName ; }   public Metadata getMetadata  ( )  {   manager . init  ( ) ;  return  manager . metadata ; }   public Configuration getConfiguration  ( )  {  return  manager . configuration ; }   public Metrics getMetrics  ( )  {  return  manager . metrics ; }   public Cluster register  (   Host . StateListener listener )  {    manager . listeners . add  ( listener ) ;  return this ; }   public Cluster unregister  (   Host . StateListener listener )  {    manager . listeners . remove  ( listener ) ;  return this ; }   public Cluster register  (  LatencyTracker tracker )  {    manager . trackers . add  ( tracker ) ;  return this ; }   public Cluster unregister  (  LatencyTracker tracker )  {    manager . trackers . remove  ( tracker ) ;  return this ; }   public CloseFuture closeAsync  ( )  {  return  manager . close  ( ) ; }   public void close  ( )  {  try  {    closeAsync  ( ) . get  ( ) ; }  catch (   ExecutionException e )  {  throw  DefaultResultSetFuture . extractCauseFromExecutionException  ( e ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; } }   public boolean isClosed  ( )  {  return    manager . closeFuture . get  ( ) != null ; }   public interface Initializer  {   public String getClusterName  ( ) ;   public  List  < InetSocketAddress > getContactPoints  ( ) ;   public Configuration getConfiguration  ( ) ;   public  Collection  <  Host . StateListener > getInitialListeners  ( ) ; }   public static class Builder  implements  Initializer  {   private String  clusterName ;   private final  List  < InetSocketAddress >  addresses =  new  ArrayList  < InetSocketAddress >  ( ) ;   private final  List  < InetAddress >  rawAddresses =  new  ArrayList  < InetAddress >  ( ) ;   private  int  port =  ProtocolOptions . DEFAULT_PORT ;   private  int  maxSchemaAgreementWaitSeconds =  ProtocolOptions . DEFAULT_MAX_SCHEMA_AGREEMENT_WAIT_SECONDS ;   private ProtocolVersion  protocolVersion =  - 1 ;   private AuthProvider  authProvider =  AuthProvider . NONE ;   private LoadBalancingPolicy  loadBalancingPolicy ;   private ReconnectionPolicy  reconnectionPolicy ;   private RetryPolicy  retryPolicy ;   private AddressTranslater  addressTranslater ;   private TimestampGenerator  timestampGenerator ;   private  ProtocolOptions . Compression  compression =   ProtocolOptions . Compression . NONE ;   private SSLOptions  sslOptions = null ;   private boolean  metricsEnabled = true ;   private boolean  jmxEnabled = true ;   private PoolingOptions  poolingOptions ;   private SocketOptions  socketOptions ;   private QueryOptions  queryOptions ;   private  Collection  <  Host . StateListener >  listeners ;    @ Override public String getClusterName  ( )  {  return clusterName ; }    @ Override public  List  < InetSocketAddress > getContactPoints  ( )  {  if  (  rawAddresses . isEmpty  ( ) )  return addresses ;   List  < InetSocketAddress >  allAddresses =  new  ArrayList  < InetSocketAddress >  ( addresses ) ;  for ( InetAddress address : rawAddresses )   allAddresses . add  (  new InetSocketAddress  ( address , port ) ) ;  return allAddresses ; }   public Builder withClusterName  (  String name )  {    this . clusterName = name ;  return this ; }   public Builder withPort  (   int port )  {    this . port = port ;  return this ; }   public Builder withMaxSchemaAgreementWaitSeconds  (   int maxSchemaAgreementWaitSeconds )  {  if  (  maxSchemaAgreementWaitSeconds <= 0 )  throw  new IllegalArgumentException  ( "Max schema agreement wait must be greater than zero" ) ;    this . maxSchemaAgreementWaitSeconds = maxSchemaAgreementWaitSeconds ;  return this ; }   public Builder withProtocolVersion  (  ProtocolVersion version )  {    this . protocolVersion = version ;  return this ; }    @ Deprecated public Builder withProtocolVersion  (   int version )  {    this . protocolVersion =  ProtocolVersion . fromInt  ( version ) ;  return this ; }   public Builder addContactPoint  (  String address )  {  if  (  address == null )  throw  new NullPointerException  ( ) ;  try  {    this . rawAddresses . add  (  InetAddress . getByName  ( address ) ) ;  return this ; }  catch (   UnknownHostException e )  {  throw  new IllegalArgumentException  (  e . getMessage  ( ) ) ; } }   public Builder addContactPoints  (  String ...  addresses )  {  for ( String address : addresses )   addContactPoint  ( address ) ;  return this ; }   public Builder addContactPoints  (  InetAddress ...  addresses )  {   Collections . addAll  (  this . rawAddresses , addresses ) ;  return this ; }   public Builder addContactPoints  (   Collection  < InetAddress > addresses )  {    this . rawAddresses . addAll  ( addresses ) ;  return this ; }   public Builder addContactPointsWithPorts  (   Collection  < InetSocketAddress > addresses )  {    this . addresses . addAll  ( addresses ) ;  return this ; }   public Builder withLoadBalancingPolicy  (  LoadBalancingPolicy policy )  {    this . loadBalancingPolicy = policy ;  return this ; }   public Builder withReconnectionPolicy  (  ReconnectionPolicy policy )  {    this . reconnectionPolicy = policy ;  return this ; }   public Builder withRetryPolicy  (  RetryPolicy policy )  {    this . retryPolicy = policy ;  return this ; }   public Builder withAddressTranslater  (  AddressTranslater translater )  {    this . addressTranslater = translater ;  return this ; }   public Builder withTimestampGenerator  (  TimestampGenerator timestampGenerator )  {    this . timestampGenerator = timestampGenerator ;  return this ; }   public Builder withCredentials  (  String username ,  String password )  {    this . authProvider =  new PlainTextAuthProvider  ( username , password ) ;  return this ; }   public Builder withAuthProvider  (  AuthProvider authProvider )  {    this . authProvider = authProvider ;  return this ; }   public Builder withCompression  (   ProtocolOptions . Compression compression )  {    this . compression = compression ;  return this ; }   public Builder withoutMetrics  ( )  {    this . metricsEnabled = false ;  return this ; }   public Builder withSSL  ( )  {    this . sslOptions =  new SSLOptions  ( ) ;  return this ; }   public Builder withSSL  (  SSLOptions sslOptions )  {    this . sslOptions = sslOptions ;  return this ; }   public Builder withInitialListeners  (   Collection  <  Host . StateListener > listeners )  {    this . listeners = listeners ;  return this ; }   public Builder withoutJMXReporting  ( )  {    this . jmxEnabled = false ;  return this ; }   public Builder withPoolingOptions  (  PoolingOptions options )  {    this . poolingOptions = options ;  return this ; }   public Builder withSocketOptions  (  SocketOptions options )  {    this . socketOptions = options ;  return this ; }   public Builder withQueryOptions  (  QueryOptions options )  {    this . queryOptions = options ;  return this ; }    @ Override public Configuration getConfiguration  ( )  {  Policies  policies =  new Policies  (   loadBalancingPolicy == null ?  Policies . defaultLoadBalancingPolicy  ( ) : loadBalancingPolicy ,   reconnectionPolicy == null ?  Policies . defaultReconnectionPolicy  ( ) : reconnectionPolicy ,   retryPolicy == null ?  Policies . defaultRetryPolicy  ( ) : retryPolicy ,   addressTranslater == null ?  Policies . defaultAddressTranslater  ( ) : addressTranslater ,   timestampGenerator == null ?  Policies . defaultTimestampGenerator  ( ) : timestampGenerator ) ;  return  new Configuration  ( policies ,   new ProtocolOptions  ( port , protocolVersion , maxSchemaAgreementWaitSeconds , sslOptions , authProvider ) . setCompression  ( compression ) ,   poolingOptions == null ?  new PoolingOptions  ( ) : poolingOptions ,   socketOptions == null ?  new SocketOptions  ( ) : socketOptions ,  metricsEnabled ?  new MetricsOptions  ( jmxEnabled ) : null ,   queryOptions == null ?  new QueryOptions  ( ) : queryOptions ) ; }    @ Override public  Collection  <  Host . StateListener > getInitialListeners  ( )  {  return   listeners == null ?  Collections .  <  Host . StateListener > emptySet  ( ) : listeners ; }   public Cluster build  ( )  {  return  Cluster . buildFrom  ( this ) ; } }   private static ThreadFactory threadFactory  (  String nameFormat )  {  return    new ThreadFactoryBuilder  ( ) . setNameFormat  ( nameFormat ) . build  ( ) ; }   static  long timeSince  (   long startNanos ,  TimeUnit destUnit )  {  return  destUnit . convert  (   System . nanoTime  ( ) - startNanos ,  TimeUnit . NANOSECONDS ) ; }   private static String generateClusterName  ( )  {  return  "cluster" +  CLUSTER_ID . incrementAndGet  ( ) ; }   private static ListeningExecutorService makeExecutor  (   int threads ,  String name )  {  ThreadPoolExecutor  executor =  new ThreadPoolExecutor  ( threads , threads , DEFAULT_THREAD_KEEP_ALIVE ,  TimeUnit . SECONDS ,  new  LinkedBlockingQueue  < Runnable >  ( ) ,  threadFactory  ( name ) ) ;   executor . allowCoreThreadTimeOut  ( true ) ;  return  MoreExecutors . listeningDecorator  ( executor ) ; }  class Manager  implements   Connection . DefaultResponseHandler  {   final String  clusterName ;   private boolean  isInit ;   private volatile boolean  isFullyInit ;   final  List  < InetSocketAddress >  contactPoints ;   final  Set  < SessionManager >  sessions =  new  CopyOnWriteArraySet  < SessionManager >  ( ) ;   final Metadata  metadata ;   final Configuration  configuration ;   final Metrics  metrics ;   final  Connection . Factory  connectionFactory ;   final ControlConnection  controlConnection ;   final  ConvictionPolicy . Factory  convictionPolicyFactory =  new   ConvictionPolicy . Simple . Factory  ( ) ;   final ScheduledExecutorService  reconnectionExecutor =  Executors . newScheduledThreadPool  ( 2 ,  threadFactory  ( "Reconnection-%d" ) ) ;   final ScheduledExecutorService  scheduledTasksExecutor =  Executors . newScheduledThreadPool  ( 1 ,  threadFactory  ( "Scheduled Tasks-%d" ) ) ;   final ListeningExecutorService  executor ;   final ListeningExecutorService  blockingExecutor ;   final ConnectionReaper  reaper ;   final  AtomicReference  < CloseFuture >  closeFuture =  new  AtomicReference  < CloseFuture >  ( ) ;   final  ConcurrentMap  < MD5Digest , PreparedStatement >  preparedQueries =    new MapMaker  ( ) . weakValues  ( ) . makeMap  ( ) ;   final  Set  <  Host . StateListener >  listeners ;   final  Set  < LatencyTracker >  trackers =  new  CopyOnWriteArraySet  < LatencyTracker >  ( ) ;   private Manager  (  String clusterName ,   List  < InetSocketAddress > contactPoints ,  Configuration configuration ,   Collection  <  Host . StateListener > listeners )  {   logger . debug  (  "Starting new cluster with contact points " + contactPoints ) ;    this . clusterName =   clusterName == null ?  generateClusterName  ( ) : clusterName ;    this . configuration = configuration ;    this . configuration . register  ( this ) ;    this . executor =  makeExecutor  ( NON_BLOCKING_EXECUTOR_SIZE , "Cassandra Java Driver worker-%d" ) ;    this . blockingExecutor =  makeExecutor  ( 2 , "Cassandra Java Driver blocking tasks worker-%d" ) ;    this . reaper =  new ConnectionReaper  ( ) ;    this . metadata =  new Metadata  ( this ) ;    this . contactPoints = contactPoints ;    this . connectionFactory =  new  Connection . Factory  ( this , configuration ) ;    this . controlConnection =  new ControlConnection  ( this ) ;    this . metrics =    configuration . getMetricsOptions  ( ) == null ? null :  new Metrics  ( this ) ;    this . listeners =  new  CopyOnWriteArraySet  <  Host . StateListener >  ( listeners ) ; }   synchronized void init  ( )  {  if  (  isClosed  ( ) )  throw  new IllegalStateException  ( "Can't use this Cluster instance because it was previously closed" ) ;  if  ( isInit )  return ;   isInit = true ;  for ( InetSocketAddress address : contactPoints )  {   metadata . add  ( address ) ; }   Set  < Host >  contactPointHosts =  Sets . newHashSet  (  metadata . allHosts  ( ) ) ;  try  {  try  {   controlConnection . connect  ( ) ; }  catch (   UnsupportedProtocolVersionException e )  {   logger . debug  ( "Cannot connect with protocol {}, trying {}" ,  e . unsupportedVersion ,  e . serverVersion ) ;    connectionFactory . protocolVersion =  e . serverVersion ;  try  {   controlConnection . connect  ( ) ; }  catch (   UnsupportedProtocolVersionException e1 )  {  throw  new DriverInternalError  ( "Cannot connect to node with its own version, this makes no sense" , e ) ; } }   Set  < Host >  downContactPointHosts =  Sets . newHashSet  ( ) ;  for ( Host host : contactPointHosts )  if  (   host . state ==   Host . State . DOWN )   downContactPointHosts . add  ( host ) ;   contactPointHosts . removeAll  ( downContactPointHosts ) ;    loadBalancingPolicy  ( ) . init  (  Cluster . this , contactPointHosts ) ;  for ( Host host : downContactPointHosts )  {    loadBalancingPolicy  ( ) . onDown  ( host ) ;  for (  Host . StateListener listener : listeners )   listener . onDown  ( host ) ; }  for ( Host host :  metadata . allHosts  ( ) )  {  if  (   host . state ==   Host . State . DOWN )  continue ;   logger . info  ( "New Cassandra host {} added" , host ) ;  if  (  !   connectionFactory . protocolVersion . isSupportedBy  ( host ) )  {   logUnsupportedVersionProtocol  ( host ,  connectionFactory . protocolVersion ) ;  return ; }  if  (  !  contactPointHosts . contains  ( host ) )    loadBalancingPolicy  ( ) . onAdd  ( host ) ;   host . setUp  ( ) ;  for (  Host . StateListener listener : listeners )   listener . onAdd  ( host ) ; }   isFullyInit = true ; }  catch (   NoHostAvailableException e )  {   close  ( ) ;  throw e ; } }  ProtocolVersion protocolVersion  ( )  {  return  connectionFactory . protocolVersion ; }  Cluster getCluster  ( )  {  return  Cluster . this ; }  LoadBalancingPolicy loadBalancingPolicy  ( )  {  return   configuration . getPolicies  ( ) . getLoadBalancingPolicy  ( ) ; }  ReconnectionPolicy reconnectionPolicy  ( )  {  return   configuration . getPolicies  ( ) . getReconnectionPolicy  ( ) ; }  InetSocketAddress translateAddress  (  InetAddress address )  {  InetSocketAddress  sa =  new InetSocketAddress  ( address ,  connectionFactory . getPort  ( ) ) ;  InetSocketAddress  translated =    configuration . getPolicies  ( ) . getAddressTranslater  ( ) . translate  ( sa ) ;  return   translated == null ? sa : translated ; }   private Session newSession  ( )  {  SessionManager  session =  new SessionManager  (  Cluster . this ) ;   sessions . add  ( session ) ;  return session ; }  boolean removeSession  (  Session session )  {  return  sessions . remove  ( session ) ; }  void reportLatency  (  Host host ,   long latencyNanos )  {  for ( LatencyTracker tracker : trackers )  {   tracker . update  ( host , latencyNanos ) ; } }  boolean isClosed  ( )  {  return   closeFuture . get  ( ) != null ; }   private CloseFuture close  ( )  {  CloseFuture  future =  closeFuture . get  ( ) ;  if  (  future != null )  return future ;   logger . debug  ( "Shutting down" ) ;   shutdownNow  ( reconnectionExecutor ) ;   shutdownNow  ( scheduledTasksExecutor ) ;   shutdownNow  ( blockingExecutor ) ;   executor . shutdown  ( ) ;  if  (  metrics != null )   metrics . shutdown  ( ) ;  LoadBalancingPolicy  loadBalancingPolicy =  loadBalancingPolicy  ( ) ;  if  (  loadBalancingPolicy instanceof CloseableLoadBalancingPolicy )    (  ( CloseableLoadBalancingPolicy ) loadBalancingPolicy ) . close  ( ) ;  AddressTranslater  translater =   configuration . getPolicies  ( ) . getAddressTranslater  ( ) ;  if  (  translater instanceof CloseableAddressTranslater )    (  ( CloseableAddressTranslater ) translater ) . close  ( ) ;   List  < CloseFuture >  futures =  new  ArrayList  < CloseFuture >  (   sessions . size  ( ) + 1 ) ;   futures . add  (  controlConnection . closeAsync  ( ) ) ;  for ( Session session : sessions )   futures . add  (  session . closeAsync  ( ) ) ;   future =  new ClusterCloseFuture  ( futures ) ;  return   closeFuture . compareAndSet  ( null , future ) ? future :  closeFuture . get  ( ) ; }   private void shutdownNow  (  ExecutorService executor )  {   List  < Runnable >  pendingTasks =  executor . shutdownNow  ( ) ;  for ( Runnable pendingTask : pendingTasks )  {  if  (  pendingTask instanceof  FutureTask  <  ? > )    (  (  FutureTask  <  ? > ) pendingTask ) . cancel  ( false ) ; } }  void logUnsupportedVersionProtocol  (  Host host ,  ProtocolVersion version )  {   logger . warn  (   "Detected added or restarted Cassandra host {} but ignoring it since it does not support the version {} of the native " + "protocol which is currently in use. If you want to force the use of a particular version of the native protocol, use " + "Cluster.Builder#usingProtocolVersion() when creating the Cluster instance." , host , version ) ; }  void logClusterNameMismatch  (  Host host ,  String expectedClusterName ,  String actualClusterName )  {   logger . warn  (  "Detected added or restarted Cassandra host {} but ignoring it since its cluster name '{}' does not match the one " + "currently known ({})" , host , actualClusterName , expectedClusterName ) ; }   public  ListenableFuture  <  ? > triggerOnUp  (   final Host host )  {  return  executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   onUp  ( host ) ; } } ) ; }   private void onUp  (   final Host host )  throws InterruptedException , ExecutionException  {   onUp  ( host , blockingExecutor ) ; }   private void onUp  (   final Host host ,  ListeningExecutorService poolCreationExecutor )  throws InterruptedException , ExecutionException  {   logger . debug  ( "Host {} is UP" , host ) ;  if  (  isClosed  ( ) )  return ;  if  (  !   connectionFactory . protocolVersion . isSupportedBy  ( host ) )  {   logUnsupportedVersionProtocol  ( host ,  connectionFactory . protocolVersion ) ;  return ; }  boolean  locked =   host . notificationsLock . tryLock  ( NOTIF_LOCK_TIMEOUT_SECONDS ,  TimeUnit . SECONDS ) ;  if  (  ! locked )  {   logger . warn  ( "Could not acquire notifications lock within {} seconds, ignoring UP notification for {}" , NOTIF_LOCK_TIMEOUT_SECONDS , host ) ;  return ; }  try  {  if  (   host . state ==   Host . State . UP )  return ;   Future  <  ? >  scheduledAttempt =   host . reconnectionAttempt . getAndSet  ( null ) ;  if  (  scheduledAttempt != null )  {   logger . debug  ( "Cancelling reconnection attempt since node is UP" ) ;   scheduledAttempt . cancel  ( false ) ; }  try  {   prepareAllQueries  ( host ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   UnsupportedProtocolVersionException e )  {   logUnsupportedVersionProtocol  ( host ,  e . unsupportedVersion ) ;  return ; }  catch (   ClusterNameMismatchException e )  {   logClusterNameMismatch  ( host ,  e . expectedClusterName ,  e . actualClusterName ) ;  return ; }  for ( SessionManager s : sessions )   s . removePool  ( host ) ;    loadBalancingPolicy  ( ) . onUp  ( host ) ;   controlConnection . onUp  ( host ) ;   logger . trace  ( "Adding/renewing host pools for newly UP host {}" , host ) ;   List  <  ListenableFuture  < Boolean > >  futures =  new  ArrayList  <  ListenableFuture  < Boolean > >  (  sessions . size  ( ) ) ;  for ( SessionManager s : sessions )   futures . add  (  s . forceRenewPool  ( host , poolCreationExecutor ) ) ;   ListenableFuture  <  List  < Boolean > >  f =  Futures . allAsList  ( futures ) ;   Futures . addCallback  ( f ,  new  FutureCallback  <  List  < Boolean > >  ( )  {   public void onSuccess  (   List  < Boolean > poolCreationResults )  {  if  (  Iterables . any  ( poolCreationResults ,  Predicates . equalTo  ( false ) ) )  {   logger . debug  ( "Connection pool cannot be created, not marking {} UP" , host ) ;  return ; }   host . setUp  ( ) ;  for (  Host . StateListener listener : listeners )   listener . onUp  ( host ) ; }   public void onFailure  (  Throwable t )  {  if  (  !  (  t instanceof InterruptedException ) )   logger . error  ( "Unexpected error while marking node UP: while this shouldn't happen, this shouldn't be critical" , t ) ; } } ) ;   f . get  ( ) ;  for ( SessionManager s : sessions )   s . updateCreatedPools  ( blockingExecutor ) ; }  finally  {    host . notificationsLock . unlock  ( ) ; } }   public  ListenableFuture  <  ? > triggerOnDown  (   final Host host )  {  return  triggerOnDown  ( host , false ) ; }   public  ListenableFuture  <  ? > triggerOnDown  (   final Host host ,   final boolean isHostAddition )  {  return  executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   onDown  ( host , isHostAddition , false ) ; } } ) ; }   public void onSuspected  (   final Host host )  {   logger . debug  ( "Host {} is Suspected" , host ) ;  if  (  isClosed  ( ) )  return ;  if  (    loadBalancingPolicy  ( ) . distance  ( host ) ==  HostDistance . IGNORED )  {   triggerOnDown  ( host ) ;  return ; }  synchronized  ( host )  {  if  (   !  host . setSuspected  ( ) ||    host . reconnectionAttempt . get  ( ) != null )  return ;    host . initialReconnectionAttempt . set  (  executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {  boolean  success ;  try  {    connectionFactory . open  ( host ) . closeAsync  ( ) ;   onUp  ( host ,  MoreExecutors . sameThreadExecutor  ( ) ) ;   success =   host . state ==   Host . State . UP ; }  catch (   Exception e )  {   success = false ; }  if  (  ! success )   onDown  ( host , false , true ) ; } } ) ) ;    loadBalancingPolicy  ( ) . onSuspected  ( host ) ; }   controlConnection . onSuspected  ( host ) ;  for ( SessionManager s : sessions )   s . onSuspected  ( host ) ;  for (  Host . StateListener listener : listeners )   listener . onSuspected  ( host ) ; }   private void onDown  (   final Host host ,   final boolean isHostAddition ,   final boolean isSuspectedVerification )  throws InterruptedException , ExecutionException  {   logger . debug  ( "Host {} is DOWN" , host ) ;  if  (  isClosed  ( ) )  return ;  boolean  locked =   host . notificationsLock . tryLock  ( NOTIF_LOCK_TIMEOUT_SECONDS ,  TimeUnit . SECONDS ) ;  if  (  ! locked )  {   logger . warn  ( "Could not acquire notifications lock within {} seconds, ignoring DOWN notification for {}" , NOTIF_LOCK_TIMEOUT_SECONDS , host ) ;  return ; }  try  {  if  (   ! isSuspectedVerification &&   host . state ==   Host . State . SUSPECT )  {   logger . debug  ( "Aborting onDown because a reconnection is running on SUSPECT host {}" , host ) ;  return ; }  if  (    host . reconnectionAttempt . get  ( ) != null )  {   logger . debug  ( "Aborting onDown because a reconnection is running on DOWN host {}" , host ) ;  return ; }  HostDistance  distance =   loadBalancingPolicy  ( ) . distance  ( host ) ;  boolean  wasUp =  host . isUp  ( ) ;   host . setDown  ( ) ;    loadBalancingPolicy  ( ) . onDown  ( host ) ;   controlConnection . onDown  ( host ) ;  for ( SessionManager s : sessions )   s . onDown  ( host ) ;  if  ( wasUp )  {  for (  Host . StateListener listener : listeners )   listener . onDown  ( host ) ; }  if  (  distance ==  HostDistance . IGNORED )  return ;   logger . debug  ( "{} is down, scheduling connection retries" , host ) ;   startPeriodicReconnectionAttempt  ( host , isHostAddition ) ; }  finally  {    host . notificationsLock . unlock  ( ) ; } }  void startPeriodicReconnectionAttempt  (   final Host host ,   final boolean isHostAddition )  {    new AbstractReconnectionHandler  ( reconnectionExecutor ,   reconnectionPolicy  ( ) . newSchedule  ( ) ,  host . reconnectionAttempt )  {   protected Connection tryReconnect  ( )  throws ConnectionException , InterruptedException , UnsupportedProtocolVersionException , ClusterNameMismatchException  {  return  connectionFactory . open  ( host ) ; }   protected void onReconnection  (  Connection connection )  {   connection . closeAsync  ( ) ;  if  (  controlConnection . refreshNodeInfo  ( host ) )  {   logger . debug  ( "Successful reconnection to {}, setting host UP" , host ) ;  try  {  if  ( isHostAddition )   onAdd  ( host ) ; else   onUp  ( host ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   Exception e )  {   logger . error  ( "Unexpected error while setting node up" , e ) ; } } else  {   logger . debug  ( "Not enough info for {}, ignoring host" , host ) ; } }   protected boolean onConnectionException  (  ConnectionException e ,   long nextDelayMs )  {  if  (  logger . isDebugEnabled  ( ) )   logger . debug  ( "Failed reconnection to {} ({}), scheduling retry in {} milliseconds" , host ,  e . getMessage  ( ) , nextDelayMs ) ;  return true ; }   protected boolean onUnknownException  (  Exception e ,   long nextDelayMs )  {   logger . error  (  String . format  ( "Unknown error during reconnection to %s, scheduling retry in %d milliseconds" , host , nextDelayMs ) , e ) ;  return true ; }   protected boolean onAuthenticationException  (  AuthenticationException e ,   long nextDelayMs )  {   logger . error  (  String . format  ( "Authentication error during reconnection to %s, scheduling retry in %d milliseconds" , host , nextDelayMs ) , e ) ;  return true ; } } . start  ( ) ; }  void startSingleReconnectionAttempt  (   final Host host )  {  if  (   isClosed  ( ) ||  host . isUp  ( ) )  return ;   logger . debug  ( "Scheduling one-time reconnection to {}" , host ) ;    new AbstractReconnectionHandler  ( reconnectionExecutor ,   reconnectionPolicy  ( ) . newSchedule  ( ) ,  host . reconnectionAttempt , 0 )  {   protected Connection tryReconnect  ( )  throws ConnectionException , InterruptedException , UnsupportedProtocolVersionException , ClusterNameMismatchException  {  return  connectionFactory . open  ( host ) ; }   protected void onReconnection  (  Connection connection )  {   connection . closeAsync  ( ) ;  if  (  controlConnection . refreshNodeInfo  ( host ) )  {   logger . debug  ( "Successful reconnection to {}, setting host UP" , host ) ;  try  {   onUp  ( host ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   Exception e )  {   logger . error  ( "Unexpected error while setting node up" , e ) ; } } else  {   logger . debug  ( "Not enough info for {}, ignoring host" , host ) ; } }   protected boolean onConnectionException  (  ConnectionException e ,   long nextDelayMs )  {  if  (  logger . isDebugEnabled  ( ) )   logger . debug  ( "Failed one-time reconnection to {} ({})" , host ,  e . getMessage  ( ) ) ;  return false ; }   protected boolean onUnknownException  (  Exception e ,   long nextDelayMs )  {   logger . error  (  String . format  ( "Unknown error during one-time reconnection to %s" , host ) , e ) ;  return false ; }   protected boolean onAuthenticationException  (  AuthenticationException e ,   long nextDelayMs )  {   logger . error  (  String . format  ( "Authentication error during one-time reconnection to %s" , host ) , e ) ;  return false ; } } . start  ( ) ; }   public  ListenableFuture  <  ? > triggerOnAdd  (   final Host host )  {  return  executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   onAdd  ( host ) ; } } ) ; }   private void onAdd  (   final Host host )  throws InterruptedException , ExecutionException  {  if  (  isClosed  ( ) )  return ;   logger . info  ( "New Cassandra host {} added" , host ) ;  if  (  !   connectionFactory . protocolVersion . isSupportedBy  ( host ) )  {   logUnsupportedVersionProtocol  ( host ,  connectionFactory . protocolVersion ) ;  return ; }  boolean  locked =   host . notificationsLock . tryLock  ( NOTIF_LOCK_TIMEOUT_SECONDS ,  TimeUnit . SECONDS ) ;  if  (  ! locked )  {   logger . warn  ( "Could not acquire notifications lock within {} seconds, ignoring ADD notification for {}" , NOTIF_LOCK_TIMEOUT_SECONDS , host ) ;  return ; }  try  {    loadBalancingPolicy  ( ) . onAdd  ( host ) ;  if  (    loadBalancingPolicy  ( ) . distance  ( host ) ==  HostDistance . IGNORED )  {   host . setUp  ( ) ;  for (  Host . StateListener listener : listeners )   listener . onAdd  ( host ) ;  return ; }  try  {   prepareAllQueries  ( host ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   UnsupportedProtocolVersionException e )  {   logUnsupportedVersionProtocol  ( host ,  e . unsupportedVersion ) ;  return ; }  catch (   ClusterNameMismatchException e )  {   logClusterNameMismatch  ( host ,  e . expectedClusterName ,  e . actualClusterName ) ;  return ; }   controlConnection . onAdd  ( host ) ;   List  <  ListenableFuture  < Boolean > >  futures =  new  ArrayList  <  ListenableFuture  < Boolean > >  (  sessions . size  ( ) ) ;  for ( SessionManager s : sessions )   futures . add  (  s . maybeAddPool  ( host , blockingExecutor ) ) ;   ListenableFuture  <  List  < Boolean > >  f =  Futures . allAsList  ( futures ) ;   Futures . addCallback  ( f ,  new  FutureCallback  <  List  < Boolean > >  ( )  {   public void onSuccess  (   List  < Boolean > poolCreationResults )  {  if  (  Iterables . any  ( poolCreationResults ,  Predicates . equalTo  ( false ) ) )  {   logger . debug  ( "Connection pool cannot be created, not marking {} UP" , host ) ;  return ; }   host . setUp  ( ) ;  for (  Host . StateListener listener : listeners )   listener . onAdd  ( host ) ; }   public void onFailure  (  Throwable t )  {  if  (  !  (  t instanceof InterruptedException ) )   logger . error  ( "Unexpected error while adding node: while this shouldn't happen, this shouldn't be critical" , t ) ; } } ) ;   f . get  ( ) ;  for ( SessionManager s : sessions )   s . updateCreatedPools  ( blockingExecutor ) ; }  finally  {    host . notificationsLock . unlock  ( ) ; } }   public  ListenableFuture  <  ? > triggerOnRemove  (   final Host host )  {  return  executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   onRemove  ( host ) ; } } ) ; }   private void onRemove  (  Host host )  throws InterruptedException , ExecutionException  {  if  (  isClosed  ( ) )  return ;  boolean  locked =   host . notificationsLock . tryLock  ( NOTIF_LOCK_TIMEOUT_SECONDS ,  TimeUnit . SECONDS ) ;  if  (  ! locked )  {   logger . warn  ( "Could not acquire notifications lock within {} seconds, ignoring REMOVE notification for {}" , NOTIF_LOCK_TIMEOUT_SECONDS , host ) ;  return ; }  try  {   host . setDown  ( ) ;   logger . debug  ( "Removing host {}" , host ) ;    loadBalancingPolicy  ( ) . onRemove  ( host ) ;   controlConnection . onRemove  ( host ) ;  for ( SessionManager s : sessions )   s . onRemove  ( host ) ;  for (  Host . StateListener listener : listeners )   listener . onRemove  ( host ) ; }  finally  {    host . notificationsLock . unlock  ( ) ; } }   public boolean signalConnectionFailure  (  Host host ,  ConnectionException exception ,  boolean isHostAddition ,  boolean markSuspected )  {  if  (   ! isFullyInit ||  isClosed  ( ) )  return true ;  boolean  isDown =  host . signalConnectionFailure  ( exception ) ;  if  ( isDown )  {  if  (  isHostAddition ||  ! markSuspected )  {   triggerOnDown  ( host , isHostAddition ) ; } else  {   onSuspected  ( host ) ; } }  return isDown ; }   public void removeHost  (  Host host ,  boolean isInitialConnection )  {  if  (  host == null )  return ;  if  (  metadata . remove  ( host ) )  {  if  ( isInitialConnection )  {   logger . warn  ( "You listed {} in your contact points, but it could not be reached at startup" , host ) ; } else  {   logger . info  ( "Cassandra host {} removed" , host ) ;   triggerOnRemove  ( host ) ; } } }   public void ensurePoolsSizing  ( )  {  if  (    protocolVersion  ( ) . compareTo  (  ProtocolVersion . V3 ) >= 0 )  return ;  for ( SessionManager session : sessions )  {  for ( HostConnectionPool pool :   session . pools . values  ( ) )   pool . ensureCoreConnections  ( ) ; } }   public PreparedStatement addPrepared  (  PreparedStatement stmt )  {  PreparedStatement  previous =  preparedQueries . putIfAbsent  (   stmt . getPreparedId  ( ) . id , stmt ) ;  if  (  previous != null )  {   logger . warn  (  "Re-preparing already prepared query {}. Please note that preparing the same query more than once is " + "generally an anti-pattern and will likely affect performance. Consider preparing the statement only once." ,  stmt . getQueryString  ( ) ) ;  return previous ; }  return stmt ; }   private void prepareAllQueries  (  Host host )  throws InterruptedException , UnsupportedProtocolVersionException , ClusterNameMismatchException  {  if  (  preparedQueries . isEmpty  ( ) )  return ;   logger . debug  ( "Preparing {} prepared queries on newly up node {}" ,  preparedQueries . size  ( ) , host ) ;  try  {  Connection  connection =  connectionFactory . open  ( host ) ;  try  {  try  {   ControlConnection . waitForSchemaAgreement  ( connection , this ) ; }  catch (   ExecutionException e )  { }   SetMultimap  < String , String >  perKeyspace =  HashMultimap . create  ( ) ;  for ( PreparedStatement ps :  preparedQueries . values  ( ) )  {  String  keyspace =    ps . getQueryKeyspace  ( ) == null ? "" :  ps . getQueryKeyspace  ( ) ;   perKeyspace . put  ( keyspace ,  ps . getQueryString  ( ) ) ; }  for ( String keyspace :  perKeyspace . keySet  ( ) )  {  if  (  !  keyspace . isEmpty  ( ) )   connection . setKeyspace  ( keyspace ) ;    List <  Connection . Future >  futures =  new  ArrayList  <  Connection . Future >  (  preparedQueries . size  ( ) ) ;  for ( String query :  perKeyspace . get  ( keyspace ) )  {   futures . add  (  connection . write  (  new  Requests . Prepare  ( query ) ) ) ; }  for (  Connection . Future future : futures )  {  try  {   future . get  ( ) ; }  catch (   ExecutionException e )  {   logger . debug  ( "Unexpected error while preparing queries on new/newly up host" , e ) ; } } } }  finally  {   connection . closeAsync  ( ) ; } }  catch (   ConnectionException e )  { }  catch (   AuthenticationException e )  { }  catch (   BusyConnectionException e )  { } }   public void submitSchemaRefresh  (   final String keyspace ,   final String table ,   final String udt )  {   logger . trace  ( "Submitting schema refresh" ) ;   executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {   controlConnection . refreshSchema  ( keyspace , table , udt ) ; } } ) ; }   public void refreshSchemaAndSignal  (   final Connection connection ,   final DefaultResultSetFuture future ,   final ResultSet rs ,   final String keyspace ,   final String table ,   final String udt )  {  if  (  logger . isDebugEnabled  ( ) )   logger . debug  ( "Refreshing schema for {}{}" ,   keyspace == null ? "" : keyspace ,   table == null ? "" :  '.' + table ) ;   executor . submit  (  new Runnable  ( )  {    @ Override public void run  ( )  {  try  {  if  (  !  ControlConnection . waitForSchemaAgreement  ( connection ,   Cluster . Manager . this ) )   logger . warn  ( "No schema agreement from live replicas after {} s. The schema may not be up to date on some nodes." ,   configuration . getProtocolOptions  ( ) . getMaxSchemaAgreementWaitSeconds  ( ) ) ;   ControlConnection . refreshSchema  ( connection , keyspace , table , udt ,   Cluster . Manager . this , false ) ; }  catch (   Exception e )  {   logger . error  ( "Error during schema refresh ({}). The schema from Cluster.getMetadata() might appear stale. Asynchronously submitting job to fix." ,  e . getMessage  ( ) ) ;   submitSchemaRefresh  ( keyspace , table , udt ) ; }  finally  {   future . setResult  ( rs ) ; } } } ) ; }    @ Override public void handle  (   Message . Response response )  {  if  (  !  (  response instanceof  Responses . Event ) )  {   logger . error  ( "Received an unexpected message from the server: {}" , response ) ;  return ; }   final ProtocolEvent  event =   (  (  Responses . Event ) response ) . event ;   logger . debug  ( "Received event {}, scheduling delivery" , response ) ;  switch  (  event . type )  {   case TOPOLOGY_CHANGE :   ProtocolEvent . TopologyChange  tpc =  (  ProtocolEvent . TopologyChange ) event ;  InetSocketAddress  tpAddr =  translateAddress  (   tpc . node . getAddress  ( ) ) ;  switch  (  tpc . change )  {   case NEW_NODE :   final Host  newHost =  metadata . add  ( tpAddr ) ;  if  (  newHost != null )  {   scheduledTasksExecutor . schedule  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {  if  (  controlConnection . refreshNodeInfo  ( newHost ) )  {   onAdd  ( newHost ) ; } else  {   logger . debug  ( "Not enough info for {}, ignoring host" , newHost ) ; } } } , NEW_NODE_DELAY_SECONDS ,  TimeUnit . SECONDS ) ; }  break ;   case REMOVED_NODE :   removeHost  (  metadata . getHost  ( tpAddr ) , false ) ;  break ;   case MOVED_NODE :   executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  {   controlConnection . refreshNodeListAndTokenMap  ( ) ; } } ) ;  break ; }  break ;   case STATUS_CHANGE :   ProtocolEvent . StatusChange  stc =  (  ProtocolEvent . StatusChange ) event ;  InetSocketAddress  stAddr =  translateAddress  (   stc . node . getAddress  ( ) ) ;  switch  (  stc . status )  {   case UP :   final Host  hostUp =  metadata . getHost  ( stAddr ) ;  if  (  hostUp == null )  {   final Host  h =  metadata . add  ( stAddr ) ;  if  (  h == null )  return ;   scheduledTasksExecutor . schedule  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {  if  (  controlConnection . refreshNodeInfo  ( h ) )  {   onAdd  ( h ) ; } else  {   logger . debug  ( "Not enough info for {}, ignoring host" , h ) ; } } } , NEW_NODE_DELAY_SECONDS ,  TimeUnit . SECONDS ) ; } else  {   executor . submit  (  new ExceptionCatchingRunnable  ( )  {    @ Override public void runMayThrow  ( )  throws InterruptedException , ExecutionException  {  if  (  controlConnection . refreshNodeInfo  ( hostUp ) )  {   onUp  ( hostUp ) ; } else  {   logger . debug  ( "Not enough info for {}, ignoring host" , hostUp ) ; } } } ) ; }  break ;   case DOWN :  Host  hostDown =  metadata . getHost  ( stAddr ) ;  if  (  hostDown != null )   triggerOnDown  ( hostDown ) ;  break ; }  break ;   case SCHEMA_CHANGE :   ProtocolEvent . SchemaChange  scc =  (  ProtocolEvent . SchemaChange ) event ;  switch  (  scc . change )  {   case CREATED :  switch  (  scc . target )  {   case KEYSPACE :   submitSchemaRefresh  (  scc . keyspace , null , null ) ;  break ;   case TABLE :   submitSchemaRefresh  (  scc . keyspace ,  scc . name , null ) ;  break ;   case TYPE :   submitSchemaRefresh  (  scc . keyspace , null ,  scc . name ) ;  break ; }  break ;   case DROPPED : 
<<<<<<<
 KeyspaceMetadata  keyspace ;
=======
 if  (   scc . table . isEmpty  ( ) )    manager . metadata . removeKeyspace  (  scc . keyspace ) ; else  {  KeyspaceMetadata  keyspace =   manager . metadata . getKeyspaceInternal  (  scc . keyspace ) ;  if  (  keyspace == null )   logger . warn  ( "Received a DROPPED notification for {}.{}, but this keyspace is unknown in our metadata" ,  scc . keyspace ,  scc . table ) ; else   keyspace . removeTable  (  scc . table ) ; }
>>>>>>>
  switch  (  scc . target )  {   case KEYSPACE :    manager . metadata . removeKeyspace  (  scc . keyspace ) ;  break ;   case TABLE :   keyspace =   manager . metadata . getKeyspace  (  scc . keyspace ) ;  if  (  keyspace == null )   logger . warn  ( "Received a DROPPED notification for table {}.{}, but this keyspace is unknown in our metadata" ,  scc . keyspace ,  scc . name ) ; else   keyspace . removeTable  (  scc . name ) ;  break ;   case TYPE :   keyspace =   manager . metadata . getKeyspace  (  scc . keyspace ) ;  if  (  keyspace == null )   logger . warn  ( "Received a DROPPED notification for UDT {}.{}, but this keyspace is unknown in our metadata" ,  scc . keyspace ,  scc . name ) ; else   keyspace . removeUserType  (  scc . name ) ;  break ; }  break ;   case UPDATED :  switch  (  scc . target )  {   case KEYSPACE :   submitSchemaRefresh  (  scc . keyspace , null , null ) ;  break ;   case TABLE :   submitSchemaRefresh  (  scc . keyspace ,  scc . name , null ) ;  break ;   case TYPE :   submitSchemaRefresh  (  scc . keyspace , null ,  scc . name ) ;  break ; }  break ; }  break ; } }  void refreshConnectedHosts  ( )  {  Host  ccHost =  controlConnection . connectedHost  ( ) ;  if  (   ccHost == null ||    loadBalancingPolicy  ( ) . distance  ( ccHost ) !=  HostDistance . LOCAL )   controlConnection . reconnect  ( ) ;  for ( SessionManager s : sessions )   s . updateCreatedPools  ( executor ) ; }  void refreshConnectedHost  (  Host host )  {  Host  ccHost =  controlConnection . connectedHost  ( ) ;  if  (   ccHost == null ||   ccHost . equals  ( host ) &&    loadBalancingPolicy  ( ) . distance  ( ccHost ) !=  HostDistance . LOCAL )   controlConnection . reconnect  ( ) ;  for ( SessionManager s : sessions )   s . updateCreatedPools  ( host , executor ) ; }   private class ClusterCloseFuture  extends  CloseFuture . Forwarding  {  ClusterCloseFuture  (   List  < CloseFuture > futures )  {  super  ( futures ) ; }    @ Override public CloseFuture force  ( )  {   shutdownNow  ( executor ) ;  return  super . force  ( ) ; }    @ Override protected void onFuturesDone  ( )  {    (  new Thread  ( "Shutdown-checker" )  {   public void run  ( )  {  try  {   reconnectionExecutor . awaitTermination  (  Long . MAX_VALUE ,  TimeUnit . SECONDS ) ;   scheduledTasksExecutor . awaitTermination  (  Long . MAX_VALUE ,  TimeUnit . SECONDS ) ;   executor . awaitTermination  (  Long . MAX_VALUE ,  TimeUnit . SECONDS ) ;   blockingExecutor . awaitTermination  (  Long . MAX_VALUE ,  TimeUnit . SECONDS ) ;   connectionFactory . shutdown  ( ) ;   reaper . shutdown  ( ) ;   set  ( null ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ;   setException  ( e ) ; } } } ) . start  ( ) ; } } }   static class ConnectionReaper  {   private static final  int  INTERVAL_MS = 15000 ;   private final ScheduledExecutorService  executor =  Executors . newScheduledThreadPool  ( 1 ,  threadFactory  ( "Reaper-%d" ) ) ;   private final  Map  < Connection , Long >  connections =  new  ConcurrentHashMap  < Connection , Long >  ( ) ;   private volatile boolean  shutdown ;   private final Runnable  reaperTask =  new Runnable  ( )  {    @ Override public void run  ( )  {   long  now =  System . currentTimeMillis  ( ) ;   Iterator  <  Entry  < Connection , Long > >  iterator =   connections . entrySet  ( ) . iterator  ( ) ;  while  (  iterator . hasNext  ( ) )  {   Entry  < Connection , Long >  entry =  iterator . next  ( ) ;  Connection  connection =  entry . getKey  ( ) ;  Long  terminateTime =  entry . getValue  ( ) ;  if  (  terminateTime <= now )  {  boolean  terminated =  connection . tryTerminate  ( true ) ;  if  ( terminated )   iterator . remove  ( ) ; } } } } ;  ConnectionReaper  ( )  {   executor . scheduleWithFixedDelay  ( reaperTask , INTERVAL_MS , INTERVAL_MS ,  TimeUnit . MILLISECONDS ) ; }  void register  (  Connection connection ,   long terminateTime )  {  if  ( shutdown )  {   logger . warn  ( "Connection registered after reaper shutdown: {}" , connection ) ;   connection . tryTerminate  ( true ) ; } else  {   connections . put  ( connection , terminateTime ) ; } }  void shutdown  ( )  {   shutdown = true ;   executor . shutdownNow  ( ) ;   reaperTask . run  ( ) ; } } }