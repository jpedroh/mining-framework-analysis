  package     com . datastax . driver . core . querybuilder ;   import   java . nio . ByteBuffer ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . List ;  import     com . datastax . driver . core . RegularStatement ;   public class Batch  extends BuiltStatement  {   private final  List  < RegularStatement >  statements ;   private final boolean  logged ;   private final Options  usings ;   private ByteBuffer  routingKey ;  Batch  (   RegularStatement  [ ] statements ,  boolean logged )  {  super  (  ( String ) null ) ;    this . statements =    statements . length == 0 ?  new  ArrayList  < RegularStatement >  ( ) :  new  ArrayList  < RegularStatement >  (  statements . length ) ;    this . logged = logged ;    this . usings =  new Options  ( this ) ;  for (   int  i = 0 ;  i <  statements . length ;  i ++ )   add  (  statements [ i ] ) ; }    @ Override StringBuilder buildQueryString  (   List  < Object > variables )  {  StringBuilder  builder =  new StringBuilder  ( ) ;   builder . append  (   isCounterOp  ( ) ? "BEGIN COUNTER BATCH" :  (  logged ? "BEGIN BATCH" : "BEGIN UNLOGGED BATCH" ) ) ;  if  (  !   usings . usings . isEmpty  ( ) )  {   builder . append  ( " USING " ) ;   Utils . joinAndAppend  ( builder , " AND " ,  usings . usings , variables ) ; }   builder . append  ( ' ' ) ;  for (   int  i = 0 ;  i <  statements . size  ( ) ;  i ++ )  {  RegularStatement  stmt =  statements . get  ( i ) ;  if  (  stmt instanceof BuiltStatement )  {  BuiltStatement  bst =  ( BuiltStatement ) stmt ;   builder . append  (  maybeAddSemicolon  (  bst . buildQueryString  ( variables ) ) ) ; } else  {  String  str =  stmt . getQueryString  ( ) ;   builder . append  ( str ) ;  if  (  !   str . trim  ( ) . endsWith  ( ";" ) )   builder . append  ( ';' ) ;  if  (   (  stmt instanceof BuiltStatement ) &&  variables != null )  {   List  < Object >  vals =   (  ( BuiltStatement ) stmt ) . getRawValues  ( ) ;  if  (  vals != null )   variables . addAll  ( vals ) ; } } }   builder . append  ( "APPLY BATCH;" ) ;  return builder ; }   public Batch add  (  RegularStatement statement )  {  boolean  isCounterOp =   statement instanceof BuiltStatement &&   (  ( BuiltStatement ) statement ) . isCounterOp  ( ) ;  if  (   this . isCounterOp == null )   setCounterOp  ( isCounterOp ) ; else  if  (   isCounterOp  ( ) != isCounterOp )  throw  new IllegalArgumentException  ( "Cannot mix counter operations and non-counter operations in a batch statement" ) ;    this . statements . add  ( statement ) ;  if  (  statement instanceof BuiltStatement )  {    this . hasBindMarkers |=   (  ( BuiltStatement ) statement ) . hasBindMarkers ; } else  {    this . hasBindMarkers = true ;  if  (   statement . getValues  ( ) != null )    this . nonBuiltStatementValues +=   statement . getValues  ( ) . length ; }   checkForBindMarkers  ( null ) ;  if  (   routingKey == null &&   statement . getRoutingKey  ( ) != null )   routingKey =  statement . getRoutingKey  ( ) ;  return this ; }   public Options using  (  Using using )  {  return  usings . and  ( using ) ; }    @ Override public ByteBuffer getRoutingKey  ( )  {  return routingKey ; }    @ Override public String getKeyspace  ( )  {  return   statements . isEmpty  ( ) ? null :   statements . get  ( 0 ) . getKeyspace  ( ) ; }   public static class Options  extends   BuiltStatement . ForwardingStatement  < Batch >  {   private final  List  < Using >  usings =  new  ArrayList  < Using >  ( ) ;  Options  (  Batch statement )  {  super  ( statement ) ; }   public Options and  (  Using using )  {   usings . add  ( using ) ;   checkForBindMarkers  ( using ) ;  return this ; }   public Batch add  (  RegularStatement statement )  {  return   this . statement . add  ( statement ) ; } }   private  int  nonBuiltStatementValues ; 
<<<<<<<
=======
   @ Override StringBuilder buildQueryString  (   List  < ByteBuffer > variables )  {  StringBuilder  builder =  new StringBuilder  ( ) ;   builder . append  (   isCounterOp  ( ) ? "BEGIN COUNTER BATCH" :  (  logged ? "BEGIN BATCH" : "BEGIN UNLOGGED BATCH" ) ) ;  if  (  !   usings . usings . isEmpty  ( ) )  {   builder . append  ( " USING " ) ;   Utils . joinAndAppend  ( builder , " AND " ,  usings . usings , variables ) ; }   builder . append  ( ' ' ) ;  for (   int  i = 0 ;  i <  statements . size  ( ) ;  i ++ )  {  RegularStatement  stmt =  statements . get  ( i ) ;  if  (  stmt instanceof BuiltStatement )  {  BuiltStatement  bst =  ( BuiltStatement ) stmt ;   builder . append  (  maybeAddSemicolon  (  bst . buildQueryString  ( variables ) ) ) ; } else  {  String  str =  stmt . getQueryString  ( ) ;   builder . append  ( str ) ;  if  (  !   str . trim  ( ) . endsWith  ( ";" ) )   builder . append  ( ';' ) ;  assert  variables == null ; } }   builder . append  ( "APPLY BATCH;" ) ;  return builder ; }
>>>>>>>
    @ Override public  ByteBuffer  [ ] getValues  ( )  {  if  (  nonBuiltStatementValues == 0 )  return  super . getValues  ( ) ;   ByteBuffer  [ ]  values =  new ByteBuffer  [ nonBuiltStatementValues ] ;   int  i = 0 ;  for ( RegularStatement statement : statements )  {  if  (  statement instanceof BuiltStatement )  continue ;   ByteBuffer  [ ]  statementValues =  statement . getValues  ( ) ;   System . arraycopy  ( statementValues , 0 , values , i ,  statementValues . length ) ;   i +=  statementValues . length ; }  return values ; } }