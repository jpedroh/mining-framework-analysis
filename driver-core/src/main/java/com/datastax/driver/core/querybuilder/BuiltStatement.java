  package     com . datastax . driver . core . querybuilder ;   import   java . nio . ByteBuffer ;  import   java . util . ArrayList ;  import   java . util . List ;  import     com . datastax . driver . core . RegularStatement ;  import      com . datastax . driver . core . policies . RetryPolicy ;  import    com . datastax . driver . core .  * ;   abstract class BuiltStatement  extends RegularStatement  {   private final  List  < ColumnMetadata >  partitionKey ;   private final  ByteBuffer  [ ]  routingKey ;   final String  keyspace ;   private boolean  dirty ;   private String  cache ;   private  ByteBuffer  [ ]  values ;  Boolean  isCounterOp ;  boolean  hasBindMarkers ;   private boolean  forceNoValues ;  BuiltStatement  (  String keyspace )  {    this . partitionKey = null ;    this . routingKey = null ;    this . keyspace = keyspace ; }  BuiltStatement  (  TableMetadata tableMetadata )  {    this . partitionKey =  tableMetadata . getPartitionKey  ( ) ;    this . routingKey =  new ByteBuffer  [   tableMetadata . getPartitionKey  ( ) . size  ( ) ] ;    this . keyspace =   tableMetadata . getKeyspace  ( ) . getName  ( ) ; }    @ Override public String getQueryString  ( )  {   maybeRebuildCache  ( ) ;  return cache ; }   private void maybeRebuildCache  ( )  {  if  (   ! dirty &&  cache != null )  return ;  StringBuilder  sb ;   values = null ;  if  (  hasBindMarkers || forceNoValues )  {   sb =  buildQueryString  ( null ) ; } else  {   List  < ByteBuffer >  l =  new  ArrayList  < ByteBuffer >  ( ) ;   sb =  buildQueryString  ( l ) ;  if  (  !  l . isEmpty  ( ) )   values =  l . toArray  (  new ByteBuffer  [  l . size  ( ) ] ) ; }   maybeAddSemicolon  ( sb ) ;   cache =  sb . toString  ( ) ;   dirty = false ; }   static StringBuilder maybeAddSemicolon  (  StringBuilder sb )  {   int  l =  sb . length  ( ) ;  while  (   l > 0 &&   sb . charAt  (  l - 1 ) <= ' ' )   l -= 1 ;  if  (  l !=  sb . length  ( ) )   sb . setLength  ( l ) ;  if  (   l == 0 ||   sb . charAt  (  l - 1 ) != ';' )   sb . append  ( ';' ) ;  return sb ; }   abstract StringBuilder buildQueryString  (   List  < ByteBuffer > variables ) ;  boolean isCounterOp  ( )  {  return   isCounterOp == null ? false : isCounterOp ; }  void setCounterOp  (  boolean isCounterOp )  {    this . isCounterOp = isCounterOp ; }  void checkForBindMarkers  (  Object value )  {   dirty = true ;  if  (  Utils . containsBindMarker  ( value ) )   hasBindMarkers = true ; }  void checkForBindMarkers  (   Utils . Appendeable value )  {   dirty = true ;  if  (   value != null &&  value . containsBindMarker  ( ) )   hasBindMarkers = true ; }  void maybeAddRoutingKey  (  String name ,  Object value )  {  if  (     routingKey == null ||  name == null ||  value == null ||  value instanceof BindMarker )  return ;  for (   int  i = 0 ;  i <  partitionKey . size  ( ) ;  i ++ )  {  if  (   name . equals  (   partitionKey . get  ( i ) . getName  ( ) ) &&  Utils . isRawValue  ( value ) )  {    routingKey [ i ] =    partitionKey . get  ( i ) . getType  ( ) . parse  (  Utils . toRawString  ( value ) ) ;  return ; } } }    @ Override public ByteBuffer getRoutingKey  ( )  {  if  (  routingKey == null )  return null ;  for ( ByteBuffer bb : routingKey )  if  (  bb == null )  return null ;  return    routingKey . length == 1 ?  routingKey [ 0 ] :  compose  ( routingKey ) ; }    @ Override public String getKeyspace  ( )  {  return keyspace ; }    @ Override public  ByteBuffer  [ ] getValues  ( )  {   maybeRebuildCache  ( ) ;  return values ; }    @ Override public String toString  ( )  {  if  ( forceNoValues )  return  getQueryString  ( ) ;  return   maybeAddSemicolon  (  buildQueryString  ( null ) ) . toString  ( ) ; }   public RegularStatement setForceNoValues  (  boolean forceNoValues )  {    this . forceNoValues = forceNoValues ;    this . dirty = true ;  return this ; }   static ByteBuffer compose  (  ByteBuffer ...  buffers )  {   int  totalLength = 0 ;  for ( ByteBuffer bb : buffers )   totalLength +=   2 +  bb . remaining  ( ) + 1 ;  ByteBuffer  out =  ByteBuffer . allocate  ( totalLength ) ;  for ( ByteBuffer buffer : buffers )  {  ByteBuffer  bb =  buffer . duplicate  ( ) ;   putShortLength  ( out ,  bb . remaining  ( ) ) ;   out . put  ( bb ) ;   out . put  (  (  byte ) 0 ) ; }   out . flip  ( ) ;  return out ; }   private static void putShortLength  (  ByteBuffer bb ,   int length )  {   bb . put  (  (  byte )  (   (  length >> 8 ) & 0xFF ) ) ;   bb . put  (  (  byte )  (  length & 0xFF ) ) ; }   abstract static class ForwardingStatement  <  T  extends BuiltStatement >  extends BuiltStatement  {  T  statement ;  ForwardingStatement  (  T statement )  {  super  (  ( String ) null ) ;    this . statement = statement ; }    @ Override public String getQueryString  ( )  {  return  statement . getQueryString  ( ) ; }    @ Override StringBuilder buildQueryString  (   List  < ByteBuffer > values )  {  return  statement . buildQueryString  ( values ) ; }    @ Override public ByteBuffer getRoutingKey  ( )  {  return  statement . getRoutingKey  ( ) ; }    @ Override public String getKeyspace  ( )  {  return  statement . getKeyspace  ( ) ; }    @ Override boolean isCounterOp  ( )  {  return  statement . isCounterOp  ( ) ; }    @ Override public Statement setConsistencyLevel  (  ConsistencyLevel consistency )  {   statement . setConsistencyLevel  ( consistency ) ;  return this ; }    @ Override public ConsistencyLevel getConsistencyLevel  ( )  {  return  statement . getConsistencyLevel  ( ) ; }    @ Override public Statement enableTracing  ( )  {   statement . enableTracing  ( ) ;  return this ; }    @ Override public Statement disableTracing  ( )  {   statement . disableTracing  ( ) ;  return this ; }    @ Override public boolean isTracing  ( )  {  return  statement . isTracing  ( ) ; }    @ Override public Statement setRetryPolicy  (  RetryPolicy policy )  {   statement . setRetryPolicy  ( policy ) ;  return this ; }    @ Override public RetryPolicy getRetryPolicy  ( )  {  return  statement . getRetryPolicy  ( ) ; }    @ Override public  ByteBuffer  [ ] getValues  ( )  {  return  statement . getValues  ( ) ; }    @ Override void checkForBindMarkers  (  Object value )  {   statement . checkForBindMarkers  ( value ) ; }    @ Override void checkForBindMarkers  (   Utils . Appendeable value )  {   statement . checkForBindMarkers  ( value ) ; }    @ Override public String toString  ( )  {  return  statement . toString  ( ) ; } } }