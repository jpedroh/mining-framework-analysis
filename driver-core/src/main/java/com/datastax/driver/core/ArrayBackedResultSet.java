  package    com . datastax . driver . core ;   import   java . nio . ByteBuffer ;  import  java . util .  * ;  import    java . util . concurrent . ExecutionException ;  import      com . google . common . util . concurrent . Futures ;  import      com . google . common . util . concurrent . ListenableFuture ;  import      com . google . common . util . concurrent . SettableFuture ;  import      com . google . common . util . concurrent . Uninterruptibles ;  import      com . datastax . driver . core . exceptions . DriverInternalError ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  class ArrayBackedResultSet  implements  ResultSet  {   private static final Logger  logger =  LoggerFactory . getLogger  (  ResultSet . class ) ;   private static final  Queue  <  List  < ByteBuffer > >  EMPTY_QUEUE =  new  ArrayDeque  <  List  < ByteBuffer > >  ( 0 ) ;   private final ColumnDefinitions  metadata ;   private final  Queue  <  List  < ByteBuffer > >  rows ;   private final  List  < ExecutionInfo >  infos ;   private volatile FetchingState  fetchState ;   private final SessionManager  session ;   private final Statement  statement ;   private ArrayBackedResultSet  (  ColumnDefinitions metadata ,   Queue  <  List  < ByteBuffer > > rows ,  ExecutionInfo info ,  ByteBuffer initialPagingState ,  SessionManager session ,  Statement statement )  {    this . metadata = metadata ;    this . rows = rows ;    this . session = session ;  if  (  initialPagingState == null )  {    this . fetchState = null ;    this . infos =  Collections .  < ExecutionInfo > singletonList  ( info ) ; } else  {    this . fetchState =  new FetchingState  ( initialPagingState , null ) ;    this . infos =  new  ArrayList  < ExecutionInfo >  ( ) ;    this . infos . add  ( info ) ; }    this . statement = statement ;  assert   fetchState == null ||  (   session != null &&  statement != null ) ; }   static ArrayBackedResultSet fromMessage  (   Responses . Result msg ,  SessionManager session ,  ExecutionInfo info ,  Statement statement )  {  UUID  tracingId =  msg . getTracingId  ( ) ;   info =    tracingId == null ||  info == null ? info :  info . withTrace  (  new QueryTrace  ( tracingId , session ) ) ;  switch  (  msg . kind )  {   case VOID :  return  empty  ( info ) ;   case ROWS :    Responses . Result . Rows  r =  (   Responses . Result . Rows ) msg ;  ColumnDefinitions  columnDefs ;  if  (    r . metadata . columns == null )  {  assert  statement instanceof BoundStatement ;   columnDefs =     (  ( BoundStatement ) statement ) . statement . getPreparedId  ( ) . resultSetMetadata ;  assert  columnDefs != null ; } else  {   columnDefs =   r . metadata . columns ; }  return  new ArrayBackedResultSet  ( columnDefs ,  r . data , info ,   r . metadata . pagingState , session , statement ) ;   case SET_KEYSPACE :   case SCHEMA_CHANGE :  return  empty  ( info ) ;   case PREPARED :  throw  new RuntimeException  ( "Prepared statement received when a ResultSet was expected" ) ;   default :   logger . error  ( "Received unknow result type '{}'; returning empty result set" ,  msg . kind ) ;  return  empty  ( info ) ; } }   private static ArrayBackedResultSet empty  (  ExecutionInfo info )  {  return  new ArrayBackedResultSet  (  ColumnDefinitions . EMPTY , EMPTY_QUEUE , info , null , null , null ) ; }   public ColumnDefinitions getColumnDefinitions  ( )  {  return metadata ; }   public boolean isExhausted  ( )  {  if  (  !  rows . isEmpty  ( ) )  return false ;   fetchMoreResultsBlocking  ( ) ;  assert   !  rows . isEmpty  ( ) ||  isFullyFetched  ( ) ;  return  rows . isEmpty  ( ) ; }   public Row one  ( )  {   List  < ByteBuffer >  nextRow =  rows . poll  ( ) ;  if  (  nextRow != null )  return  ArrayBackedRow . fromData  ( metadata , nextRow ) ;   fetchMoreResultsBlocking  ( ) ;  return  ArrayBackedRow . fromData  ( metadata ,  rows . poll  ( ) ) ; }   public  List  < Row > all  ( )  {  if  (  isExhausted  ( ) )  return  Collections . emptyList  ( ) ;   List  < Row >  result =  new  ArrayList  < Row >  (  rows . size  ( ) ) ;  for ( Row row : this )   result . add  ( row ) ;  return result ; }    @ Override public  Iterator  < Row > iterator  ( )  {  return  new  Iterator  < Row >  ( )  {    @ Override public boolean hasNext  ( )  {  return  !  isExhausted  ( ) ; }    @ Override public Row next  ( )  {  return   ArrayBackedResultSet . this . one  ( ) ; }    @ Override public void remove  ( )  {  throw  new UnsupportedOperationException  ( ) ; } } ; }   public  int getAvailableWithoutFetching  ( )  {  return  rows . size  ( ) ; }   public boolean isFullyFetched  ( )  {  return  fetchState == null ; }   private void fetchMoreResultsBlocking  ( )  {  try  {   Uninterruptibles . getUninterruptibly  (  fetchMoreResults  ( ) ) ; }  catch (   ExecutionException e )  {  throw  DefaultResultSetFuture . extractCauseFromExecutionException  ( e ) ; } }   public  ListenableFuture  < Void > fetchMoreResults  ( )  {  if  (  isFullyFetched  ( ) )  return  Futures . immediateFuture  ( null ) ;  if  (   fetchState . inProgress != null )  return  fetchState . inProgress ;  assert   fetchState . nextStart != null ;  ByteBuffer  state =  fetchState . nextStart ;   SettableFuture  < Void >  future =  SettableFuture . create  ( ) ;   fetchState =  new FetchingState  ( null , future ) ;  return  queryNextPage  ( state , future ) ; }   private  ListenableFuture  < Void > queryNextPage  (  ByteBuffer nextStart ,   final  SettableFuture  < Void > future )  {  assert  !  (  statement instanceof BatchStatement ) ;   final  Message . Request  request =  session . makeRequestMessage  ( statement , nextStart ) ;   session . execute  (  new  RequestHandler . Callback  ( )  {    @ Override public  Message . Request request  ( )  {  return request ; }    @ Override public void register  (  RequestHandler handler )  { }    @ Override public void onSet  (  Connection connection ,   Message . Response response ,  ExecutionInfo info ,  Statement statement ,   long latency )  {  try  {  switch  (  response . type )  {   case RESULT :   Responses . Result  rm =  (  Responses . Result ) response ;  ArrayBackedResultSet  tmp =  ArrayBackedResultSet . fromMessage  ( rm ,   ArrayBackedResultSet . this . session , info , statement ) ;     ArrayBackedResultSet . this . rows . addAll  (  tmp . rows ) ;     ArrayBackedResultSet . this . fetchState =  tmp . fetchState ;     ArrayBackedResultSet . this . infos . addAll  (  tmp . infos ) ;   future . set  ( null ) ;  break ;   case ERROR :   future . setException  (   (  (  Responses . Error ) response ) . asException  (  connection . address ) ) ;  break ;   default :   connection . defunct  (  new ConnectionException  (  connection . address ,  String . format  ( "Got unexpected %s response" ,  response . type ) ) ) ;   future . setException  (  new DriverInternalError  (  String . format  ( "Got unexpected %s response from %s" ,  response . type ,  connection . address ) ) ) ;  break ; } }  catch (   RuntimeException e )  {   future . setException  (  new DriverInternalError  (  "Unexpected error while processing response from " +  connection . address , e ) ) ; } }    @ Override public void onSet  (  Connection connection ,   Message . Response response ,   long latency )  {   onSet  ( connection , response , null , null , latency ) ; }    @ Override public void onException  (  Connection connection ,  Exception exception ,   long latency )  {   future . setException  ( exception ) ; }    @ Override public void onTimeout  (  Connection connection ,   long latency )  {  throw  new UnsupportedOperationException  ( ) ; } } , statement ) ;  return future ; }   public ExecutionInfo getExecutionInfo  ( )  {  return  infos . get  (   infos . size  ( ) - 1 ) ; }   public  List  < ExecutionInfo > getAllExecutionInfo  ( )  {  return  new  ArrayList  < ExecutionInfo >  ( infos ) ; }    @ Override public String toString  ( )  {  StringBuilder  sb =  new StringBuilder  ( ) ;    sb . append  ( "ResultSet[ exhausted: " ) . append  (  isExhausted  ( ) ) ;     sb . append  ( ", " ) . append  ( metadata ) . append  ( "]" ) ;  return  sb . toString  ( ) ; }   private static class FetchingState  {   public final ByteBuffer  nextStart ;   public final  ListenableFuture  < Void >  inProgress ;  FetchingState  (  ByteBuffer nextStart ,   ListenableFuture  < Void > inProgress )  {  assert   (  nextStart == null ) !=  (  inProgress == null ) ;    this . nextStart = nextStart ;    this . inProgress = inProgress ; } } }