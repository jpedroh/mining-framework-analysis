  package    com . datastax . driver . core ;   import   java . net . InetAddress ;  import   java . net . InetSocketAddress ;  import   java . util . Iterator ;  import   java . util . concurrent .  * ;  import     java . util . concurrent . atomic . AtomicInteger ;  import    javax . net . ssl . SSLEngine ;  import      com . datastax . cassandra . transport . messages . AuthChallenge ;  import      com . datastax . cassandra . transport . messages . AuthResponse ;  import     com . google . common . collect . ImmutableMap ;  import      com . datastax . driver . core . exceptions . AuthenticationException ;  import      com . google . common . util . concurrent . Uninterruptibles ;  import      com . google . common . util . concurrent . ThreadFactoryBuilder ;  import      com . datastax . driver . core . exceptions . DriverInternalError ;  import     org . apache . cassandra . service . ClientState ;  import    com . datastax . cassandra . transport .  * ;  import     com . datastax . cassandra . transport . messages .  * ;  import     org . jboss . netty . bootstrap . ClientBootstrap ;  import    org . jboss . netty . channel .  * ;  import      org . jboss . netty . channel . group . ChannelGroup ;  import      org . jboss . netty . channel . group . ChannelGroupFuture ;  import      org . jboss . netty . channel . group . DefaultChannelGroup ;  import       org . jboss . netty . channel . socket . nio . NioClientSocketChannelFactory ;  import      org . jboss . netty . handler . ssl . SslHandler ;  import     org . jboss . netty . util . HashedWheelTimer ;  import     org . jboss . netty . util . Timeout ;  import     org . jboss . netty . util . TimerTask ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  class Connection  extends     com . datastax . cassandra . transport . Connection  {   private static final Logger  logger =  LoggerFactory . getLogger  (  Connection . class ) ;   private static final String  CQL_VERSION = "3.0.0" ;   private static final  Connection . Tracker  EMPTY_TRACKER =  new  Connection . Tracker  ( )  {    @ Override public void addConnection  (  Channel ch ,      com . datastax . cassandra . transport . Connection connection )  { }    @ Override public void closeAll  ( )  { } } ;   public final InetAddress  address ;   private final String  name ;   private final Channel  channel ;   private final Factory  factory ;   private final Dispatcher  dispatcher =  new Dispatcher  ( ) ;   public final AtomicInteger  inFlight =  new AtomicInteger  ( 0 ) ;   private final AtomicInteger  writer =  new AtomicInteger  ( 0 ) ;   private volatile boolean  isClosed ;   private volatile String  keyspace ;   private volatile boolean  isDefunct ;   private volatile ConnectionException  exception ;   private Connection  (  String name ,  InetAddress address ,  Factory factory )  throws ConnectionException , InterruptedException  {  super  ( EMPTY_TRACKER ) ;    this . address = address ;    this . factory = factory ;    this . name = name ;  ClientBootstrap  bootstrap =  factory . newBootstrap  ( ) ;  if  (     factory . configuration . getProtocolOptions  ( ) . sslOptions == null )   bootstrap . setPipelineFactory  (  new PipelineFactory  ( this ) ) ; else   bootstrap . setPipelineFactory  (  new SecurePipelineFactory  ( this ,    factory . configuration . getProtocolOptions  ( ) . sslOptions ) ) ;  ChannelFuture  future =  bootstrap . connect  (  new InetSocketAddress  ( address ,  factory . getPort  ( ) ) ) ;   writer . incrementAndGet  ( ) ;  try  {    this . channel =   future . awaitUninterruptibly  ( ) . getChannel  ( ) ;     this . factory . allChannels . add  (  this . channel ) ;  if  (  !  future . isSuccess  ( ) )  {  if  (  logger . isDebugEnabled  ( ) )   logger . debug  (  String . format  ( "[%s] Error connecting to %s%s" , name , address ,  extractMessage  (  future . getCause  ( ) ) ) ) ;  throw  new TransportException  ( address , "Cannot connect" ,  future . getCause  ( ) ) ; } }  finally  {   writer . decrementAndGet  ( ) ; }   logger . trace  ( "[{}] Connection opened successfully" , name ) ;   initializeTransport  ( ) ;   logger . trace  ( "[{}] Transport initialized and ready" , name ) ; }   private static String extractMessage  (  Throwable t )  {  String  msg =     t == null ||   t . getMessage  ( ) == null ||   t . getMessage  ( ) . isEmpty  ( ) ?  t . toString  ( ) :  t . getMessage  ( ) ;  return   " (" + msg + ")" ; }   private void initializeTransport  ( )  throws ConnectionException , InterruptedException  {    ImmutableMap . Builder  < String , String >  options =  new   ImmutableMap . Builder  < String , String >  ( ) ;   options . put  (  StartupMessage . CQL_VERSION , CQL_VERSION ) ;   ProtocolOptions . Compression  compression =    factory . configuration . getProtocolOptions  ( ) . getCompression  ( ) ;  if  (  compression !=   ProtocolOptions . Compression . NONE )  {   options . put  (  StartupMessage . COMPRESSION ,  compression . toString  ( ) ) ;   setCompressor  (  compression . compressor  ( ) ) ; }  StartupMessage  startup =  new StartupMessage  (  options . build  ( ) ) ;  try  {       com . datastax . cassandra . transport . Message . Response  response =   write  ( startup ) . get  ( ) ;  switch  (  response . type )  {   case READY :  break ;   case ERROR :  throw  defunct  (  new TransportException  ( address ,  String . format  ( "Error initializing connection: %s" ,    (  ( ErrorMessage ) response ) . error . getMessage  ( ) ) ) ) ;   case AUTHENTICATE :  Authenticator  authenticator =   factory . authProvider . newAuthenticator  ( address ) ;    byte  [ ]  initialResponse =  authenticator . initialResponse  ( ) ;  if  (  null == initialResponse )   initialResponse =  new  byte  [ 0 ] ;       com . datastax . cassandra . transport . Message . Response  authResponse =   write  (  new AuthResponse  ( initialResponse ) ) . get  ( ) ;   waitForSaslCompletion  ( authResponse , authenticator ) ;  break ;   default :  throw  defunct  (  new TransportException  ( address ,  String . format  ( "Unexpected %s response message from server to a STARTUP message" ,  response . type ) ) ) ; } }  catch (   BusyConnectionException e )  {  throw  new DriverInternalError  ( "Newly created connection should not be busy" ) ; }  catch (   ExecutionException e )  {  throw  defunct  (  new ConnectionException  ( address ,  String . format  ( "Unexpected error during transport initialization (%s)" ,  e . getCause  ( ) ) ,  e . getCause  ( ) ) ) ; } }   private void waitForSaslCompletion  (       com . datastax . cassandra . transport . Message . Response authResponse ,  Authenticator authenticator )  throws ConnectionException , BusyConnectionException , ExecutionException , InterruptedException  {  switch  (  authResponse . type )  {   case AUTH_SUCCESS :   case READY :   logger . debug  ( "Server has sent us a Ready message, authentication should be complete." ) ;  break ;   case AUTH_CHALLENGE :    byte  [ ]  responseToServer =  authenticator . evaluateChallenge  (   (  ( AuthChallenge ) authResponse ) . getToken  ( ) ) ;  if  (  responseToServer == null )  {   logger . trace  ( "Response to server is null: authentication should now be complete." ) ;  return ; } else  {   logger . trace  ( "Sending token response back to server" ) ;   waitForSaslCompletion  (   write  (  new AuthResponse  ( responseToServer ) ) . get  ( ) , authenticator ) ; }  break ;   case ERROR :  throw  new AuthenticationException  ( address ,   (   (  ( ErrorMessage ) authResponse ) . error ) . getMessage  ( ) ) ;   default :  throw  new TransportException  ( address ,  String . format  ( "Unexpected %s response message from server to authentication message" ,  authResponse . type ) ) ; } }   public boolean isDefunct  ( )  {  return isDefunct ; }   public ConnectionException lastException  ( )  {  return exception ; }  ConnectionException defunct  (  ConnectionException e )  {  if  (  logger . isDebugEnabled  ( ) )   logger . debug  (  "Defuncting connection to " + address , e ) ;   exception = e ;   isDefunct = true ;   dispatcher . errorOutAllHandler  ( e ) ;   close  ( ) ;  return e ; }   public String keyspace  ( )  {  return keyspace ; }   public void setKeyspace  (  String keyspace )  throws ConnectionException  {  if  (  keyspace == null )  return ;  if  (    this . keyspace != null &&   this . keyspace . equals  ( keyspace ) )  return ;  try  {   logger . trace  ( "[{}] Setting keyspace {}" , name , keyspace ) ;   long  timeout =  factory . getConnectTimeoutMillis  ( ) ;  Future  future =  write  (  new QueryMessage  (   "USE \"" + keyspace + "\"" ,  ConsistencyLevel . DEFAULT_CASSANDRA_CL ) ) ;       com . datastax . cassandra . transport . Message . Response  response =  Uninterruptibles . getUninterruptibly  ( future , timeout ,  TimeUnit . MILLISECONDS ) ;  switch  (  response . type )  {   case RESULT :    this . keyspace = keyspace ;  break ;   default :   defunct  (  new ConnectionException  ( address ,  String . format  ( "Problem while setting keyspace, got %s as response" , response ) ) ) ;  break ; } }  catch (   ConnectionException e )  {  throw  defunct  ( e ) ; }  catch (   TimeoutException e )  {   logger . warn  (  String . format  ( "Timeout while setting keyspace on connection to %s. This should not happen but is not critical (it will retried)" , address ) ) ; }  catch (   BusyConnectionException e )  {   logger . warn  (  String . format  ( "Tried to set the keyspace on busy connection to %s. This should not happen but is not critical (it will retried)" , address ) ) ; }  catch (   ExecutionException e )  {  throw  defunct  (  new ConnectionException  ( address , "Error while setting keyspace" , e ) ) ; } }   public Future write  (       com . datastax . cassandra . transport . Message . Request request )  throws ConnectionException , BusyConnectionException  {  Future  future =  new Future  ( request ) ;   write  ( future ) ;  return future ; }   public ResponseHandler write  (  ResponseCallback callback )  throws ConnectionException , BusyConnectionException  {       com . datastax . cassandra . transport . Message . Request  request =  callback . request  ( ) ;   request . attach  ( this ) ;  ResponseHandler  handler =  new ResponseHandler  ( this , callback ) ;   dispatcher . add  ( handler ) ;   request . setStreamId  (  handler . streamId ) ;  if  ( isDefunct )  {   dispatcher . removeHandler  (  handler . streamId , true ) ;  throw  new ConnectionException  ( address , "Write attempt on defunct connection" ) ; }  if  ( isClosed )  {   dispatcher . removeHandler  (  handler . streamId , true ) ;  throw  new ConnectionException  ( address , "Connection has been closed" ) ; }   logger . trace  ( "[{}] writing request {}" , name , request ) ;   writer . incrementAndGet  ( ) ;    channel . write  ( request ) . addListener  (  writeHandler  ( request , handler ) ) ;  return handler ; }   private ChannelFutureListener writeHandler  (   final      com . datastax . cassandra . transport . Message . Request request ,   final ResponseHandler handler )  {  return  new ChannelFutureListener  ( )  {    @ Override public void operationComplete  (  ChannelFuture writeFuture )  {   writer . decrementAndGet  ( ) ;  if  (  !  writeFuture . isSuccess  ( ) )  {   logger . debug  ( "[{}] Error writing request {}" , name , request ) ;   dispatcher . removeHandler  (  handler . streamId ) ;  ConnectionException  ce ;  if  (   writeFuture . getCause  ( ) instanceof    java . nio . channels . ClosedChannelException )  {   ce =  new TransportException  ( address , "Error writing: Closed channel" ) ; } else  {   ce =  new TransportException  ( address , "Error writing" ,  writeFuture . getCause  ( ) ) ; }    handler . callback . onException  (  Connection . this ,  defunct  ( ce ) ) ; } else  {   logger . trace  ( "[{}] request sent successfully" , name ) ; } } } ; }   public void close  ( )  {  try  {   close  ( 0 ,  TimeUnit . MILLISECONDS ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; } }   public boolean close  (   long timeout ,  TimeUnit unit )  throws InterruptedException  {  if  ( isClosed )  return true ;   logger . trace  ( "[{}] closing connection" , name ) ;   isClosed = true ;   long  start =  System . nanoTime  ( ) ;  if  (  ! isDefunct )  {  while  (    writer . get  ( ) > 0 &&   Cluster . timeSince  ( start , unit ) < timeout )   Uninterruptibles . sleepUninterruptibly  ( 1 , unit ) ; }  boolean  closed =   channel == null ? true :   channel . close  ( ) . await  (  timeout -  Cluster . timeSince  ( start , unit ) , unit ) ;   dispatcher . errorOutAllHandler  (  new TransportException  ( address , "Connection has been closed" ) ) ;  return closed ; }   public boolean isClosed  ( )  {  return isClosed ; }    @ Override public String toString  ( )  {  return  String . format  ( "Connection[%s, inFlight=%d, closed=%b]" , name ,  inFlight . get  ( ) , isClosed ) ; }   public void validateNewMessage  (       com . datastax . cassandra . transport . Message . Type type )  { } ;   public void applyStateTransition  (       com . datastax . cassandra . transport . Message . Type requestType ,       com . datastax . cassandra . transport . Message . Type responseType )  { } ;   public ClientState clientState  ( )  {  return null ; } ;   public static class Factory  {   private final ExecutorService  bossExecutor =  Executors . newCachedThreadPool  ( ) ;   private final ExecutorService  workerExecutor =  Executors . newCachedThreadPool  ( ) ;   public final HashedWheelTimer  timer =  new HashedWheelTimer  (    new ThreadFactoryBuilder  ( ) . setNameFormat  ( "Timeouter-%d" ) . build  ( ) ) ;   private final ChannelFactory  channelFactory =  new NioClientSocketChannelFactory  ( bossExecutor , workerExecutor ) ;   private final ChannelGroup  allChannels =  new DefaultChannelGroup  ( ) ;   private final  ConcurrentMap  < Host , AtomicInteger >  idGenerators =  new  ConcurrentHashMap  < Host , AtomicInteger >  ( ) ;   public final DefaultResponseHandler  defaultHandler ;   public final Configuration  configuration ;   public final AuthProvider  authProvider ;   private volatile boolean  isShutdown ;   public Factory  (   Cluster . Manager manager ,  AuthProvider authProvider )  {  this  ( manager ,  manager . configuration , authProvider ) ; }   private Factory  (  DefaultResponseHandler defaultHandler ,  Configuration configuration ,  AuthProvider authProvider )  {    this . defaultHandler = defaultHandler ;    this . configuration = configuration ;    this . authProvider = authProvider ; }   public  int getPort  ( )  {  return   configuration . getProtocolOptions  ( ) . getPort  ( ) ; }   public Connection open  (  Host host )  throws ConnectionException , InterruptedException  {  InetAddress  address =  host . getAddress  ( ) ;  if  ( isShutdown )  throw  new ConnectionException  ( address , "Connection factory is shut down" ) ;  String  name =    address . toString  ( ) + "-" +   getIdGenerator  ( host ) . getAndIncrement  ( ) ;  return  new Connection  ( name , address , this ) ; }   private AtomicInteger getIdGenerator  (  Host host )  {  AtomicInteger  g =  idGenerators . get  ( host ) ;  if  (  g == null )  {   g =  new AtomicInteger  ( 1 ) ;  AtomicInteger  old =  idGenerators . putIfAbsent  ( host , g ) ;  if  (  old != null )   g = old ; }  return g ; }   public  long getConnectTimeoutMillis  ( )  {  return   configuration . getSocketOptions  ( ) . getConnectTimeoutMillis  ( ) ; }   public  long getReadTimeoutMillis  ( )  {  return   configuration . getSocketOptions  ( ) . getReadTimeoutMillis  ( ) ; }   private ClientBootstrap newBootstrap  ( )  {  ClientBootstrap  b =  new ClientBootstrap  ( channelFactory ) ;  SocketOptions  options =  configuration . getSocketOptions  ( ) ;   b . setOption  ( "connectTimeoutMillis" ,  options . getConnectTimeoutMillis  ( ) ) ;  Boolean  keepAlive =  options . getKeepAlive  ( ) ;  if  (  keepAlive != null )   b . setOption  ( "keepAlive" , keepAlive ) ;  Boolean  reuseAddress =  options . getReuseAddress  ( ) ;  if  (  reuseAddress != null )   b . setOption  ( "reuseAddress" , reuseAddress ) ;  Integer  soLinger =  options . getSoLinger  ( ) ;  if  (  soLinger != null )   b . setOption  ( "soLinger" , soLinger ) ;  Boolean  tcpNoDelay =  options . getTcpNoDelay  ( ) ;  if  (  tcpNoDelay != null )   b . setOption  ( "tcpNoDelay" , tcpNoDelay ) ;  Integer  receiveBufferSize =  options . getReceiveBufferSize  ( ) ;  if  (  receiveBufferSize != null )   b . setOption  ( "receiveBufferSize" , receiveBufferSize ) ;  Integer  sendBufferSize =  options . getSendBufferSize  ( ) ;  if  (  sendBufferSize != null )   b . setOption  ( "sendBufferSize" , sendBufferSize ) ;  return b ; }   public boolean shutdown  (   long timeout ,  TimeUnit unit )  throws InterruptedException  {   isShutdown = true ;   long  start =  System . nanoTime  ( ) ;  ChannelGroupFuture  future =  allChannels . close  ( ) ;   channelFactory . releaseExternalResources  ( ) ;   timer . stop  ( ) ;  return    future . await  ( timeout , unit ) &&  bossExecutor . awaitTermination  (  timeout -  Cluster . timeSince  ( start , unit ) , unit ) &&  workerExecutor . awaitTermination  (  timeout -  Cluster . timeSince  ( start , unit ) , unit ) ; } }   private class Dispatcher  extends SimpleChannelUpstreamHandler  {   public final StreamIdGenerator  streamIdHandler =  new StreamIdGenerator  ( ) ;   private final  ConcurrentMap  < Integer , ResponseHandler >  pending =  new  ConcurrentHashMap  < Integer , ResponseHandler >  ( ) ;   public void add  (  ResponseHandler handler )  {  ResponseHandler  old =  pending . put  (  handler . streamId , handler ) ;  assert  old == null ; }    @ Override public void messageReceived  (  ChannelHandlerContext ctx ,  MessageEvent e )  {  if  (  !  (   e . getMessage  ( ) instanceof      com . datastax . cassandra . transport . Message . Response ) )  {   logger . error  ( "[{}] Received unexpected message: {}" , name ,  e . getMessage  ( ) ) ;   defunct  (  new TransportException  ( address ,  "Unexpected message received: " +  e . getMessage  ( ) ) ) ; } else  {       com . datastax . cassandra . transport . Message . Response  response =  (      com . datastax . cassandra . transport . Message . Response )  e . getMessage  ( ) ;   int  streamId =  response . getStreamId  ( ) ;   logger . trace  ( "[{}] received: {}" , name ,  e . getMessage  ( ) ) ;  if  (  streamId < 0 )  {    factory . defaultHandler . handle  ( response ) ;  return ; }  ResponseHandler  handler =  pending . remove  ( streamId ) ;   streamIdHandler . release  ( streamId ) ;  if  (  handler == null )  {   streamIdHandler . unmark  ( streamId ) ;   logger . debug  ( "[{}] Response received on stream {} but no handler set anymore (either the request has timeouted or it was closed due to another error). Received message is {}" , name , streamId , response ) ;  return ; }   handler . cancelTimeout  ( ) ;    handler . callback . onSet  (  Connection . this , response ,   System . nanoTime  ( ) -  handler . startTime ) ; } }    @ Override public void exceptionCaught  (  ChannelHandlerContext ctx ,  ExceptionEvent e )  {  if  (  logger . isTraceEnabled  ( ) )   logger . trace  (  String . format  ( "[%s] connection error" , name ) ,  e . getCause  ( ) ) ;  if  (   writer . get  ( ) > 0 )  return ;   defunct  (  new TransportException  ( address ,  String . format  ( "Unexpected exception triggered (%s)" ,  e . getCause  ( ) ) ,  e . getCause  ( ) ) ) ; }   public void errorOutAllHandler  (  ConnectionException ce )  {   Iterator  < ResponseHandler >  iter =   pending . values  ( ) . iterator  ( ) ;  while  (  iter . hasNext  ( ) )  {  ResponseHandler  handler =  iter . next  ( ) ;    handler . callback . onException  (  Connection . this , ce ,   System . nanoTime  ( ) -  handler . startTime ) ;   iter . remove  ( ) ; } }    @ Override public void channelClosed  (  ChannelHandlerContext ctx ,  ChannelStateEvent e )  {  if  ( isClosed )   errorOutAllHandler  (  new TransportException  ( address , "Channel has been closed" ) ) ; else   defunct  (  new TransportException  ( address , "Channel has been closed" ) ) ; }   public void removeHandler  (   int streamId ,  boolean releaseStreamId )  {  if  (  ! releaseStreamId )   streamIdHandler . mark  ( streamId ) ;  ResponseHandler  handler =  pending . remove  ( streamId ) ;  if  (  handler != null )   handler . cancelTimeout  ( ) ;  if  ( releaseStreamId )   streamIdHandler . release  ( streamId ) ; } }   static class Future  extends  SimpleFuture  <      com . datastax . cassandra . transport . Message . Response >  implements   RequestHandler . Callback  {   private final      com . datastax . cassandra . transport . Message . Request  request ;   private volatile InetAddress  address ;   public Future  (       com . datastax . cassandra . transport . Message . Request request )  {    this . request = request ; }    @ Override public void register  (  RequestHandler handler )  { }    @ Override public      com . datastax . cassandra . transport . Message . Request request  ( )  {  return request ; }    @ Override public void onSet  (  Connection connection ,       com . datastax . cassandra . transport . Message . Response response ,  ExecutionInfo info )  {   onSet  ( connection , response ) ; }    @ Override public void onSet  (  Connection connection ,       com . datastax . cassandra . transport . Message . Response response )  {    this . address =  connection . address ;   super . set  ( response ) ; }   public InetAddress getAddress  ( )  {  return address ; }    @ Override public void onSet  (  Connection connection ,   Message . Response response ,  ExecutionInfo info ,   long latency )  {   onSet  ( connection , response , latency ) ; }    @ Override public void onSet  (  Connection connection ,   Message . Response response ,   long latency )  {    this . address =  connection . address ;   super . set  ( response ) ; }    @ Override public void onException  (  Connection connection ,  Exception exception ,   long latency )  {  if  (  connection != null )    this . address =  connection . address ;   super . setException  ( exception ) ; }    @ Override public void onTimeout  (  Connection connection ,   long latency )  {  assert  connection != null ;    this . address =  connection . address ;   super . setException  (  new ConnectionException  (  connection . address , "Operation Timeouted" ) ) ; } }  interface ResponseCallback  {   public      com . datastax . cassandra . transport . Message . Request request  ( ) ;   public void onSet  (  Connection connection ,       com . datastax . cassandra . transport . Message . Response response ) ;   public void onSet  (  Connection connection ,   Message . Response response ,   long latency ) ;   public void onException  (  Connection connection ,  Exception exception ,   long latency ) ;   public void onTimeout  (  Connection connection ,   long latency ) ; }   static class ResponseHandler  {   public final Connection  connection ;   public final  int  streamId ;   public final ResponseCallback  callback ;   private final Timeout  timeout ;   public ResponseHandler  (  Connection connection ,  ResponseCallback callback )  throws BusyConnectionException  {    this . connection = connection ;    this . streamId =    connection . dispatcher . streamIdHandler . next  ( ) ;    this . callback = callback ;   long  timeoutMs =   connection . factory . getReadTimeoutMillis  ( ) ;    this . timeout =   timeoutMs <= 0 ? null :    connection . factory . timer . newTimeout  (  onTimeoutTask  ( ) , timeoutMs ,  TimeUnit . MILLISECONDS ) ;    this . startTime =  System . nanoTime  ( ) ; }  void cancelTimeout  ( )  {  if  (  timeout != null )   timeout . cancel  ( ) ; }   public void cancelHandler  ( )  {    connection . dispatcher . removeHandler  ( streamId , false ) ; }   private TimerTask onTimeoutTask  ( )  {  return  new TimerTask  ( )  {    @ Override public void run  (  Timeout timeout )  {   callback . onTimeout  ( connection ,   System . nanoTime  ( ) - startTime ) ;   cancelHandler  ( ) ; } } ; }   private final  long  startTime ; }   public interface DefaultResponseHandler  {   public void handle  (       com . datastax . cassandra . transport . Message . Response response ) ; }   private static class PipelineFactory  implements  ChannelPipelineFactory  {   private static final  Message . ProtocolDecoder  messageDecoder =  new  Message . ProtocolDecoder  ( ) ;   private static final  Message . ProtocolEncoder  messageEncoder =  new  Message . ProtocolEncoder  ( ) ;   private static final  Frame . Decompressor  frameDecompressor =  new  Frame . Decompressor  ( ) ;   private static final  Frame . Compressor  frameCompressor =  new  Frame . Compressor  ( ) ;   private static final  Frame . Encoder  frameEncoder =  new  Frame . Encoder  ( ) ;   private static final  Connection . Tracker  tracker ;  static  {   tracker =  new  Connection . Tracker  ( )  {    @ Override public void addConnection  (  Channel ch ,      com . datastax . cassandra . transport . Connection connection )  { }    @ Override public void closeAll  ( )  { } } ; }   private final Connection  connection ;   private final      com . datastax . cassandra . transport . Connection . Factory  cfactory ;   public PipelineFactory  (   final Connection connection )  {    this . connection = connection ;    this . cfactory =  new      com . datastax . cassandra . transport . Connection . Factory  ( )  {    @ Override public Connection newConnection  (   Connection . Tracker tracker )  {  return connection ; } } ; }    @ Override public ChannelPipeline getPipeline  ( )  throws Exception  {  ChannelPipeline  pipeline =  Channels . pipeline  ( ) ;   pipeline . addLast  ( "frameDecoder" ,  new  Frame . Decoder  ( tracker , cfactory ) ) ;   pipeline . addLast  ( "frameEncoder" , frameEncoder ) ;   pipeline . addLast  ( "frameDecompressor" , frameDecompressor ) ;   pipeline . addLast  ( "frameCompressor" , frameCompressor ) ;   pipeline . addLast  ( "messageDecoder" , messageDecoder ) ;   pipeline . addLast  ( "messageEncoder" , messageEncoder ) ;   pipeline . addLast  ( "dispatcher" ,  connection . dispatcher ) ;  return pipeline ; } }   private static class SecurePipelineFactory  extends PipelineFactory  {   private final SSLOptions  options ;   public SecurePipelineFactory  (   final Connection connection ,  SSLOptions options )  {  super  ( connection ) ;    this . options = options ; }   public ChannelPipeline getPipeline  ( )  throws Exception  {  SSLEngine  engine =   options . context . createSSLEngine  ( ) ;   engine . setUseClientMode  ( true ) ;   engine . setEnabledCipherSuites  (  options . cipherSuites ) ;  ChannelPipeline  pipeline =  super . getPipeline  ( ) ;  SslHandler  handler =  new SslHandler  ( engine ) ;   handler . setCloseOnSSLException  ( true ) ;   pipeline . addFirst  ( "ssl" , handler ) ;  return pipeline ; } }   public  int maxAvailableStreams  ( )  {  return   dispatcher . streamIdHandler . maxAvailableStreams  ( ) ; } 
<<<<<<<
=======
  private ChannelFutureListener writeHandler  (   final  Message . Request request ,   final ResponseHandler handler )  {  return  new ChannelFutureListener  ( )  {    @ Override public void operationComplete  (  ChannelFuture writeFuture )  {   writer . decrementAndGet  ( ) ;  if  (  !  writeFuture . isSuccess  ( ) )  {   logger . debug  ( "[{}] Error writing request {}" , name , request ) ;   dispatcher . removeHandler  (  handler . streamId , true ) ;  ConnectionException  ce ;  if  (   writeFuture . getCause  ( ) instanceof    java . nio . channels . ClosedChannelException )  {   ce =  new TransportException  ( address , "Error writing: Closed channel" ) ; } else  {   ce =  new TransportException  ( address , "Error writing" ,  writeFuture . getCause  ( ) ) ; }    handler . callback . onException  (  Connection . this ,  defunct  ( ce ) ,   System . nanoTime  ( ) -  handler . startTime ) ; } else  {   logger . trace  ( "[{}] request sent successfully" , name ) ; } } } ; }
>>>>>>>
 }