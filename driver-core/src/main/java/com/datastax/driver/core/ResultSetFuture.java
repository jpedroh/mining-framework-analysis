  package    com . datastax . driver . core ;   import    java . util . concurrent . ExecutionException ;  import    java . util . concurrent . TimeoutException ;  import    java . util . concurrent . TimeUnit ;  import      com . google . common . util . concurrent . Uninterruptibles ;  import     com . datastax . cassandra . transport . Message ;  import      com . datastax . cassandra . transport . messages . ErrorMessage ;  import      com . datastax . cassandra . transport . messages . ResultMessage ;  import     com . datastax . driver . core . exceptions .  * ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;   public class ResultSetFuture  extends  SimpleFuture  < ResultSet >  {   private static final Logger  logger =  LoggerFactory . getLogger  (  ResultSetFuture . class ) ;   private final  Session . Manager  session ;   final ResponseCallback  callback ;  ResultSetFuture  (   Session . Manager session ,   Message . Request request )  {    this . session = session ;    this . callback =  new ResponseCallback  ( request ) ; }  class ResponseCallback  implements   RequestHandler . Callback  {   private final  Message . Request  request ;   private volatile RequestHandler  handler ;  ResponseCallback  (   Message . Request request )  {    this . request = request ; }    @ Override public void register  (  RequestHandler handler )  {    this . handler = handler ; }    @ Override public  Message . Request request  ( )  {  return request ; }    @ Override public void onSet  (  Connection connection ,   Message . Response response ,  ExecutionInfo info ,   long latency )  {  try  {  switch  (  response . type )  {   case RESULT :  ResultMessage  rm =  ( ResultMessage ) response ;  switch  (  rm . kind )  {   case SET_KEYSPACE :    session . poolsState . setKeyspace  (   (  (  ResultMessage . SetKeyspace ) rm ) . keyspace ) ;   set  (  ResultSet . fromMessage  ( rm , session , info ) ) ;  break ;   case SCHEMA_CHANGE :   ResultMessage . SchemaChange  scc =  (  ResultMessage . SchemaChange ) rm ;  ResultSet  rs =  ResultSet . fromMessage  ( rm , session , info ) ;  switch  (  scc . change )  {   case CREATED :  if  (   scc . columnFamily . isEmpty  ( ) )  {     session . cluster . manager . refreshSchema  ( connection ,  ResultSetFuture . this , rs , null , null ) ; } else  {     session . cluster . manager . refreshSchema  ( connection ,  ResultSetFuture . this , rs ,  scc . keyspace , null ) ; }  break ;   case DROPPED :  if  (   scc . columnFamily . isEmpty  ( ) )  {     session . cluster . manager . refreshSchema  ( connection ,  ResultSetFuture . this , rs , null , null ) ; } else  {     session . cluster . manager . refreshSchema  ( connection ,  ResultSetFuture . this , rs ,  scc . keyspace , null ) ; }  break ;   case UPDATED :  if  (   scc . columnFamily . isEmpty  ( ) )  {     session . cluster . manager . refreshSchema  ( connection ,  ResultSetFuture . this , rs ,  scc . keyspace , null ) ; } else  {     session . cluster . manager . refreshSchema  ( connection ,  ResultSetFuture . this , rs ,  scc . keyspace ,  scc . columnFamily ) ; }  break ;   default :   logger . info  ( "Ignoring unknown schema change result" ) ;  break ; }  break ;   default :   set  (  ResultSet . fromMessage  ( rm , session , info ) ) ;  break ; }  break ;   case ERROR :   setException  (  convertException  (   (  ( ErrorMessage ) response ) . error ) ) ;  break ;   default :   connection . defunct  (  new ConnectionException  (  connection . address ,  String . format  ( "Got unexpected %s response" ,  response . type ) ) ) ;   setException  (  new DriverInternalError  (  String . format  ( "Got unexpected %s response from %s" ,  response . type ,  connection . address ) ) ) ;  break ; } }  catch (   RuntimeException e )  {   setException  (  new DriverInternalError  (  "Unexpected error while processing response from " +  connection . address , e ) ) ; } }    @ Override public void onSet  (  Connection connection ,   Message . Response response ,   long latency )  {   onSet  ( connection , response , null , latency ) ; }    @ Override public void onException  (  Connection connection ,  Exception exception ,   long latency )  {   setException  ( exception ) ; }    @ Override public void onTimeout  (  Connection connection ,   long latency )  {   setException  (  new ConnectionException  (  connection . address , "Operation Timeouted" ) ) ; } }   public ResultSet getUninterruptibly  ( )  {  try  {  return  Uninterruptibles . getUninterruptibly  ( this ) ; }  catch (   ExecutionException e )  {   extractCauseFromExecutionException  ( e ) ;  throw  new AssertionError  ( ) ; } }   public ResultSet getUninterruptibly  (   long timeout ,  TimeUnit unit )  throws TimeoutException  {  try  {  return  Uninterruptibles . getUninterruptibly  ( this , timeout , unit ) ; }  catch (   ExecutionException e )  {   extractCauseFromExecutionException  ( e ) ;  throw  new AssertionError  ( ) ; } }    @ Override public boolean cancel  (  boolean mayInterruptIfRunning )  {  if  (  !  super . cancel  ( mayInterruptIfRunning ) )  return false ;    callback . handler . cancel  ( ) ;  return true ; }   static void extractCauseFromExecutionException  (  ExecutionException e )  {  if  (   e . getCause  ( ) instanceof DriverException )  throw   (  ( DriverException )  e . getCause  ( ) ) . copy  ( ) ; else  throw  new DriverInternalError  ( "Unexpected exception thrown" ,  e . getCause  ( ) ) ; }   static void extractCause  (  Throwable cause )  {  if  (  cause instanceof DriverException )  throw   (  ( DriverException ) cause ) . copy  ( ) ;  throw  new DriverInternalError  ( "Unexpected exception thrown" , cause ) ; }   static Exception convertException  (      org . apache . cassandra . exceptions . TransportException te )  {  switch  (  te . code  ( ) )  {   case SERVER_ERROR :  return  new DriverInternalError  (  "An unexpected error occured server side: " +  te . getMessage  ( ) ) ;   case PROTOCOL_ERROR :  return  new DriverInternalError  (  "An unexpected protocol error occured. This is a bug in this library, please report: " +  te . getMessage  ( ) ) ;   case UNAVAILABLE :      org . apache . cassandra . exceptions . UnavailableException  ue =  (     org . apache . cassandra . exceptions . UnavailableException ) te ;  return  new UnavailableException  (  ConsistencyLevel . from  (  ue . consistency ) ,  ue . required ,  ue . alive ) ;   case OVERLOADED :  return  new DriverInternalError  ( "Queried host was overloaded; this shouldn't happen, another node should have been tried" ) ;   case IS_BOOTSTRAPPING :  return  new DriverInternalError  ( "Queried host was boostrapping; this shouldn't happen, another node should have been tried" ) ;   case TRUNCATE_ERROR :  return  new TruncateException  (  te . getMessage  ( ) ) ;   case WRITE_TIMEOUT :      org . apache . cassandra . exceptions . WriteTimeoutException  wte =  (     org . apache . cassandra . exceptions . WriteTimeoutException ) te ;  return  new WriteTimeoutException  (  ConsistencyLevel . from  (  wte . consistency ) ,  WriteType . from  (  wte . writeType ) ,  wte . received ,  wte . blockFor ) ;   case READ_TIMEOUT :      org . apache . cassandra . exceptions . ReadTimeoutException  rte =  (     org . apache . cassandra . exceptions . ReadTimeoutException ) te ;  return  new ReadTimeoutException  (  ConsistencyLevel . from  (  rte . consistency ) ,  rte . received ,  rte . blockFor ,  rte . dataPresent ) ;   case SYNTAX_ERROR :  return  new SyntaxError  (  te . getMessage  ( ) ) ;   case UNAUTHORIZED :  return  new UnauthorizedException  (  te . getMessage  ( ) ) ;   case INVALID :  return  new InvalidQueryException  (  te . getMessage  ( ) ) ;   case CONFIG_ERROR :  return  new InvalidConfigurationInQueryException  (  te . getMessage  ( ) ) ;   case ALREADY_EXISTS :      org . apache . cassandra . exceptions . AlreadyExistsException  aee =  (     org . apache . cassandra . exceptions . AlreadyExistsException ) te ;  return  new AlreadyExistsException  (  aee . ksName ,  aee . cfName ) ;   default :  return  new DriverInternalError  (  "Unknown error return code: " +  te . code  ( ) ) ; } } }