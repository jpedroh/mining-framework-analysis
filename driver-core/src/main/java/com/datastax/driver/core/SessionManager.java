  package    com . datastax . driver . core ;   import   java . net . InetSocketAddress ;  import   java . nio . ByteBuffer ;  import  java . util .  * ;  import   java . util . concurrent .  * ;  import     java . util . concurrent . atomic . AtomicReference ;  import     java . util . concurrent . locks . Lock ;  import     com . google . common . base . Function ;  import     com . google . common . collect . ImmutableList ;  import     com . google . common . util . concurrent .  * ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import      com . datastax . driver . core . exceptions . DriverInternalError ;  import      com . datastax . driver . core . exceptions . UnsupportedFeatureException ;  import      com . datastax . driver . core . policies . LoadBalancingPolicy ;  import      com . datastax . driver . core . policies . ReconnectionPolicy ;  class SessionManager  extends AbstractSession  {   private static final Logger  logger =  LoggerFactory . getLogger  (  Session . class ) ;   final Cluster  cluster ;   final  ConcurrentMap  < Host , HostConnectionPool >  pools ;   final  HostConnectionPool . PoolState  poolsState ;   final  AtomicReference  < CloseFuture >  closeFuture =  new  AtomicReference  < CloseFuture >  ( ) ;   private final  Striped  < Lock >  poolCreationLocks =  Striped . lazyWeakLock  ( 5 ) ;   private volatile boolean  isInit ;   private volatile boolean  isClosing ;  SessionManager  (  Cluster cluster )  {    this . cluster = cluster ;    this . pools =  new  ConcurrentHashMap  < Host , HostConnectionPool >  ( ) ;    this . poolsState =  new  HostConnectionPool . PoolState  ( ) ; }   public synchronized Session init  ( )  {  if  ( isInit )  return this ;   cluster . init  ( ) ;   Collection  < Host >  hosts =   cluster . getMetadata  ( ) . allHosts  ( ) ;  if  (     cluster . manager . sessions . size  ( ) == 1 )  {   createPoolsInParallel  ( hosts ) ; } else  {   createPoolsSequentially  ( hosts ) ; }   isInit = true ;   updateCreatedPools  (  executor  ( ) ) ;  return this ; }   private void createPoolsInParallel  (   Collection  < Host > hosts )  {   List  <  ListenableFuture  < Boolean > >  futures =  new  ArrayList  <  ListenableFuture  < Boolean > >  (  hosts . size  ( ) ) ;  for ( Host host : hosts )  if  (   host . state !=   Host . State . DOWN )   futures . add  (  maybeAddPool  ( host ,  executor  ( ) ) ) ;   ListenableFuture  <  List  < Boolean > >  f =  Futures . allAsList  ( futures ) ;  try  {   f . get  ( ) ; }  catch (   ExecutionException e )  {  throw  new DriverInternalError  ( e ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; } }   private void createPoolsSequentially  (   Collection  < Host > hosts )  {  for ( Host host :   cluster . getMetadata  ( ) . allHosts  ( ) )  {  try  {  if  (   host . state !=   Host . State . DOWN )    maybeAddPool  ( host ,  executor  ( ) ) . get  ( ) ; }  catch (   ExecutionException e )  {  throw  new DriverInternalError  ( e ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; } } }   public String getLoggedKeyspace  ( )  {  return  poolsState . keyspace ; }   public ResultSetFuture executeAsync  (  Statement statement )  {  return  executeQuery  (  makeRequestMessage  ( statement , null ) , statement ) ; }   public  ListenableFuture  < PreparedStatement > prepareAsync  (  String query )  {   Connection . Future  future =  new  Connection . Future  (  new  Requests . Prepare  ( query ) ) ;   execute  ( future ,  Statement . DEFAULT ) ;  return  toPreparedStatement  ( query , future ) ; }   public CloseFuture closeAsync  ( )  {  CloseFuture  future =  closeFuture . get  ( ) ;  if  (  future != null )  return future ;   isClosing = true ;    cluster . manager . removeSession  ( this ) ;   List  < CloseFuture >  futures =  new  ArrayList  < CloseFuture >  (  pools . size  ( ) ) ;  for ( HostConnectionPool pool :  pools . values  ( ) )   futures . add  (  pool . closeAsync  ( ) ) ;   future =  new  CloseFuture . Forwarding  ( futures ) ;  return   closeFuture . compareAndSet  ( null , future ) ? future :  closeFuture . get  ( ) ; }   public boolean isClosed  ( )  {  return   closeFuture . get  ( ) != null ; }   public Cluster getCluster  ( )  {  return cluster ; }   public  Session . State getState  ( )  {  return  new State  ( this ) ; }   private  ListenableFuture  < PreparedStatement > toPreparedStatement  (   final String query ,   final  Connection . Future future )  {  return  Futures . transform  ( future ,  new  Function  <  Message . Response , PreparedStatement >  ( )  {   public PreparedStatement apply  (   Message . Response response )  {  switch  (  response . type )  {   case RESULT :   Responses . Result  rm =  (  Responses . Result ) response ;  switch  (  rm . kind )  {   case PREPARED :    Responses . Result . Prepared  pmsg =  (   Responses . Result . Prepared ) rm ;  PreparedStatement  stmt =  DefaultPreparedStatement . fromMessage  ( pmsg ,  cluster . getMetadata  ( ) ,    cluster . getConfiguration  ( ) . getProtocolOptions  ( ) . getProtocolVersionEnum  ( ) , query ,  poolsState . keyspace ) ;   stmt =   cluster . manager . addPrepared  ( stmt ) ;  try  {   prepare  (  stmt . getQueryString  ( ) ,  future . getAddress  ( ) ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  return stmt ;   default :  throw  new DriverInternalError  (  String . format  ( "%s response received when prepared statement was expected" ,  rm . kind ) ) ; }   case ERROR :  throw   (  (  Responses . Error ) response ) . asException  (  future . getAddress  ( ) ) ;   default :  throw  new DriverInternalError  (  String . format  ( "%s response received when prepared statement was expected" ,  response . type ) ) ; } } } ,  executor  ( ) ) ; }   Connection . Factory connectionFactory  ( )  {  return   cluster . manager . connectionFactory ; }  Configuration configuration  ( )  {  return   cluster . manager . configuration ; }  LoadBalancingPolicy loadBalancingPolicy  ( )  {  return   cluster . manager . loadBalancingPolicy  ( ) ; }  ReconnectionPolicy reconnectionPolicy  ( )  {  return   cluster . manager . reconnectionPolicy  ( ) ; }  ListeningExecutorService executor  ( )  {  return   cluster . manager . executor ; }  ListeningExecutorService blockingExecutor  ( )  {  return   cluster . manager . blockingExecutor ; }   ListenableFuture  < Boolean > forceRenewPool  (   final Host host ,  ListeningExecutorService executor )  {   final HostDistance  distance =    cluster . manager . loadBalancingPolicy  ( ) . distance  ( host ) ;  if  (  distance ==  HostDistance . IGNORED )  return  Futures . immediateFuture  ( true ) ;  return  executor . submit  (  new  Callable  < Boolean >  ( )  {   public Boolean call  ( )  {  while  ( true )  {  try  {  if  ( isClosing )  return true ;  HostConnectionPool  newPool =  HostConnectionPool . newInstance  ( host , distance ,  SessionManager . this ,    cluster . getConfiguration  ( ) . getProtocolOptions  ( ) . getProtocolVersionEnum  ( ) ) ;  HostConnectionPool  previous =  pools . put  ( host , newPool ) ;  if  (  previous == null )  {   logger . debug  ( "Added connection pool for {}" , host ) ; } else  {   logger . debug  ( "Renewed connection pool for {}" , host ) ;   previous . closeAsync  ( ) ; }  if  ( isClosing )   newPool . closeAsync  ( ) ;  return true ; }  catch (   Exception e )  {   logger . error  (  "Error creating pool to " + host , e ) ;  return false ; } } } } ) ; }   private boolean replacePool  (  Host host ,  HostDistance distance ,  HostConnectionPool condition )  throws ConnectionException , UnsupportedProtocolVersionException , ClusterNameMismatchException  {  if  ( isClosing )  return true ;  Lock  l =  poolCreationLocks . get  ( host ) ;   l . lock  ( ) ;  try  {  HostConnectionPool  previous =  pools . get  ( host ) ;  if  (  previous != condition )  return false ;  HostConnectionPool  newPool =  HostConnectionPool . newInstance  ( host , distance ,  SessionManager . this ,    cluster . getConfiguration  ( ) . getProtocolOptions  ( ) . getProtocolVersionEnum  ( ) ) ;   previous =  pools . put  ( host , newPool ) ;  if  (   previous != null &&  !  previous . isClosed  ( ) )  {   logger . warn  ( "Replacing a pool that wasn't closed. Closing it now, but this was not expected." ) ;   previous . closeAsync  ( ) ; }  if  ( isClosing )   newPool . closeAsync  ( ) ;  return true ; }  finally  {   l . unlock  ( ) ; } }   ListenableFuture  < Boolean > maybeAddPool  (   final Host host ,  ListeningExecutorService executor )  {   final HostDistance  distance =    cluster . manager . loadBalancingPolicy  ( ) . distance  ( host ) ;  if  (  distance ==  HostDistance . IGNORED )  return  Futures . immediateFuture  ( true ) ;  HostConnectionPool  previous =  pools . get  ( host ) ;  if  (   previous != null &&  !  previous . isClosed  ( ) )  return  Futures . immediateFuture  ( true ) ;  return  executor . submit  (  new  Callable  < Boolean >  ( )  {   public Boolean call  ( )  {  try  {  while  ( true )  {  HostConnectionPool  previous =  pools . get  ( host ) ;  if  (   previous != null &&  !  previous . isClosed  ( ) )  return true ;  if  (  replacePool  ( host , distance , previous ) )  {   logger . debug  ( "Added connection pool for {}" , host ) ;  return true ; } } }  catch (   UnsupportedProtocolVersionException e )  {    cluster . manager . logUnsupportedVersionProtocol  ( host ) ;    cluster . manager . triggerOnDown  ( host , false ) ;  return false ; }  catch (   ClusterNameMismatchException e )  {    cluster . manager . logClusterNameMismatch  ( host ,  e . expectedClusterName ,  e . actualClusterName ) ;    cluster . manager . triggerOnDown  ( host , false ) ;  return false ; }  catch (   Exception e )  {   logger . error  (  "Error creating pool to " + host , e ) ;  return false ; } } } ) ; }  CloseFuture removePool  (  Host host )  {   final HostConnectionPool  pool =  pools . remove  ( host ) ;  return   pool == null ?  CloseFuture . immediateFuture  ( ) :  pool . closeAsync  ( ) ; }  void updateCreatedPools  (  ListeningExecutorService executor )  {  if  (  ! isInit )  return ;  try  {   List  < Host >  toRemove =  new  ArrayList  < Host >  ( ) ;   List  <  ListenableFuture  <  ? > >  poolCreationFutures =  new  ArrayList  <  ListenableFuture  <  ? > >  ( ) ;  for ( Host h :   cluster . getMetadata  ( ) . allHosts  ( ) )  {  HostDistance  dist =   loadBalancingPolicy  ( ) . distance  ( h ) ;  HostConnectionPool  pool =  pools . get  ( h ) ;  if  (  pool == null )  {  if  (   dist !=  HostDistance . IGNORED &&   h . state ==   Host . State . UP )   poolCreationFutures . add  (  maybeAddPool  ( h , executor ) ) ; } else  if  (  dist !=  pool . hostDistance )  {  if  (  dist ==  HostDistance . IGNORED )  {   toRemove . add  ( h ) ; } else  {    pool . hostDistance = dist ;   pool . ensureCoreConnections  ( ) ; } } }    Futures . allAsList  ( poolCreationFutures ) . get  ( ) ;   List  <  ListenableFuture  <  ? > >  poolRemovalFutures =  new  ArrayList  <  ListenableFuture  <  ? > >  (  toRemove . size  ( ) ) ;  for ( Host h : toRemove )   poolRemovalFutures . add  (  removePool  ( h ) ) ;    Futures . allAsList  ( poolRemovalFutures ) . get  ( ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   ExecutionException e )  {   logger . error  ( "Unexpected error while refreshing connection pools" ,  e . getCause  ( ) ) ; } }  void updateCreatedPools  (  Host h ,  ListeningExecutorService executor )  {  HostDistance  dist =   loadBalancingPolicy  ( ) . distance  ( h ) ;  HostConnectionPool  pool =  pools . get  ( h ) ;  try  {  if  (  pool == null )  {  if  (   dist !=  HostDistance . IGNORED &&   h . state ==   Host . State . UP )    maybeAddPool  ( h , executor ) . get  ( ) ; } else  if  (  dist !=  pool . hostDistance )  {  if  (  dist ==  HostDistance . IGNORED )  {    removePool  ( h ) . get  ( ) ; } else  {    pool . hostDistance = dist ;   pool . ensureCoreConnections  ( ) ; } } }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  catch (   ExecutionException e )  {   logger . error  ( "Unexpected error while refreshing connection pools" ,  e . getCause  ( ) ) ; } }  void onDown  (  Host host )  throws InterruptedException , ExecutionException  {     removePool  ( host ) . force  ( ) . get  ( ) ;   updateCreatedPools  (  MoreExecutors . sameThreadExecutor  ( ) ) ; }  void onSuspected  (  Host host )  { }  void onRemove  (  Host host )  throws InterruptedException , ExecutionException  {   onDown  ( host ) ; }  void setKeyspace  (  String keyspace )  {   long  timeout =    configuration  ( ) . getSocketOptions  ( ) . getConnectTimeoutMillis  ( ) ;  try  {   Future  <  ? >  future =  executeQuery  (  new  Requests . Query  (  "use " + keyspace ) ,  Statement . DEFAULT ) ;   Uninterruptibles . getUninterruptibly  ( future , timeout ,  TimeUnit . MILLISECONDS ) ; }  catch (   TimeoutException e )  {  throw  new DriverInternalError  (  String . format  ( "No responses after %d milliseconds while setting current keyspace. This should not happen, unless you have setup a very low connection timeout." , timeout ) ) ; }  catch (   ExecutionException e )  {  throw  DefaultResultSetFuture . extractCauseFromExecutionException  ( e ) ; } }   Message . Request makeRequestMessage  (  Statement statement ,  ByteBuffer pagingState )  {  if  (  ! isInit )   init  ( ) ;  ProtocolVersion  version =   cluster . manager . protocolVersion  ( ) ;  ConsistencyLevel  consistency =  statement . getConsistencyLevel  ( ) ;  if  (  consistency == null )   consistency =    configuration  ( ) . getQueryOptions  ( ) . getConsistencyLevel  ( ) ;  ConsistencyLevel  serialConsistency =  statement . getSerialConsistencyLevel  ( ) ;  if  (    version . compareTo  (  ProtocolVersion . V3 ) < 0 &&  statement instanceof BatchStatement )  {  if  (  serialConsistency != null )  throw  new UnsupportedFeatureException  ( version , "Serial consistency on batch statements is not supported" ) ; } else  if  (  serialConsistency == null )   serialConsistency =    configuration  ( ) . getQueryOptions  ( ) . getSerialConsistencyLevel  ( ) ;   long  defaultTimestamp =  Long . MIN_VALUE ;  if  (     cluster . manager . protocolVersion  ( ) . compareTo  (  ProtocolVersion . V3 ) >= 0 )  {   defaultTimestamp =  statement . getDefaultTimestamp  ( ) ;  if  (  defaultTimestamp ==  Long . MIN_VALUE )   defaultTimestamp =     cluster . getConfiguration  ( ) . getPolicies  ( ) . getTimestampGenerator  ( ) . next  ( ) ; }  return  makeRequestMessage  ( statement , consistency , serialConsistency , pagingState , defaultTimestamp ) ; }   Message . Request makeRequestMessage  (  Statement statement ,  ConsistencyLevel cl ,  ConsistencyLevel scl ,  ByteBuffer pagingState ,   long defaultTimestamp )  {  ProtocolVersion  protoVersion =   cluster . manager . protocolVersion  ( ) ;   int  fetchSize =  statement . getFetchSize  ( ) ;  if  (  protoVersion ==  ProtocolVersion . V1 )  {  assert  pagingState == null ;  if  (  fetchSize <= 0 )   fetchSize =  - 1 ; else  if  (  fetchSize !=  Integer . MAX_VALUE )  throw  new UnsupportedFeatureException  ( protoVersion , "Paging is not supported" ) ; } else  if  (  fetchSize <= 0 )  {   fetchSize =    configuration  ( ) . getQueryOptions  ( ) . getFetchSize  ( ) ; }  if  (  fetchSize ==  Integer . MAX_VALUE )   fetchSize =  - 1 ;  if  (  statement instanceof RegularStatement )  {  RegularStatement  rs =  ( RegularStatement ) statement ;  if  (   protoVersion ==  ProtocolVersion . V1 &&  rs instanceof      com . datastax . driver . core . querybuilder . BuiltStatement )    (  (      com . datastax . driver . core . querybuilder . BuiltStatement ) rs ) . setForceNoValues  ( true ) ;   ByteBuffer  [ ]  rawValues =  rs . getValues  ( protoVersion ) ;  if  (   protoVersion ==  ProtocolVersion . V1 &&  rawValues != null )  throw  new UnsupportedFeatureException  ( protoVersion , "Binary values are not supported" ) ;   List  < ByteBuffer >  values =   rawValues == null ?  Collections .  < ByteBuffer > emptyList  ( ) :  Arrays . asList  ( rawValues ) ;  String  qString =  rs . getQueryString  ( ) ;   Requests . QueryProtocolOptions  options =  new  Requests . QueryProtocolOptions  ( cl , values , false , fetchSize , pagingState , scl , defaultTimestamp ) ;  return  new  Requests . Query  ( qString , options ) ; } else  if  (  statement instanceof BoundStatement )  {  BoundStatement  bs =  ( BoundStatement ) statement ;   bs . ensureAllSet  ( ) ;  boolean  skipMetadata =   protoVersion !=  ProtocolVersion . V1 &&     bs . statement . getPreparedId  ( ) . resultSetMetadata != null ;   Requests . QueryProtocolOptions  options =  new  Requests . QueryProtocolOptions  ( cl ,  Arrays . asList  (   bs . wrapper . values ) , skipMetadata , fetchSize , pagingState , scl , defaultTimestamp ) ;  return  new  Requests . Execute  (    bs . statement . getPreparedId  ( ) . id , options ) ; } else  {  assert  statement instanceof BatchStatement : statement ;  assert  pagingState == null ;  if  (  protoVersion ==  ProtocolVersion . V1 )  throw  new UnsupportedFeatureException  ( protoVersion , "Protocol level batching is not supported" ) ;  BatchStatement  bs =  ( BatchStatement ) statement ;   bs . ensureAllSet  ( ) ;   BatchStatement . IdAndValues  idAndVals =  bs . getIdAndValues  ( protoVersion ) ;   Requests . BatchProtocolOptions  options =  new  Requests . BatchProtocolOptions  ( cl , scl , defaultTimestamp ) ;  return  new  Requests . Batch  (  bs . batchType ,  idAndVals . ids ,  idAndVals . values , options ) ; } }  void execute  (   RequestHandler . Callback callback ,  Statement statement )  {  if  (  ! isInit )   init  ( ) ;    new RequestHandler  ( this , callback , statement ) . sendRequest  ( ) ; }   private void prepare  (  String query ,  InetSocketAddress toExclude )  throws InterruptedException  {  for (   Map . Entry  < Host , HostConnectionPool > entry :  pools . entrySet  ( ) )  {  if  (    entry . getKey  ( ) . getSocketAddress  ( ) . equals  ( toExclude ) )  continue ;  PooledConnection  c = null ;  boolean  timedOut = false ;  try  {   c =   entry . getValue  ( ) . borrowConnection  ( 200 ,  TimeUnit . MILLISECONDS ) ;    c . write  (  new  Requests . Prepare  ( query ) ) . get  ( ) ; }  catch (   ConnectionException e )  { }  catch (   BusyConnectionException e )  { }  catch (   TimeoutException e )  { }  catch (   ExecutionException e )  {   logger . error  (  String . format  ( "Unexpected error while preparing query (%s) on %s" , query ,  entry . getKey  ( ) ) , e ) ;   timedOut =   e . getCause  ( ) instanceof OperationTimedOutException ; }  finally  {  if  (   c != null &&  ! timedOut )   c . release  ( ) ; } } }  ResultSetFuture executeQuery  (   Message . Request msg ,  Statement statement )  {  if  (  statement . isTracing  ( ) )   msg . setTracingRequested  ( ) ;  DefaultResultSetFuture  future =  new DefaultResultSetFuture  ( this ,    configuration  ( ) . getProtocolOptions  ( ) . getProtocolVersionEnum  ( ) , msg ) ;   execute  ( future , statement ) ;  return future ; }   private static class State  implements   Session . State  {   private final SessionManager  session ;   private final  List  < Host >  connectedHosts ;   private final   int  [ ]  openConnections ;   private final   int  [ ]  inFlightQueries ;   private State  (  SessionManager session )  {    this . session = session ;    this . connectedHosts =  ImmutableList . copyOf  (   session . pools . keySet  ( ) ) ;    this . openConnections =  new  int  [  connectedHosts . size  ( ) ] ;    this . inFlightQueries =  new  int  [  connectedHosts . size  ( ) ] ;   int  i = 0 ;  for ( Host h : connectedHosts )  {  HostConnectionPool  p =   session . pools . get  ( h ) ;  if  (  p == null )  {    openConnections [ i ] = 0 ;    inFlightQueries [ i ] = 0 ;  continue ; }    openConnections [ i ] =  p . opened  ( ) ;    inFlightQueries [ i ] =  p . inFlightQueriesCount  ( ) ;   i ++ ; } }   private  int getIdx  (  Host h )  {  for (   int  i = 0 ;  i <  connectedHosts . size  ( ) ;  i ++ )  if  (  h ==  connectedHosts . get  ( i ) )  return i ;  return  - 1 ; }   public Session getSession  ( )  {  return session ; }   public  Collection  < Host > getConnectedHosts  ( )  {  return connectedHosts ; }   public  int getOpenConnections  (  Host host )  {   int  i =  getIdx  ( host ) ;  return   i < 0 ? 0 :  openConnections [ i ] ; }   public  int getInFlightQueries  (  Host host )  {   int  i =  getIdx  ( host ) ;  return   i < 0 ? 0 :  inFlightQueries [ i ] ; } } }