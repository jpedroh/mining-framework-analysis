  package    com . datastax . driver . core ;   import   java . net . InetAddress ;  import   java . nio . ByteBuffer ;  import   java . util . concurrent .  * ;  import     java . util . concurrent . atomic . AtomicReference ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import   java . util . Arrays ;  import   java . util . Collection ;  import   java . util . Map ;  import     com . google . common . util . concurrent .  * ;  import      com . datastax . driver . core . exceptions . AuthenticationException ;  import      com . datastax . driver . core . exceptions . DriverInternalError ;  import      com . datastax . driver . core . policies . LoadBalancingPolicy ;  import      com . datastax . driver . core . policies . ReconnectionPolicy ;  class SessionManager  implements  Session  {   private static final Logger  logger =  LoggerFactory . getLogger  (  Session . class ) ;   final Cluster  cluster ;   final  ConcurrentMap  < Host , HostConnectionPool >  pools ;   final  HostConnectionPool . PoolState  poolsState ;   final  AtomicReference  < ShutdownFuture >  shutdownFuture =  new  AtomicReference  < ShutdownFuture >  ( ) ;  SessionManager  (  Cluster cluster ,   Collection  < Host > hosts )  {    this . cluster = cluster ;    this . pools =  new  ConcurrentHashMap  < Host , HostConnectionPool >  (  hosts . size  ( ) ) ;    this . poolsState =  new  HostConnectionPool . PoolState  ( ) ;  for ( Host host : hosts )  {  try  {    addOrRenewPool  ( host , false ) . get  ( ) ; }  catch (   ExecutionException e )  {  throw  new DriverInternalError  ( e ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; } } }   public ResultSet execute  (  String query )  {  return  execute  (  new SimpleStatement  ( query ) ) ; }   public ResultSet execute  (  String query ,  Object ...  values )  {  return  execute  (  new SimpleStatement  ( query , values ) ) ; }   public ResultSet execute  (  Statement statement )  {  return   executeAsync  ( statement ) . getUninterruptibly  ( ) ; }   public ResultSetFuture executeAsync  (  String query )  {  return  executeAsync  (  new SimpleStatement  ( query ) ) ; }   public ResultSetFuture executeAsync  (  String query ,  Object ...  values )  {  return  executeAsync  (  new SimpleStatement  ( query , values ) ) ; }   public ResultSetFuture executeAsync  (  Statement statement )  {  return  executeQuery  (  makeRequestMessage  ( statement , null ) , statement ) ; }   public PreparedStatement prepare  (  String query )  {   Connection . Future  future =  new  Connection . Future  (  new  Requests . Prepare  ( query ) ) ;   execute  ( future ,  Statement . DEFAULT ) ;  return  toPreparedStatement  ( query , future ) ; }   public PreparedStatement prepare  (  RegularStatement statement )  {  if  (   statement . getValues  ( ) != null )  throw  new IllegalArgumentException  ( "A statement to prepare should not have values" ) ;  PreparedStatement  prepared =  prepare  (  statement . toString  ( ) ) ;  ByteBuffer  routingKey =  statement . getRoutingKey  ( ) ;  if  (  routingKey != null )   prepared . setRoutingKey  ( routingKey ) ;   prepared . setConsistencyLevel  (  statement . getConsistencyLevel  ( ) ) ;  if  (  statement . isTracing  ( ) )   prepared . enableTracing  ( ) ;   prepared . setRetryPolicy  (  statement . getRetryPolicy  ( ) ) ;  return prepared ; }   public ShutdownFuture shutdown  ( )  {  ShutdownFuture  future =  shutdownFuture . get  ( ) ;  if  (  future != null )  return future ;   List  < ShutdownFuture >  futures =  new  ArrayList  < ShutdownFuture >  (  pools . size  ( ) ) ;  for ( HostConnectionPool pool :  pools . values  ( ) )   futures . add  (  pool . shutdown  ( ) ) ;   future =  new  ShutdownFuture . Forwarding  ( futures ) ;  return   shutdownFuture . compareAndSet  ( null , future ) ? future :  shutdownFuture . get  ( ) ; }   public Cluster getCluster  ( )  {  return cluster ; }   private PreparedStatement toPreparedStatement  (  String query ,   Connection . Future future )  {  try  {   Message . Response  response =  Uninterruptibles . getUninterruptibly  ( future ) ;  switch  (  response . type )  {   case RESULT :   Responses . Result  rm =  (  Responses . Result ) response ;  switch  (  rm . kind )  {   case PREPARED :    Responses . Result . Prepared  pmsg =  (   Responses . Result . Prepared ) rm ;  DefaultPreparedStatement  stmt =  DefaultPreparedStatement . fromMessage  ( pmsg ,  cluster . getMetadata  ( ) , query ,  poolsState . keyspace ) ;  try  {    cluster . manager . prepare  ( stmt ,  future . getAddress  ( ) ) ; }  catch (   InterruptedException e )  {    Thread . currentThread  ( ) . interrupt  ( ) ; }  return stmt ;   default :  throw  new DriverInternalError  (  String . format  ( "%s response received when prepared statement was expected" ,  rm . kind ) ) ; }   case ERROR :  throw   (  (  Responses . Error ) response ) . asException  (  future . getAddress  ( ) ) ;  break ;   default :  throw  new DriverInternalError  (  String . format  ( "%s response received when prepared statement was expected" ,  response . type ) ) ; } }  catch (   ExecutionException e )  {  throw  DefaultResultSetFuture . extractCauseFromExecutionException  ( e ) ; } }   Connection . Factory connectionFactory  ( )  {  return   cluster . manager . connectionFactory ; }  Configuration configuration  ( )  {  return   cluster . manager . configuration ; }  LoadBalancingPolicy loadBalancingPolicy  ( )  {  return   cluster . manager . loadBalancingPolicy  ( ) ; }  ReconnectionPolicy reconnectionPolicy  ( )  {  return   cluster . manager . reconnectionPolicy  ( ) ; }  ListeningExecutorService executor  ( )  {  return   cluster . manager . executor ; }  ListeningExecutorService blockingExecutor  ( )  {  return   cluster . manager . blockingTasksExecutor ; }  boolean isShutdown  ( )  {  return   shutdownFuture . get  ( ) != null ; }   ListenableFuture  < Boolean > addOrRenewPool  (   final Host host ,   final boolean isHostAddition )  {   final HostDistance  distance =    cluster . manager . loadBalancingPolicy  ( ) . distance  ( host ) ;  if  (  distance ==  HostDistance . IGNORED )  return  Futures . immediateFuture  ( true ) ;  return   executor  ( ) . submit  (  new  Callable  < Boolean >  ( )  {   public Boolean call  ( )  {   logger . debug  ( "Adding {} to list of queried hosts" , host ) ;  try  {  HostConnectionPool  previous =  pools . put  ( host ,  new HostConnectionPool  ( host , distance ,  SessionManager . this ) ) ;  if  (  previous != null )   previous . shutdown  ( ) ;  return true ; }  catch (   AuthenticationException e )  {   logger . error  ( "Error creating pool to {} ({})" , host ,  e . getMessage  ( ) ) ;    cluster . manager . signalConnectionFailure  ( host ,  new ConnectionException  (  e . getHost  ( ) ,  e . getMessage  ( ) ) , isHostAddition ) ;  return false ; }  catch (   ConnectionException e )  {   logger . debug  ( "Error creating pool to {} ({})" , host ,  e . getMessage  ( ) ) ;    cluster . manager . signalConnectionFailure  ( host , e , isHostAddition ) ;  return false ; } } } ) ; }   ListenableFuture  <  ? > removePool  (  Host host )  {   final HostConnectionPool  pool =  pools . remove  ( host ) ;  if  (  pool == null )  return  Futures . immediateFuture  ( null ) ;  return   executor  ( ) . submit  (  new Runnable  ( )  {   public void run  ( )  {   pool . shutdown  ( ) ; } } ) ; }  void updateCreatedPools  ( )  {  for ( Host h :   cluster . getMetadata  ( ) . allHosts  ( ) )  {  HostDistance  dist =   loadBalancingPolicy  ( ) . distance  ( h ) ;  HostConnectionPool  pool =  pools . get  ( h ) ;  if  (  pool == null )  {  if  (   dist !=  HostDistance . IGNORED &&  h . isUp  ( ) )   addOrRenewPool  ( h , false ) ; } else  if  (  dist !=  pool . hostDistance )  {  if  (  dist ==  HostDistance . IGNORED )  {   removePool  ( h ) ; } else  {    pool . hostDistance = dist ; } } } }  void onDown  (  Host host )  {    removePool  ( host ) . addListener  (  new Runnable  ( )  {   public void run  ( )  {   updateCreatedPools  ( ) ; } } ,  MoreExecutors . sameThreadExecutor  ( ) ) ; }  void onRemove  (  Host host )  {   onDown  ( host ) ; }  void setKeyspace  (  String keyspace )  {   long  timeout =    configuration  ( ) . getSocketOptions  ( ) . getConnectTimeoutMillis  ( ) ;  try  {   Future  <  ? >  future =  executeQuery  (  new  Requests . Query  (  "use " + keyspace ) ,  Statement . DEFAULT ) ;   Uninterruptibles . getUninterruptibly  ( future , timeout ,  TimeUnit . MILLISECONDS ) ; }  catch (   TimeoutException e )  {  throw  new DriverInternalError  (  String . format  ( "No responses after %d milliseconds while setting current keyspace. This should not happen, unless you have setup a very low connection timeout." , timeout ) ) ; }  catch (   ExecutionException e )  {  throw  DefaultResultSetFuture . extractCauseFromExecutionException  ( e ) ; } }   Message . Request makeRequestMessage  (  Statement statement ,  ByteBuffer pagingState )  {  ConsistencyLevel  consistency =  statement . getConsistencyLevel  ( ) ;  if  (  consistency == null )   consistency =    configuration  ( ) . getQueryOptions  ( ) . getConsistencyLevel  ( ) ;  ConsistencyLevel  serialConsistency =  statement . getSerialConsistencyLevel  ( ) ;  if  (  serialConsistency == null )   serialConsistency =    configuration  ( ) . getQueryOptions  ( ) . getSerialConsistencyLevel  ( ) ;  return  makeRequestMessage  ( statement , consistency , serialConsistency , pagingState ) ; }   Message . Request makeRequestMessage  (  Statement statement ,  ConsistencyLevel cl ,  ConsistencyLevel scl ,  ByteBuffer pagingState )  {   int  fetchSize =  statement . getFetchSize  ( ) ;  if  (  fetchSize <= 0 )   fetchSize =    configuration  ( ) . getQueryOptions  ( ) . getFetchSize  ( ) ;  if  (  fetchSize ==  Integer . MAX_VALUE )   fetchSize =  - 1 ;  if  (  statement instanceof RegularStatement )  {  RegularStatement  rs =  ( RegularStatement ) statement ;   ByteBuffer  [ ]  rawValues =  rs . getValues  ( ) ;   List  < ByteBuffer >  values =   rawValues == null ?  Collections .  < ByteBuffer > emptyList  ( ) :  Arrays . asList  ( rawValues ) ;  String  qString =  rs . getQueryString  ( ) ;   Requests . QueryProtocolOptions  options =  new  Requests . QueryProtocolOptions  ( cl , values , false , fetchSize , pagingState , scl ) ;  return  new  Requests . Query  ( qString , options ) ; } else  if  (  statement instanceof BoundStatement )  {  BoundStatement  bs =  ( BoundStatement ) statement ;  boolean  skipMetadata =     bs . statement . getPreparedId  ( ) . resultSetMetadata != null ;   Requests . QueryProtocolOptions  options =  new  Requests . QueryProtocolOptions  ( cl ,  Arrays . asList  (  bs . values ) , skipMetadata , fetchSize , pagingState , scl ) ;  return  new  Requests . Execute  (    bs . statement . getPreparedId  ( ) . id , options ) ; } else  {  assert  statement instanceof BatchStatement : statement ;  assert  pagingState == null ;  BatchStatement  bs =  ( BatchStatement ) statement ;   BatchStatement . IdAndValues  idAndVals =  bs . getIdAndValues  ( ) ;  return  new  Requests . Batch  (  bs . batchType ,  idAndVals . ids ,  idAndVals . values , cl ) ; } }  void execute  (   RequestHandler . Callback callback ,  Statement statement )  {    new RequestHandler  ( this , callback , statement ) . sendRequest  ( ) ; }  void prepare  (  String query ,  InetAddress toExclude )  throws InterruptedException  {  for (   Map . Entry  < Host , HostConnectionPool > entry :  pools . entrySet  ( ) )  {  if  (    entry . getKey  ( ) . getAddress  ( ) . equals  ( toExclude ) )  continue ;  Connection  c = null ;  try  {   c =   entry . getValue  ( ) . borrowConnection  ( 200 ,  TimeUnit . MILLISECONDS ) ;    c . write  (  new  Requests . Prepare  ( query ) ) . get  ( ) ; }  catch (   ConnectionException e )  { }  catch (   BusyConnectionException e )  { }  catch (   TimeoutException e )  { }  catch (   ExecutionException e )  {   logger . error  (  String . format  ( "Unexpected error while preparing query (%s) on %s" , query ,  entry . getKey  ( ) ) , e ) ; }  finally  {  if  (  c != null )    entry . getValue  ( ) . returnConnection  ( c ) ; } } }  ResultSetFuture executeQuery  (   Message . Request msg ,  Statement statement )  {  if  (  statement . isTracing  ( ) )   msg . setTracingRequested  ( ) ;  DefaultResultSetFuture  future =  new DefaultResultSetFuture  ( this , msg ) ;   execute  ( future , statement ) ;  return future ; } }