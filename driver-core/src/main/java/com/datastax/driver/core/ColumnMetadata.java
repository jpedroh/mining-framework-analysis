  package    com . datastax . driver . core ;   import   java . util . HashMap ;  import   java . util . Map ;   public class ColumnMetadata  {   private static final String  COLUMN_NAME = "column_name" ;   private static final String  VALIDATOR = "validator" ;   private static final String  COMPONENT_INDEX = "component_index" ;   private static final String  KIND = "type" ;   private static final String  INDEX_TYPE = "index_type" ;   private static final String  INDEX_OPTIONS = "index_options" ;   private static final String  INDEX_NAME = "index_name" ;   private static final String  CUSTOM_INDEX_CLASS = "class_name" ;   private final TableMetadata  table ;   private final String  name ;   private final DataType  type ;   private final IndexMetadata  index ;   private ColumnMetadata  (  TableMetadata table ,  String name ,  DataType type ,   Map  < String , String > indexColumns )  {    this . table = table ;    this . name = name ;    this . type = type ;    this . index =  IndexMetadata . build  ( this , indexColumns ) ; }   static ColumnMetadata fromRaw  (  TableMetadata tm ,  Raw raw )  {  return  new ColumnMetadata  ( tm ,  raw . name ,  raw . dataType ,  raw . indexColumns ) ; }   public String getName  ( )  {  return name ; }   public TableMetadata getTable  ( )  {  return table ; }   public DataType getType  ( )  {  return type ; }   public IndexMetadata getIndex  ( )  {  return index ; }   public static class IndexMetadata  {   private final ColumnMetadata  column ;   private final String  name ;   private final String  customClassName ;   private IndexMetadata  (  ColumnMetadata column ,  String name ,  String customClassName )  {    this . column = column ;    this . name = name ;    this . customClassName = customClassName ; }   public ColumnMetadata getIndexedColumn  ( )  {  return column ; }   public String getName  ( )  {  return name ; }   public boolean isCustomIndex  ( )  {  return  customClassName != null ; }   public String getIndexClassName  ( )  {  return customClassName ; }   public String asCQLQuery  ( )  {  TableMetadata  table =  column . getTable  ( ) ;  String  ksName =  TableMetadata . escapeId  (   table . getKeyspace  ( ) . getName  ( ) ) ;  String  cfName =  TableMetadata . escapeId  (  table . getName  ( ) ) ;  String  colName =  TableMetadata . escapeId  (  column . getName  ( ) ) ;  return   isCustomIndex  ( ) ?  String . format  ( "CREATE CUSTOM INDEX %s ON %s.%s (%s) USING '%s';" , name , ksName , cfName , colName , customClassName ) :  String . format  ( "CREATE INDEX %s ON %s.%s (%s);" , name , ksName , cfName , colName ) ; }   private static IndexMetadata build  (  ColumnMetadata column ,   Map  < String , String > indexColumns )  {  if  (  indexColumns . isEmpty  ( ) )  return null ;  String  type =  indexColumns . get  ( INDEX_TYPE ) ;  if  (  type == null )  return null ;  if  (   !  type . equalsIgnoreCase  ( "CUSTOM" ) ||  !  indexColumns . containsKey  ( INDEX_OPTIONS ) )  return  new IndexMetadata  ( column ,  indexColumns . get  ( INDEX_NAME ) , null ) ;   Map  < String , String >  indexOptions =  TableMetadata . fromJsonMap  (  indexColumns . get  ( INDEX_OPTIONS ) ) ;  return  new IndexMetadata  ( column ,  indexColumns . get  ( INDEX_NAME ) ,  indexOptions . get  ( CUSTOM_INDEX_CLASS ) ) ; } }    @ Override public String toString  ( )  {  return    TableMetadata . escapeId  ( name ) + " " + type ; }   static class Raw  {   public enum Kind  {  PARTITION_KEY ,  CLUSTERING_KEY ,  REGULAR ,  COMPACT_VALUE }   public final String  name ;   public final Kind  kind ;   public final  int  componentIndex ;   public final DataType  dataType ;   public final boolean  isReversed ;   public final  Map  < String , String >  indexColumns =  new  HashMap  < String , String >  ( ) ;  Raw  (  String name ,  Kind kind ,   int componentIndex ,  DataType dataType ,  boolean isReversed )  {    this . name = name ;    this . kind = kind ;    this . componentIndex = componentIndex ;    this . dataType = dataType ;    this . isReversed = isReversed ; }   static Raw fromRow  (  Row row )  {  String  name =  row . getString  ( COLUMN_NAME ) ;  Kind  kind =   row . isNull  ( KIND ) ?  Kind . REGULAR :  Enum . valueOf  (  Kind . class ,   row . getString  ( KIND ) . toUpperCase  ( ) ) ;   int  componentIndex =   row . isNull  ( COMPONENT_INDEX ) ? 0 :  row . getInt  ( COMPONENT_INDEX ) ;  String  validatorStr =  row . getString  ( VALIDATOR ) ;  boolean  reversed =  CassandraTypeParser . isReversed  ( validatorStr ) ;  DataType  dataType =  CassandraTypeParser . parseOne  ( validatorStr ) ;  Raw  c =  new Raw  ( name , kind , componentIndex , dataType , reversed ) ;  for ( String str :  Arrays . asList  ( INDEX_TYPE , INDEX_NAME , INDEX_OPTIONS ) )  if  (  !  row . isNull  ( str ) )    c . indexColumns . put  ( str ,  row . getString  ( str ) ) ;  return c ; } } }