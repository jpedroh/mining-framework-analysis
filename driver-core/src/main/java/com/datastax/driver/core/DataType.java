  package    com . datastax . driver . core ;   import   java . nio . ByteBuffer ;  import   java . math . BigDecimal ;  import   java . math . BigInteger ;  import   java . net . InetAddress ;  import     org . jboss . netty . buffer . ChannelBuffer ;  import     com . google . common . base . Objects ;  import     com . google . common . collect . ImmutableList ;  import     com . google . common . collect . ImmutableSet ;  import      com . datastax . driver . core . exceptions . DriverInternalError ;  import      com . datastax . driver . core . exceptions . InvalidTypeException ;  import  java . util .  * ;   public class DataType  {   public enum Name  {  ASCII  ( 1 ,  String . class ) ,  BIGINT  ( 2 ,  Long . class ) ,  BLOB  ( 3 ,  ByteBuffer . class ) ,  BOOLEAN  ( 4 ,  Boolean . class ) ,  COUNTER  ( 5 ,  Long . class ) ,  DECIMAL  ( 6 ,  BigDecimal . class ) ,  DOUBLE  ( 7 ,  Double . class ) ,  FLOAT  ( 8 ,  Float . class ) ,  INET  ( 16 ,  InetAddress . class ) ,  INT  ( 9 ,  Integer . class ) ,  TEXT  ( 10 ,  String . class ) ,  TIMESTAMP  ( 11 ,  Date . class ) ,  UUID  ( 12 ,  UUID . class ) ,  VARCHAR  ( 13 ,  String . class ) ,  VARINT  ( 14 ,  BigInteger . class ) ,  TIMEUUID  ( 15 ,  UUID . class ) ,  LIST  ( 32 ,  List . class ) ,  SET  ( 34 ,  Set . class ) ,  MAP  ( 33 ,  Map . class ) ,  CUSTOM  ( 0 ,  ByteBuffer . class )  ;   final  int  protocolId ;   final  Class  <  ? >  javaType ;   private static final  Name  [ ]  nameToIds ;  static  {   int  maxCode =  - 1 ;  for ( Name name :  Name . values  ( ) )   maxCode =  Math . max  ( maxCode ,  name . protocolId ) ;   nameToIds =  new Name  [  maxCode + 1 ] ;  for ( Name name :  Name . values  ( ) )  {  if  (   nameToIds [  name . protocolId ] != null )  throw  new IllegalStateException  ( "Duplicate Id" ) ;    nameToIds [  name . protocolId ] = name ; } }   private Name  (   int protocolId ,   Class  <  ? > javaType )  {    this . protocolId = protocolId ;    this . javaType = javaType ; }   static Name fromProtocolId  (   int id )  {  Name  name =  nameToIds [ id ] ;  if  (  name == null )  throw  new DriverInternalError  (  "Unknown data type protocol id: " + id ) ;  return name ; }   public boolean isCollection  ( )  {  switch  ( this )  {   case LIST :   case SET :   case MAP :  return true ;   default :  return false ; } }   public  Class  <  ? > asJavaClass  ( )  {  return javaType ; }    @ Override public String toString  ( )  {  return   super . toString  ( ) . toLowerCase  ( ) ; } }   private final  DataType . Name  name ;   private final  List  < DataType >  typeArguments ;   private final String  customClassName ;   private final  TypeCodec  <  ? >  codec ;   private static final  Map  < Name , DataType >  primitiveTypeMap =  new  EnumMap  < Name , DataType >  (  Name . class ) ;  static  {  for ( Name name :  Name . values  ( ) )  {  if  (   !  name . isCollection  ( ) &&  name !=  Name . CUSTOM )   primitiveTypeMap . put  ( name ,  new DataType  ( name ,  Collections .  < DataType > emptyList  ( ) ,  TypeCodec . createFor  ( name ) ) ) ; } }   private static final  Set  < DataType >  primitiveTypeSet =  ImmutableSet . copyOf  (  primitiveTypeMap . values  ( ) ) ;   private DataType  (   DataType . Name name ,   List  < DataType > typeArguments ,   TypeCodec  <  ? > codec )  {  this  ( name , typeArguments , null , codec ) ; }   private DataType  (   DataType . Name name ,   List  < DataType > typeArguments ,  String customClassName ,   TypeCodec  <  ? > codec )  {    this . name = name ;    this . typeArguments = typeArguments ;    this . customClassName = customClassName ;    this . codec = codec ; }   static DataType decode  (  ChannelBuffer buffer )  {  Name  name =  Name . fromProtocolId  (  buffer . readUnsignedShort  ( ) ) ;  switch  ( name )  {   case CUSTOM :  return  custom  (  CBUtil . readString  ( buffer ) ) ;   case LIST :  return  list  (  decode  ( buffer ) ) ;   case SET :  return  set  (  decode  ( buffer ) ) ;   case MAP :  DataType  keys =  decode  ( buffer ) ;  DataType  values =  decode  ( buffer ) ;  return  map  ( keys , values ) ;   default :  return  primitiveTypeMap . get  ( name ) ; } }    @ SuppressWarnings  ( "unchecked" )  TypeCodec  < Object > codec  ( )  {  return  (  TypeCodec  < Object > ) codec ; }   public static DataType ascii  ( )  {  return  primitiveTypeMap . get  (  Name . ASCII ) ; }   public static DataType bigint  ( )  {  return  primitiveTypeMap . get  (  Name . BIGINT ) ; }   public static DataType blob  ( )  {  return  primitiveTypeMap . get  (  Name . BLOB ) ; }   public static DataType cboolean  ( )  {  return  primitiveTypeMap . get  (  Name . BOOLEAN ) ; }   public static DataType counter  ( )  {  return  primitiveTypeMap . get  (  Name . COUNTER ) ; }   public static DataType decimal  ( )  {  return  primitiveTypeMap . get  (  Name . DECIMAL ) ; }   public static DataType cdouble  ( )  {  return  primitiveTypeMap . get  (  Name . DOUBLE ) ; }   public static DataType cfloat  ( )  {  return  primitiveTypeMap . get  (  Name . FLOAT ) ; }   public static DataType inet  ( )  {  return  primitiveTypeMap . get  (  Name . INET ) ; }   public static DataType cint  ( )  {  return  primitiveTypeMap . get  (  Name . INT ) ; }   public static DataType text  ( )  {  return  primitiveTypeMap . get  (  Name . TEXT ) ; }   public static DataType timestamp  ( )  {  return  primitiveTypeMap . get  (  Name . TIMESTAMP ) ; }   public static DataType uuid  ( )  {  return  primitiveTypeMap . get  (  Name . UUID ) ; }   public static DataType varchar  ( )  {  return  primitiveTypeMap . get  (  Name . VARCHAR ) ; }   public static DataType varint  ( )  {  return  primitiveTypeMap . get  (  Name . VARINT ) ; }   public static DataType timeuuid  ( )  {  return  primitiveTypeMap . get  (  Name . TIMEUUID ) ; }   public static DataType list  (  DataType elementType )  {  return  new DataType  (  Name . LIST ,  ImmutableList . of  ( elementType ) ,  TypeCodec . listOf  ( elementType ) ) ; }   public static DataType set  (  DataType elementType )  {  return  new DataType  (  Name . SET ,  ImmutableList . of  ( elementType ) ,  TypeCodec . setOf  ( elementType ) ) ; }   public static DataType map  (  DataType keyType ,  DataType valueType )  {  return  new DataType  (  Name . MAP ,  ImmutableList . of  ( keyType , valueType ) ,  TypeCodec . mapOf  ( keyType , valueType ) ) ; }   public static DataType custom  (  String typeClassName )  {  if  (  typeClassName == null )  throw  new NullPointerException  ( ) ;  return  new DataType  (  Name . CUSTOM ,  Collections .  < DataType > emptyList  ( ) , typeClassName ,  TypeCodec . createFor  (  Name . CUSTOM ) ) ; }   public Name getName  ( )  {  return name ; }   public  List  < DataType > getTypeArguments  ( )  {  return typeArguments ; }   public String getCustomTypeClassName  ( )  {  return customClassName ; }   public ByteBuffer parse  (  String value )  {  if  (  name ==  Name . CUSTOM )  throw  new InvalidTypeException  (  String . format  (  "Cannot parse '%s' as value of custom type of class '%s' " + "(values for custom type cannot be parse and must be inputed as bytes directly)" , value , customClassName ) ) ;  if  (  name . isCollection  ( ) )  throw  new InvalidTypeException  (  String . format  ( "Cannot parse value as %s, parsing collections is not currently supported" , name ) ) ;  return   codec  ( ) . serialize  (  codec . parse  ( value ) ) ; }   public boolean isCollection  ( )  {  return  name . isCollection  ( ) ; }   public  Class  <  ? > asJavaClass  ( )  {  return   getName  ( ) . asJavaClass  ( ) ; }   public static  Set  < DataType > allPrimitiveTypes  ( )  {  return primitiveTypeSet ; }   public ByteBuffer serialize  (  Object value )  {   Class  <  ? >  providedClass =  value . getClass  ( ) ;   Class  <  ? >  expectedClass =  asJavaClass  ( ) ;  if  (  !  expectedClass . isAssignableFrom  ( providedClass ) )  throw  new InvalidTypeException  (  String . format  ( "Invalid value for CQL type %s, expecting %s but %s provided" ,  toString  ( ) , expectedClass , providedClass ) ) ;  try  {  return   codec  ( ) . serialize  ( value ) ; }  catch (   ClassCastException e )  {  throw  new InvalidTypeException  (  "Invalid type for collection element: " +  e . getMessage  ( ) ) ; } }   public Object deserialize  (  ByteBuffer bytes )  {  return   codec  ( ) . deserialize  ( bytes ) ; }   public static ByteBuffer serializeValue  (  Object value )  {  if  (  value == null )  return null ;  DataType  dt =  TypeCodec . getDataTypeFor  ( value ) ;  if  (  dt == null )  throw  new IllegalArgumentException  (  String . format  ( "Value of type %s does not correspond to any CQL3 type" ,  value . getClass  ( ) ) ) ;  try  {  return  dt . serialize  ( value ) ; }  catch (   InvalidTypeException e )  {  throw  new IllegalArgumentException  (  e . getMessage  ( ) ) ; } }    @ Override public final  int hashCode  ( )  {  return  Arrays . hashCode  (  new Object  [ ]  { name , typeArguments , customClassName } ) ; }    @ Override public final boolean equals  (  Object o )  {  if  (  !  (  o instanceof DataType ) )  return false ;  DataType  d =  ( DataType ) o ;  return    name ==  d . name &&  typeArguments . equals  (  d . typeArguments ) &&  Objects . equal  ( customClassName ,  d . customClassName ) ; }    @ Override public String toString  ( )  {  switch  ( name )  {   case LIST :   case SET :  return  String . format  ( "%s<%s>" , name ,  typeArguments . get  ( 0 ) ) ;   case MAP :  return  String . format  ( "%s<%s, %s>" , name ,  typeArguments . get  ( 0 ) ,  typeArguments . get  ( 1 ) ) ;   case CUSTOM :  return  String . format  ( "'%s'" , customClassName ) ;   default :  return  name . toString  ( ) ; } } }