  package     com . datastax . driver . core . utils ;   import     com . google . common . base . Charsets ;  import   java . net . InetAddress ;  import   java . net . NetworkInterface ;  import   java . net . UnknownHostException ;  import   java . net . SocketException ;  import   java . security . MessageDigest ;  import   java . security . NoSuchAlgorithmException ;  import     java . util . concurrent . atomic . AtomicLong ;  import  java . util .  * ;   public final class UUIDs  {   private UUIDs  ( )  { } ;   private static final  long  START_EPOCH =  makeEpoch  ( ) ;   private static final  long  CLOCK_SEQ_AND_NODE =  makeClockSeqAndNode  ( ) ;   private static final  long  MIN_CLOCK_SEQ_AND_NODE = 0x8080808080808080L ;   private static final  long  MAX_CLOCK_SEQ_AND_NODE = 0x7f7f7f7f7f7f7f7fL ;   private static final AtomicLong  lastTimestamp =  new AtomicLong  ( 0L ) ;   private static  long makeEpoch  ( )  {  Calendar  c =  Calendar . getInstance  (  TimeZone . getTimeZone  ( "GMT-0" ) ) ;   c . set  (  Calendar . YEAR , 1582 ) ;   c . set  (  Calendar . MONTH ,  Calendar . OCTOBER ) ;   c . set  (  Calendar . DAY_OF_MONTH , 15 ) ;   c . set  (  Calendar . HOUR_OF_DAY , 0 ) ;   c . set  (  Calendar . MINUTE , 0 ) ;   c . set  (  Calendar . SECOND , 0 ) ;   c . set  (  Calendar . MILLISECOND , 0 ) ;  return  c . getTimeInMillis  ( ) ; }   private static  long makeNode  ( )  {  try  {  MessageDigest  digest =  MessageDigest . getInstance  ( "MD5" ) ;  for ( String address :  getAllLocalAddresses  ( ) )   update  ( digest , address ) ;  Properties  props =  System . getProperties  ( ) ;   update  ( digest ,  props . getProperty  ( "java.vendor" ) ) ;   update  ( digest ,  props . getProperty  ( "java.vendor.url" ) ) ;   update  ( digest ,  props . getProperty  ( "java.version" ) ) ;   update  ( digest ,  props . getProperty  ( "os.arch" ) ) ;   update  ( digest ,  props . getProperty  ( "os.name" ) ) ;   update  ( digest ,  props . getProperty  ( "os.version" ) ) ;    byte  [ ]  hash =  digest . digest  ( ) ;   long  node = 0 ;  for (   int  i = 0 ;  i < 6 ;  i ++ )   node |=   (  0x00000000000000ffL &  (  long )  hash [ i ] ) <<  (  i * 8 ) ;  return  node | 0x0000010000000000L ; }  catch (   NoSuchAlgorithmException e )  {  throw  new RuntimeException  ( e ) ; } }   private static void update  (  MessageDigest digest ,  String value )  {  if  (  value != null )   digest . update  (  value . getBytes  (  Charsets . UTF_8 ) ) ; }   private static  long makeClockSeqAndNode  ( )  {   long  clock =   new Random  (  System . currentTimeMillis  ( ) ) . nextLong  ( ) ;   long  node =  makeNode  ( ) ;   long  lsb = 0 ;   lsb |=   (  clock & 0x0000000000003FFFL ) << 48 ;   lsb |= 0x8000000000000000L ;   lsb |= node ;  return lsb ; }   public static UUID random  ( )  {  return  UUID . randomUUID  ( ) ; }   public static UUID timeBased  ( )  {  return  new UUID  (  makeMSB  (  getCurrentTimestamp  ( ) ) , CLOCK_SEQ_AND_NODE ) ; }   public static UUID startOf  (   long timestamp )  {  return  new UUID  (  makeMSB  (  fromUnixTimestamp  ( timestamp ) ) , MIN_CLOCK_SEQ_AND_NODE ) ; }   public static UUID endOf  (   long timestamp )  {   long  uuidTstamp =   fromUnixTimestamp  (  timestamp + 1 ) - 1 ;  return  new UUID  (  makeMSB  ( uuidTstamp ) , MAX_CLOCK_SEQ_AND_NODE ) ; }   public static  long unixTimestamp  (  UUID uuid )  {  if  (   uuid . version  ( ) != 1 )  throw  new IllegalArgumentException  (  String . format  ( "Can only retrieve the unix timestamp for version 1 uuid (provided version %d)" ,  uuid . version  ( ) ) ) ;   long  timestamp =  uuid . timestamp  ( ) ;  return   (  timestamp / 10000 ) + START_EPOCH ; }   private static  long getCurrentTimestamp  ( )  {  while  ( true )  {   long  now =  fromUnixTimestamp  (  System . currentTimeMillis  ( ) ) ;   long  last =  lastTimestamp . get  ( ) ;  if  (  now > last )  {  if  (  lastTimestamp . compareAndSet  ( last , now ) )  return now ; } else  {   long  lastMillis =  millisOf  ( last ) ;  if  (   millisOf  ( now ) <  millisOf  ( last ) )  return  lastTimestamp . incrementAndGet  ( ) ;   long  candidate =  last + 1 ;  if  (    millisOf  ( candidate ) == lastMillis &&  lastTimestamp . compareAndSet  ( last , candidate ) )  return candidate ; } } }   static  long fromUnixTimestamp  (   long tstamp )  {  return   (  tstamp - START_EPOCH ) * 10000 ; }   private static  long millisOf  (   long timestamp )  {  return  timestamp / 10000 ; }   static  long makeMSB  (   long timestamp )  {   long  msb = 0L ;   msb |=   (  0x00000000ffffffffL & timestamp ) << 32 ;   msb |=   (  0x0000ffff00000000L & timestamp ) >>> 16 ;   msb |=   (  0x0fff000000000000L & timestamp ) >>> 48 ;   msb |= 0x0000000000001000L ;  return msb ; }   private static  Set  < String > getAllLocalAddresses  ( )  {   Set  < String >  allIps =  new  HashSet  < String >  ( ) ;  try  {  InetAddress  localhost =  InetAddress . getLocalHost  ( ) ;   allIps . add  (  localhost . toString  ( ) ) ;   allIps . add  (  localhost . getCanonicalHostName  ( ) ) ;   InetAddress  [ ]  allMyIps =  InetAddress . getAllByName  (  localhost . getCanonicalHostName  ( ) ) ;  if  (  allMyIps != null )  {  for (   int  i = 0 ;  i <  allMyIps . length ;  i ++ )   allIps . add  (   allMyIps [ i ] . toString  ( ) ) ; } }  catch (   UnknownHostException e )  { }  try  {   Enumeration  < NetworkInterface >  en =  NetworkInterface . getNetworkInterfaces  ( ) ;  if  (  en != null )  {  while  (  en . hasMoreElements  ( ) )  {   Enumeration  < InetAddress >  enumIpAddr =   en . nextElement  ( ) . getInetAddresses  ( ) ;  while  (  enumIpAddr . hasMoreElements  ( ) )   allIps . add  (   enumIpAddr . nextElement  ( ) . toString  ( ) ) ; } } }  catch (   SocketException e )  { }  return allIps ; } }