  package     com . datastax . driver . core . policies ;   import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import     com . datastax . driver . core . ConsistencyLevel ;  import     com . datastax . driver . core . Query ;  import     com . datastax . driver . core . WriteType ;   public class LoggingRetryPolicy  implements  RetryPolicy  {   private static final Logger  logger =  LoggerFactory . getLogger  (  LoggingRetryPolicy . class ) ;   private final RetryPolicy  policy ;   public LoggingRetryPolicy  (  RetryPolicy policy )  {    this . policy = policy ; }   private static ConsistencyLevel cl  (  ConsistencyLevel cl ,  RetryDecision decision )  {  return    decision . getRetryConsistencyLevel  ( ) == null ? cl :  decision . getRetryConsistencyLevel  ( ) ; }    @ Override public RetryDecision onReadTimeout  (  Statement statement ,  ConsistencyLevel cl ,   int requiredResponses ,   int receivedResponses ,  boolean dataRetrieved ,   int nbRetry )  {  RetryDecision  decision =  policy . onReadTimeout  ( statement , cl , requiredResponses , receivedResponses , dataRetrieved , nbRetry ) ;  switch  (  decision . getType  ( ) )  {   case IGNORE :  String  f1 = "Ignoring read timeout (initial consistency: %s, required responses: %d, received responses: %d, data retrieved: %b, retries: %d)" ;   logger . info  (  String . format  ( f1 , cl , requiredResponses , receivedResponses , dataRetrieved , nbRetry ) ) ;  break ;   case RETRY :  String  f2 = "Retrying on read timeout at consistency %s (initial consistency: %s, required responses: %d, received responses: %d, data retrieved: %b, retries: %d)" ;   logger . info  (  String . format  ( f2 ,  cl  ( cl , decision ) , cl , requiredResponses , receivedResponses , dataRetrieved , nbRetry ) ) ;  break ; }  return decision ; }    @ Override public RetryDecision onWriteTimeout  (  Statement statement ,  ConsistencyLevel cl ,  WriteType writeType ,   int requiredAcks ,   int receivedAcks ,   int nbRetry )  {  RetryDecision  decision =  policy . onWriteTimeout  ( statement , cl , writeType , requiredAcks , receivedAcks , nbRetry ) ;  switch  (  decision . getType  ( ) )  {   case IGNORE :  String  f1 = "Ignoring write timeout (initial consistency: %s, write type: %s, required acknowledgments: %d, received acknowledgments: %d, retries: %d)" ;   logger . info  (  String . format  ( f1 , cl , writeType , requiredAcks , receivedAcks , nbRetry ) ) ;  break ;   case RETRY :  String  f2 = "Retrying on write timeout at consistency %s(initial consistency: %s, write type: %s, required acknowledgments: %d, received acknowledgments: %d, retries: %d)" ;   logger . info  (  String . format  ( f2 ,  cl  ( cl , decision ) , cl , writeType , requiredAcks , receivedAcks , nbRetry ) ) ;  break ; }  return decision ; }    @ Override public RetryDecision onUnavailable  (  Statement statement ,  ConsistencyLevel cl ,   int requiredReplica ,   int aliveReplica ,   int nbRetry )  {  RetryDecision  decision =  policy . onUnavailable  ( statement , cl , requiredReplica , aliveReplica , nbRetry ) ;  switch  (  decision . getType  ( ) )  {   case IGNORE :  String  f1 = "Ignoring unavailable exception (initial consistency: %s, required replica: %d, alive replica: %d, retries: %d)" ;   logger . info  (  String . format  ( f1 , cl , requiredReplica , aliveReplica , nbRetry ) ) ;  break ;   case RETRY :  String  f2 = "Retrying on unavailable exception at consistency %s (initial consistency: %s, required replica: %d, alive replica: %d, retries: %d)" ;   logger . info  (  String . format  ( f2 ,  cl  ( cl , decision ) , cl , requiredReplica , aliveReplica , nbRetry ) ) ;  break ; }  return decision ; } }