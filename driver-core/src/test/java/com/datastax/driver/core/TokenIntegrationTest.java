  package    com . datastax . driver . core ;   import   java . net . InetSocketAddress ;  import  java . util .  * ;  import     com . google . common . base . Function ;  import     com . google . common . collect . Iterables ;  import     com . google . common . collect . Lists ;  import    org . testng . annotations . AfterClass ;  import    org . testng . annotations . BeforeClass ;  import    org . testng . annotations . Test ;  import      com . datastax . driver . core . exceptions . InvalidTypeException ;  import      com . datastax . driver . core . policies . LoadBalancingPolicy ;  import      com . datastax . driver . core . policies . RoundRobinPolicy ;  import      com . datastax . driver . core . policies . WhiteListPolicy ;  import      com . datastax . driver . core . utils . CassandraVersion ;  import static      com . datastax . driver . core . Assertions . assertThat ;   public abstract class TokenIntegrationTest  {   List  < String >  schema =  Lists . newArrayList  ( "CREATE KEYSPACE test WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1}" , "CREATE KEYSPACE test2 WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 2}" , "USE test" , "CREATE TABLE foo(i int primary key)" , "INSERT INTO foo (i) VALUES (1)" , "INSERT INTO foo (i) VALUES (2)" , "INSERT INTO foo (i) VALUES (3)" ) ;   private final String  ccmOptions ;   private final DataType  expectedTokenType ;   private final  int  numTokens ;   private final boolean  useVnodes ;  CCMBridge  ccm ;  Cluster  cluster ;  Session  session ;   public TokenIntegrationTest  (  String ccmOptions ,  DataType expectedTokenType )  {  this  ( ccmOptions , expectedTokenType , false ) ; }   public TokenIntegrationTest  (  String ccmOptions ,  DataType expectedTokenType ,  boolean useVnodes )  {    this . expectedTokenType = expectedTokenType ;    this . numTokens =  useVnodes ? 256 : 1 ;    this . ccmOptions =  useVnodes ?  ccmOptions + " --vnodes" : ccmOptions ;    this . useVnodes = useVnodes ; }    @ BeforeClass  (  groups = "short" ) public void setup  ( )  {   ccm =  CCMBridge . create  ( "test" , 3 , ccmOptions ) ;  LoadBalancingPolicy  lbp =  new WhiteListPolicy  (  new RoundRobinPolicy  ( ) ,  Lists . newArrayList  (  new InetSocketAddress  (  CCMBridge . ipOfNode  ( 1 ) , 9042 ) ) ) ;   cluster =     Cluster . builder  ( ) . addContactPoints  (  CCMBridge . ipOfNode  ( 1 ) ) . withLoadBalancingPolicy  ( lbp ) . build  ( ) ;   cluster . init  ( ) ;   session =  cluster . connect  ( ) ;  for ( String statement : schema )   session . execute  ( statement ) ; }    @ AfterClass  (  groups = "short" ,  alwaysRun = true ) public void teardown  ( )  {  if  (  cluster != null )   cluster . close  ( ) ;  if  (  ccm != null )   ccm . remove  ( ) ; }    @ Test  (  groups = "short" ) public void should_expose_token_ranges  ( )  throws Exception  {  Metadata  metadata =  cluster . getMetadata  ( ) ;   int  testKey = 1 ;   Set  < Host >  replicas =  metadata . getReplicas  ( "test" ,   DataType . cint  ( ) . serialize  ( testKey ,    cluster . getConfiguration  ( ) . getProtocolOptions  ( ) . getProtocolVersionEnum  ( ) ) ) ;    assertThat  ( replicas ) . hasSize  ( 1 ) ;  Host  replica =   replicas . iterator  ( ) . next  ( ) ;  PreparedStatement  rangeStmt =  session . prepare  ( "SELECT i FROM foo WHERE token(i) > ? and token(i) <= ?" ) ;  TokenRange  foundRange = null ;  for ( TokenRange range :  metadata . getTokenRanges  ( ) )  {   List  < Row >  rows =  rangeQuery  ( rangeStmt , range ) ;  for ( Row row : rows )  {  if  (   row . getInt  ( "i" ) == testKey )  {     assertThat  ( foundRange ) . describedAs  (    "found the same key in two ranges: " + foundRange + " and " + range ) . isNull  ( ) ;   foundRange = range ;    assertThat  (  metadata . getReplicas  ( "test" , range ) ) . contains  ( replica ) ; } } }    assertThat  ( foundRange ) . isNotNull  ( ) ; }   private  List  < Row > rangeQuery  (  PreparedStatement rangeStmt ,  TokenRange range )  {   List  < Row >  rows =  Lists . newArrayList  ( ) ;  for ( TokenRange subRange :  range . unwrap  ( ) )  {  Statement  statement =  rangeStmt . bind  (  subRange . getStart  ( ) ,  subRange . getEnd  ( ) ) ;   rows . addAll  (   session . execute  ( statement ) . all  ( ) ) ; }  return rows ; }    @ Test  (  groups = "short" ) public void should_get_token_from_row_and_set_token_in_query  ( )  {  Row  row =   session . execute  ( "SELECT token(i) FROM test.foo WHERE i = 1" ) . one  ( ) ;  Token  token =  row . getToken  ( 0 ) ;    assertThat  (  token . getType  ( ) ) . isEqualTo  ( expectedTokenType ) ;    assertThat  (  row . getPartitionKeyToken  ( ) ) . isEqualTo  ( token ) ;  PreparedStatement  pst =  session . prepare  ( "SELECT * FROM test.foo WHERE token(i) = ?" ) ;   row =   session . execute  (  pst . bind  ( token ) ) . one  ( ) ;    assertThat  (  row . getInt  ( 0 ) ) . isEqualTo  ( 1 ) ;   row =   session . execute  (   pst . bind  ( ) . setToken  ( 0 , token ) ) . one  ( ) ;    assertThat  (  row . getInt  ( 0 ) ) . isEqualTo  ( 1 ) ;   row =   session . execute  (   pst . bind  ( ) . setPartitionKeyToken  ( token ) ) . one  ( ) ;    assertThat  (  row . getInt  ( 0 ) ) . isEqualTo  ( 1 ) ; }    @ Test  (  groups = "short" )  @ CassandraVersion  (  major = 2 ) public void should_get_token_from_row_and_set_token_in_query_with_binding_and_aliasing  ( )  {  Row  row =   session . execute  ( "SELECT token(i) AS t FROM test.foo WHERE i = 1" ) . one  ( ) ;  Token  token =  row . getToken  ( "t" ) ;    assertThat  (  token . getType  ( ) ) . isEqualTo  ( expectedTokenType ) ;  PreparedStatement  pst =  session . prepare  ( "SELECT * FROM test.foo WHERE token(i) = :myToken" ) ;   row =   session . execute  (   pst . bind  ( ) . setToken  ( "myToken" , token ) ) . one  ( ) ;    assertThat  (  row . getInt  ( 0 ) ) . isEqualTo  ( 1 ) ;   row =   session . execute  ( "SELECT * FROM test.foo WHERE token(i) = ?" , token ) . one  ( ) ;    assertThat  (  row . getInt  ( 0 ) ) . isEqualTo  ( 1 ) ; }    @ Test  (  groups = "short" ,  expectedExceptions =  InvalidTypeException . class ) public void should_raise_exception_when_get_token_on_non_token  ( )  {  Row  row =   session . execute  ( "SELECT i FROM test.foo WHERE i = 1" ) . one  ( ) ;   row . getToken  ( 0 ) ; }    @ Test  (  groups = "short" ) public void should_expose_token_ranges_per_host  ( )  {   checkRangesPerHost  ( "test" , 1 ) ;   checkRangesPerHost  ( "test2" , 2 ) ;    assertThat  ( cluster ) . hasValidTokenRanges  ( ) ; }   private void checkRangesPerHost  (  String keyspace ,   int replicationFactor )  {   List  < TokenRange >  allRangesWithReplicas =  Lists . newArrayList  ( ) ;  for (   int  i = 1 ;  i <= 3 ;  i ++ )  {  Host  host =  TestUtils . findHost  ( cluster , i ) ;   Set  < TokenRange >  hostRanges =   cluster . getMetadata  ( ) . getTokenRanges  ( keyspace , host ) ;  if  (  ! useVnodes )  {    assertThat  ( hostRanges ) . hasSize  (  replicationFactor * numTokens ) ; }   allRangesWithReplicas . addAll  ( hostRanges ) ; }    assertThat  ( allRangesWithReplicas ) . hasSize  (   3 * numTokens * replicationFactor ) ;   Set  < TokenRange >  allRanges =  new  HashSet  < TokenRange >  ( allRangesWithReplicas ) ;    assertThat  ( allRanges ) . hasSize  (  3 * numTokens ) ;    assertThat  ( cluster ) . hasValidTokenRanges  ( keyspace ) ; }    @ Test  (  groups = "short" ) public void should_expose_tokens_per_host  ( )  {  for ( Host host :   cluster . getMetadata  ( ) . allHosts  ( ) )  {    assertThat  (  host . getTokens  ( ) ) . hasSize  ( numTokens ) ;  Row  row =   (   host . listenAddress == null ) ?   session . execute  ( "select tokens from system.local" ) . one  ( ) :   session . execute  (   "select tokens from system.peers where peer = '" +   host . listenAddress . getHostAddress  ( ) + "'" ) . one  ( ) ;   Set  < String >  tokenStrings =  row . getSet  ( "tokens" ,  String . class ) ;    assertThat  ( tokenStrings ) . hasSize  ( numTokens ) ;   Iterable  < Token >  tokensFromSystemTable =  Iterables . transform  ( tokenStrings ,  new  Function  < String , Token >  ( )  {    @ Override public Token apply  (  String input )  {  return   tokenFactory  ( ) . fromString  ( input ) ; } } ) ;    assertThat  (  host . getTokens  ( ) ) . containsOnlyOnce  (  Iterables . toArray  ( tokensFromSystemTable ,  Token . class ) ) ; } }    @ Test  (  groups = "short" ) public void should_only_unwrap_one_range_for_all_ranges  ( )  {   Set  < TokenRange >  ranges =   cluster . getMetadata  ( ) . getTokenRanges  ( ) ;   assertOnlyOneWrapped  ( ranges ) ;   Iterable  < TokenRange >  splitRanges =  Iterables . concat  (  Iterables . transform  ( ranges ,  new  Function  < TokenRange ,  Iterable  < TokenRange > >  ( )  {    @ Override public  Iterable  < TokenRange > apply  (  TokenRange input )  {  return  input . splitEvenly  ( 10 ) ; } } ) ) ;   assertOnlyOneWrapped  ( splitRanges ) ; }   protected void assertOnlyOneWrapped  (   Iterable  < TokenRange > ranges )  {  TokenRange  wrappedRange = null ;  for ( TokenRange range : ranges )  {  if  (  range . isWrappedAround  ( ) )  {     assertThat  ( wrappedRange ) . as  ( "Found a wrapped around TokenRange (%s) when one already exists (%s)." , range , wrappedRange ) . isNull  ( ) ;   wrappedRange = range ;    assertThat  ( range ) . unwrapsOverMinToken  (  tokenFactory  ( ) ) ; } else  {    assertThat  ( range ) . unwrapsToItself  ( ) ; } } }   protected abstract  Token . Factory tokenFactory  ( ) ;    @ Test  (  groups = "short" ) public void should_expose_token_and_range_creation_methods  ( )  {  Metadata  metadata =  cluster . getMetadata  ( ) ;  TokenRange  range =    metadata . getTokenRanges  ( ) . iterator  ( ) . next  ( ) ;  Token  start =  metadata . newToken  (   range . getStart  ( ) . toString  ( ) ) ;  Token  end =  metadata . newToken  (   range . getEnd  ( ) . toString  ( ) ) ;    assertThat  (  metadata . newTokenRange  ( start , end ) ) . isEqualTo  ( range ) ; } }