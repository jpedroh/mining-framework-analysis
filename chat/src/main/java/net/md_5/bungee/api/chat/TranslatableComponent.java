  package     net . md_5 . bungee . api . chat ;   import  lombok . Getter ;  import  lombok . NoArgsConstructor ;  import  lombok . Setter ;  import     net . md_5 . bungee . api . ChatColor ;  import   java . util . ArrayList ;  import   java . util . List ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import  lombok . ToString ;  import     net . md_5 . bungee . chat . TranslationRegistry ;    @ Getter  @ Setter  @ ToString  @ NoArgsConstructor public class TranslatableComponent  extends BaseComponent  {   private final Pattern  format =  Pattern . compile  ( "%(?:(\\d+)\\$)?([A-Za-z%]|$)" ) ;   private String  translate ;   private  List  < BaseComponent >  with ;   public TranslatableComponent  (  TranslatableComponent original )  {  super  ( original ) ;   setTranslate  (  original . getTranslate  ( ) ) ;  if  (   original . getWith  ( ) != null )  {   List  < BaseComponent >  temp =  new  ArrayList  < BaseComponent >  ( ) ;  for ( BaseComponent baseComponent :  original . getWith  ( ) )  {   temp . add  (  baseComponent . duplicate  ( ) ) ; }   setWith  ( temp ) ; } }   public TranslatableComponent  (  String translate ,  Object ...  with )  {   setTranslate  ( translate ) ;  if  (   with != null &&   with . length != 0 )  {   List  < BaseComponent >  temp =  new  ArrayList  < BaseComponent >  ( ) ;  for ( Object w : with )  {  if  (  w instanceof BaseComponent )  {   temp . add  (  ( BaseComponent ) w ) ; } else  {   temp . add  (  new TextComponent  (  String . valueOf  ( w ) ) ) ; } }   setWith  ( temp ) ; } }    @ Override public BaseComponent duplicate  ( )  {  return  new TranslatableComponent  ( this ) ; }   public void setWith  (   List  < BaseComponent > components )  {  for ( BaseComponent component : components )  {    component . parent = this ; }   with = components ; }   public void addWith  (  String text )  {   addWith  (  new TextComponent  ( text ) ) ; }   public void addWith  (  BaseComponent component )  {  if  (  with == null )  {   with =  new  ArrayList  < BaseComponent >  ( ) ; }    component . parent = this ;   with . add  ( component ) ; }    @ Override protected void toPlainText  (  StringBuilder builder )  {  String  trans =   TranslationRegistry . INSTANCE . translate  ( translate ) ;  Matcher  matcher =  format . matcher  ( trans ) ;   int  position = 0 ;   int  i = 0 ;  while  (  matcher . find  ( position ) )  {   int  pos =  matcher . start  ( ) ;  if  (  pos != position )  {   builder . append  (  trans . substring  ( position , pos ) ) ; }   position =  matcher . end  ( ) ;  String  formatCode =  matcher . group  ( 2 ) ;  switch  (  formatCode . charAt  ( 0 ) )  {   case 's' :   case 'd' :  String  withIndex =  matcher . group  ( 1 ) ;    with . get  (   withIndex != null ?   Integer . parseInt  ( withIndex ) - 1 :  i ++ ) . toPlainText  ( builder ) ;  break ;   case '%' :   builder . append  ( '%' ) ;  break ; } }  if  (   trans . length  ( ) != position )  {   builder . append  (  trans . substring  ( position ,  trans . length  ( ) ) ) ; }   super . toPlainText  ( builder ) ; }    @ Override protected void toLegacyText  (  StringBuilder builder )  {  String  trans =   TranslationRegistry . INSTANCE . translate  ( translate ) ;  Matcher  matcher =  format . matcher  ( trans ) ;   int  position = 0 ;   int  i = 0 ;  while  (  matcher . find  ( position ) )  {   int  pos =  matcher . start  ( ) ;  if  (  pos != position )  {   addFormat  ( builder ) ;   builder . append  (  trans . substring  ( position , pos ) ) ; }   position =  matcher . end  ( ) ;  String  formatCode =  matcher . group  ( 2 ) ;  switch  (  formatCode . charAt  ( 0 ) )  {   case 's' :   case 'd' :  String  withIndex =  matcher . group  ( 1 ) ;    with . get  (   withIndex != null ?   Integer . parseInt  ( withIndex ) - 1 :  i ++ ) . toLegacyText  ( builder ) ;  break ;   case '%' :   addFormat  ( builder ) ;   builder . append  ( '%' ) ;  break ; } }  if  (   trans . length  ( ) != position )  {   addFormat  ( builder ) ;   builder . append  (  trans . substring  ( position ,  trans . length  ( ) ) ) ; }   super . toLegacyText  ( builder ) ; }   private void addFormat  (  StringBuilder builder )  {   builder . append  (  getColor  ( ) ) ;  if  (  isBold  ( ) )  {   builder . append  (  ChatColor . BOLD ) ; }  if  (  isItalic  ( ) )  {   builder . append  (  ChatColor . ITALIC ) ; }  if  (  isUnderlined  ( ) )  {   builder . append  (  ChatColor . UNDERLINE ) ; }  if  (  isStrikethrough  ( ) )  {   builder . append  (  ChatColor . STRIKETHROUGH ) ; }  if  (  isObfuscated  ( ) )  {   builder . append  (  ChatColor . MAGIC ) ; } } }