[#ftl]
[#--

    Copyright Â© 2006-2016 Web Cohesion (info@webcohesion.com)

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

--]
[#-- @ftlvariable name="type" type="com.webcohesion.enunciate.modules.jackson.model.TypeDefinition" --]
[#-- @ftlvariable name="generatedCodeLicense" type="java.lang.String" --]
[#--template for the client-side complex type.--]
[@file name=(simpleNameFor(type, false) + ".java")  package=packageFor(type) charset="utf-8"]
/**
 * ${(generatedCodeLicense!"")?replace("\n", "\n * ")}
 *
 * Generated by <a href="http://enunciate.webcohesion.com">Enunciate</a>.
 */
package ${packageFor(type)};

import com.fasterxml.jackson.annotation.*;

/**
 * ${(type.docComment!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
@JsonInclude( JsonInclude.Include.NON_NULL )
@JsonIgnoreProperties( ignoreUnknown = true )
[#if ((wrapRootValue!false) && (type.jsonRootName??))]
@JsonRootName("${type.jsonRootName}")
[/#if]
[#if type.hasSubTypes!false]
@JsonSubTypes({
  [#list type.subTypes?keys as name]
  @JsonSubTypes.Type(value = ${classnameFor(type.subTypes[name])}.class, name = "${name}")[#if name_has_next],[/#if]
  [/#list]
})
[/#if]
[#if type.hasTypeInfo!false]
@JsonTypeInfo( use = JsonTypeInfo.Id.${type.typeIdType?string}, include = JsonTypeInfo.As.${type.typeIdInclusion?string}, property = "${type.typeIdProperty!""}")
[/#if]
public [#if type.final]final [/#if]class ${simpleNameFor(type)} [#if !type.baseObject]extends ${classnameFor(type.superclass)} [#else]implements java.io.Serializable [/#if]{

  [#if type.value??]
    [#if !isFacetExcluded(type.value)]
  @JsonIgnore
  private ${classnameFor(type.value)} _${type.value.simpleName};
    [/#if]
  [#else]
    [#list type.members as member]
      [#if !isFacetExcluded(member)]
  @JsonIgnore
  private ${classnameFor(member)} _${member.simpleName};
      [/#if]
    [/#list]
  [/#if]
  [#if type.wildcardMember??]
  @JsonIgnore
  private java.util.Map<String, Object> otherAttributes;
  [/#if]
  [#if type.value??]
    [#if !isFacetExcluded(type.value)]

  /**
   * ${(type.value.javaDoc.return!type.value.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n   * ")}
   */
  @JsonValue
  public ${classnameFor(type.value)} get${type.value.simpleNameString?cap_first}() {
    return this._${type.value.simpleName};
  }

  /**
   * ${(type.value.javaDoc.return!type.value.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n   * ")}
   */
  @JsonValue
  public void set${type.value.simpleNameString?cap_first}(${classnameFor(type.value)} _${type.value.simpleName}) {
    this._${type.value.simpleName} = _${type.value.simpleName};
  }
      [#if type.value.referencesQNameEnum!false]

  /**
   * Convenience accessor for the known value of a ${type.value.simpleName} property.
   *
   * @see ${classnameFor(type.value.QNameEnumRef)}#convertFromKnownQName
   */
  @JsonIgnore
  public ${classnameFor(type.value.QNameEnumRef)} getKnown${type.value.simpleNameString?cap_first}() {
    return ${classnameFor(type.value.QNameEnumRef)}.convertFromKnownQName(get${type.value.simpleNameString?cap_first}());
  }

  /**
   * Convenience accessor for the known value of a ${type.value.simpleName} property.
   *
   * @see ${classnameFor(type.value.QNameEnumRef)}#convertToKnownQName
   */
  @JsonIgnore
  public void setKnown${type.value.simpleNameString?cap_first}(${classnameFor(type.value.QNameEnumRef)} _${type.value.simpleName}) {
    set${type.value.simpleNameString?cap_first}(${classnameFor(type.value.QNameEnumRef)}.convertToKnownQName(_${type.value.simpleName})[#if type.value.resolvedAccessorType.isInstanceOf("java.lang.String")].toString()[/#if]);
  }
      [/#if]
    [/#if]
  [#else]
    [#list type.members as member]
      [#if !isFacetExcluded(member)]

  /**
   * ${(member.javaDoc.return!member.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n   * ")}
   */
        [#if member.choices?size > 1]
  @JsonSubTypes ( {
          [#list member.choices as choice]
    @JsonSubTypes.Type ( [#if choice.name?length > 0]name = "${choice.name}", [/#if]value = ${classnameFor(choice)}.class )[#if choice_has_next],[/#if]
          [/#list]
  } )
        [/#if]
        [#if member.subtypeIdInclusion??]
  @JsonTypeInfo( include = JsonTypeInfo.As.${member.subtypeIdInclusion?string}, use = JsonTypeInfo.Id.NAME )
        [/#if]
        [#if member.formatInfo??]
          [#assign formatInfo=member.formatInfo/]
  @JsonFormat( pattern = "${formatInfo.pattern!""}"[#if formatInfo.shape??], shape = JsonFormat.Shape.${formatInfo.shape.name()}[/#if][#if formatInfo.timezone??], timezone = "${formatInfo.timezone}"[/#if][#if formatInfo.locale??], locale = "${formatInfo.locale}"[/#if] )
        [/#if]
  @JsonProperty( value = "${member.name}", required = ${member.required?c}[#if member.defaultValue??], defaultValue="${member.defaultValue}"[/#if] )
  public ${classnameFor(member)} get${member.simpleNameString?cap_first}() {
    return this._${member.simpleName};
  }

  /**
   * ${(member.javaDoc.return!member.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n   * ")}
   */
        [#if member.choices?size > 1]
  @JsonSubTypes ( {
          [#list member.choices as choice]
    @JsonSubTypes.Type ( [#if choice.name?length > 0]name = "${choice.name}", [/#if]value = ${classnameFor(choice)}.class )[#if choice_has_next],[/#if]
          [/#list]
  } )
        [/#if]
        [#if member.subtypeIdInclusion??]
  @JsonTypeInfo( include = JsonTypeInfo.As.${member.subtypeIdInclusion?string}, use = JsonTypeInfo.Id.NAME )
        [/#if]
  @JsonProperty( value = "${member.name}", required = ${member.required?c}[#if member.defaultValue??], defaultValue="${member.defaultValue}"[/#if] )
  public void set${member.simpleNameString?cap_first}(${classnameFor(member)} _${member.simpleName}) {
    this._${member.simpleName} = _${member.simpleName};
  }
        [#if member.referencesQNameEnum!false]

  /**
   * Convenience accessor for the known value of a ${member.simpleName} property.
   *
   * @see ${classnameFor(member.QNameEnumRef)}#convertFromKnownQName
   */
  @JsonIgnore
  public ${classnameFor(member.QNameEnumRef)} getKnown${member.simpleNameString?cap_first}() {
    return ${classnameFor(member.QNameEnumRef)}.convertFromKnownQName(get${member.simpleNameString?cap_first}());
  }

  /**
   * Convenience accessor for the known value of a ${member.simpleName} property.
   *
   * @see ${classnameFor(member.QNameEnumRef)}#convertToKnownQName
   */
  @JsonIgnore
  public void setKnown${member.simpleNameString?cap_first}(${classnameFor(member.QNameEnumRef)} _${member.simpleName}) {
    set${member.simpleNameString?cap_first}(${classnameFor(member.QNameEnumRef)}.convertToKnownQName(_${member.simpleName})[#if member.resolvedAccessorType.isInstanceOf("java.lang.String")].toString()[/#if]);
  }
        [/#if]
      [/#if]
    [/#list]
  [/#if]
  [#if type.wildcardMember??]

  /**
   * The other attributes.
   *
   * @return The other attributes.
   */
  @JsonAnyGetter
  public java.util.Map<String, Object> getOtherAttributes() {
    return this.otherAttributes;
  }

  /**
   * Add an "other" attribute.
   *
   * @param key The key.
   * @param value The value.
   */
  @JsonAnySetter
  public void addOtherAttribute(String key, Object value) {
    if (this.otherAttributes == null) {
      this.otherAttributes = new java.util.TreeMap<String, Object>();
    }
    this.otherAttributes.put(key, value);
  }
  [/#if]
}
[/@file]
