  package    org . imixs . workflow . engine ;   import   java . text . DateFormat ;  import   java . text . ParseException ;  import   java . text . SimpleDateFormat ;  import   java . util . ArrayList ;  import   java . util . Collections ;  import   java . util . Date ;  import   java . util . HashMap ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . StringTokenizer ;  import    java . util . logging . Level ;  import    java . util . logging . Logger ;  import    java . util . regex . Matcher ;  import    java . util . regex . Pattern ;  import   jakarta . annotation . Resource ;  import    jakarta . annotation . security . DeclareRoles ;  import    jakarta . annotation . security . RolesAllowed ;  import    jakarta . enterprise . event . Event ;  import    jakarta . enterprise . inject . Any ;  import    jakarta . enterprise . inject . Instance ;  import   jakarta . inject . Inject ;  import    org . imixs . workflow . Adapter ;  import    org . imixs . workflow . ItemCollection ;  import    org . imixs . workflow . Model ;  import    org . imixs . workflow . ModelManager ;  import    org . imixs . workflow . Plugin ;  import    org . imixs . workflow . WorkflowContext ;  import    org . imixs . workflow . WorkflowKernel ;  import    org . imixs . workflow . WorkflowManager ;  import      org . imixs . workflow . engine . plugins . ResultPlugin ;  import     org . imixs . workflow . exceptions . AccessDeniedException ;  import     org . imixs . workflow . exceptions . InvalidAccessException ;  import     org . imixs . workflow . exceptions . ModelException ;  import     org . imixs . workflow . exceptions . PluginException ;  import     org . imixs . workflow . exceptions . ProcessingErrorException ;  import     org . imixs . workflow . exceptions . QueryException ;  import   jakarta . ejb . LocalBean ;  import   jakarta . ejb . SessionContext ;  import   jakarta . ejb . Stateless ;  import   jakarta . ejb . TransactionAttribute ;  import   jakarta . ejb . TransactionAttributeType ;    @ DeclareRoles  (  { "org.imixs.ACCESSLEVEL.NOACCESS" , "org.imixs.ACCESSLEVEL.READERACCESS" , "org.imixs.ACCESSLEVEL.AUTHORACCESS" , "org.imixs.ACCESSLEVEL.EDITORACCESS" , "org.imixs.ACCESSLEVEL.MANAGERACCESS" } )  @ RolesAllowed  (  { "org.imixs.ACCESSLEVEL.NOACCESS" , "org.imixs.ACCESSLEVEL.READERACCESS" , "org.imixs.ACCESSLEVEL.AUTHORACCESS" , "org.imixs.ACCESSLEVEL.EDITORACCESS" , "org.imixs.ACCESSLEVEL.MANAGERACCESS" } )  @ Stateless  @ LocalBean public class WorkflowService  implements  WorkflowManager , WorkflowContext  {   public static final String  UNIQUEIDREF = "$uniqueidref" ;   public static final String  READACCESS = "$readaccess" ;   public static final String  WRITEACCESS = "$writeaccess" ;   public static final String  PARTICIPANTS = "$participants" ;   public static final String  DEFAULT_TYPE = "workitem" ;   public static final  int  SORT_ORDER_CREATED_DESC = 0 ;   public static final  int  SORT_ORDER_CREATED_ASC = 1 ;   public static final  int  SORT_ORDER_MODIFIED_DESC = 2 ;   public static final  int  SORT_ORDER_MODIFIED_ASC = 3 ;   public static final String  INVALID_ITEMVALUE_FORMAT = "INVALID_ITEMVALUE_FORMAT" ;   public static final String  INVALID_TAG_FORMAT = "INVALID_TAG_FORMAT" ;    @ Inject  @ Any private  Instance  < Plugin >  plugins ;    @ Inject  @ Any protected  Instance  < Adapter >  adapters ;    @ Inject DocumentService  documentService ;    @ Inject ModelService  modelService ;    @ Inject ReportService  reportService ;    @ Resource SessionContext  ctx ;    @ Inject protected  Event  < ProcessingEvent >  processingEvents ;    @ Inject protected  Event  < TextEvent >  textEvents ;   private static Logger  logger =  Logger . getLogger  (   WorkflowService . class . getName  ( ) ) ;   public WorkflowService  ( )  {  super  ( ) ; }   public ItemCollection getWorkItem  (  String uniqueid )  {  return  documentService . load  ( uniqueid ) ; }   public  List  < ItemCollection > getWorkListByOwner  (  String name ,  String type ,   int pageSize ,   int pageIndex ,  String sortBy ,  boolean sortReverse )  {  if  (   name == null ||  "" . equals  ( name ) )   name =   ctx . getCallerPrincipal  ( ) . getName  ( ) ;  String  searchTerm = "(" ;  if  (   type != null &&  !  "" . equals  ( type ) )  {   searchTerm +=   " type:\"" + type + "\" AND " ; }   searchTerm +=     " (namowner:\"" + name + "\" OR $owner:\"" + name + "\") )" ;  try  {  return  documentService . find  ( searchTerm , pageSize , pageIndex , sortBy , sortReverse ) ; }  catch (   QueryException e )  {   logger . severe  (  "getWorkListByOwner - invalid param: " +  e . getMessage  ( ) ) ;  return null ; } }   public  List  < ItemCollection > getWorkListByAuthor  (  String name ,  String type ,   int pageSize ,   int pageIndex ,  String sortBy ,  boolean sortReverse )  {  if  (   name == null ||  "" . equals  ( name ) )   name =   ctx . getCallerPrincipal  ( ) . getName  ( ) ;  String  searchTerm = "(" ;  if  (   type != null &&  !  "" . equals  ( type ) )  {   searchTerm +=   " type:\"" + type + "\" AND " ; }   searchTerm +=   " $writeaccess:\"" + name + "\" )" ;  try  {  return  documentService . find  ( searchTerm , pageSize , pageIndex , sortBy , sortReverse ) ; }  catch (   QueryException e )  {   logger . severe  (  "getWorkListByAuthor - invalid param: " +  e . getMessage  ( ) ) ;  return null ; } }   public  List  < ItemCollection > getWorkListByCreator  (  String name ,  String type ,   int pageSize ,   int pageIndex ,  String sortBy ,  boolean sortReverse )  {  if  (   name == null ||  "" . equals  ( name ) )   name =   ctx . getCallerPrincipal  ( ) . getName  ( ) ;  String  searchTerm = "(" ;  if  (   type != null &&  !  "" . equals  ( type ) )  {   searchTerm +=   " type:\"" + type + "\" AND " ; }   searchTerm +=   " $creator:\"" + name + "\" )" ;  try  {  return  documentService . find  ( searchTerm , pageSize , pageIndex , sortBy , sortReverse ) ; }  catch (   QueryException e )  {   logger . severe  (  "getWorkListByCreator - invalid param: " +  e . getMessage  ( ) ) ;  return null ; } }   public  List  < ItemCollection > getWorkListByWriteAccess  (  String type ,   int pageSize ,   int pageIndex ,  String sortBy ,  boolean sortReverse )  {  StringBuffer  nameListBuffer =  new StringBuffer  ( ) ;  String  name =   ctx . getCallerPrincipal  ( ) . getName  ( ) ;   nameListBuffer . append  (   "($writeaccess:\"" + name + "\"" ) ;  String  accessRoles =  documentService . getAccessRoles  ( ) ;  String  roleList =  "org.imixs.ACCESSLEVEL.READERACCESS,org.imixs.ACCESSLEVEL.AUTHORACCESS,org.imixs.ACCESSLEVEL.EDITORACCESS," + accessRoles ;  StringTokenizer  roleListTokens =  new StringTokenizer  ( roleList , "," ) ;  while  (  roleListTokens . hasMoreTokens  ( ) )  {  String  testRole =   roleListTokens . nextToken  ( ) . trim  ( ) ;  if  (   !  "" . equals  ( testRole ) &&  ctx . isCallerInRole  ( testRole ) )   nameListBuffer . append  (   " OR $writeaccess:\"" + testRole + "\"" ) ; }   nameListBuffer . append  ( ")" ) ;  String  searchTerm = "(" ;  if  (   type != null &&  !  "" . equals  ( type ) )  {   searchTerm +=    " type:\"" + type + "\" AND " +  nameListBuffer . toString  ( ) ; }   searchTerm +=   " $writeaccess:\"" + name + "\" )" ;  try  {  return  documentService . find  ( searchTerm , pageSize , pageIndex , sortBy , sortReverse ) ; }  catch (   QueryException e )  {   logger . severe  (  "getWorkListByWriteAccess - invalid param: " +  e . getMessage  ( ) ) ;  return null ; } }   public  List  < ItemCollection > getWorkListByGroup  (  String name ,  String type ,   int pageSize ,   int pageIndex ,  String sortBy ,  boolean sortReverse )  {  String  searchTerm = "(" ;  if  (   type != null &&  !  "" . equals  ( type ) )  {   searchTerm +=   " type:\"" + type + "\" AND " ; }   searchTerm +=     " ($workflowgroup:\"" + name + "\" OR txtworkflowgroup:\"" + name + "\") )" ;  try  {  return  documentService . find  ( searchTerm , pageSize , pageIndex , sortBy , sortReverse ) ; }  catch (   QueryException e )  {   logger . severe  (  "getWorkListByGroup - invalid param: " +  e . getMessage  ( ) ) ;  return null ; } }   public  List  < ItemCollection > getWorkListByProcessID  (   int aid ,  String type ,   int pageSize ,   int pageIndex ,  String sortBy ,  boolean sortReverse )  {  String  searchTerm = "(" ;  if  (   type != null &&  !  "" . equals  ( type ) )  {   searchTerm +=   " type:\"" + type + "\" AND " ; }   searchTerm +=   " $processid:\"" + aid + "\" )" ;  try  {  return  documentService . find  ( searchTerm , pageSize , pageIndex , sortBy , sortReverse ) ; }  catch (   QueryException e )  {   logger . severe  (  "getWorkListByProcessID - invalid param: " +  e . getMessage  ( ) ) ;  return null ; } }   public  List  < ItemCollection > getWorkListByRef  (  String aref ,  String type ,   int pageSize ,   int pageIndex ,  String sortBy ,  boolean sortReverse )  {  String  searchTerm = "(" ;  if  (   type != null &&  !  "" . equals  ( type ) )  {   searchTerm +=   " type:\"" + type + "\" AND " ; }   searchTerm +=   " $uniqueidref:\"" + aref + "\" )" ;  try  {  return  documentService . find  ( searchTerm , pageSize , pageIndex , sortBy , sortReverse ) ; }  catch (   QueryException e )  {   logger . severe  (  "getWorkListByRef - invalid param: " +  e . getMessage  ( ) ) ;  return null ; } }   public  List  < ItemCollection > getWorkListByRef  (  String aref )  {  return  getWorkListByRef  ( aref , null , 0 , 0 , null , false ) ; }    @ SuppressWarnings  ( "unchecked" ) public  List  < ItemCollection > getEvents  (  ItemCollection workitem )  throws ModelException  {   List  < ItemCollection >  result =  new  ArrayList  < ItemCollection >  ( ) ;   int  processID =  workitem . getTaskID  ( ) ;  Model  model =  modelService . getModelByWorkitem  ( workitem ) ;   List  < ItemCollection >  eventList =  model . findAllEventsByTask  ( processID ) ;  String  username =  getUserName  ( ) ;  boolean  bManagerAccess =  ctx . isCallerInRole  (  DocumentService . ACCESSLEVEL_MANAGERACCESS ) ;  for ( ItemCollection event : eventList )  {  if  (  "0" . equals  (  event . getItemValueString  ( "keypublicresult" ) ) )  {  continue ; }   List  < String >  readAccessList =  event . getItemValue  ( "$readaccess" ) ;  if  (   ! bManagerAccess &&  !  readAccessList . isEmpty  ( ) )  {  boolean  accessGranted = false ;   List  < String >  auserNameList =  getUserNameList  ( ) ;  for ( String aReadAccess : readAccessList )  {  if  (   aReadAccess != null &&  !  aReadAccess . isEmpty  ( ) )  {  if  (   auserNameList . indexOf  ( aReadAccess ) >  - 1 )  {   accessGranted = true ;  break ; } } }  if  (  ! accessGranted )  {  continue ; } }   List  < String >  restrictedList =  event . getItemValue  ( "keyRestrictedVisibility" ) ;  if  (   ! bManagerAccess &&  !  restrictedList . isEmpty  ( ) )  {   List  < String >  totalNameList =  new  ArrayList  < String >  ( ) ;  for ( String itemName : restrictedList )  {   totalNameList . addAll  (  workitem . getItemValue  ( itemName ) ) ; }   totalNameList . removeAll  (  Collections . singleton  ( null ) ) ;   totalNameList . removeAll  (  Collections . singleton  ( "" ) ) ;  if  (   !  totalNameList . isEmpty  ( ) &&  !  totalNameList . contains  ( username ) )  {  continue ; } }   result . add  ( event ) ; }  return result ; }   public ItemCollection processWorkItem  (  ItemCollection workitem )  throws AccessDeniedException , ProcessingErrorException , PluginException , ModelException  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;   long  lStartTime =  System . currentTimeMillis  ( ) ;  if  (  workitem == null )  throw  new ProcessingErrorException  (   WorkflowService . class . getSimpleName  ( ) ,  ProcessingErrorException . INVALID_WORKITEM , "workitem Is Null!" ) ;  if  (  processingEvents != null )  {   processingEvents . fire  (  new ProcessingEvent  ( workitem ,  ProcessingEvent . BEFORE_PROCESS ) ) ; } else  {   logger . warning  ( "CDI Support is missing - ProcessingEvents Not Supported!" ) ; }  if  (  !   workitem . getUniqueID  ( ) . isEmpty  ( ) )  {  ItemCollection  currentInstance =  this . getWorkItem  (  workitem . getUniqueID  ( ) ) ;  if  (  currentInstance != null )  {  if  (  !  currentInstance . getItemValueBoolean  (  DocumentService . ISAUTHOR ) )  {  throw  new AccessDeniedException  (  AccessDeniedException . OPERATION_NOTALLOWED ,   "$uniqueid: " +  workitem . getItemValueInteger  (  WorkflowKernel . UNIQUEID ) + " - No Author Access!" ) ; }  if  (    workitem . getTaskID  ( ) > 0 &&   currentInstance . getTaskID  ( ) !=  workitem . getTaskID  ( ) )  {  throw  new ProcessingErrorException  (   WorkflowService . class . getSimpleName  ( ) ,  ProcessingErrorException . INVALID_PROCESSID ,      "$uniqueid: " +  workitem . getItemValueInteger  (  WorkflowKernel . UNIQUEID ) + " - $taskid=" +  workitem . getTaskID  ( ) + " Did Not Match Expected $taskid=" +  currentInstance . getTaskID  ( ) ) ; }   workitem . mergeItems  (  currentInstance . getAllItems  ( ) ) ; } else  {  if  (    (   workitem . getTaskID  ( ) <= 0 ) ||  (   workitem . getEventID  ( ) <= 0 ) ||  (    workitem . getModelVersion  ( ) . isEmpty  ( ) &&   workitem . getWorkflowGroup  ( ) . isEmpty  ( ) ) )  {  throw  new InvalidAccessException  (  InvalidAccessException . OPERATION_NOTALLOWED ,   "$uniqueid: " +  workitem . getItemValueInteger  (  WorkflowKernel . UNIQUEID ) + " - Insufficient Data or Lack Of Permission!" ) ; } } }  if  (  "" . equals  (  workitem . getType  ( ) ) )  {   workitem . replaceItemValue  ( "type" , DEFAULT_TYPE ) ; }  Model  model = null ;  try  {   model =   this . getModelManager  ( ) . getModelByWorkitem  ( workitem ) ; }  catch (   ModelException e )  {  throw  new ProcessingErrorException  (   WorkflowService . class . getSimpleName  ( ) ,  ProcessingErrorException . INVALID_PROCESSID ,  e . getMessage  ( ) , e ) ; }  WorkflowKernel  workflowkernel =  new WorkflowKernel  ( this ) ;   registerPlugins  ( workflowkernel , model ) ;   registerAdapters  ( workflowkernel ) ;   updateMetadata  ( workitem ) ;  try  {   long  lKernelTime =  System . currentTimeMillis  ( ) ;   workitem =  workflowkernel . process  ( workitem ) ;  if  ( debug )  {   logger . fine  (   "...WorkflowKernel processing time=" +  (   System . currentTimeMillis  ( ) - lKernelTime ) + "ms" ) ; } }  catch (   PluginException pe )  {   logger . severe  (   "processing workitem '" +  workitem . getItemValueString  (  WorkflowKernel . UNIQUEID ) + " failed, rollback transaction..." ) ;   ctx . setRollbackOnly  ( ) ;  throw pe ; }  if  (  processingEvents != null )  {   processingEvents . fire  (  new ProcessingEvent  ( workitem ,  ProcessingEvent . AFTER_PROCESS ) ) ; }   List  < ItemCollection >  splitWorkitems =  workflowkernel . getSplitWorkitems  ( ) ;  for ( ItemCollection splitWorkitemm : splitWorkitems )  {  if  (  processingEvents != null )  {   processingEvents . fire  (  new ProcessingEvent  ( splitWorkitemm ,  ProcessingEvent . AFTER_PROCESS ) ) ; }   documentService . save  ( splitWorkitemm ) ; }   workitem =  documentService . save  ( workitem ) ;  if  ( debug )  {   logger . fine  (   "...total processing time=" +  (   System . currentTimeMillis  ( ) - lStartTime ) + "ms" ) ; }  return workitem ; }   public ItemCollection processWorkItem  (  ItemCollection workitem ,  ItemCollection event )  throws AccessDeniedException , ProcessingErrorException , PluginException , ModelException  {  return  processWorkItem  ( workitem ,  event . getItemValueInteger  ( "numactivityid" ) ) ; }   public ItemCollection processWorkItem  (  ItemCollection workitem ,   int eventID )  throws AccessDeniedException , ProcessingErrorException , PluginException , ModelException  {   workitem . setEventID  ( eventID ) ;  return  processWorkItem  ( workitem ) ; }    @ TransactionAttribute  (  value =  TransactionAttributeType . REQUIRES_NEW ) public ItemCollection processWorkItemByNewTransaction  (  ItemCollection workitem )  throws AccessDeniedException , ProcessingErrorException , PluginException , ModelException  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;  if  ( debug )  {   logger . finest  ( " ....processing workitem by by new transaction..." ) ; }  return  processWorkItem  ( workitem ) ; }   public void removeWorkItem  (  ItemCollection aworkitem )  throws AccessDeniedException  {   documentService . remove  ( aworkitem ) ; }   public ModelManager getModelManager  ( )  {  return modelService ; }   public SessionContext getSessionContext  ( )  {  return ctx ; }   public DocumentService getDocumentService  ( )  {  return documentService ; }   public ReportService getReportService  ( )  {  return reportService ; }   public String getUserName  ( )  {  return   ctx . getCallerPrincipal  ( ) . getName  ( ) ; }   public boolean isUserInRole  (  String rolename )  {  try  {  return  ctx . isCallerInRole  ( rolename ) ; }  catch (   Exception e )  {  return false ; } }   public  List  < String > getUserNameList  ( )  {  return  documentService . getUserNameList  ( ) ; }   public String adaptText  (  String text ,  ItemCollection documentContext )  throws PluginException  {  if  (  textEvents != null )  {  TextEvent  event =  new TextEvent  ( text , documentContext ) ;   textEvents . fire  ( event ) ;   text =  event . getText  ( ) ; } else  {   logger . warning  ( "CDI Support is missing - TextEvent wil not be fired" ) ; }  return text ; }   public  List  < String > adaptTextList  (  String text ,  ItemCollection documentContext )  throws PluginException  {  if  (  textEvents != null )  {  TextEvent  event =  new TextEvent  ( text , documentContext ) ;   textEvents . fire  ( event ) ;  return  event . getTextList  ( ) ; } else  {   logger . warning  ( "CDI Support is missing - TextEvent wil not be fired" ) ; }   List  < String >  textList =  new  ArrayList  < String >  ( ) ;   textList . add  ( text ) ;  return textList ; }   public ItemCollection evalWorkflowResult  (  ItemCollection event ,  String tag ,  ItemCollection documentContext ,  boolean resolveItemValues )  throws PluginException  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;  ItemCollection  result =  new ItemCollection  ( ) ;  String  workflowResult =  event . getItemValueString  ( "txtActivityResult" ) ;  if  (   workflowResult . trim  ( ) . isEmpty  ( ) )  {  return null ; }  if  (   tag == null ||  tag . isEmpty  ( ) )  {   logger . warning  ( "cannot eval workflow result - no tag name specified. Verify model!" ) ;  return null ; }  if  (   workflowResult . indexOf  (  "<" + tag ) ==  - 1 )  {  return null ; }  if  ( resolveItemValues )  {   workflowResult =  adaptText  ( workflowResult , documentContext ) ; }  boolean  invalidPattern = false ;  Pattern  patternSimple =  Pattern . compile  (     "<" + tag + " (.*?)>(.*?)|<" + tag + " (.*?)./>" ,  Pattern . DOTALL ) ;  Matcher  matcherSimple =  patternSimple . matcher  ( workflowResult ) ;  if  (  matcherSimple . find  ( ) )  {   invalidPattern = true ;  Pattern  pattern =  Pattern . compile  (       "(?s)(?:(<" + tag + "(?>\\b(?:\".*?\"|'.*?'|[^>]*?)*>)(?<=/>))|(<" + tag + "(?>\\b(?:\".*?\"|'.*?'|[^>]*?)*>)(?<!/>))(.*?)(</" + tag + "\\s*>))" ,  Pattern . DOTALL ) ;  Matcher  matcher =  pattern . matcher  ( workflowResult ) ;  while  (  matcher . find  ( ) )  {   invalidPattern = false ;  String  content = "" ;  String  attributes =  matcher . group  ( 1 ) ;  if  (  attributes == null )  {   attributes =  matcher . group  ( 2 ) ;   content =  matcher . group  ( 3 ) ; } else  {   content =  matcher . group  ( 2 ) ; }  if  (  content == null )  {   content = "" ; }  if  (   attributes != null &&  !  attributes . isEmpty  ( ) )  {  String  spattern = "(\\S+)=[\"']?((?:.(?![\"']?\\s+(?:\\S+)=|[>\"']))+.)[\"']?" ;  Pattern  attributePattern =  Pattern . compile  ( spattern ) ;  Matcher  attributeMatcher =  attributePattern . matcher  ( attributes ) ;   Map  < String , String >  attrMap =  new  HashMap  < String , String >  ( ) ;  while  (  attributeMatcher . find  ( ) )  {  String  attrName =  attributeMatcher . group  ( 1 ) ;  String  attrValue =  attributeMatcher . group  ( 2 ) ;   attrMap . put  ( attrName , attrValue ) ; }  String  tagName =  attrMap . get  ( "name" ) ;  if  (  tagName == null )  {  throw  new PluginException  (   ResultPlugin . class . getSimpleName  ( ) , INVALID_TAG_FORMAT ,   "<" + tag + "> tag contains no name attribute." ) ; }  for ( String attrName :  attrMap . keySet  ( ) )  {  if  (  !  "name" . equals  ( attrName ) )  {   result . appendItemValue  (   tagName + "." + attrName ,  attrMap . get  ( attrName ) ) ; } }  String  sType =  result . getItemValueString  (  tagName + ".type" ) ;  String  sFormat =  result . getItemValueString  (  tagName + ".format" ) ;  if  (  !  sType . isEmpty  ( ) )  {  if  (  "boolean" . equalsIgnoreCase  ( sType ) )  {   result . appendItemValue  ( tagName ,  Boolean . valueOf  ( content ) ) ; } else  if  (  "integer" . equalsIgnoreCase  ( sType ) )  {  try  {   result . appendItemValue  ( tagName ,  Integer . valueOf  ( content ) ) ; }  catch (   NumberFormatException e )  {   result . appendItemValue  ( tagName ,  new Integer  ( 0 ) ) ; } } else  if  (  "double" . equalsIgnoreCase  ( sType ) )  {  try  {   result . appendItemValue  ( tagName ,  Double . valueOf  ( content ) ) ; }  catch (   NumberFormatException e )  {   result . appendItemValue  ( tagName ,  new Double  ( 0 ) ) ; } } else  if  (  "float" . equalsIgnoreCase  ( sType ) )  {  try  {   result . appendItemValue  ( tagName ,  Float . valueOf  ( content ) ) ; }  catch (   NumberFormatException e )  {   result . appendItemValue  ( tagName ,  new Float  ( 0 ) ) ; } } else  if  (  "long" . equalsIgnoreCase  ( sType ) )  {  try  {   result . appendItemValue  ( tagName ,  Long . valueOf  ( content ) ) ; }  catch (   NumberFormatException e )  {   result . appendItemValue  ( tagName ,  new Long  ( 0 ) ) ; } } else  if  (  "date" . equalsIgnoreCase  ( sType ) )  {  if  (   content == null ||  content . isEmpty  ( ) )  {  if  ( debug )  {   logger . finer  ( "......can not convert empty string into date object" ) ; } } else  {  try  {  if  ( debug )  {   logger . finer  ( "......convert string into date object" ) ; }  Date  dateResult = null ;  if  (   sFormat == null ||  sFormat . isEmpty  ( ) )  {   dateResult =   DateFormat . getDateTimeInstance  (  DateFormat . SHORT ,  DateFormat . SHORT ) . parse  ( content ) ; } else  {  DateFormat  dateFormat =  new SimpleDateFormat  ( sFormat ) ;   dateResult =  dateFormat . parse  ( content ) ; }   result . appendItemValue  ( tagName , dateResult ) ; }  catch (   ParseException e )  {  if  ( debug )  {   logger . finer  (  "failed to convert string into date object: " +  e . getMessage  ( ) ) ; } } } } else   result . appendItemValue  ( tagName , content ) ; } else  {   result . appendItemValue  ( tagName , content ) ; } } else  {  throw  new PluginException  (   ResultPlugin . class . getSimpleName  ( ) , INVALID_TAG_FORMAT ,   "<" + tag + "> tag contains no name attribute." ) ; } } }  if  ( invalidPattern )  {  throw  new PluginException  (   ResultPlugin . class . getSimpleName  ( ) , INVALID_TAG_FORMAT ,       "invalid <" + tag + "> tag format in workflowResult: " + workflowResult + "  , expected format is <" + tag + " name=\"...\">...</item> " ) ; }  return result ; }   public ItemCollection evalWorkflowResult  (  ItemCollection event ,  String tag ,  ItemCollection documentContext )  throws PluginException  {  return  evalWorkflowResult  ( event , tag , documentContext , true ) ; }    @ Deprecated public ItemCollection evalWorkflowResult  (  ItemCollection event ,  ItemCollection documentContext ,  boolean resolveItemValues )  throws PluginException  {   logger . warning  ( "Method call evalWorkflowResult(event, workitem, resolve) is deprecated, use method evalWorkflowResult(event, tag, workitem, resolve) instead!" ) ;  return  this . evalWorkflowResult  ( event , "item" , documentContext , resolveItemValues ) ; }    @ Deprecated public ItemCollection evalWorkflowResult  (  ItemCollection event ,  ItemCollection documentContext )  throws PluginException  {   logger . warning  ( "Method call evalWorkflowResult(event, workitem) is deprecated, use method evalWorkflowResult(event, tag, workitem) instead!" ) ;  return  this . evalWorkflowResult  ( event , "item" , documentContext ) ; }   public ItemCollection evalNextTask  (  ItemCollection documentContext )  throws PluginException , ModelException  {  WorkflowKernel  workflowkernel =  new WorkflowKernel  ( this ) ;   int  taskID =  workflowkernel . eval  ( documentContext ) ;  ItemCollection  task =    this . getModelManager  ( ) . getModel  (  documentContext . getModelVersion  ( ) ) . getTask  ( taskID ) ;  return task ; }    @ SuppressWarnings  ( "unchecked" ) protected void registerPlugins  (  WorkflowKernel workflowkernel ,  Model model )  throws PluginException  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;  ItemCollection  profile =  model . getDefinition  ( ) ;   List  < String >  vPlugins =  (  List  < String > )  profile . getItemValue  ( "txtPlugins" ) ;  for (   int  i = 0 ;  i <  vPlugins . size  ( ) ;  i ++ )  {  String  aPluginClassName =  vPlugins . get  ( i ) ;  Plugin  aPlugin =  findPluginByName  ( aPluginClassName ) ;  if  (  aPlugin != null )  {  if  ( debug )  {   logger . finest  (   "......register CDI plugin class: " + aPluginClassName + "..." ) ; }   workflowkernel . registerPlugin  ( aPlugin ) ; } else  {   workflowkernel . registerPlugin  ( aPluginClassName ) ; } } }   protected void registerAdapters  (  WorkflowKernel workflowkernel )  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;  if  (  debug &&  (   adapters == null ||  !   adapters . iterator  ( ) . hasNext  ( ) ) )  {   logger . finest  ( "......no CDI Adapters injected" ) ; } else  {  for ( Adapter adapter :  this . adapters )  {  if  ( debug )  {   logger . finest  (   "......register CDI Adapter class '" +   adapter . getClass  ( ) . getName  ( ) + "'" ) ; }   workflowkernel . registerAdapter  ( adapter ) ; } } }   protected void updateMetadata  (  ItemCollection workitem )  {  String  nameEditor ;   nameEditor =   ctx . getCallerPrincipal  ( ) . getName  ( ) ;  if  (    workitem . getItemValueString  ( "$creator" ) . isEmpty  ( ) &&  !   workitem . getItemValueString  ( "namCreator" ) . isEmpty  ( ) )  {   workitem . replaceItemValue  ( "$creator" ,  workitem . getItemValue  ( "namCreator" ) ) ; }  if  (   workitem . getItemValueString  ( "$creator" ) . isEmpty  ( ) )  {   workitem . replaceItemValue  ( "$creator" , nameEditor ) ;   workitem . replaceItemValue  ( "namCreator" , nameEditor ) ; }  if  (   !  nameEditor . equals  (  workitem . getItemValueString  ( "$editor" ) ) &&  !   workitem . getItemValueString  ( "$editor" ) . isEmpty  ( ) )  {   workitem . replaceItemValue  ( "$lasteditor" ,  workitem . getItemValueString  ( "$editor" ) ) ;   workitem . replaceItemValue  ( "namlasteditor" ,  workitem . getItemValueString  ( "$editor" ) ) ; }   workitem . replaceItemValue  ( "$editor" , nameEditor ) ;   workitem . replaceItemValue  ( "namcurrenteditor" , nameEditor ) ; }   private Plugin findPluginByName  (  String pluginClassName )  {  if  (   pluginClassName == null ||  pluginClassName . isEmpty  ( ) )  return null ;  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;  if  (   plugins == null ||  !   plugins . iterator  ( ) . hasNext  ( ) )  {  if  ( debug )  {   logger . finest  ( "......no CDI plugins injected" ) ; }  return null ; }  for ( Plugin plugin :  this . plugins )  {  if  (    plugin . getClass  ( ) . getName  ( ) . equals  ( pluginClassName ) )  {  if  ( debug )  {   logger . finest  (   "......CDI plugin '" + pluginClassName + "' successful injected" ) ; }  return plugin ; } }  return null ; } }