  package    org . imixs . workflow . engine ;   import   java . io . FileInputStream ;  import   java . io . FileOutputStream ;  import   java . io . IOException ;  import   java . io . ObjectInputStream ;  import   java . io . ObjectOutputStream ;  import   java . util . ArrayList ;  import   java . util . Calendar ;  import   java . util . Collection ;  import   java . util . Date ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . StringTokenizer ;  import   java . util . Vector ;  import    java . util . logging . Level ;  import    java . util . logging . Logger ;  import   jakarta . annotation . Resource ;  import    jakarta . annotation . security . DeclareRoles ;  import    jakarta . annotation . security . RolesAllowed ;  import    jakarta . enterprise . event . Event ;  import   jakarta . inject . Inject ;  import      org . eclipse . microprofile . config . inject . ConfigProperty ;  import    org . imixs . workflow . ItemCollection ;  import    org . imixs . workflow . WorkflowKernel ;  import      org . imixs . workflow . engine . index . DefaultOperator ;  import      org . imixs . workflow . engine . index . SearchService ;  import      org . imixs . workflow . engine . index . SortOrder ;  import      org . imixs . workflow . engine . index . UpdateService ;  import      org . imixs . workflow . engine . jpa . Document ;  import     org . imixs . workflow . exceptions . AccessDeniedException ;  import     org . imixs . workflow . exceptions . InvalidAccessException ;  import     org . imixs . workflow . exceptions . PluginException ;  import     org . imixs . workflow . exceptions . QueryException ;  import   jakarta . ejb . SessionContext ;  import   jakarta . ejb . Stateless ;  import   jakarta . ejb . TransactionAttribute ;  import   jakarta . ejb . TransactionAttributeType ;  import   jakarta . persistence . EntityManager ;  import   jakarta . persistence . FlushModeType ;  import   jakarta . persistence . PersistenceContext ;  import   jakarta . persistence . Query ;    @ DeclareRoles  (  { "org.imixs.ACCESSLEVEL.NOACCESS" , "org.imixs.ACCESSLEVEL.READERACCESS" , "org.imixs.ACCESSLEVEL.AUTHORACCESS" , "org.imixs.ACCESSLEVEL.EDITORACCESS" , "org.imixs.ACCESSLEVEL.MANAGERACCESS" } )  @ RolesAllowed  (  { "org.imixs.ACCESSLEVEL.NOACCESS" , "org.imixs.ACCESSLEVEL.READERACCESS" , "org.imixs.ACCESSLEVEL.AUTHORACCESS" , "org.imixs.ACCESSLEVEL.EDITORACCESS" , "org.imixs.ACCESSLEVEL.MANAGERACCESS" } )  @ Stateless public class DocumentService  {   public static final String  ACCESSLEVEL_NOACCESS = "org.imixs.ACCESSLEVEL.NOACCESS" ;   public static final String  ACCESSLEVEL_READERACCESS = "org.imixs.ACCESSLEVEL.READERACCESS" ;   public static final String  ACCESSLEVEL_AUTHORACCESS = "org.imixs.ACCESSLEVEL.AUTHORACCESS" ;   public static final String  ACCESSLEVEL_EDITORACCESS = "org.imixs.ACCESSLEVEL.EDITORACCESS" ;   public static final String  ACCESSLEVEL_MANAGERACCESS = "org.imixs.ACCESSLEVEL.MANAGERACCESS" ;   public static final String  EVENTLOG_TOPIC_INDEX_ADD = "index.add" ;   public static final String  EVENTLOG_TOPIC_INDEX_REMOVE = "index.remove" ;   public static final String  READACCESS = "$readaccess" ;   public static final String  WRITEACCESS = "$writeaccess" ;   public static final String  ISAUTHOR = "$isAuthor" ;   public static final String  NOINDEX = "$noindex" ;   public static final String  IMMUTABLE = "$immutable" ;   public static final String  VERSION = "$version" ;   private static final String  REGEX_UUID = "([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})|([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}-[0-9]{13,15})" ;   private static final String  REGEX_OLDUID = "([0-9a-f]{8}-.*|[0-9a-f]{11}-.*)" ;   public static final String  USER_GROUP_LIST = "org.imixs.USER.GROUPLIST" ;   private final static Logger  logger =  Logger . getLogger  (   DocumentService . class . getName  ( ) ) ;   public static final String  OPERATION_NOTALLOWED = "OPERATION_NOTALLOWED" ;   public static final String  INVALID_PARAMETER = "INVALID_PARAMETER" ;   public static final String  INVALID_UNIQUEID = "INVALID_UNIQUEID" ;    @ Resource SessionContext  ctx ;    @ Resource  (  name = "ACCESS_ROLES" ) private String  accessRoles = "" ;    @ Resource  (  name = "DISABLE_OPTIMISTIC_LOCKING" ) private Boolean  disableOptimisticLocking = false ;    @ PersistenceContext  (  unitName = "org.imixs.workflow.jpa" ) private EntityManager  manager ;    @ Inject private UpdateService  indexUpdateService ;    @ Inject private SearchService  indexSearchService ;    @ Inject private EventLogService  eventLogService ;    @ Inject protected  Event  < DocumentEvent >  documentEvents ;    @ Inject protected  Event  < UserGroupEvent >  userGroupEvents ;    @ Inject  @ ConfigProperty  (  name = "index.defaultOperator" ,  defaultValue = "AND" ) private String  indexDefaultOperator ;   public String getAccessRoles  ( )  {  return accessRoles ; }   public void setAccessRoles  (  String accessRoles )  {    this . accessRoles = accessRoles ; }   public void setDisableOptimisticLocking  (  Boolean disableOptimisticLocking )  {    this . disableOptimisticLocking = disableOptimisticLocking ; }   public Boolean getDisableOptimisticLocking  ( )  {  return disableOptimisticLocking ; }   public  List  < String > getUserNameList  ( )  {   List  < String >  userNameList =  new  Vector  < String >  ( ) ;   userNameList . add  (    ctx . getCallerPrincipal  ( ) . getName  ( ) . toString  ( ) ) ;  String  roleList =  "org.imixs.ACCESSLEVEL.READERACCESS,org.imixs.ACCESSLEVEL.AUTHORACCESS,org.imixs.ACCESSLEVEL.EDITORACCESS,org.imixs.ACCESSLEVEL.MANAGERACCESS," + accessRoles ;  StringTokenizer  roleListTokens =  new StringTokenizer  ( roleList , "," ) ;  while  (  roleListTokens . hasMoreTokens  ( ) )  {  try  {  String  testRole =   roleListTokens . nextToken  ( ) . trim  ( ) ;  if  (   !  "" . equals  ( testRole ) &&  ctx . isCallerInRole  ( testRole ) )   userNameList . add  ( testRole ) ; }  catch (   Exception e )  { } }  if  (  userGroupEvents != null )  {  UserGroupEvent  groupEvent =  new UserGroupEvent  (    ctx . getCallerPrincipal  ( ) . getName  ( ) . toString  ( ) ) ;   userGroupEvents . fire  ( groupEvent ) ;  if  (   groupEvent . getGroups  ( ) != null )  {   userNameList . addAll  (  groupEvent . getGroups  ( ) ) ; } } else  {   logger . warning  ( "Missing CDI support for Event<UserGroupEvent> !" ) ; }  return userNameList ; }   public boolean isUserContained  (   List  < String > nameList )  {  if  (  nameList == null )  {  return false ; }   List  < String >  userNameList =  getUserNameList  ( ) ;  for ( String aName : nameList )  {  if  (   aName != null &&  !  aName . isEmpty  ( ) )  {  if  (   userNameList . stream  ( ) . anyMatch  (  aName :: equals ) )  {  return true ; } } }  return false ; }   public boolean isUserInRole  (  String rolename )  {  try  {  return  ctx . isCallerInRole  ( rolename ) ; }  catch (   Exception e )  {  return false ; } }   public ItemCollection save  (  ItemCollection document )  throws AccessDeniedException  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;   long  lSaveTime =  System . currentTimeMillis  ( ) ;  if  ( debug )  {   logger . finest  (    "......save - ID=" +  document . getUniqueID  ( ) + ", provided version=" +  document . getItemValueInteger  ( VERSION ) ) ; }  Document  persistedDocument = null ;   manager . setFlushMode  (  FlushModeType . COMMIT ) ;  String  sID =  document . getItemValueString  (  WorkflowKernel . UNIQUEID ) ;  if  (   !  sID . isEmpty  ( ) &&  !  isValidUIDPattern  ( sID ) )  {  throw  new InvalidAccessException  ( INVALID_PARAMETER ,  "invalid UUID pattern - " + sID ) ; }  if  (  !  sID . isEmpty  ( ) )  {   persistedDocument =  manager . find  (  Document . class , sID ) ;  if  (  debug &&  persistedDocument == null )  {   logger . finest  (   "......Document '" + sID + "' not found!" ) ; } }  if  (  persistedDocument == null )  {  if  (  !  (    ctx . isCallerInRole  ( ACCESSLEVEL_MANAGERACCESS ) ||  ctx . isCallerInRole  ( ACCESSLEVEL_EDITORACCESS ) ||  ctx . isCallerInRole  ( ACCESSLEVEL_AUTHORACCESS ) ) )  {  throw  new AccessDeniedException  ( OPERATION_NOTALLOWED , "You are not allowed to perform this operation" ) ; }   persistedDocument =  new Document  ( sID ) ;  Date  datCreated =  document . getItemValueDate  ( "$created" ) ;  if  (  datCreated != null )  {  Calendar  cal =  Calendar . getInstance  ( ) ;   cal . setTime  ( datCreated ) ;   persistedDocument . setCreated  ( cal ) ; }  if  ( debug )  {   logger . finest  ( "......persist activeEntity" ) ; }   manager . persist  ( persistedDocument ) ; } else  {  if  (   !  isCallerAuthor  ( persistedDocument ) ||  !  isCallerReader  ( persistedDocument ) )  {  throw  new AccessDeniedException  ( OPERATION_NOTALLOWED , "You are not allowed to perform this operation" ) ; }  if  (   ItemCollection . createByReference  (  persistedDocument . getData  ( ) ) . getItemValueBoolean  ( IMMUTABLE ) )  {  throw  new AccessDeniedException  ( OPERATION_NOTALLOWED , "Operation not allowed, document is immutable!" ) ; } }  if  ( debug )  {   logger . finest  (    "......save - ID=" +  document . getUniqueID  ( ) + " managed version=" +  persistedDocument . getVersion  ( ) ) ; }   document . removeItem  ( ISAUTHOR ) ;  String  aType =  document . getItemValueString  ( "type" ) ;  if  (  "" . equals  ( aType ) )  {   aType = "document" ;   document . replaceItemValue  ( "type" , aType ) ; }   persistedDocument . setType  ( aType ) ;   document . replaceItemValue  ( "$uniqueid" ,  persistedDocument . getId  ( ) ) ;   document . replaceItemValue  ( "$created" ,   persistedDocument . getCreated  ( ) . getTime  ( ) ) ;  Calendar  cal =  Calendar . getInstance  ( ) ;   persistedDocument . setModified  ( cal ) ;   document . replaceItemValue  ( "$modified" ,  cal . getTime  ( ) ) ;  if  (  documentEvents != null )  {   documentEvents . fire  (  new DocumentEvent  ( document ,  DocumentEvent . ON_DOCUMENT_SAVE ) ) ; } else  {   logger . warning  ( "Missing CDI support for Event<DocumentEvent> !" ) ; }  if  (   (  !   persistedDocument . getId  ( ) . equals  (  document . getUniqueID  ( ) ) ) ||  (  !    persistedDocument . getCreated  ( ) . getTime  ( ) . equals  (  document . getItemValueDate  ( "$created" ) ) ) )  {  throw  new InvalidAccessException  (  InvalidAccessException . INVALID_ID , "Invalid data after DocumentEvent 'ON_DOCUMENT_SAVE'." ) ; }  if  ( disableOptimisticLocking )  {   document . removeItem  ( "$Version" ) ; }  if  (    ! disableOptimisticLocking &&  document . hasItem  ( VERSION ) &&   document . getItemValueInteger  ( VERSION ) > 0 )  {   int  version =  document . getItemValueInteger  ( VERSION ) ;   persistedDocument . setVersion  ( version ) ; }  ItemCollection  clone =  ( ItemCollection )  document . clone  ( ) ;   persistedDocument . setData  (  clone . getAllItems  ( ) ) ;   document . removeItem  ( VERSION ) ;   document . replaceItemValue  ( ISAUTHOR ,  isCallerAuthor  ( persistedDocument ) ) ;  if  (  !  document . getItemValueBoolean  ( NOINDEX ) )  {   addDocumentToIndex  ( document ) ; } else  {   removeDocumentFromIndex  (  document . getUniqueID  ( ) ) ; }   persistedDocument . setPending  ( true ) ;  if  ( debug )  {   logger . fine  (     "...'" +  document . getUniqueID  ( ) + "' saved in " +  (   System . currentTimeMillis  ( ) - lSaveTime ) + "ms" ) ; }  return document ; }   public void addDocumentToIndex  (  ItemCollection document )  {  if  (  !  document . getItemValueBoolean  (  DocumentService . NOINDEX ) )  {   eventLogService . createEvent  ( EVENTLOG_TOPIC_INDEX_ADD ,  document . getUniqueID  ( ) ) ; } }   public void removeDocumentFromIndex  (  String uniqueID )  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;   long  ltime =  System . currentTimeMillis  ( ) ;   eventLogService . createEvent  ( EVENTLOG_TOPIC_INDEX_REMOVE , uniqueID ) ;  if  ( debug )  {   logger . fine  (   "... update eventLog cache in " +  (   System . currentTimeMillis  ( ) - ltime ) + " ms (1 document to be removed)" ) ; } }    @ TransactionAttribute  (  value =  TransactionAttributeType . REQUIRES_NEW ) public ItemCollection saveByNewTransaction  (  ItemCollection itemcol )  throws AccessDeniedException  {  return  save  ( itemcol ) ; }   public ItemCollection load  (  String id )  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;   long  lLoadTime =  System . currentTimeMillis  ( ) ;  Document  persistedDocument = null ;  if  (   id == null ||  id . isEmpty  ( ) )  {  return null ; }   persistedDocument =  manager . find  (  Document . class , id ) ;  if  (   persistedDocument != null &&  isCallerReader  ( persistedDocument ) )  {  ItemCollection  result = null ;  if  (  persistedDocument . isPending  ( ) )  {  if  ( debug )  {   logger . finest  (    "......clone manged entity '" + id + "' pending status=" +  persistedDocument . isPending  ( ) ) ; }   result =  new ItemCollection  (  persistedDocument . getData  ( ) ) ; } else  {   result =  new ItemCollection  ( ) ;   result . setAllItems  (  persistedDocument . getData  ( ) ) ;   manager . detach  ( persistedDocument ) ; }   updateMetaData  ( result , persistedDocument ) ;  if  (  documentEvents != null )  {   documentEvents . fire  (  new DocumentEvent  ( result ,  DocumentEvent . ON_DOCUMENT_LOAD ) ) ; } else  {   logger . warning  ( "Missing CDI support for Event<DocumentEvent> !" ) ; }  if  ( debug )  {   logger . fine  (     "...'" +  result . getUniqueID  ( ) + "' loaded in " +  (   System . currentTimeMillis  ( ) - lLoadTime ) + "ms" ) ; }  return result ; } else  return null ; }   public void remove  (  ItemCollection document )  throws AccessDeniedException  {  if  (  document == null )  {  return ; }  Document  persistedDocument = null ;  String  sID =  document . getItemValueString  ( "$uniqueid" ) ;   persistedDocument =  manager . find  (  Document . class , sID ) ;  if  (  persistedDocument != null )  {  if  (   !  isCallerReader  ( persistedDocument ) ||  !  isCallerAuthor  ( persistedDocument ) )  throw  new AccessDeniedException  ( OPERATION_NOTALLOWED , "remove - You are not allowed to perform this operation" ) ;  if  (  documentEvents != null )  {   documentEvents . fire  (  new DocumentEvent  ( document ,  DocumentEvent . ON_DOCUMENT_DELETE ) ) ; } else  {   logger . warning  ( "Missing CDI support for Event<DocumentEvent> !" ) ; }   manager . remove  ( persistedDocument ) ;  if  (  !  document . getItemValueBoolean  ( NOINDEX ) )  {   removeDocumentFromIndex  (  document . getUniqueID  ( ) ) ; } } else  throw  new AccessDeniedException  ( INVALID_UNIQUEID , "remove - invalid $uniqueid" ) ; }   public  int count  (  String searchTerm )  throws QueryException  {  return  count  ( searchTerm , 0 ) ; }   public  int count  (  String sSearchTerm ,   int maxResult )  throws QueryException  {   indexUpdateService . updateIndex  ( ) ;  return  indexSearchService . getTotalHits  ( sSearchTerm , maxResult , null ) ; }   public  int countPages  (  String searchTerm ,   int pageSize )  throws QueryException  {   double  pages = 1 ;   double  count =  count  ( searchTerm ) ;  if  (  count > 0 )  {   pages =  Math . ceil  (  count / pageSize ) ; }  return  (  (  int ) pages ) ; }    @ TransactionAttribute  (  value =  TransactionAttributeType . REQUIRES_NEW ) public  List  < ItemCollection > find  (  String searchTerm ,   int pageSize ,   int pageIndex )  throws QueryException  {  return  find  ( searchTerm , pageSize , pageIndex , null , false ) ; }    @ TransactionAttribute  (  value =  TransactionAttributeType . REQUIRES_NEW ) public  List  < ItemCollection > find  (  String searchTerm ,   int pageSize ,   int pageIndex ,  String sortBy ,  boolean sortReverse )  throws QueryException  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;  if  ( debug )  {   logger . finest  (          "......find - SearchTerm=" + searchTerm + "  , pageSize=" + pageSize + " pageNumber=" + pageIndex + " , sortBy=" + sortBy + " reverse=" + sortReverse ) ; }  SortOrder  sortOrder = null ;  if  (   sortBy != null &&  !  sortBy . isEmpty  ( ) )  {   sortOrder =  new SortOrder  ( sortBy , sortReverse ) ; }   indexUpdateService . updateIndex  ( ) ;  DefaultOperator  defaultOperator = null ;  if  (   indexDefaultOperator != null &&  "OR" . equals  (  indexDefaultOperator . toUpperCase  ( ) ) )  {   defaultOperator =  DefaultOperator . OR ; } else  {   defaultOperator =  DefaultOperator . AND ; }  return  indexSearchService . search  ( searchTerm , pageSize , pageIndex , sortOrder , defaultOperator , false ) ; }   public  List  < ItemCollection > findStubs  (  String searchTerm ,   int pageSize ,   int pageIndex ,  String sortBy ,  boolean sortReverse )  throws QueryException  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;  if  ( debug )  {   logger . finest  (          "......find - SearchTerm=" + searchTerm + "  , pageSize=" + pageSize + " pageNumber=" + pageIndex + " , sortBy=" + sortBy + " reverse=" + sortReverse ) ; }  SortOrder  sortOrder = null ;  if  (   sortBy != null &&  !  sortBy . isEmpty  ( ) )  {   sortOrder =  new SortOrder  ( sortBy , sortReverse ) ; }   indexUpdateService . updateIndex  ( ) ;  DefaultOperator  defaultOperator = null ; ;  if  (   indexDefaultOperator != null &&  "OR" . equals  (  indexDefaultOperator . toUpperCase  ( ) ) )  {   defaultOperator =  DefaultOperator . OR ; } else  {   defaultOperator =  DefaultOperator . AND ; }  return  indexSearchService . search  ( searchTerm , pageSize , pageIndex , sortOrder , defaultOperator , true ) ; }    @ TransactionAttribute  (  value =  TransactionAttributeType . REQUIRES_NEW ) public  List  < ItemCollection > findDocumentsByRef  (  String uniqueIdRef ,   int pageSize ,   int pageIndex )  {  String  searchTerm =    "(" + "$uniqueidref:\"" + uniqueIdRef + "\")" ;  try  {  return  find  ( searchTerm , pageSize , pageIndex ) ; }  catch (   QueryException e )  {   logger . severe  (  "findDocumentsByRef - invalid query: " +  e . getMessage  ( ) ) ;  return null ; } }    @ TransactionAttribute  (  value =  TransactionAttributeType . REQUIRES_NEW ) public  List  < ItemCollection > getDocumentsByType  (  String type )  {  if  (   type == null ||  type . isEmpty  ( ) )  {  throw  new InvalidAccessException  ( INVALID_PARAMETER , "undefined type attribute" ) ; }  String  query = "SELECT document FROM Document AS document " ;   query +=   " WHERE document.type = '" + type + "'" ;   query += " ORDER BY document.created DESC" ;  return  getDocumentsByQuery  ( query ) ; }    @ TransactionAttribute  (  value =  TransactionAttributeType . REQUIRES_NEW ) public  List  < ItemCollection > getDocumentsByQuery  (  String query )  {  return  getDocumentsByQuery  ( query ,  - 1 ) ; }    @ TransactionAttribute  (  value =  TransactionAttributeType . REQUIRES_NEW ) public  List  < ItemCollection > getDocumentsByQuery  (  String query ,   int maxResult )  {  return  getDocumentsByQuery  ( query , 0 , maxResult ) ; }    @ TransactionAttribute  (  value =  TransactionAttributeType . REQUIRES_NEW ) public  List  < ItemCollection > getDocumentsByQuery  (  String query ,   int firstResult ,   int maxResult )  {  boolean  debug =  logger . isLoggable  (  Level . FINE ) ;   List  < ItemCollection >  result =  new  ArrayList  < ItemCollection >  ( ) ;  Query  q =  manager . createQuery  ( query ) ;  if  (  maxResult > 0 )  {   q . setMaxResults  ( maxResult ) ; }  if  (  firstResult > 0 )  {   q . setFirstResult  ( firstResult ) ; }   long  l =  System . currentTimeMillis  ( ) ;    @ SuppressWarnings  ( "unchecked" )  Collection  < Document >  documentList =  q . getResultList  ( ) ;  if  (  documentList == null )  {  if  ( debug )  {   logger . finest  ( "......getDocumentsByQuery - no ducuments found." ) ; }  return result ; }  for ( Document doc : documentList )  {  if  (  isCallerReader  ( doc ) )  {  ItemCollection  _tmp = null ;  if  (  doc . isPending  ( ) )  {  if  ( debug )  {   logger . finest  (    "......clone manged entity '" +  doc . getId  ( ) + "' pending status=" +  doc . isPending  ( ) ) ; }   _tmp =  new ItemCollection  (  doc . getData  ( ) ) ; } else  {   _tmp =  new ItemCollection  ( ) ;   _tmp . setAllItems  (  doc . getData  ( ) ) ;   manager . detach  ( doc ) ; }   updateMetaData  ( _tmp , doc ) ;   result . add  ( _tmp ) ;  if  (  documentEvents != null )  {   documentEvents . fire  (  new DocumentEvent  ( _tmp ,  DocumentEvent . ON_DOCUMENT_LOAD ) ) ; } } }  if  ( debug )  {   logger . fine  (     "...getDocumentsByQuery - found " +  documentList . size  ( ) + " documents in " +  (   System . currentTimeMillis  ( ) - l ) + " ms" ) ; }  return result ; }   public void backup  (  String query ,  String filePath )  throws IOException , QueryException  {  boolean  hasMoreData = true ;   int  JUNK_SIZE = 100 ;   long  totalcount = 0 ;   int  pageIndex = 0 ;   int  icount = 0 ;   logger . info  ( "backup - starting..." ) ;   logger . info  (  "backup - query=" + query ) ;   logger . info  (  "backup - target=" + filePath ) ;  if  (   filePath == null ||  filePath . isEmpty  ( ) )  {   logger . severe  ( "Invalid FilePath!" ) ;  return ; }  FileOutputStream  fos =  new FileOutputStream  ( filePath ) ;  ObjectOutputStream  out =  new ObjectOutputStream  ( fos ) ;  while  ( hasMoreData )  {   Collection  < ItemCollection >  col =  find  ( query , JUNK_SIZE , pageIndex ) ;   totalcount =  totalcount +  col . size  ( ) ;   logger . info  (   "backup - processing...... " +  col . size  ( ) + " documents read...." ) ;  if  (   col . size  ( ) < JUNK_SIZE )  {   hasMoreData = false ;   logger . finest  ( "......all data read." ) ; } else  {   pageIndex ++ ;   logger . finest  ( "......next page..." ) ; }  for ( ItemCollection aworkitem : col )  {   Map  <  ? ,  ? >  hmap =  aworkitem . getAllItems  ( ) ;   out . writeObject  ( hmap ) ;   icount ++ ; } }   out . close  ( ) ;   logger . info  (   "backup - finished: " + icount + " documents read totaly." ) ; }    @ SuppressWarnings  (  { "rawtypes" , "unchecked" } ) public void restore  (  String filePath )  throws IOException  {   int  JUNK_SIZE = 100 ;   long  totalcount = 0 ;   long  errorCount = 0 ;   int  icount = 0 ;  FileInputStream  fis =  new FileInputStream  ( filePath ) ;  ObjectInputStream  in =  new ObjectInputStream  ( fis ) ;   logger . info  (   "...starting restor form file " + filePath + "..." ) ;   long  l =  System . currentTimeMillis  ( ) ;  while  ( true )  {  try  {  Map  hmap =  ( Map )  in . readObject  ( ) ;  ItemCollection  itemCol =  new ItemCollection  ( hmap ) ;   itemCol . removeItem  ( VERSION ) ;   itemCol =   ctx . getBusinessObject  (  DocumentService . class ) . saveByNewTransaction  ( itemCol ) ;   totalcount ++ ;   icount ++ ;  if  (  icount >= JUNK_SIZE )  {   icount = 0 ;   logger . info  (     "...restored " + totalcount + " document in " +  (   System . currentTimeMillis  ( ) - l ) + "ms...." ) ;   l =  System . currentTimeMillis  ( ) ; } }  catch (     java . io . EOFException eofe )  {  break ; }  catch (   ClassNotFoundException e )  {   errorCount ++ ;   logger . warning  (    "...error importing workitem at position " +  (  totalcount + errorCount ) + " Error: " +  e . getMessage  ( ) ) ; }  catch (   AccessDeniedException e )  {   errorCount ++ ;   logger . warning  (    "...error importing workitem at position " +  (  totalcount + errorCount ) + " Error: " +  e . getMessage  ( ) ) ; } }   in . close  ( ) ;  String  loginfo =      "Import successfull! " + totalcount + " Entities imported. " + errorCount + " Errors.  Import FileName:" + filePath ;   logger . info  ( loginfo ) ; }   public boolean isAuthor  (  ItemCollection itemcol )  {    @ SuppressWarnings  ( "unchecked" )  List  < String >  writeAccessList =  itemcol . getItemValue  ( WRITEACCESS ) ;  if  (  ctx . isCallerInRole  ( ACCESSLEVEL_NOACCESS ) )  return false ;  if  (   ctx . isCallerInRole  ( ACCESSLEVEL_MANAGERACCESS ) ||  ctx . isCallerInRole  ( ACCESSLEVEL_EDITORACCESS ) )  return true ;  if  (  ctx . isCallerInRole  ( ACCESSLEVEL_AUTHORACCESS ) )  {  if  (  isUserContained  ( writeAccessList ) )  {  return true ; } }  return false ; }   private void updateMetaData  (  ItemCollection itemColection ,  Document doc )  {  if  ( disableOptimisticLocking )  {   itemColection . removeItem  ( VERSION ) ; } else  {   itemColection . replaceItemValue  ( VERSION ,  doc . getVersion  ( ) ) ; }   itemColection . replaceItemValue  ( "$modified" ,   doc . getModified  ( ) . getTime  ( ) ) ;   itemColection . replaceItemValue  ( ISAUTHOR ,  isCallerAuthor  ( doc ) ) ; }   private boolean isCallerReader  (  Document document )  {  ItemCollection  itemcol =  ItemCollection . createByReference  (  document . getData  ( ) ) ;    @ SuppressWarnings  ( "unchecked" )  List  < String >  readAccessList =  itemcol . getItemValue  ( READACCESS ) ;  if  (  ctx . isCallerInRole  ( ACCESSLEVEL_NOACCESS ) )  return false ;  if  (  ctx . isCallerInRole  ( ACCESSLEVEL_MANAGERACCESS ) )  return true ;  if  (   isEmptyList  ( readAccessList ) ||  isUserContained  ( readAccessList ) )  {  return true ; }  return false ; }   private boolean isCallerAuthor  (  Document document )  {  ItemCollection  itemcol =  ItemCollection . createByReference  (  document . getData  ( ) ) ;  return  isAuthor  ( itemcol ) ; }   public boolean isEmptyList  (   List  < String > aList )  {  if  (   aList == null ||   aList . size  ( ) == 0 )  {  return true ; }  for ( String aEntry : aList )  {  if  (   aEntry != null &&  !  aEntry . isEmpty  ( ) )  {  return false ; } }  return true ; }   public static boolean isValidUIDPattern  (  String uid )  {  boolean  valid =  uid . matches  ( REGEX_UUID ) ;  if  (  ! valid )  {   valid =  uid . matches  ( REGEX_OLDUID ) ; }  return valid ; } }