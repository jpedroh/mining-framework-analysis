  package     org . imixs . workflow . engine . adminp ;   import   java . text . DateFormat ;  import   java . text . SimpleDateFormat ;  import   java . util . ArrayList ;  import   java . util . Date ;  import   java . util . List ;  import    java . util . logging . Logger ;  import    jakarta . annotation . security . DeclareRoles ;  import    jakarta . annotation . security . RunAs ;  import   jakarta . inject . Inject ;  import      org . eclipse . microprofile . config . inject . ConfigProperty ;  import    org . imixs . workflow . ItemCollection ;  import      org . imixs . workflow . engine . index . UpdateService ;  import      org . imixs . workflow . engine . jpa . Document ;  import     org . imixs . workflow . exceptions . AccessDeniedException ;  import     org . imixs . workflow . exceptions . InvalidAccessException ;  import     org . imixs . workflow . exceptions . PluginException ;  import   jakarta . ejb . LocalBean ;  import   jakarta . ejb . Stateless ;  import   jakarta . ejb . TransactionAttribute ;  import   jakarta . ejb . TransactionAttributeType ;  import   jakarta . persistence . EntityManager ;  import   jakarta . persistence . PersistenceContext ;  import   jakarta . persistence . Query ;    @ DeclareRoles  (  { "org.imixs.ACCESSLEVEL.MANAGERACCESS" } )  @ RunAs  ( "org.imixs.ACCESSLEVEL.MANAGERACCESS" )  @ Stateless  @ LocalBean public class JobHandlerRebuildIndex  implements  JobHandler  {   private static final String  BLOCK_SIZE_DEFAULT = "500" ;   private static final String  TIMEOUT_DEFAULT = "120" ;    @ Inject  @ ConfigProperty  (  name = "lucene.rebuild.block_size" ,  defaultValue = BLOCK_SIZE_DEFAULT )  int  block_size ;    @ Inject  @ ConfigProperty  (  name = "lucene.rebuild.time_out" ,  defaultValue = TIMEOUT_DEFAULT )  int  time_out ;   private static final  int  READ_AHEAD = 32 ;   public final static String  ITEM_SYNCPOINT = "syncpoint" ;   public final static String  ITEM_SYNCDATE = "syncdate" ;   public static final String  SNAPSHOT_TYPE_PRAFIX = "snapshot-" ;    @ PersistenceContext  (  unitName = "org.imixs.workflow.jpa" ) private EntityManager  manager ;    @ Inject UpdateService  updateService ;   private static Logger  logger =  Logger . getLogger  (   JobHandlerRebuildIndex . class . getName  ( ) ) ;    @ Override  @ TransactionAttribute  (  value =  TransactionAttributeType . REQUIRES_NEW ) public ItemCollection run  (  ItemCollection adminp )  throws AdminPException  {   long  lProfiler =  System . currentTimeMillis  ( ) ;   long  syncPoint =  adminp . getItemValueLong  ( "_syncpoint" ) ;   int  totalCount =  adminp . getItemValueInteger  ( "numUpdates" ) ;   int  blockCount = 0 ;   int  jobBlockSize =  adminp . getItemValueInteger  ( "blocksize" ) ;  if  (  jobBlockSize > 0 )  {   block_size = jobBlockSize ; }   int  jobTimeOut =  adminp . getItemValueInteger  ( "numinterval" ) ;  if  (  jobTimeOut > 0 )  {   time_out = jobTimeOut ; }   logger . info  (      "...Job " +  AdminPService . JOB_REBUILD_INDEX + " (" +  adminp . getUniqueID  ( ) + ") - lucene.rebuild.block_size=" + block_size ) ;   logger . info  (      "...Job " +  AdminPService . JOB_REBUILD_INDEX + " (" +  adminp . getUniqueID  ( ) + ") - lucene.rebuild.time_out=" + time_out ) ;  try  {  while  ( true )  {   List  < ItemCollection >  resultList =  new  ArrayList  < ItemCollection >  ( ) ;   List  < Document >  documents =  findNextDocumentsBySyncPoint  ( syncPoint ) ;  if  (   documents != null &&   documents . size  ( ) > 0 )  {  for ( Document doc : documents )  {   syncPoint =   doc . getCreated  ( ) . getTimeInMillis  ( ) ;  try  {   resultList . add  (  new ItemCollection  (  doc . getData  ( ) ) ) ; }  catch (   InvalidAccessException e )  {   logger . warning  (    "...unable to index document '" +  doc . getId  ( ) + "' " +  e . getMessage  ( ) ) ; }   manager . detach  ( doc ) ; }   updateService . updateIndex  ( resultList ) ;   manager . flush  ( ) ;   totalCount +=  resultList . size  ( ) ;   blockCount +=  resultList . size  ( ) ;  if  (  blockCount >= block_size )  {   long  time =   (   System . currentTimeMillis  ( ) - lProfiler ) / 1000 ;  if  (  time == 0 )  {   time = 1 ; }   logger . info  (         "...Job " +  AdminPService . JOB_REBUILD_INDEX + " (" +  adminp . getUniqueID  ( ) + ") - ..." + totalCount + " documents indexed in " + time + " sec. ... " ) ;   blockCount = 0 ; } } else  {   manager . flush  ( ) ;  break ; }   long  time =   (   System . currentTimeMillis  ( ) - lProfiler ) / 1000 ;  if  (  time == 0 )  {   time = 1 ; }  if  (  time > time_out )  {   logger . info  (         "...Job " +  AdminPService . JOB_REBUILD_INDEX + " (" +  adminp . getUniqueID  ( ) + ") - suspended: " + totalCount + " documents indexed in " + time + " sec. " ) ;   adminp . replaceItemValue  ( "_syncpoint" , syncPoint ) ;   adminp . replaceItemValue  (  JobHandler . ISCOMPLETED , false ) ;   adminp . replaceItemValue  ( "numUpdates" , totalCount ) ;   adminp . replaceItemValue  ( "numProcessed" , totalCount ) ;   adminp . replaceItemValue  ( "numLastCount" , 0 ) ;  return adminp ; } } }  catch (   Exception e )  {   logger . severe  (           "...Job " +  AdminPService . JOB_REBUILD_INDEX + " (" +  adminp . getUniqueID  ( ) + ") - failed - " +  e . getMessage  ( ) + " last syncpoint  " + syncPoint + " - " + totalCount + "  documents reindexed...." ) ;   e . printStackTrace  ( ) ;   adminp . replaceItemValue  (  JobHandler . ISCOMPLETED , false ) ;  Date  syncDate =  new Date  ( syncPoint ) ;   adminp . replaceItemValue  ( "error" ,  e . getMessage  ( ) ) ;   adminp . replaceItemValue  ( ITEM_SYNCPOINT , syncPoint ) ;   adminp . replaceItemValue  ( ITEM_SYNCDATE , syncDate ) ;   adminp . replaceItemValue  ( "numUpdates" , totalCount ) ;   adminp . replaceItemValue  ( "numProcessed" , totalCount ) ;   adminp . replaceItemValue  ( "numLastCount" , 0 ) ;  return adminp ; }   long  time =   (   System . currentTimeMillis  ( ) - lProfiler ) / 1000 ;  if  (  time == 0 )  {   time = 1 ; }   logger . info  (         "...Job " +  AdminPService . JOB_REBUILD_INDEX + " (" +  adminp . getUniqueID  ( ) + ") - Finished: " + totalCount + " documents indexed in " + time + " sec. " ) ;   adminp . replaceItemValue  (  JobHandler . ISCOMPLETED , true ) ;   adminp . replaceItemValue  ( "numUpdates" , totalCount ) ;   adminp . replaceItemValue  ( "numProcessed" , totalCount ) ;   adminp . replaceItemValue  ( "numLastCount" , 0 ) ;  return adminp ; }    @ SuppressWarnings  ( "unchecked" ) private  List  < Document > findNextDocumentsBySyncPoint  (   long lSyncpoint )  {  Date  syncpoint =  new Date  ( lSyncpoint ) ;  DateFormat  isoFormat =  new SimpleDateFormat  ( "yyyy-MM-dd HH:mm:ss.SSS" ) ;  String  query = "SELECT document FROM Document AS document " ;   query +=   " WHERE document.created > '" +  isoFormat . format  ( syncpoint ) + "'" ;   query +=   " AND NOT document.type LIKE '" + SNAPSHOT_TYPE_PRAFIX + "%' " ;   query += " AND NOT document.type LIKE 'workitemlob%' " ;   query += " AND document.type != 'event' " ;   query += " ORDER BY document.created ASC" ;  Query  q =  manager . createQuery  ( query ) ;   q . setFirstResult  ( 0 ) ;   q . setMaxResults  ( READ_AHEAD ) ;   List  < Document >  documentList =  q . getResultList  ( ) ;  if  (   documentList != null &&   documentList . size  ( ) > 0 )  {  Document  lastDocument = null ;  Document  nextToLastDocument = null ;  if  (   documentList . size  ( ) == READ_AHEAD )  {   lastDocument =  documentList . get  (  READ_AHEAD - 1 ) ;   nextToLastDocument =  documentList . get  (  READ_AHEAD - 2 ) ;  if  (    lastDocument != null &&  nextToLastDocument != null &&   lastDocument . getCreated  ( ) . equals  (  nextToLastDocument . getCreated  ( ) ) )  {   logger . finest  ( "......there are more than one document with the same creation timestamp!" ) ;   syncpoint =  new Date  (   lastDocument . getCreated  ( ) . getTimeInMillis  ( ) ) ;   query = "SELECT document FROM Document AS document " ;   query +=   " WHERE document.created = '" +  isoFormat . format  ( syncpoint ) + "'" ;   query +=   " AND NOT document.type LIKE '" + SNAPSHOT_TYPE_PRAFIX + "%' " ;   query += " AND NOT document.type LIKE 'workitemlob%' " ;   query += " AND document.type != 'event' " ;   query += " ORDER BY document.created ASC" ;   q =  manager . createQuery  ( query ) ;   q . setFirstResult  ( 0 ) ;   q . setMaxResults  ( block_size ) ;   documentList . addAll  (  q . getResultList  ( ) ) ;  return documentList ; } else  {   documentList . remove  ( lastDocument ) ;   manager . detach  ( lastDocument ) ;  return documentList ; } } else  {  return documentList ; } }  return null ; } }