  package     org . apache . metamodel . elasticsearch . rest ;   import   java . util . ArrayList ;  import   java . util . Arrays ;  import   java . util . Comparator ;  import   java . util . List ;  import   java . util . Map ;  import   java . util . Set ;  import    org . apache . metamodel . BatchUpdateScript ;  import    org . apache . metamodel . DataContext ;  import    org . apache . metamodel . MetaModelException ;  import    org . apache . metamodel . QueryPostprocessDataContext ;  import    org . apache . metamodel . UpdateScript ;  import    org . apache . metamodel . UpdateSummary ;  import    org . apache . metamodel . UpdateableDataContext ;  import     org . apache . metamodel . data . DataSet ;  import     org . apache . metamodel . data . DataSetHeader ;  import     org . apache . metamodel . data . Row ;  import     org . apache . metamodel . data . SimpleDataSetHeader ;  import      org . apache . metamodel . elasticsearch . common . ElasticSearchMetaData ;  import      org . apache . metamodel . elasticsearch . common . ElasticSearchUtils ;  import     org . apache . metamodel . query . FilterItem ;  import     org . apache . metamodel . query . LogicalOperator ;  import     org . apache . metamodel . query . SelectItem ;  import     org . apache . metamodel . schema . Column ;  import     org . apache . metamodel . schema . MutableColumn ;  import     org . apache . metamodel . schema . MutableSchema ;  import     org . apache . metamodel . schema . MutableTable ;  import     org . apache . metamodel . schema . Schema ;  import     org . apache . metamodel . schema . Table ;  import     org . apache . metamodel . util . SimpleTableDef ;  import     org . elasticsearch . index . query . QueryBuilder ;  import     org . elasticsearch . index . query . QueryBuilders ;  import     org . elasticsearch . search . builder . SearchSourceBuilder ;  import   org . slf4j . Logger ;  import   org . slf4j . LoggerFactory ;  import    com . google . gson . JsonElement ;  import    com . google . gson . JsonObject ;  import    io . searchbox . client . JestClient ;  import    io . searchbox . client . JestResult ;  import    io . searchbox . core . Count ;  import    io . searchbox . core . CountResult ;  import    io . searchbox . core . Get ;  import    io . searchbox . core . Search ;  import    io . searchbox . core . SearchResult ;  import     io . searchbox . indices . mapping . GetMapping ;  import    io . searchbox . params . Parameters ;  import   java . util . Collections ;   public class ElasticSearchRestDataContext  extends QueryPostprocessDataContext  implements  DataContext , UpdateableDataContext  {   private static final Logger  logger =  LoggerFactory . getLogger  (  ElasticSearchRestDataContext . class ) ;   public static final String  FIELD_ID = "_id" ;   public static final String  TIMEOUT_SCROLL = "1m" ;   private final JestClient  elasticSearchClient ;   private final String  indexName ;   private final  List  < SimpleTableDef >  staticTableDefinitions ;   private final  List  < SimpleTableDef >  dynamicTableDefinitions =  new  ArrayList  < >  ( ) ;   public ElasticSearchRestDataContext  (  JestClient client ,  String indexName ,  SimpleTableDef ...  tableDefinitions )  {  if  (  client == null )  {  throw  new IllegalArgumentException  ( "ElasticSearch Client cannot be null" ) ; }  if  (   indexName == null ||    indexName . trim  ( ) . length  ( ) == 0 )  {  throw  new IllegalArgumentException  (  "Invalid ElasticSearch Index name: " + indexName ) ; }    this . elasticSearchClient = client ;    this . indexName = indexName ;    this . staticTableDefinitions =  (    tableDefinitions == null ||   tableDefinitions . length == 0 ?  Collections .  < SimpleTableDef > emptyList  ( ) :  Arrays . asList  ( tableDefinitions ) ) ;    this . dynamicTableDefinitions . addAll  (  Arrays . asList  (  detectSchema  ( ) ) ) ; }   public ElasticSearchRestDataContext  (  JestClient client ,  String indexName )  {  this  ( client , indexName ,  new SimpleTableDef  [ 0 ] ) ; }   private  SimpleTableDef  [ ] detectSchema  ( )  {   logger . info  ( "Detecting schema for index '{}'" , indexName ) ;   final JestResult  jestResult ;  try  {   final GetMapping  getMapping =    new  GetMapping . Builder  ( ) . addIndex  ( indexName ) . build  ( ) ;   jestResult =  elasticSearchClient . execute  ( getMapping ) ; }  catch (   Exception e )  {   logger . error  ( "Failed to retrieve mappings" , e ) ;  throw  new MetaModelException  ( "Failed to execute request for index information needed to detect schema" , e ) ; }  if  (  !  jestResult . isSucceeded  ( ) )  {   logger . error  ( "Failed to retrieve mappings; {}" ,  jestResult . getErrorMessage  ( ) ) ;  throw  new MetaModelException  (  "Failed to retrieve mappings; " +  jestResult . getErrorMessage  ( ) ) ; }   final  List  < SimpleTableDef >  result =  new  ArrayList  < >  ( ) ;   final  Set  <   Map . Entry  < String , JsonElement > >  mappings =     jestResult . getJsonObject  ( ) . getAsJsonObject  ( indexName ) . getAsJsonObject  ( "mappings" ) . entrySet  ( ) ;  if  (   mappings . size  ( ) == 0 )  {   logger . warn  ( "No metadata returned for index name '{}' - no tables will be detected." ) ; } else  {  for (   Map . Entry  < String , JsonElement > entry : mappings )  {   final String  documentType =  entry . getKey  ( ) ;  try  {   final SimpleTableDef  table =  detectTable  (     entry . getValue  ( ) . getAsJsonObject  ( ) . get  ( "properties" ) . getAsJsonObject  ( ) , documentType ) ;   result . add  ( table ) ; }  catch (   Exception e )  {   logger . error  ( "Unexpected error during detectTable for document type '{}'" , documentType , e ) ; } } }   final  SimpleTableDef  [ ]  tableDefArray =  result . toArray  (  new SimpleTableDef  [  result . size  ( ) ] ) ;   Arrays . sort  ( tableDefArray ,  new  Comparator  < SimpleTableDef >  ( )  {    @ Override public  int compare  (  SimpleTableDef o1 ,  SimpleTableDef o2 )  {  return   o1 . getName  ( ) . compareTo  (  o2 . getName  ( ) ) ; } } ) ;  return tableDefArray ; }   private static SimpleTableDef detectTable  (  JsonObject metadataProperties ,  String documentType )  {   final ElasticSearchMetaData  metaData =  JestElasticSearchMetaDataParser . parse  ( metadataProperties ) ;  return  new SimpleTableDef  ( documentType ,  metaData . getColumnNames  ( ) ,  metaData . getColumnTypes  ( ) ) ; }    @ Override protected Schema getMainSchema  ( )  throws MetaModelException  {   final MutableSchema  theSchema =  new MutableSchema  (  getMainSchemaName  ( ) ) ;  for (  final SimpleTableDef tableDef : staticTableDefinitions )  {   addTable  ( theSchema , tableDef ) ; }   final  SimpleTableDef  [ ]  tables =  detectSchema  ( ) ;  synchronized  ( this )  {   dynamicTableDefinitions . clear  ( ) ;   dynamicTableDefinitions . addAll  (  Arrays . asList  ( tables ) ) ;  for (  final SimpleTableDef tableDef : dynamicTableDefinitions )  {   final  List  < String >  tableNames =  Arrays . asList  (  theSchema . getTableNames  ( ) ) ;  if  (  !  tableNames . contains  (  tableDef . getName  ( ) ) )  {   addTable  ( theSchema , tableDef ) ; } } }  return theSchema ; }   private void addTable  (   final MutableSchema theSchema ,   final SimpleTableDef tableDef )  {   final MutableTable  table =   tableDef . toTable  ( ) . setSchema  ( theSchema ) ;   final Column  idColumn =  table . getColumnByName  ( FIELD_ID ) ;  if  (   idColumn != null &&  idColumn instanceof MutableColumn )  {   final MutableColumn  mutableColumn =  ( MutableColumn ) idColumn ;   mutableColumn . setPrimaryKey  ( true ) ; }   theSchema . addTable  ( table ) ; }    @ Override protected String getMainSchemaName  ( )  throws MetaModelException  {  return indexName ; }    @ Override protected DataSet materializeMainSchemaTable  (  Table table ,   List  < SelectItem > selectItems ,   List  < FilterItem > whereItems ,   int firstRow ,   int maxRows )  {   final QueryBuilder  queryBuilder =  ElasticSearchUtils . createQueryBuilderForSimpleWhere  ( whereItems ,  LogicalOperator . AND ) ;  if  (  queryBuilder != null )  {  SearchSourceBuilder  searchSourceBuilder =  createSearchRequest  ( firstRow , maxRows , queryBuilder ) ;  SearchResult  result =  executeSearch  ( table , searchSourceBuilder ,  scrollNeeded  ( maxRows ) ) ;  return  new JestElasticSearchDataSet  ( elasticSearchClient , result , selectItems ) ; }  return  super . materializeMainSchemaTable  ( table , selectItems , whereItems , firstRow , maxRows ) ; }   private SearchResult executeSearch  (  Table table ,  SearchSourceBuilder searchSourceBuilder ,  boolean scroll )  {   Search . Builder  builder =    new  Search . Builder  (  searchSourceBuilder . toString  ( ) ) . addIndex  (  getIndexName  ( ) ) . addType  (  table . getName  ( ) ) ;  if  ( scroll )  {   builder . setParameter  (  Parameters . SCROLL , TIMEOUT_SCROLL ) ; }  Search  search =  builder . build  ( ) ;  SearchResult  result ;  try  {   result =  elasticSearchClient . execute  ( search ) ; }  catch (   Exception e )  {   logger . warn  ( "Could not execute ElasticSearch query" , e ) ;  throw  new MetaModelException  ( "Could not execute ElasticSearch query" , e ) ; }  return result ; }    @ Override protected DataSet materializeMainSchemaTable  (  Table table ,   Column  [ ] columns ,   int maxRows )  {  SearchResult  searchResult =  executeSearch  ( table ,  createSearchRequest  ( 1 , maxRows , null ) ,  scrollNeeded  ( maxRows ) ) ;  return  new JestElasticSearchDataSet  ( elasticSearchClient , searchResult , columns ) ; }   private SearchSourceBuilder createSearchRequest  (   int firstRow ,   int maxRows ,  QueryBuilder queryBuilder )  {   final SearchSourceBuilder  searchRequest =  new SearchSourceBuilder  ( ) ;  if  (  firstRow > 1 )  {   final  int  zeroBasedFrom =  firstRow - 1 ;   searchRequest . from  ( zeroBasedFrom ) ; }  if  (  limitMaxRowsIsSet  ( maxRows ) )  {   searchRequest . size  ( maxRows ) ; } else  {   searchRequest . size  (  Integer . MAX_VALUE ) ; }  if  (  queryBuilder != null )  {   searchRequest . query  ( queryBuilder ) ; }  return searchRequest ; }    @ Override protected Row executePrimaryKeyLookupQuery  (  Table table ,   List  < SelectItem > selectItems ,  Column primaryKeyColumn ,  Object keyValue )  {  if  (  keyValue == null )  {  return null ; }   final String  documentType =  table . getName  ( ) ;   final String  id =  keyValue . toString  ( ) ;   final Get  get =    new  Get . Builder  ( indexName , id ) . type  ( documentType ) . build  ( ) ;   final JestResult  getResult =  JestClientExecutor . execute  ( elasticSearchClient , get ) ;   final DataSetHeader  header =  new SimpleDataSetHeader  ( selectItems ) ;  return  JestElasticSearchUtils . createRow  (    getResult . getJsonObject  ( ) . get  ( "_source" ) . getAsJsonObject  ( ) , id , header ) ; }    @ Override protected Number executeCountQuery  (  Table table ,   List  < FilterItem > whereItems ,  boolean functionApproximationAllowed )  {  if  (  !  whereItems . isEmpty  ( ) )  {  return null ; }   final String  documentType =  table . getName  ( ) ;  SearchSourceBuilder  sourceBuilder =  new SearchSourceBuilder  ( ) ;   sourceBuilder . query  (  QueryBuilders . termQuery  ( "_type" , documentType ) ) ;  Count  count =     new  Count . Builder  ( ) . addIndex  ( indexName ) . query  (  sourceBuilder . toString  ( ) ) . build  ( ) ;  CountResult  countResult ;  try  {   countResult =  elasticSearchClient . execute  ( count ) ; }  catch (   Exception e )  {   logger . warn  ( "Could not execute ElasticSearch get query" , e ) ;  throw  new MetaModelException  ( "Could not execute ElasticSearch get query" , e ) ; }  return  countResult . getCount  ( ) ; }   private boolean limitMaxRowsIsSet  (   int maxRows )  {  return  (  maxRows !=  - 1 ) ; }    @ Override public UpdateSummary executeUpdate  (  UpdateScript update )  {   final boolean  isBatch =  update instanceof BatchUpdateScript ;   final JestElasticSearchUpdateCallback  callback =  new JestElasticSearchUpdateCallback  ( this , isBatch ) ;   update . run  ( callback ) ;   callback . onExecuteUpdateFinished  ( ) ;  return  callback . getUpdateSummary  ( ) ; }   public JestClient getElasticSearchClient  ( )  {  return elasticSearchClient ; }   public String getIndexName  ( )  {  return indexName ; }   private static final  int  SCROLL_THRESHOLD = 400 ;   private boolean scrollNeeded  (   int maxRows )  {  return   !  limitMaxRowsIsSet  ( maxRows ) ||  maxRows > SCROLL_THRESHOLD ; } }