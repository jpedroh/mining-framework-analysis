  package   net . javacrumbs . jsonunit ;   import      net . javacrumbs . jsonunit . core . internal . Diff ;  import   org . hamcrest . BaseMatcher ;  import   org . hamcrest . Description ;  import   org . hamcrest . Matcher ;  import static       net . javacrumbs . jsonunit . core . internal . Diff . create ;   public class JsonMatchers  {   public static  <  T >  Matcher  < T > jsonEquals  (  Object expected )  {  return  new  JsonPartMatcher  < T >  ( "" , expected ) ; }   public static  <  T >  Matcher  < T > jsonPartEquals  (  String path ,  Object expected )  {  return  new  JsonPartMatcher  < T >  ( path , expected ) ; }   public static  Matcher  < String > jsonStringEquals  (  Object expected )  {  return  jsonEquals  ( expected ) ; }   public static  Matcher  < String > jsonStringPartEquals  (  String path ,  Object expected )  {  return  jsonPartEquals  ( path , expected ) ; }   private static final class JsonPartMatcher  <  T >  extends  BaseMatcher  < T >  {   private final Object  expected ;   private final String  path ;   private String  differences ;  JsonPartMatcher  (  String path ,  Object expected )  {    this . expected = expected ;    this . path = path ; }   public boolean matches  (  Object item )  {  Diff  diff =  create  ( expected , item , "fullJson" , path ,  JsonAssert . getIgnorePlaceholder  ( ) ,  JsonAssert . getTolerance  ( ) ) ;  if  (  !  diff . similar  ( ) )  {   differences =  diff . differences  ( ) ; }  return  diff . similar  ( ) ; }   public void describeTo  (  Description description )  {  if  (  "" . equals  ( path ) )  {   description . appendText  (  expected . toString  ( ) ) ; } else  {      description . appendText  (  expected . toString  ( ) ) . appendText  ( " in \"" ) . appendText  ( path ) . appendText  ( "\"" ) ; } }    @ Override public void describeMismatch  (  Object item ,  Description description )  {   description . appendText  ( differences ) ; } } }