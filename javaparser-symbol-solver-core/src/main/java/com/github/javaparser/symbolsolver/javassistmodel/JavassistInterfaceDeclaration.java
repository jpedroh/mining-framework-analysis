  package     com . github . javaparser . symbolsolver . javassistmodel ;   import     com . github . javaparser . ast . AccessSpecifier ;  import      com . github . javaparser . ast . body . ClassOrInterfaceDeclaration ;  import     com . github . javaparser . resolution . MethodUsage ;  import     com . github . javaparser . resolution . UnsolvedSymbolException ;  import     com . github . javaparser . resolution . declarations .  * ;  import      com . github . javaparser . resolution . types . ResolvedReferenceType ;  import      com . github . javaparser . resolution . types . ResolvedType ;  import       com . github . javaparser . symbolsolver . core . resolution . Context ;  import       com . github . javaparser . symbolsolver . core . resolution . MethodUsageResolutionCapability ;  import      com . github . javaparser . symbolsolver . logic . AbstractTypeDeclaration ;  import      com . github . javaparser . symbolsolver . logic . MethodResolutionCapability ;  import       com . github . javaparser . symbolsolver . model . resolution . SymbolReference ;  import       com . github . javaparser . symbolsolver . model . resolution . TypeSolver ;  import      com . github . javaparser . symbolsolver . resolution . SymbolSolver ;  import  javassist . CtClass ;  import  javassist . CtField ;  import  javassist . NotFoundException ;  import  java . util .  * ;  import    java . util . stream . Collectors ;   public class JavassistInterfaceDeclaration  extends AbstractTypeDeclaration  implements  ResolvedInterfaceDeclaration , MethodResolutionCapability , MethodUsageResolutionCapability  {   private CtClass  ctClass ;   private TypeSolver  typeSolver ;   private JavassistTypeDeclarationAdapter  javassistTypeDeclarationAdapter ;    @ Override public String toString  ( )  {  return      "JavassistInterfaceDeclaration{" + "ctClass=" +  ctClass . getName  ( ) + ", typeSolver=" + typeSolver + '}' ; }   public JavassistInterfaceDeclaration  (  CtClass ctClass ,  TypeSolver typeSolver )  {  if  (  !  ctClass . isInterface  ( ) )  {  throw  new IllegalArgumentException  (  "Not an interface: " +  ctClass . getName  ( ) ) ; }    this . ctClass = ctClass ;    this . typeSolver = typeSolver ;    this . javassistTypeDeclarationAdapter =  new JavassistTypeDeclarationAdapter  ( ctClass , typeSolver , this ) ; }    @ Override public  List  < ResolvedReferenceType > getInterfacesExtended  ( )  {  return  javassistTypeDeclarationAdapter . getInterfaces  ( ) ; }    @ Override public String getPackageName  ( )  {  return  ctClass . getPackageName  ( ) ; }    @ Override public String getClassName  ( )  {  String  className =   ctClass . getName  ( ) . replace  ( '$' , '.' ) ;  if  (   getPackageName  ( ) != null )  {  return  className . substring  (    getPackageName  ( ) . length  ( ) + 1 ) ; }  return className ; }    @ Override public String getQualifiedName  ( )  {  return   ctClass . getName  ( ) . replace  ( '$' , '.' ) ; }    @ Deprecated public  Optional  < MethodUsage > solveMethodAsUsage  (  String name ,   List  < ResolvedType > argumentsTypes ,  Context invokationContext ,   List  < ResolvedType > typeParameterValues )  {  return  JavassistUtils . solveMethodAsUsage  ( name , argumentsTypes , typeSolver , invokationContext , typeParameterValues , this , ctClass ) ; }    @ Override  @ Deprecated public  SymbolReference  < ResolvedMethodDeclaration > solveMethod  (  String name ,   List  < ResolvedType > argumentsTypes ,  boolean staticOnly )  {  return  JavassistUtils . solveMethod  ( name , argumentsTypes , staticOnly , typeSolver , this , ctClass ) ; }    @ Override public boolean isAssignableBy  (  ResolvedType type )  {  throw  new UnsupportedOperationException  ( ) ; }    @ Override public  List  < ResolvedFieldDeclaration > getAllFields  ( )  {  return  javassistTypeDeclarationAdapter . getDeclaredFields  ( ) ; }    @ Override public boolean isAssignableBy  (  ResolvedReferenceTypeDeclaration other )  {  throw  new UnsupportedOperationException  ( ) ; }    @ Override public  List  < ResolvedReferenceType > getAncestors  (  boolean acceptIncompleteList )  {  return  javassistTypeDeclarationAdapter . getAncestors  ( this , acceptIncompleteList ) ; }    @ Override public  Set  < ResolvedMethodDeclaration > getDeclaredMethods  ( )  {  return    Arrays . stream  (  ctClass . getDeclaredMethods  ( ) ) . map  (  m ->  new JavassistMethodDeclaration  ( m , typeSolver ) ) . collect  (  Collectors . toSet  ( ) ) ; }    @ Override public boolean hasDirectlyAnnotation  (  String canonicalName )  {  return  ctClass . hasAnnotation  ( canonicalName ) ; }    @ Override public String getName  ( )  {   String  [ ]  nameElements =    ctClass . getSimpleName  ( ) . replace  ( '$' , '.' ) . split  ( "\\." ) ;  return  nameElements [   nameElements . length - 1 ] ; }    @ Override public  List  < ResolvedTypeParameterDeclaration > getTypeParameters  ( )  {  return  javassistTypeDeclarationAdapter . getTypeParameters  ( ) ; }    @ Override public AccessSpecifier accessSpecifier  ( )  {  return  JavassistFactory . modifiersToAccessLevel  (  ctClass . getModifiers  ( ) ) ; }    @ Override public ResolvedInterfaceDeclaration asInterface  ( )  {  return this ; }    @ Deprecated public  SymbolReference  <  ? extends ResolvedValueDeclaration > solveSymbol  (  String name ,  TypeSolver typeSolver )  {  for ( CtField field :  ctClass . getDeclaredFields  ( ) )  {  if  (   field . getName  ( ) . equals  ( name ) )  {  return  SymbolReference . solved  (  new JavassistFieldDeclaration  ( field , typeSolver ) ) ; } }   String  [ ]  interfaceFQNs =  getInterfaceFQNs  ( ) ;  for ( String interfaceFQN : interfaceFQNs )  {   SymbolReference  <  ? extends ResolvedValueDeclaration >  interfaceRef =  solveSymbolForFQN  ( name , interfaceFQN ) ;  if  (  interfaceRef . isSolved  ( ) )  {  return interfaceRef ; } }  return  SymbolReference . unsolved  (  ResolvedValueDeclaration . class ) ; }   private  SymbolReference  <  ? extends ResolvedValueDeclaration > solveSymbolForFQN  (  String symbolName ,  String fqn )  {  if  (  fqn == null )  {  return  SymbolReference . unsolved  (  ResolvedValueDeclaration . class ) ; }  ResolvedReferenceTypeDeclaration  fqnTypeDeclaration =  typeSolver . solveType  ( fqn ) ;  return   new SymbolSolver  ( typeSolver ) . solveSymbolInType  ( fqnTypeDeclaration , symbolName ) ; }   private  String  [ ] getInterfaceFQNs  ( )  {  return   ctClass . getClassFile  ( ) . getInterfaces  ( ) ; }    @ Override public  Optional  < ResolvedReferenceTypeDeclaration > containerType  ( )  {  return  javassistTypeDeclarationAdapter . containerType  ( ) ; }    @ Override public  Set  < ResolvedReferenceTypeDeclaration > internalTypes  ( )  {  try  {  return    Arrays . stream  (  ctClass . getDeclaredClasses  ( ) ) . map  (  itype ->  JavassistFactory . toTypeDeclaration  ( itype , typeSolver ) ) . collect  (  Collectors . toSet  ( ) ) ; }  catch (   NotFoundException e )  {  throw  new RuntimeException  ( e ) ; } }    @ Override public ResolvedReferenceTypeDeclaration getInternalType  (  String name )  {   Optional  < ResolvedReferenceTypeDeclaration >  type =     this . internalTypes  ( ) . stream  ( ) . filter  (  f ->   f . getName  ( ) . endsWith  ( name ) ) . findFirst  ( ) ;  return  type . orElseThrow  (   ( ) ->  new UnsolvedSymbolException  (  "Internal type not found: " + name ) ) ; }    @ Override public boolean hasInternalType  (  String name )  {  return    this . internalTypes  ( ) . stream  ( ) . anyMatch  (  f ->   f . getName  ( ) . endsWith  ( name ) ) ; }    @ Override public  List  < ResolvedConstructorDeclaration > getConstructors  ( )  {  return  Collections . emptyList  ( ) ; }    @ Override public  Optional  < ClassOrInterfaceDeclaration > toAst  ( )  {  return  Optional . empty  ( ) ; } }