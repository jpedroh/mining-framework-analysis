  package      org . apache . shardingsphere . elasticjob . reg . zookeeper ;   import     org . apache . curator . utils . ThreadUtils ;  import       org . apache . shardingsphere . elasticjob . reg . listener . DataChangedEvent ;  import        org . apache . shardingsphere . elasticjob . reg . zookeeper . fixture . EmbedTestingServer ;  import        org . apache . shardingsphere . elasticjob . reg . zookeeper . util . ZookeeperRegistryCenterTestUtil ;  import   org . junit . AfterClass ;  import   org . junit . BeforeClass ;  import   org . junit . Test ;  import static    org . junit . Assert . assertThat ;  import static    org . hamcrest . CoreMatchers . startsWith ;  import    java . util . concurrent . CountDownLatch ;  import    java . util . concurrent . Executor ;  import    java . util . concurrent . Executors ;  import    java . util . concurrent . ThreadFactory ;   public final class ZookeeperRegistryCenterWatchTest  {   private static final ZookeeperConfiguration  ZOOKEEPER_CONFIGURATION =  new ZookeeperConfiguration  (  EmbedTestingServer . getConnectionString  ( ) ,   ZookeeperRegistryCenterWatchTest . class . getName  ( ) ) ;   private static ZookeeperRegistryCenter  zkRegCenter ;    @ BeforeClass public static void setUp  ( )  {   EmbedTestingServer . start  ( ) ;   zkRegCenter =  new ZookeeperRegistryCenter  ( ZOOKEEPER_CONFIGURATION ) ;   ZOOKEEPER_CONFIGURATION . setConnectionTimeoutMilliseconds  ( 30000 ) ;   zkRegCenter . init  ( ) ;   ZookeeperRegistryCenterTestUtil . persist  ( zkRegCenter ) ; }    @ AfterClass public static void tearDown  ( )  {   zkRegCenter . close  ( ) ; }    @ Test  (  timeout = 10000L ) public void assertWatchWithoutExecutor  ( )  throws InterruptedException  {  CountDownLatch  waitingForCountDownValue =  new CountDownLatch  ( 1 ) ;   zkRegCenter . addCacheData  ( "/test" ) ;  CountDownLatch  waitingForWatchReady =  new CountDownLatch  ( 1 ) ;   zkRegCenter . watch  ( "/test" ,  event ->  {   waitingForWatchReady . countDown  ( ) ;  if  (     DataChangedEvent . Type . UPDATED ==  event . getType  ( ) &&  "countDown" . equals  (  event . getValue  ( ) ) )  {   waitingForCountDownValue . countDown  ( ) ; } } , null ) ;   waitingForWatchReady . await  ( ) ;   zkRegCenter . update  ( "/test" , "countDown" ) ;   waitingForCountDownValue . await  ( ) ; }    @ Test  (  timeout = 10000L ) public void assertWatchWithExecutor  ( )  throws InterruptedException  {  CountDownLatch  waitingForCountDownValue =  new CountDownLatch  ( 1 ) ;   zkRegCenter . addCacheData  ( "/test" ) ;  CountDownLatch  waitingForWatchReady =  new CountDownLatch  ( 1 ) ;  String  threadNamePreffix = "ListenerNotify" ;  ThreadFactory  threadFactory =  ThreadUtils . newGenericThreadFactory  ( threadNamePreffix ) ;  Executor  executor =  Executors . newSingleThreadExecutor  ( threadFactory ) ;   zkRegCenter . watch  ( "/test" ,  event ->  {   assertThat  (   Thread . currentThread  ( ) . getName  ( ) ,  startsWith  ( threadNamePreffix ) ) ;   waitingForWatchReady . countDown  ( ) ;  if  (     DataChangedEvent . Type . UPDATED ==  event . getType  ( ) &&  "countDown" . equals  (  event . getValue  ( ) ) )  {   waitingForCountDownValue . countDown  ( ) ; } } , executor ) ;   waitingForWatchReady . await  ( ) ;   zkRegCenter . update  ( "/test" , "countDown" ) ;   waitingForCountDownValue . await  ( ) ; } 
<<<<<<<
=======
   @ Test  (  timeout = 30000L ) public void assertWatch  ( )  throws InterruptedException  {  CountDownLatch  waitingForCountDownValue =  new CountDownLatch  ( 1 ) ;   zkRegCenter . addCacheData  ( "/test" ) ;  CountDownLatch  waitingForWatchReady =  new CountDownLatch  ( 1 ) ;   zkRegCenter . watch  ( "/test" ,  event ->  {   waitingForWatchReady . countDown  ( ) ;  if  (     DataChangedEvent . Type . UPDATED ==  event . getType  ( ) &&  "countDown" . equals  (  event . getValue  ( ) ) )  {   waitingForCountDownValue . countDown  ( ) ; } } ) ;   waitingForWatchReady . await  ( ) ;   zkRegCenter . update  ( "/test" , "countDown" ) ;   waitingForCountDownValue . await  ( ) ; }
>>>>>>>
 }